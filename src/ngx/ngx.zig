pub const __builtin_bswap16 = @import("std").zig.c_builtins.__builtin_bswap16;
pub const __builtin_bswap32 = @import("std").zig.c_builtins.__builtin_bswap32;
pub const __builtin_bswap64 = @import("std").zig.c_builtins.__builtin_bswap64;
pub const __builtin_signbit = @import("std").zig.c_builtins.__builtin_signbit;
pub const __builtin_signbitf = @import("std").zig.c_builtins.__builtin_signbitf;
pub const __builtin_popcount = @import("std").zig.c_builtins.__builtin_popcount;
pub const __builtin_ctz = @import("std").zig.c_builtins.__builtin_ctz;
pub const __builtin_clz = @import("std").zig.c_builtins.__builtin_clz;
pub const __builtin_sqrt = @import("std").zig.c_builtins.__builtin_sqrt;
pub const __builtin_sqrtf = @import("std").zig.c_builtins.__builtin_sqrtf;
pub const __builtin_sin = @import("std").zig.c_builtins.__builtin_sin;
pub const __builtin_sinf = @import("std").zig.c_builtins.__builtin_sinf;
pub const __builtin_cos = @import("std").zig.c_builtins.__builtin_cos;
pub const __builtin_cosf = @import("std").zig.c_builtins.__builtin_cosf;
pub const __builtin_exp = @import("std").zig.c_builtins.__builtin_exp;
pub const __builtin_expf = @import("std").zig.c_builtins.__builtin_expf;
pub const __builtin_exp2 = @import("std").zig.c_builtins.__builtin_exp2;
pub const __builtin_exp2f = @import("std").zig.c_builtins.__builtin_exp2f;
pub const __builtin_log = @import("std").zig.c_builtins.__builtin_log;
pub const __builtin_logf = @import("std").zig.c_builtins.__builtin_logf;
pub const __builtin_log2 = @import("std").zig.c_builtins.__builtin_log2;
pub const __builtin_log2f = @import("std").zig.c_builtins.__builtin_log2f;
pub const __builtin_log10 = @import("std").zig.c_builtins.__builtin_log10;
pub const __builtin_log10f = @import("std").zig.c_builtins.__builtin_log10f;
pub const __builtin_abs = @import("std").zig.c_builtins.__builtin_abs;
pub const __builtin_labs = @import("std").zig.c_builtins.__builtin_labs;
pub const __builtin_llabs = @import("std").zig.c_builtins.__builtin_llabs;
pub const __builtin_fabs = @import("std").zig.c_builtins.__builtin_fabs;
pub const __builtin_fabsf = @import("std").zig.c_builtins.__builtin_fabsf;
pub const __builtin_floor = @import("std").zig.c_builtins.__builtin_floor;
pub const __builtin_floorf = @import("std").zig.c_builtins.__builtin_floorf;
pub const __builtin_ceil = @import("std").zig.c_builtins.__builtin_ceil;
pub const __builtin_ceilf = @import("std").zig.c_builtins.__builtin_ceilf;
pub const __builtin_trunc = @import("std").zig.c_builtins.__builtin_trunc;
pub const __builtin_truncf = @import("std").zig.c_builtins.__builtin_truncf;
pub const __builtin_round = @import("std").zig.c_builtins.__builtin_round;
pub const __builtin_roundf = @import("std").zig.c_builtins.__builtin_roundf;
pub const __builtin_strlen = @import("std").zig.c_builtins.__builtin_strlen;
pub const __builtin_strcmp = @import("std").zig.c_builtins.__builtin_strcmp;
pub const __builtin_object_size = @import("std").zig.c_builtins.__builtin_object_size;
pub const __builtin___memset_chk = @import("std").zig.c_builtins.__builtin___memset_chk;
pub const __builtin_memset = @import("std").zig.c_builtins.__builtin_memset;
pub const __builtin___memcpy_chk = @import("std").zig.c_builtins.__builtin___memcpy_chk;
pub const __builtin_memcpy = @import("std").zig.c_builtins.__builtin_memcpy;
pub const __builtin_expect = @import("std").zig.c_builtins.__builtin_expect;
pub const __builtin_nanf = @import("std").zig.c_builtins.__builtin_nanf;
pub const __builtin_huge_valf = @import("std").zig.c_builtins.__builtin_huge_valf;
pub const __builtin_inff = @import("std").zig.c_builtins.__builtin_inff;
pub const __builtin_isnan = @import("std").zig.c_builtins.__builtin_isnan;
pub const __builtin_isinf = @import("std").zig.c_builtins.__builtin_isinf;
pub const __builtin_isinf_sign = @import("std").zig.c_builtins.__builtin_isinf_sign;
pub const __has_builtin = @import("std").zig.c_builtins.__has_builtin;
pub const __builtin_assume = @import("std").zig.c_builtins.__builtin_assume;
pub const __builtin_unreachable = @import("std").zig.c_builtins.__builtin_unreachable;
pub const __builtin_constant_p = @import("std").zig.c_builtins.__builtin_constant_p;
pub const __builtin_mul_overflow = @import("std").zig.c_builtins.__builtin_mul_overflow;
pub const __u_char = u8;
pub const __u_short = c_ushort;
pub const __u_int = c_uint;
pub const __u_long = c_ulong;
pub const __int8_t = i8;
pub const __uint8_t = u8;
pub const __int16_t = c_short;
pub const __uint16_t = c_ushort;
pub const __int32_t = c_int;
pub const __uint32_t = c_uint;
pub const __int64_t = c_long;
pub const __uint64_t = c_ulong;
pub const __int_least8_t = __int8_t;
pub const __uint_least8_t = __uint8_t;
pub const __int_least16_t = __int16_t;
pub const __uint_least16_t = __uint16_t;
pub const __int_least32_t = __int32_t;
pub const __uint_least32_t = __uint32_t;
pub const __int_least64_t = __int64_t;
pub const __uint_least64_t = __uint64_t;
pub const __quad_t = c_long;
pub const __u_quad_t = c_ulong;
pub const __intmax_t = c_long;
pub const __uintmax_t = c_ulong;
pub const __dev_t = c_ulong;
pub const __uid_t = c_uint;
pub const __gid_t = c_uint;
pub const __ino_t = c_ulong;
pub const __ino64_t = c_ulong;
pub const __mode_t = c_uint;
pub const __nlink_t = c_ulong;
pub const __off_t = c_long;
pub const __off64_t = c_long;
pub const __pid_t = c_int;
pub const __fsid_t = extern struct {
    __val: [2]c_int = @import("std").mem.zeroes([2]c_int),
};
pub const __clock_t = c_long;
pub const __rlim_t = c_ulong;
pub const __rlim64_t = c_ulong;
pub const __id_t = c_uint;
pub const __time_t = c_long;
pub const __useconds_t = c_uint;
pub const __suseconds_t = c_long;
pub const __suseconds64_t = c_long;
pub const __daddr_t = c_int;
pub const __key_t = c_int;
pub const __clockid_t = c_int;
pub const __timer_t = ?*anyopaque;
pub const __blksize_t = c_long;
pub const __blkcnt_t = c_long;
pub const __blkcnt64_t = c_long;
pub const __fsblkcnt_t = c_ulong;
pub const __fsblkcnt64_t = c_ulong;
pub const __fsfilcnt_t = c_ulong;
pub const __fsfilcnt64_t = c_ulong;
pub const __fsword_t = c_long;
pub const __ssize_t = c_long;
pub const __syscall_slong_t = c_long;
pub const __syscall_ulong_t = c_ulong;
pub const __loff_t = __off64_t;
pub const __caddr_t = [*c]u8;
pub const __intptr_t = c_long;
pub const __socklen_t = c_uint;
pub const __sig_atomic_t = c_int;
pub const u_char = __u_char;
pub const u_short = __u_short;
pub const u_int = __u_int;
pub const u_long = __u_long;
pub const quad_t = __quad_t;
pub const u_quad_t = __u_quad_t;
pub const fsid_t = __fsid_t;
pub const loff_t = __loff_t;
pub const ino_t = __ino64_t;
pub const ino64_t = __ino64_t;
pub const dev_t = __dev_t;
pub const gid_t = __gid_t;
pub const mode_t = __mode_t;
pub const nlink_t = __nlink_t;
pub const uid_t = __uid_t;
pub const off_t = __off64_t;
pub const off64_t = __off64_t;
pub const pid_t = __pid_t;
pub const id_t = __id_t;
pub const daddr_t = __daddr_t;
pub const caddr_t = __caddr_t;
pub const key_t = __key_t;
pub const clock_t = __clock_t;
pub const clockid_t = __clockid_t;
pub const time_t = __time_t;
pub const timer_t = __timer_t;
pub const useconds_t = __useconds_t;
pub const suseconds_t = __suseconds_t;
pub const ulong = c_ulong;
pub const ushort = c_ushort;
pub const uint = c_uint;
pub const u_int8_t = __uint8_t;
pub const u_int16_t = __uint16_t;
pub const u_int32_t = __uint32_t;
pub const u_int64_t = __uint64_t;
pub const register_t = c_long;
pub fn __bswap_16(arg___bsx: __uint16_t) callconv(.c) __uint16_t {
    var __bsx = arg___bsx;
    _ = &__bsx;
    return @as(__uint16_t, @bitCast(@as(c_short, @truncate(((@as(c_int, @bitCast(@as(c_uint, __bsx))) >> @intCast(8)) & @as(c_int, 255)) | ((@as(c_int, @bitCast(@as(c_uint, __bsx))) & @as(c_int, 255)) << @intCast(8))))));
}
pub fn __bswap_32(arg___bsx: __uint32_t) callconv(.c) __uint32_t {
    var __bsx = arg___bsx;
    _ = &__bsx;
    return ((((__bsx & @as(c_uint, 4278190080)) >> @intCast(24)) | ((__bsx & @as(c_uint, 16711680)) >> @intCast(8))) | ((__bsx & @as(c_uint, 65280)) << @intCast(8))) | ((__bsx & @as(c_uint, 255)) << @intCast(24));
}
pub fn __bswap_64(arg___bsx: __uint64_t) callconv(.c) __uint64_t {
    var __bsx = arg___bsx;
    _ = &__bsx;
    return @as(__uint64_t, @bitCast(@as(c_ulong, @truncate(((((((((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 18374686479671623680)) >> @intCast(56)) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 71776119061217280)) >> @intCast(40))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 280375465082880)) >> @intCast(24))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 1095216660480)) >> @intCast(8))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 4278190080)) << @intCast(8))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 16711680)) << @intCast(24))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 65280)) << @intCast(40))) | ((@as(c_ulonglong, @bitCast(@as(c_ulonglong, __bsx))) & @as(c_ulonglong, 255)) << @intCast(56))))));
}
pub fn __uint16_identity(arg___x: __uint16_t) callconv(.c) __uint16_t {
    var __x = arg___x;
    _ = &__x;
    return __x;
}
pub fn __uint32_identity(arg___x: __uint32_t) callconv(.c) __uint32_t {
    var __x = arg___x;
    _ = &__x;
    return __x;
}
pub fn __uint64_identity(arg___x: __uint64_t) callconv(.c) __uint64_t {
    var __x = arg___x;
    _ = &__x;
    return __x;
}
pub const __sigset_t = extern struct {
    __val: [16]c_ulong = @import("std").mem.zeroes([16]c_ulong),
};
pub const sigset_t = __sigset_t;
pub const struct_timeval = extern struct {
    tv_sec: __time_t = @import("std").mem.zeroes(__time_t),
    tv_usec: __suseconds_t = @import("std").mem.zeroes(__suseconds_t),
};
pub const struct_timespec = extern struct {
    tv_sec: __time_t = @import("std").mem.zeroes(__time_t),
    tv_nsec: __syscall_slong_t = @import("std").mem.zeroes(__syscall_slong_t),
};
pub const __fd_mask = c_long;
pub const fd_set = extern struct {
    fds_bits: [16]__fd_mask = @import("std").mem.zeroes([16]__fd_mask),
};
pub const fd_mask = __fd_mask;
pub extern fn select(__nfds: c_int, noalias __readfds: [*c]fd_set, noalias __writefds: [*c]fd_set, noalias __exceptfds: [*c]fd_set, noalias __timeout: [*c]struct_timeval) c_int;
pub extern fn pselect(__nfds: c_int, noalias __readfds: [*c]fd_set, noalias __writefds: [*c]fd_set, noalias __exceptfds: [*c]fd_set, noalias __timeout: [*c]const struct_timespec, noalias __sigmask: [*c]const __sigset_t) c_int;
pub const blksize_t = __blksize_t;
pub const blkcnt_t = __blkcnt64_t;
pub const fsblkcnt_t = __fsblkcnt64_t;
pub const fsfilcnt_t = __fsfilcnt64_t;
pub const blkcnt64_t = __blkcnt64_t;
pub const fsblkcnt64_t = __fsblkcnt64_t;
pub const fsfilcnt64_t = __fsfilcnt64_t;
const struct_unnamed_1 = extern struct {
    __low: c_uint = @import("std").mem.zeroes(c_uint),
    __high: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const __atomic_wide_counter = extern union {
    __value64: c_ulonglong,
    __value32: struct_unnamed_1,
};
pub const struct___pthread_internal_list = extern struct {
    __prev: [*c]struct___pthread_internal_list = @import("std").mem.zeroes([*c]struct___pthread_internal_list),
    __next: [*c]struct___pthread_internal_list = @import("std").mem.zeroes([*c]struct___pthread_internal_list),
};
pub const __pthread_list_t = struct___pthread_internal_list;
pub const struct___pthread_internal_slist = extern struct {
    __next: [*c]struct___pthread_internal_slist = @import("std").mem.zeroes([*c]struct___pthread_internal_slist),
};
pub const __pthread_slist_t = struct___pthread_internal_slist;
pub const struct___pthread_mutex_s = extern struct {
    __lock: c_int = @import("std").mem.zeroes(c_int),
    __count: c_uint = @import("std").mem.zeroes(c_uint),
    __owner: c_int = @import("std").mem.zeroes(c_int),
    __nusers: c_uint = @import("std").mem.zeroes(c_uint),
    __kind: c_int = @import("std").mem.zeroes(c_int),
    __spins: c_short = @import("std").mem.zeroes(c_short),
    __elision: c_short = @import("std").mem.zeroes(c_short),
    __list: __pthread_list_t = @import("std").mem.zeroes(__pthread_list_t),
};
pub const struct___pthread_rwlock_arch_t = extern struct {
    __readers: c_uint = @import("std").mem.zeroes(c_uint),
    __writers: c_uint = @import("std").mem.zeroes(c_uint),
    __wrphase_futex: c_uint = @import("std").mem.zeroes(c_uint),
    __writers_futex: c_uint = @import("std").mem.zeroes(c_uint),
    __pad3: c_uint = @import("std").mem.zeroes(c_uint),
    __pad4: c_uint = @import("std").mem.zeroes(c_uint),
    __cur_writer: c_int = @import("std").mem.zeroes(c_int),
    __shared: c_int = @import("std").mem.zeroes(c_int),
    __rwelision: i8 = @import("std").mem.zeroes(i8),
    __pad1: [7]u8 = @import("std").mem.zeroes([7]u8),
    __pad2: c_ulong = @import("std").mem.zeroes(c_ulong),
    __flags: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct___pthread_cond_s = extern struct {
    __wseq: __atomic_wide_counter = @import("std").mem.zeroes(__atomic_wide_counter),
    __g1_start: __atomic_wide_counter = @import("std").mem.zeroes(__atomic_wide_counter),
    __g_refs: [2]c_uint = @import("std").mem.zeroes([2]c_uint),
    __g_size: [2]c_uint = @import("std").mem.zeroes([2]c_uint),
    __g1_orig_size: c_uint = @import("std").mem.zeroes(c_uint),
    __wrefs: c_uint = @import("std").mem.zeroes(c_uint),
    __g_signals: [2]c_uint = @import("std").mem.zeroes([2]c_uint),
};
pub const __tss_t = c_uint;
pub const __thrd_t = c_ulong;
pub const __once_flag = extern struct {
    __data: c_int = @import("std").mem.zeroes(c_int),
};
pub const pthread_t = c_ulong;
pub const pthread_mutexattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub const pthread_condattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub const pthread_key_t = c_uint;
pub const pthread_once_t = c_int;
pub const union_pthread_attr_t = extern union {
    __size: [56]u8,
    __align: c_long,
};
pub const pthread_attr_t = union_pthread_attr_t;
pub const pthread_mutex_t = extern union {
    __data: struct___pthread_mutex_s,
    __size: [40]u8,
    __align: c_long,
};
pub const pthread_cond_t = extern union {
    __data: struct___pthread_cond_s,
    __size: [48]u8,
    __align: c_longlong,
};
pub const pthread_rwlock_t = extern union {
    __data: struct___pthread_rwlock_arch_t,
    __size: [56]u8,
    __align: c_long,
};
pub const pthread_rwlockattr_t = extern union {
    __size: [8]u8,
    __align: c_long,
};
pub const pthread_spinlock_t = c_int;
pub const pthread_barrier_t = extern union {
    __size: [32]u8,
    __align: c_long,
};
pub const pthread_barrierattr_t = extern union {
    __size: [4]u8,
    __align: c_int,
};
pub const struct_timezone = extern struct {
    tz_minuteswest: c_int = @import("std").mem.zeroes(c_int),
    tz_dsttime: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn gettimeofday(noalias __tv: [*c]struct_timeval, noalias __tz: ?*anyopaque) c_int;
pub extern fn settimeofday(__tv: [*c]const struct_timeval, __tz: [*c]const struct_timezone) c_int;
pub extern fn adjtime(__delta: [*c]const struct_timeval, __olddelta: [*c]struct_timeval) c_int;
pub const ITIMER_REAL: c_int = 0;
pub const ITIMER_VIRTUAL: c_int = 1;
pub const ITIMER_PROF: c_int = 2;
pub const enum___itimer_which = c_uint;
pub const struct_itimerval = extern struct {
    it_interval: struct_timeval = @import("std").mem.zeroes(struct_timeval),
    it_value: struct_timeval = @import("std").mem.zeroes(struct_timeval),
};
pub const __itimer_which_t = enum___itimer_which;
pub extern fn getitimer(__which: __itimer_which_t, __value: [*c]struct_itimerval) c_int;
pub extern fn setitimer(__which: __itimer_which_t, noalias __new: [*c]const struct_itimerval, noalias __old: [*c]struct_itimerval) c_int;
pub extern fn utimes(__file: [*c]const u8, __tvp: [*c]const struct_timeval) c_int;
pub extern fn lutimes(__file: [*c]const u8, __tvp: [*c]const struct_timeval) c_int;
pub extern fn futimes(__fd: c_int, __tvp: [*c]const struct_timeval) c_int;
pub extern fn futimesat(__fd: c_int, __file: [*c]const u8, __tvp: [*c]const struct_timeval) c_int;
pub const socklen_t = __socklen_t;
pub extern fn access(__name: [*c]const u8, __type: c_int) c_int;
pub extern fn euidaccess(__name: [*c]const u8, __type: c_int) c_int;
pub extern fn eaccess(__name: [*c]const u8, __type: c_int) c_int;
pub extern fn execveat(__fd: c_int, __path: [*c]const u8, __argv: [*c]const [*c]u8, __envp: [*c]const [*c]u8, __flags: c_int) c_int;
pub extern fn faccessat(__fd: c_int, __file: [*c]const u8, __type: c_int, __flag: c_int) c_int;
pub extern fn lseek(__fd: c_int, __offset: __off64_t, __whence: c_int) __off64_t;
pub extern fn lseek64(__fd: c_int, __offset: __off64_t, __whence: c_int) __off64_t;
pub extern fn close(__fd: c_int) c_int;
pub extern fn closefrom(__lowfd: c_int) void;
pub extern fn read(__fd: c_int, __buf: ?*anyopaque, __nbytes: usize) isize;
pub extern fn write(__fd: c_int, __buf: ?*const anyopaque, __n: usize) isize;
pub extern fn pread(__fd: c_int, __buf: ?*anyopaque, __nbytes: usize, __offset: __off64_t) isize;
pub extern fn pwrite(__fd: c_int, __buf: ?*const anyopaque, __nbytes: usize, __offset: __off64_t) isize;
pub extern fn pread64(__fd: c_int, __buf: ?*anyopaque, __nbytes: usize, __offset: __off64_t) isize;
pub extern fn pwrite64(__fd: c_int, __buf: ?*const anyopaque, __n: usize, __offset: __off64_t) isize;
pub extern fn pipe(__pipedes: [*c]c_int) c_int;
pub extern fn pipe2(__pipedes: [*c]c_int, __flags: c_int) c_int;
pub extern fn alarm(__seconds: c_uint) c_uint;
pub extern fn sleep(__seconds: c_uint) c_uint;
pub extern fn ualarm(__value: __useconds_t, __interval: __useconds_t) __useconds_t;
pub extern fn usleep(__useconds: __useconds_t) c_int;
pub extern fn pause() c_int;
pub extern fn chown(__file: [*c]const u8, __owner: __uid_t, __group: __gid_t) c_int;
pub extern fn fchown(__fd: c_int, __owner: __uid_t, __group: __gid_t) c_int;
pub extern fn lchown(__file: [*c]const u8, __owner: __uid_t, __group: __gid_t) c_int;
pub extern fn fchownat(__fd: c_int, __file: [*c]const u8, __owner: __uid_t, __group: __gid_t, __flag: c_int) c_int;
pub extern fn chdir(__path: [*c]const u8) c_int;
pub extern fn fchdir(__fd: c_int) c_int;
pub extern fn getcwd(__buf: [*c]u8, __size: usize) [*c]u8;
pub extern fn get_current_dir_name() [*c]u8;
pub extern fn getwd(__buf: [*c]u8) [*c]u8;
pub extern fn dup(__fd: c_int) c_int;
pub extern fn dup2(__fd: c_int, __fd2: c_int) c_int;
pub extern fn dup3(__fd: c_int, __fd2: c_int, __flags: c_int) c_int;
pub extern var __environ: [*c][*c]u8;
pub extern var environ: [*c][*c]u8;
pub extern fn execve(__path: [*c]const u8, __argv: [*c]const [*c]u8, __envp: [*c]const [*c]u8) c_int;
pub extern fn fexecve(__fd: c_int, __argv: [*c]const [*c]u8, __envp: [*c]const [*c]u8) c_int;
pub extern fn execv(__path: [*c]const u8, __argv: [*c]const [*c]u8) c_int;
pub extern fn execle(__path: [*c]const u8, __arg: [*c]const u8, ...) c_int;
pub extern fn execl(__path: [*c]const u8, __arg: [*c]const u8, ...) c_int;
pub extern fn execvp(__file: [*c]const u8, __argv: [*c]const [*c]u8) c_int;
pub extern fn execlp(__file: [*c]const u8, __arg: [*c]const u8, ...) c_int;
pub extern fn execvpe(__file: [*c]const u8, __argv: [*c]const [*c]u8, __envp: [*c]const [*c]u8) c_int;
pub extern fn nice(__inc: c_int) c_int;
pub extern fn _exit(__status: c_int) noreturn;
pub const _PC_LINK_MAX: c_int = 0;
pub const _PC_MAX_CANON: c_int = 1;
pub const _PC_MAX_INPUT: c_int = 2;
pub const _PC_NAME_MAX: c_int = 3;
pub const _PC_PATH_MAX: c_int = 4;
pub const _PC_PIPE_BUF: c_int = 5;
pub const _PC_CHOWN_RESTRICTED: c_int = 6;
pub const _PC_NO_TRUNC: c_int = 7;
pub const _PC_VDISABLE: c_int = 8;
pub const _PC_SYNC_IO: c_int = 9;
pub const _PC_ASYNC_IO: c_int = 10;
pub const _PC_PRIO_IO: c_int = 11;
pub const _PC_SOCK_MAXBUF: c_int = 12;
pub const _PC_FILESIZEBITS: c_int = 13;
pub const _PC_REC_INCR_XFER_SIZE: c_int = 14;
pub const _PC_REC_MAX_XFER_SIZE: c_int = 15;
pub const _PC_REC_MIN_XFER_SIZE: c_int = 16;
pub const _PC_REC_XFER_ALIGN: c_int = 17;
pub const _PC_ALLOC_SIZE_MIN: c_int = 18;
pub const _PC_SYMLINK_MAX: c_int = 19;
pub const _PC_2_SYMLINKS: c_int = 20;
const enum_unnamed_2 = c_uint;
pub const _SC_ARG_MAX: c_int = 0;
pub const _SC_CHILD_MAX: c_int = 1;
pub const _SC_CLK_TCK: c_int = 2;
pub const _SC_NGROUPS_MAX: c_int = 3;
pub const _SC_OPEN_MAX: c_int = 4;
pub const _SC_STREAM_MAX: c_int = 5;
pub const _SC_TZNAME_MAX: c_int = 6;
pub const _SC_JOB_CONTROL: c_int = 7;
pub const _SC_SAVED_IDS: c_int = 8;
pub const _SC_REALTIME_SIGNALS: c_int = 9;
pub const _SC_PRIORITY_SCHEDULING: c_int = 10;
pub const _SC_TIMERS: c_int = 11;
pub const _SC_ASYNCHRONOUS_IO: c_int = 12;
pub const _SC_PRIORITIZED_IO: c_int = 13;
pub const _SC_SYNCHRONIZED_IO: c_int = 14;
pub const _SC_FSYNC: c_int = 15;
pub const _SC_MAPPED_FILES: c_int = 16;
pub const _SC_MEMLOCK: c_int = 17;
pub const _SC_MEMLOCK_RANGE: c_int = 18;
pub const _SC_MEMORY_PROTECTION: c_int = 19;
pub const _SC_MESSAGE_PASSING: c_int = 20;
pub const _SC_SEMAPHORES: c_int = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: c_int = 22;
pub const _SC_AIO_LISTIO_MAX: c_int = 23;
pub const _SC_AIO_MAX: c_int = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: c_int = 25;
pub const _SC_DELAYTIMER_MAX: c_int = 26;
pub const _SC_MQ_OPEN_MAX: c_int = 27;
pub const _SC_MQ_PRIO_MAX: c_int = 28;
pub const _SC_VERSION: c_int = 29;
pub const _SC_PAGESIZE: c_int = 30;
pub const _SC_RTSIG_MAX: c_int = 31;
pub const _SC_SEM_NSEMS_MAX: c_int = 32;
pub const _SC_SEM_VALUE_MAX: c_int = 33;
pub const _SC_SIGQUEUE_MAX: c_int = 34;
pub const _SC_TIMER_MAX: c_int = 35;
pub const _SC_BC_BASE_MAX: c_int = 36;
pub const _SC_BC_DIM_MAX: c_int = 37;
pub const _SC_BC_SCALE_MAX: c_int = 38;
pub const _SC_BC_STRING_MAX: c_int = 39;
pub const _SC_COLL_WEIGHTS_MAX: c_int = 40;
pub const _SC_EQUIV_CLASS_MAX: c_int = 41;
pub const _SC_EXPR_NEST_MAX: c_int = 42;
pub const _SC_LINE_MAX: c_int = 43;
pub const _SC_RE_DUP_MAX: c_int = 44;
pub const _SC_CHARCLASS_NAME_MAX: c_int = 45;
pub const _SC_2_VERSION: c_int = 46;
pub const _SC_2_C_BIND: c_int = 47;
pub const _SC_2_C_DEV: c_int = 48;
pub const _SC_2_FORT_DEV: c_int = 49;
pub const _SC_2_FORT_RUN: c_int = 50;
pub const _SC_2_SW_DEV: c_int = 51;
pub const _SC_2_LOCALEDEF: c_int = 52;
pub const _SC_PII: c_int = 53;
pub const _SC_PII_XTI: c_int = 54;
pub const _SC_PII_SOCKET: c_int = 55;
pub const _SC_PII_INTERNET: c_int = 56;
pub const _SC_PII_OSI: c_int = 57;
pub const _SC_POLL: c_int = 58;
pub const _SC_SELECT: c_int = 59;
pub const _SC_UIO_MAXIOV: c_int = 60;
pub const _SC_IOV_MAX: c_int = 60;
pub const _SC_PII_INTERNET_STREAM: c_int = 61;
pub const _SC_PII_INTERNET_DGRAM: c_int = 62;
pub const _SC_PII_OSI_COTS: c_int = 63;
pub const _SC_PII_OSI_CLTS: c_int = 64;
pub const _SC_PII_OSI_M: c_int = 65;
pub const _SC_T_IOV_MAX: c_int = 66;
pub const _SC_THREADS: c_int = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: c_int = 68;
pub const _SC_GETGR_R_SIZE_MAX: c_int = 69;
pub const _SC_GETPW_R_SIZE_MAX: c_int = 70;
pub const _SC_LOGIN_NAME_MAX: c_int = 71;
pub const _SC_TTY_NAME_MAX: c_int = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: c_int = 73;
pub const _SC_THREAD_KEYS_MAX: c_int = 74;
pub const _SC_THREAD_STACK_MIN: c_int = 75;
pub const _SC_THREAD_THREADS_MAX: c_int = 76;
pub const _SC_THREAD_ATTR_STACKADDR: c_int = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: c_int = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: c_int = 79;
pub const _SC_THREAD_PRIO_INHERIT: c_int = 80;
pub const _SC_THREAD_PRIO_PROTECT: c_int = 81;
pub const _SC_THREAD_PROCESS_SHARED: c_int = 82;
pub const _SC_NPROCESSORS_CONF: c_int = 83;
pub const _SC_NPROCESSORS_ONLN: c_int = 84;
pub const _SC_PHYS_PAGES: c_int = 85;
pub const _SC_AVPHYS_PAGES: c_int = 86;
pub const _SC_ATEXIT_MAX: c_int = 87;
pub const _SC_PASS_MAX: c_int = 88;
pub const _SC_XOPEN_VERSION: c_int = 89;
pub const _SC_XOPEN_XCU_VERSION: c_int = 90;
pub const _SC_XOPEN_UNIX: c_int = 91;
pub const _SC_XOPEN_CRYPT: c_int = 92;
pub const _SC_XOPEN_ENH_I18N: c_int = 93;
pub const _SC_XOPEN_SHM: c_int = 94;
pub const _SC_2_CHAR_TERM: c_int = 95;
pub const _SC_2_C_VERSION: c_int = 96;
pub const _SC_2_UPE: c_int = 97;
pub const _SC_XOPEN_XPG2: c_int = 98;
pub const _SC_XOPEN_XPG3: c_int = 99;
pub const _SC_XOPEN_XPG4: c_int = 100;
pub const _SC_CHAR_BIT: c_int = 101;
pub const _SC_CHAR_MAX: c_int = 102;
pub const _SC_CHAR_MIN: c_int = 103;
pub const _SC_INT_MAX: c_int = 104;
pub const _SC_INT_MIN: c_int = 105;
pub const _SC_LONG_BIT: c_int = 106;
pub const _SC_WORD_BIT: c_int = 107;
pub const _SC_MB_LEN_MAX: c_int = 108;
pub const _SC_NZERO: c_int = 109;
pub const _SC_SSIZE_MAX: c_int = 110;
pub const _SC_SCHAR_MAX: c_int = 111;
pub const _SC_SCHAR_MIN: c_int = 112;
pub const _SC_SHRT_MAX: c_int = 113;
pub const _SC_SHRT_MIN: c_int = 114;
pub const _SC_UCHAR_MAX: c_int = 115;
pub const _SC_UINT_MAX: c_int = 116;
pub const _SC_ULONG_MAX: c_int = 117;
pub const _SC_USHRT_MAX: c_int = 118;
pub const _SC_NL_ARGMAX: c_int = 119;
pub const _SC_NL_LANGMAX: c_int = 120;
pub const _SC_NL_MSGMAX: c_int = 121;
pub const _SC_NL_NMAX: c_int = 122;
pub const _SC_NL_SETMAX: c_int = 123;
pub const _SC_NL_TEXTMAX: c_int = 124;
pub const _SC_XBS5_ILP32_OFF32: c_int = 125;
pub const _SC_XBS5_ILP32_OFFBIG: c_int = 126;
pub const _SC_XBS5_LP64_OFF64: c_int = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: c_int = 128;
pub const _SC_XOPEN_LEGACY: c_int = 129;
pub const _SC_XOPEN_REALTIME: c_int = 130;
pub const _SC_XOPEN_REALTIME_THREADS: c_int = 131;
pub const _SC_ADVISORY_INFO: c_int = 132;
pub const _SC_BARRIERS: c_int = 133;
pub const _SC_BASE: c_int = 134;
pub const _SC_C_LANG_SUPPORT: c_int = 135;
pub const _SC_C_LANG_SUPPORT_R: c_int = 136;
pub const _SC_CLOCK_SELECTION: c_int = 137;
pub const _SC_CPUTIME: c_int = 138;
pub const _SC_THREAD_CPUTIME: c_int = 139;
pub const _SC_DEVICE_IO: c_int = 140;
pub const _SC_DEVICE_SPECIFIC: c_int = 141;
pub const _SC_DEVICE_SPECIFIC_R: c_int = 142;
pub const _SC_FD_MGMT: c_int = 143;
pub const _SC_FIFO: c_int = 144;
pub const _SC_PIPE: c_int = 145;
pub const _SC_FILE_ATTRIBUTES: c_int = 146;
pub const _SC_FILE_LOCKING: c_int = 147;
pub const _SC_FILE_SYSTEM: c_int = 148;
pub const _SC_MONOTONIC_CLOCK: c_int = 149;
pub const _SC_MULTI_PROCESS: c_int = 150;
pub const _SC_SINGLE_PROCESS: c_int = 151;
pub const _SC_NETWORKING: c_int = 152;
pub const _SC_READER_WRITER_LOCKS: c_int = 153;
pub const _SC_SPIN_LOCKS: c_int = 154;
pub const _SC_REGEXP: c_int = 155;
pub const _SC_REGEX_VERSION: c_int = 156;
pub const _SC_SHELL: c_int = 157;
pub const _SC_SIGNALS: c_int = 158;
pub const _SC_SPAWN: c_int = 159;
pub const _SC_SPORADIC_SERVER: c_int = 160;
pub const _SC_THREAD_SPORADIC_SERVER: c_int = 161;
pub const _SC_SYSTEM_DATABASE: c_int = 162;
pub const _SC_SYSTEM_DATABASE_R: c_int = 163;
pub const _SC_TIMEOUTS: c_int = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: c_int = 165;
pub const _SC_USER_GROUPS: c_int = 166;
pub const _SC_USER_GROUPS_R: c_int = 167;
pub const _SC_2_PBS: c_int = 168;
pub const _SC_2_PBS_ACCOUNTING: c_int = 169;
pub const _SC_2_PBS_LOCATE: c_int = 170;
pub const _SC_2_PBS_MESSAGE: c_int = 171;
pub const _SC_2_PBS_TRACK: c_int = 172;
pub const _SC_SYMLOOP_MAX: c_int = 173;
pub const _SC_STREAMS: c_int = 174;
pub const _SC_2_PBS_CHECKPOINT: c_int = 175;
pub const _SC_V6_ILP32_OFF32: c_int = 176;
pub const _SC_V6_ILP32_OFFBIG: c_int = 177;
pub const _SC_V6_LP64_OFF64: c_int = 178;
pub const _SC_V6_LPBIG_OFFBIG: c_int = 179;
pub const _SC_HOST_NAME_MAX: c_int = 180;
pub const _SC_TRACE: c_int = 181;
pub const _SC_TRACE_EVENT_FILTER: c_int = 182;
pub const _SC_TRACE_INHERIT: c_int = 183;
pub const _SC_TRACE_LOG: c_int = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: c_int = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: c_int = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: c_int = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: c_int = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: c_int = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: c_int = 190;
pub const _SC_LEVEL2_CACHE_SIZE: c_int = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: c_int = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: c_int = 193;
pub const _SC_LEVEL3_CACHE_SIZE: c_int = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: c_int = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: c_int = 196;
pub const _SC_LEVEL4_CACHE_SIZE: c_int = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: c_int = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: c_int = 199;
pub const _SC_IPV6: c_int = 235;
pub const _SC_RAW_SOCKETS: c_int = 236;
pub const _SC_V7_ILP32_OFF32: c_int = 237;
pub const _SC_V7_ILP32_OFFBIG: c_int = 238;
pub const _SC_V7_LP64_OFF64: c_int = 239;
pub const _SC_V7_LPBIG_OFFBIG: c_int = 240;
pub const _SC_SS_REPL_MAX: c_int = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: c_int = 242;
pub const _SC_TRACE_NAME_MAX: c_int = 243;
pub const _SC_TRACE_SYS_MAX: c_int = 244;
pub const _SC_TRACE_USER_EVENT_MAX: c_int = 245;
pub const _SC_XOPEN_STREAMS: c_int = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: c_int = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: c_int = 248;
pub const _SC_MINSIGSTKSZ: c_int = 249;
pub const _SC_SIGSTKSZ: c_int = 250;
const enum_unnamed_3 = c_uint;
pub const _CS_PATH: c_int = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: c_int = 1;
pub const _CS_GNU_LIBC_VERSION: c_int = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: c_int = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: c_int = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: c_int = 5;
pub const _CS_LFS_CFLAGS: c_int = 1000;
pub const _CS_LFS_LDFLAGS: c_int = 1001;
pub const _CS_LFS_LIBS: c_int = 1002;
pub const _CS_LFS_LINTFLAGS: c_int = 1003;
pub const _CS_LFS64_CFLAGS: c_int = 1004;
pub const _CS_LFS64_LDFLAGS: c_int = 1005;
pub const _CS_LFS64_LIBS: c_int = 1006;
pub const _CS_LFS64_LINTFLAGS: c_int = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: c_int = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: c_int = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: c_int = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: c_int = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: c_int = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: c_int = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: c_int = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: c_int = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: c_int = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: c_int = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: c_int = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: c_int = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: c_int = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: c_int = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: c_int = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: c_int = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: c_int = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: c_int = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: c_int = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: c_int = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: c_int = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: c_int = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: c_int = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: c_int = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: c_int = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: c_int = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: c_int = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: c_int = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: c_int = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: c_int = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: c_int = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: c_int = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: c_int = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: c_int = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: c_int = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: c_int = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: c_int = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: c_int = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: c_int = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: c_int = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: c_int = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: c_int = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: c_int = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: c_int = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: c_int = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: c_int = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: c_int = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: c_int = 1147;
pub const _CS_V6_ENV: c_int = 1148;
pub const _CS_V7_ENV: c_int = 1149;
const enum_unnamed_4 = c_uint;
pub extern fn pathconf(__path: [*c]const u8, __name: c_int) c_long;
pub extern fn fpathconf(__fd: c_int, __name: c_int) c_long;
pub extern fn sysconf(__name: c_int) c_long;
pub extern fn confstr(__name: c_int, __buf: [*c]u8, __len: usize) usize;
pub extern fn getpid() __pid_t;
pub extern fn getppid() __pid_t;
pub extern fn getpgrp() __pid_t;
pub extern fn __getpgid(__pid: __pid_t) __pid_t;
pub extern fn getpgid(__pid: __pid_t) __pid_t;
pub extern fn setpgid(__pid: __pid_t, __pgid: __pid_t) c_int;
pub extern fn setpgrp() c_int;
pub extern fn setsid() __pid_t;
pub extern fn getsid(__pid: __pid_t) __pid_t;
pub extern fn getuid() __uid_t;
pub extern fn geteuid() __uid_t;
pub extern fn getgid() __gid_t;
pub extern fn getegid() __gid_t;
pub extern fn getgroups(__size: c_int, __list: [*c]__gid_t) c_int;
pub extern fn group_member(__gid: __gid_t) c_int;
pub extern fn setuid(__uid: __uid_t) c_int;
pub extern fn setreuid(__ruid: __uid_t, __euid: __uid_t) c_int;
pub extern fn seteuid(__uid: __uid_t) c_int;
pub extern fn setgid(__gid: __gid_t) c_int;
pub extern fn setregid(__rgid: __gid_t, __egid: __gid_t) c_int;
pub extern fn setegid(__gid: __gid_t) c_int;
pub extern fn getresuid(__ruid: [*c]__uid_t, __euid: [*c]__uid_t, __suid: [*c]__uid_t) c_int;
pub extern fn getresgid(__rgid: [*c]__gid_t, __egid: [*c]__gid_t, __sgid: [*c]__gid_t) c_int;
pub extern fn setresuid(__ruid: __uid_t, __euid: __uid_t, __suid: __uid_t) c_int;
pub extern fn setresgid(__rgid: __gid_t, __egid: __gid_t, __sgid: __gid_t) c_int;
pub extern fn fork() __pid_t;
pub extern fn vfork() c_int;
pub extern fn _Fork() __pid_t;
pub extern fn ttyname(__fd: c_int) [*c]u8;
pub extern fn ttyname_r(__fd: c_int, __buf: [*c]u8, __buflen: usize) c_int;
pub extern fn isatty(__fd: c_int) c_int;
pub extern fn ttyslot() c_int;
pub extern fn link(__from: [*c]const u8, __to: [*c]const u8) c_int;
pub extern fn linkat(__fromfd: c_int, __from: [*c]const u8, __tofd: c_int, __to: [*c]const u8, __flags: c_int) c_int;
pub extern fn symlink(__from: [*c]const u8, __to: [*c]const u8) c_int;
pub extern fn readlink(noalias __path: [*c]const u8, noalias __buf: [*c]u8, __len: usize) isize;
pub extern fn symlinkat(__from: [*c]const u8, __tofd: c_int, __to: [*c]const u8) c_int;
pub extern fn readlinkat(__fd: c_int, noalias __path: [*c]const u8, noalias __buf: [*c]u8, __len: usize) isize;
pub extern fn unlink(__name: [*c]const u8) c_int;
pub extern fn unlinkat(__fd: c_int, __name: [*c]const u8, __flag: c_int) c_int;
pub extern fn rmdir(__path: [*c]const u8) c_int;
pub extern fn tcgetpgrp(__fd: c_int) __pid_t;
pub extern fn tcsetpgrp(__fd: c_int, __pgrp_id: __pid_t) c_int;
pub extern fn getlogin() [*c]u8;
pub extern fn getlogin_r(__name: [*c]u8, __name_len: usize) c_int;
pub extern fn setlogin(__name: [*c]const u8) c_int;
pub extern var optarg: [*c]u8;
pub extern var optind: c_int;
pub extern var opterr: c_int;
pub extern var optopt: c_int;
pub extern fn getopt(___argc: c_int, ___argv: [*c]const [*c]u8, __shortopts: [*c]const u8) c_int;
pub extern fn gethostname(__name: [*c]u8, __len: usize) c_int;
pub extern fn sethostname(__name: [*c]const u8, __len: usize) c_int;
pub extern fn sethostid(__id: c_long) c_int;
pub extern fn getdomainname(__name: [*c]u8, __len: usize) c_int;
pub extern fn setdomainname(__name: [*c]const u8, __len: usize) c_int;
pub extern fn vhangup() c_int;
pub extern fn revoke(__file: [*c]const u8) c_int;
pub extern fn profil(__sample_buffer: [*c]c_ushort, __size: usize, __offset: usize, __scale: c_uint) c_int;
pub extern fn acct(__name: [*c]const u8) c_int;
pub extern fn getusershell() [*c]u8;
pub extern fn endusershell() void;
pub extern fn setusershell() void;
pub extern fn daemon(__nochdir: c_int, __noclose: c_int) c_int;
pub extern fn chroot(__path: [*c]const u8) c_int;
pub extern fn getpass(__prompt: [*c]const u8) [*c]u8;
pub extern fn fsync(__fd: c_int) c_int;
pub extern fn syncfs(__fd: c_int) c_int;
pub extern fn gethostid() c_long;
pub extern fn sync() void;
pub extern fn getpagesize() c_int;
pub extern fn getdtablesize() c_int;
pub extern fn truncate(__file: [*c]const u8, __length: __off64_t) c_int;
pub extern fn truncate64(__file: [*c]const u8, __length: __off64_t) c_int;
pub extern fn ftruncate(__fd: c_int, __length: __off64_t) c_int;
pub extern fn ftruncate64(__fd: c_int, __length: __off64_t) c_int;
pub extern fn brk(__addr: ?*anyopaque) c_int;
pub extern fn sbrk(__delta: isize) ?*anyopaque;
pub extern fn syscall(__sysno: c_long, ...) c_long;
pub extern fn lockf(__fd: c_int, __cmd: c_int, __len: __off64_t) c_int;
pub extern fn lockf64(__fd: c_int, __cmd: c_int, __len: __off64_t) c_int;
pub extern fn copy_file_range(__infd: c_int, __pinoff: [*c]__off64_t, __outfd: c_int, __poutoff: [*c]__off64_t, __length: usize, __flags: c_uint) isize;
pub extern fn fdatasync(__fildes: c_int) c_int;
pub extern fn crypt(__key: [*c]const u8, __salt: [*c]const u8) [*c]u8;
pub extern fn swab(noalias __from: ?*const anyopaque, noalias __to: ?*anyopaque, __n: isize) void;
pub extern fn getentropy(__buffer: ?*anyopaque, __length: usize) c_int;
pub extern fn close_range(__fd: c_uint, __max_fd: c_uint, __flags: c_int) c_int;
pub extern fn gettid() __pid_t;
pub const struct___va_list_tag_5 = extern struct {
    gp_offset: c_uint = @import("std").mem.zeroes(c_uint),
    fp_offset: c_uint = @import("std").mem.zeroes(c_uint),
    overflow_arg_area: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    reg_save_area: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const __builtin_va_list = [1]struct___va_list_tag_5;
pub const __gnuc_va_list = __builtin_va_list;
pub const va_list = __builtin_va_list;
pub const ptrdiff_t = c_long;
pub const wchar_t = c_int;
pub const max_align_t = extern struct {
    __clang_max_align_nonce1: c_longlong align(8) = @import("std").mem.zeroes(c_longlong),
    __clang_max_align_nonce2: c_longdouble align(16) = @import("std").mem.zeroes(c_longdouble),
};
const union_unnamed_6 = extern union {
    __wch: c_uint,
    __wchb: [4]u8,
};
pub const __mbstate_t = extern struct {
    __count: c_int = @import("std").mem.zeroes(c_int),
    __value: union_unnamed_6 = @import("std").mem.zeroes(union_unnamed_6),
};
pub const struct__G_fpos_t = extern struct {
    __pos: __off_t = @import("std").mem.zeroes(__off_t),
    __state: __mbstate_t = @import("std").mem.zeroes(__mbstate_t),
};
pub const __fpos_t = struct__G_fpos_t;
pub const struct__G_fpos64_t = extern struct {
    __pos: __off64_t = @import("std").mem.zeroes(__off64_t),
    __state: __mbstate_t = @import("std").mem.zeroes(__mbstate_t),
};
pub const __fpos64_t = struct__G_fpos64_t;
pub const struct__IO_marker = opaque {};
pub const _IO_lock_t = anyopaque;
pub const struct__IO_codecvt = opaque {};
pub const struct__IO_wide_data = opaque {};
pub const struct__IO_FILE = extern struct {
    _flags: c_int = @import("std").mem.zeroes(c_int),
    _IO_read_ptr: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_read_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_read_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_write_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_write_ptr: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_write_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_buf_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_buf_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_save_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_backup_base: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _IO_save_end: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    _markers: ?*struct__IO_marker = @import("std").mem.zeroes(?*struct__IO_marker),
    _chain: [*c]struct__IO_FILE = @import("std").mem.zeroes([*c]struct__IO_FILE),
    _fileno: c_int = @import("std").mem.zeroes(c_int),
    _flags2: c_int = @import("std").mem.zeroes(c_int),
    _old_offset: __off_t = @import("std").mem.zeroes(__off_t),
    _cur_column: c_ushort = @import("std").mem.zeroes(c_ushort),
    _vtable_offset: i8 = @import("std").mem.zeroes(i8),
    _shortbuf: [1]u8 = @import("std").mem.zeroes([1]u8),
    _lock: ?*_IO_lock_t = @import("std").mem.zeroes(?*_IO_lock_t),
    _offset: __off64_t = @import("std").mem.zeroes(__off64_t),
    _codecvt: ?*struct__IO_codecvt = @import("std").mem.zeroes(?*struct__IO_codecvt),
    _wide_data: ?*struct__IO_wide_data = @import("std").mem.zeroes(?*struct__IO_wide_data),
    _freeres_list: [*c]struct__IO_FILE = @import("std").mem.zeroes([*c]struct__IO_FILE),
    _freeres_buf: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    _prevchain: [*c][*c]struct__IO_FILE = @import("std").mem.zeroes([*c][*c]struct__IO_FILE),
    _mode: c_int = @import("std").mem.zeroes(c_int),
    _unused2: [20]u8 = @import("std").mem.zeroes([20]u8),
};
pub const __FILE = struct__IO_FILE;
pub const FILE = struct__IO_FILE;
pub const cookie_read_function_t = fn (?*anyopaque, [*c]u8, usize) callconv(.c) __ssize_t;
pub const cookie_write_function_t = fn (?*anyopaque, [*c]const u8, usize) callconv(.c) __ssize_t;
pub const cookie_seek_function_t = fn (?*anyopaque, [*c]__off64_t, c_int) callconv(.c) c_int;
pub const cookie_close_function_t = fn (?*anyopaque) callconv(.c) c_int;
pub const struct__IO_cookie_io_functions_t = extern struct {
    read: ?*const cookie_read_function_t = @import("std").mem.zeroes(?*const cookie_read_function_t),
    write: ?*const cookie_write_function_t = @import("std").mem.zeroes(?*const cookie_write_function_t),
    seek: ?*const cookie_seek_function_t = @import("std").mem.zeroes(?*const cookie_seek_function_t),
    close: ?*const cookie_close_function_t = @import("std").mem.zeroes(?*const cookie_close_function_t),
};
pub const cookie_io_functions_t = struct__IO_cookie_io_functions_t;
pub const fpos_t = __fpos64_t;
pub const fpos64_t = __fpos64_t;
pub extern var stdin: [*c]FILE;
pub extern var stdout: [*c]FILE;
pub extern var stderr: [*c]FILE;
pub extern fn remove(__filename: [*c]const u8) c_int;
pub extern fn rename(__old: [*c]const u8, __new: [*c]const u8) c_int;
pub extern fn renameat(__oldfd: c_int, __old: [*c]const u8, __newfd: c_int, __new: [*c]const u8) c_int;
pub extern fn renameat2(__oldfd: c_int, __old: [*c]const u8, __newfd: c_int, __new: [*c]const u8, __flags: c_uint) c_int;
pub extern fn fclose(__stream: [*c]FILE) c_int;
pub extern fn tmpfile() [*c]FILE;
pub extern fn tmpfile64() [*c]FILE;
pub extern fn tmpnam([*c]u8) [*c]u8;
pub extern fn tmpnam_r(__s: [*c]u8) [*c]u8;
pub extern fn tempnam(__dir: [*c]const u8, __pfx: [*c]const u8) [*c]u8;
pub extern fn fflush(__stream: [*c]FILE) c_int;
pub extern fn fflush_unlocked(__stream: [*c]FILE) c_int;
pub extern fn fcloseall() c_int;
pub extern fn fopen(__filename: [*c]const u8, __modes: [*c]const u8) [*c]FILE;
pub extern fn freopen(noalias __filename: [*c]const u8, noalias __modes: [*c]const u8, noalias __stream: [*c]FILE) [*c]FILE;
pub extern fn fopen64(noalias __filename: [*c]const u8, noalias __modes: [*c]const u8) [*c]FILE;
pub extern fn freopen64(noalias __filename: [*c]const u8, noalias __modes: [*c]const u8, noalias __stream: [*c]FILE) [*c]FILE;
pub extern fn fdopen(__fd: c_int, __modes: [*c]const u8) [*c]FILE;
pub extern fn fopencookie(noalias __magic_cookie: ?*anyopaque, noalias __modes: [*c]const u8, __io_funcs: cookie_io_functions_t) [*c]FILE;
pub extern fn fmemopen(__s: ?*anyopaque, __len: usize, __modes: [*c]const u8) [*c]FILE;
pub extern fn open_memstream(__bufloc: [*c][*c]u8, __sizeloc: [*c]usize) [*c]FILE;
pub extern fn setbuf(noalias __stream: [*c]FILE, noalias __buf: [*c]u8) void;
pub extern fn setvbuf(noalias __stream: [*c]FILE, noalias __buf: [*c]u8, __modes: c_int, __n: usize) c_int;
pub extern fn setbuffer(noalias __stream: [*c]FILE, noalias __buf: [*c]u8, __size: usize) void;
pub extern fn setlinebuf(__stream: [*c]FILE) void;
pub extern fn fprintf(__stream: [*c]FILE, __format: [*c]const u8, ...) c_int;
pub extern fn printf(__format: [*c]const u8, ...) c_int;
pub extern fn sprintf(__s: [*c]u8, __format: [*c]const u8, ...) c_int;
pub extern fn vfprintf(__s: [*c]FILE, __format: [*c]const u8, __arg: [*c]struct___va_list_tag_5) c_int;
pub extern fn vprintf(__format: [*c]const u8, __arg: [*c]struct___va_list_tag_5) c_int;
pub extern fn vsprintf(__s: [*c]u8, __format: [*c]const u8, __arg: [*c]struct___va_list_tag_5) c_int;
pub extern fn snprintf(__s: [*c]u8, __maxlen: c_ulong, __format: [*c]const u8, ...) c_int;
pub extern fn vsnprintf(__s: [*c]u8, __maxlen: c_ulong, __format: [*c]const u8, __arg: [*c]struct___va_list_tag_5) c_int;
pub extern fn vasprintf(noalias __ptr: [*c][*c]u8, noalias __f: [*c]const u8, __arg: [*c]struct___va_list_tag_5) c_int;
pub extern fn __asprintf(noalias __ptr: [*c][*c]u8, noalias __fmt: [*c]const u8, ...) c_int;
pub extern fn asprintf(noalias __ptr: [*c][*c]u8, noalias __fmt: [*c]const u8, ...) c_int;
pub extern fn vdprintf(__fd: c_int, noalias __fmt: [*c]const u8, __arg: [*c]struct___va_list_tag_5) c_int;
pub extern fn dprintf(__fd: c_int, noalias __fmt: [*c]const u8, ...) c_int;
pub extern fn fscanf(noalias __stream: [*c]FILE, noalias __format: [*c]const u8, ...) c_int;
pub extern fn scanf(noalias __format: [*c]const u8, ...) c_int;
pub extern fn sscanf(noalias __s: [*c]const u8, noalias __format: [*c]const u8, ...) c_int;
pub const _Float32 = f32;
pub const _Float64 = f64;
pub const _Float32x = f64;
pub const _Float64x = c_longdouble;
pub extern fn vfscanf(noalias __s: [*c]FILE, noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag_5) c_int;
pub extern fn vscanf(noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag_5) c_int;
pub extern fn vsscanf(noalias __s: [*c]const u8, noalias __format: [*c]const u8, __arg: [*c]struct___va_list_tag_5) c_int;
pub extern fn fgetc(__stream: [*c]FILE) c_int;
pub extern fn getc(__stream: [*c]FILE) c_int;
pub extern fn getchar() c_int;
pub extern fn getc_unlocked(__stream: [*c]FILE) c_int;
pub extern fn getchar_unlocked() c_int;
pub extern fn fgetc_unlocked(__stream: [*c]FILE) c_int;
pub extern fn fputc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putchar(__c: c_int) c_int;
pub extern fn fputc_unlocked(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putc_unlocked(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn putchar_unlocked(__c: c_int) c_int;
pub extern fn getw(__stream: [*c]FILE) c_int;
pub extern fn putw(__w: c_int, __stream: [*c]FILE) c_int;
pub extern fn fgets(noalias __s: [*c]u8, __n: c_int, noalias __stream: [*c]FILE) [*c]u8;
pub extern fn fgets_unlocked(noalias __s: [*c]u8, __n: c_int, noalias __stream: [*c]FILE) [*c]u8;
pub extern fn __getdelim(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, __delimiter: c_int, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn getdelim(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, __delimiter: c_int, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn getline(noalias __lineptr: [*c][*c]u8, noalias __n: [*c]usize, noalias __stream: [*c]FILE) __ssize_t;
pub extern fn fputs(noalias __s: [*c]const u8, noalias __stream: [*c]FILE) c_int;
pub extern fn puts(__s: [*c]const u8) c_int;
pub extern fn ungetc(__c: c_int, __stream: [*c]FILE) c_int;
pub extern fn fread(__ptr: ?*anyopaque, __size: c_ulong, __n: c_ulong, __stream: [*c]FILE) c_ulong;
pub extern fn fwrite(__ptr: ?*const anyopaque, __size: c_ulong, __n: c_ulong, __s: [*c]FILE) c_ulong;
pub extern fn fputs_unlocked(noalias __s: [*c]const u8, noalias __stream: [*c]FILE) c_int;
pub extern fn fread_unlocked(noalias __ptr: ?*anyopaque, __size: usize, __n: usize, noalias __stream: [*c]FILE) usize;
pub extern fn fwrite_unlocked(noalias __ptr: ?*const anyopaque, __size: usize, __n: usize, noalias __stream: [*c]FILE) usize;
pub extern fn fseek(__stream: [*c]FILE, __off: c_long, __whence: c_int) c_int;
pub extern fn ftell(__stream: [*c]FILE) c_long;
pub extern fn rewind(__stream: [*c]FILE) void;
pub extern fn fseeko(__stream: [*c]FILE, __off: __off64_t, __whence: c_int) c_int;
pub extern fn ftello(__stream: [*c]FILE) __off64_t;
pub extern fn fgetpos(noalias __stream: [*c]FILE, noalias __pos: [*c]fpos_t) c_int;
pub extern fn fsetpos(__stream: [*c]FILE, __pos: [*c]const fpos_t) c_int;
pub extern fn fseeko64(__stream: [*c]FILE, __off: __off64_t, __whence: c_int) c_int;
pub extern fn ftello64(__stream: [*c]FILE) __off64_t;
pub extern fn fgetpos64(noalias __stream: [*c]FILE, noalias __pos: [*c]fpos64_t) c_int;
pub extern fn fsetpos64(__stream: [*c]FILE, __pos: [*c]const fpos64_t) c_int;
pub extern fn clearerr(__stream: [*c]FILE) void;
pub extern fn feof(__stream: [*c]FILE) c_int;
pub extern fn ferror(__stream: [*c]FILE) c_int;
pub extern fn clearerr_unlocked(__stream: [*c]FILE) void;
pub extern fn feof_unlocked(__stream: [*c]FILE) c_int;
pub extern fn ferror_unlocked(__stream: [*c]FILE) c_int;
pub extern fn perror(__s: [*c]const u8) void;
pub extern fn fileno(__stream: [*c]FILE) c_int;
pub extern fn fileno_unlocked(__stream: [*c]FILE) c_int;
pub extern fn pclose(__stream: [*c]FILE) c_int;
pub extern fn popen(__command: [*c]const u8, __modes: [*c]const u8) [*c]FILE;
pub extern fn ctermid(__s: [*c]u8) [*c]u8;
pub extern fn cuserid(__s: [*c]u8) [*c]u8;
pub const struct_obstack = opaque {};
pub extern fn obstack_printf(noalias __obstack: ?*struct_obstack, noalias __format: [*c]const u8, ...) c_int;
pub extern fn obstack_vprintf(noalias __obstack: ?*struct_obstack, noalias __format: [*c]const u8, __args: [*c]struct___va_list_tag_5) c_int;
pub extern fn flockfile(__stream: [*c]FILE) void;
pub extern fn ftrylockfile(__stream: [*c]FILE) c_int;
pub extern fn funlockfile(__stream: [*c]FILE) void;
pub extern fn __uflow([*c]FILE) c_int;
pub extern fn __overflow([*c]FILE, c_int) c_int;
pub const div_t = extern struct {
    quot: c_int = @import("std").mem.zeroes(c_int),
    rem: c_int = @import("std").mem.zeroes(c_int),
};
pub const ldiv_t = extern struct {
    quot: c_long = @import("std").mem.zeroes(c_long),
    rem: c_long = @import("std").mem.zeroes(c_long),
};
pub const lldiv_t = extern struct {
    quot: c_longlong = @import("std").mem.zeroes(c_longlong),
    rem: c_longlong = @import("std").mem.zeroes(c_longlong),
};
pub extern fn __ctype_get_mb_cur_max() usize;
pub extern fn atof(__nptr: [*c]const u8) f64;
pub extern fn atoi(__nptr: [*c]const u8) c_int;
pub extern fn atol(__nptr: [*c]const u8) c_long;
pub extern fn atoll(__nptr: [*c]const u8) c_longlong;
pub extern fn strtod(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f64;
pub extern fn strtof(__nptr: [*c]const u8, __endptr: [*c][*c]u8) f32;
pub extern fn strtold(__nptr: [*c]const u8, __endptr: [*c][*c]u8) c_longdouble;
pub extern fn strtof32(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8) _Float32;
pub extern fn strtof64(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8) _Float64;
pub extern fn strtof32x(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8) _Float32x;
pub extern fn strtof64x(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8) _Float64x;
pub extern fn strtol(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_long;
pub extern fn strtoul(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulong;
pub extern fn strtoq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtouq(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn strtoll(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_longlong;
pub extern fn strtoull(__nptr: [*c]const u8, __endptr: [*c][*c]u8, __base: c_int) c_ulonglong;
pub extern fn strfromd(__dest: [*c]u8, __size: usize, __format: [*c]const u8, __f: f64) c_int;
pub extern fn strfromf(__dest: [*c]u8, __size: usize, __format: [*c]const u8, __f: f32) c_int;
pub extern fn strfroml(__dest: [*c]u8, __size: usize, __format: [*c]const u8, __f: c_longdouble) c_int;
pub extern fn strfromf32(__dest: [*c]u8, __size: usize, __format: [*c]const u8, __f: _Float32) c_int;
pub extern fn strfromf64(__dest: [*c]u8, __size: usize, __format: [*c]const u8, __f: _Float64) c_int;
pub extern fn strfromf32x(__dest: [*c]u8, __size: usize, __format: [*c]const u8, __f: _Float32x) c_int;
pub extern fn strfromf64x(__dest: [*c]u8, __size: usize, __format: [*c]const u8, __f: _Float64x) c_int;
pub const struct___locale_data_7 = opaque {};
pub const struct___locale_struct = extern struct {
    __locales: [13]?*struct___locale_data_7 = @import("std").mem.zeroes([13]?*struct___locale_data_7),
    __ctype_b: [*c]const c_ushort = @import("std").mem.zeroes([*c]const c_ushort),
    __ctype_tolower: [*c]const c_int = @import("std").mem.zeroes([*c]const c_int),
    __ctype_toupper: [*c]const c_int = @import("std").mem.zeroes([*c]const c_int),
    __names: [13][*c]const u8 = @import("std").mem.zeroes([13][*c]const u8),
};
pub const __locale_t = [*c]struct___locale_struct;
pub const locale_t = __locale_t;
pub extern fn strtol_l(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int, __loc: locale_t) c_long;
pub extern fn strtoul_l(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int, __loc: locale_t) c_ulong;
pub extern fn strtoll_l(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int, __loc: locale_t) c_longlong;
pub extern fn strtoull_l(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int, __loc: locale_t) c_ulonglong;
pub extern fn strtod_l(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __loc: locale_t) f64;
pub extern fn strtof_l(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __loc: locale_t) f32;
pub extern fn strtold_l(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __loc: locale_t) c_longdouble;
pub extern fn strtof32_l(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __loc: locale_t) _Float32;
pub extern fn strtof64_l(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __loc: locale_t) _Float64;
pub extern fn strtof32x_l(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __loc: locale_t) _Float32x;
pub extern fn strtof64x_l(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __loc: locale_t) _Float64x;
pub extern fn l64a(__n: c_long) [*c]u8;
pub extern fn a64l(__s: [*c]const u8) c_long;
pub extern fn random() c_long;
pub extern fn srandom(__seed: c_uint) void;
pub extern fn initstate(__seed: c_uint, __statebuf: [*c]u8, __statelen: usize) [*c]u8;
pub extern fn setstate(__statebuf: [*c]u8) [*c]u8;
pub const struct_random_data = extern struct {
    fptr: [*c]i32 = @import("std").mem.zeroes([*c]i32),
    rptr: [*c]i32 = @import("std").mem.zeroes([*c]i32),
    state: [*c]i32 = @import("std").mem.zeroes([*c]i32),
    rand_type: c_int = @import("std").mem.zeroes(c_int),
    rand_deg: c_int = @import("std").mem.zeroes(c_int),
    rand_sep: c_int = @import("std").mem.zeroes(c_int),
    end_ptr: [*c]i32 = @import("std").mem.zeroes([*c]i32),
};
pub extern fn random_r(noalias __buf: [*c]struct_random_data, noalias __result: [*c]i32) c_int;
pub extern fn srandom_r(__seed: c_uint, __buf: [*c]struct_random_data) c_int;
pub extern fn initstate_r(__seed: c_uint, noalias __statebuf: [*c]u8, __statelen: usize, noalias __buf: [*c]struct_random_data) c_int;
pub extern fn setstate_r(noalias __statebuf: [*c]u8, noalias __buf: [*c]struct_random_data) c_int;
pub extern fn rand() c_int;
pub extern fn srand(__seed: c_uint) void;
pub extern fn rand_r(__seed: [*c]c_uint) c_int;
pub extern fn drand48() f64;
pub extern fn erand48(__xsubi: [*c]c_ushort) f64;
pub extern fn lrand48() c_long;
pub extern fn nrand48(__xsubi: [*c]c_ushort) c_long;
pub extern fn mrand48() c_long;
pub extern fn jrand48(__xsubi: [*c]c_ushort) c_long;
pub extern fn srand48(__seedval: c_long) void;
pub extern fn seed48(__seed16v: [*c]c_ushort) [*c]c_ushort;
pub extern fn lcong48(__param: [*c]c_ushort) void;
pub const struct_drand48_data = extern struct {
    __x: [3]c_ushort = @import("std").mem.zeroes([3]c_ushort),
    __old_x: [3]c_ushort = @import("std").mem.zeroes([3]c_ushort),
    __c: c_ushort = @import("std").mem.zeroes(c_ushort),
    __init: c_ushort = @import("std").mem.zeroes(c_ushort),
    __a: c_ulonglong = @import("std").mem.zeroes(c_ulonglong),
};
pub extern fn drand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]f64) c_int;
pub extern fn erand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]f64) c_int;
pub extern fn lrand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn nrand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn mrand48_r(noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn jrand48_r(__xsubi: [*c]c_ushort, noalias __buffer: [*c]struct_drand48_data, noalias __result: [*c]c_long) c_int;
pub extern fn srand48_r(__seedval: c_long, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn seed48_r(__seed16v: [*c]c_ushort, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn lcong48_r(__param: [*c]c_ushort, __buffer: [*c]struct_drand48_data) c_int;
pub extern fn arc4random() __uint32_t;
pub extern fn arc4random_buf(__buf: ?*anyopaque, __size: usize) void;
pub extern fn arc4random_uniform(__upper_bound: __uint32_t) __uint32_t;
pub extern fn malloc(__size: c_ulong) ?*anyopaque;
pub extern fn calloc(__nmemb: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn realloc(__ptr: ?*anyopaque, __size: c_ulong) ?*anyopaque;
pub extern fn free(__ptr: ?*anyopaque) void;
pub extern fn reallocarray(__ptr: ?*anyopaque, __nmemb: usize, __size: usize) ?*anyopaque;
pub extern fn alloca(__size: c_ulong) ?*anyopaque;
pub extern fn valloc(__size: usize) ?*anyopaque;
pub extern fn posix_memalign(__memptr: [*c]?*anyopaque, __alignment: usize, __size: usize) c_int;
pub extern fn aligned_alloc(__alignment: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn abort() noreturn;
pub extern fn atexit(__func: ?*const fn () callconv(.c) void) c_int;
pub extern fn at_quick_exit(__func: ?*const fn () callconv(.c) void) c_int;
pub extern fn on_exit(__func: ?*const fn (c_int, ?*anyopaque) callconv(.c) void, __arg: ?*anyopaque) c_int;
pub extern fn exit(__status: c_int) noreturn;
pub extern fn quick_exit(__status: c_int) noreturn;
pub extern fn _Exit(__status: c_int) noreturn;
pub extern fn getenv(__name: [*c]const u8) [*c]u8;
pub extern fn secure_getenv(__name: [*c]const u8) [*c]u8;
pub extern fn putenv(__string: [*c]u8) c_int;
pub extern fn setenv(__name: [*c]const u8, __value: [*c]const u8, __replace: c_int) c_int;
pub extern fn unsetenv(__name: [*c]const u8) c_int;
pub extern fn clearenv() c_int;
pub extern fn mktemp(__template: [*c]u8) [*c]u8;
pub extern fn mkstemp(__template: [*c]u8) c_int;
pub extern fn mkstemp64(__template: [*c]u8) c_int;
pub extern fn mkstemps(__template: [*c]u8, __suffixlen: c_int) c_int;
pub extern fn mkstemps64(__template: [*c]u8, __suffixlen: c_int) c_int;
pub extern fn mkdtemp(__template: [*c]u8) [*c]u8;
pub extern fn mkostemp(__template: [*c]u8, __flags: c_int) c_int;
pub extern fn mkostemp64(__template: [*c]u8, __flags: c_int) c_int;
pub extern fn mkostemps(__template: [*c]u8, __suffixlen: c_int, __flags: c_int) c_int;
pub extern fn mkostemps64(__template: [*c]u8, __suffixlen: c_int, __flags: c_int) c_int;
pub extern fn system(__command: [*c]const u8) c_int;
pub extern fn canonicalize_file_name(__name: [*c]const u8) [*c]u8;
pub extern fn realpath(noalias __name: [*c]const u8, noalias __resolved: [*c]u8) [*c]u8;
pub const __compar_fn_t = ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.c) c_int;
pub const comparison_fn_t = __compar_fn_t;
pub const __compar_d_fn_t = ?*const fn (?*const anyopaque, ?*const anyopaque, ?*anyopaque) callconv(.c) c_int;
pub extern fn bsearch(__key: ?*const anyopaque, __base: ?*const anyopaque, __nmemb: usize, __size: usize, __compar: __compar_fn_t) ?*anyopaque;
pub extern fn qsort(__base: ?*anyopaque, __nmemb: usize, __size: usize, __compar: __compar_fn_t) void;
pub extern fn qsort_r(__base: ?*anyopaque, __nmemb: usize, __size: usize, __compar: __compar_d_fn_t, __arg: ?*anyopaque) void;
pub extern fn abs(__x: c_int) c_int;
pub extern fn labs(__x: c_long) c_long;
pub extern fn llabs(__x: c_longlong) c_longlong;
pub extern fn div(__numer: c_int, __denom: c_int) div_t;
pub extern fn ldiv(__numer: c_long, __denom: c_long) ldiv_t;
pub extern fn lldiv(__numer: c_longlong, __denom: c_longlong) lldiv_t;
pub extern fn ecvt(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn fcvt(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn gcvt(__value: f64, __ndigit: c_int, __buf: [*c]u8) [*c]u8;
pub extern fn qecvt(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn qfcvt(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int) [*c]u8;
pub extern fn qgcvt(__value: c_longdouble, __ndigit: c_int, __buf: [*c]u8) [*c]u8;
pub extern fn ecvt_r(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn fcvt_r(__value: f64, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn qecvt_r(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn qfcvt_r(__value: c_longdouble, __ndigit: c_int, noalias __decpt: [*c]c_int, noalias __sign: [*c]c_int, noalias __buf: [*c]u8, __len: usize) c_int;
pub extern fn mblen(__s: [*c]const u8, __n: usize) c_int;
pub extern fn mbtowc(noalias __pwc: [*c]wchar_t, noalias __s: [*c]const u8, __n: usize) c_int;
pub extern fn wctomb(__s: [*c]u8, __wchar: wchar_t) c_int;
pub extern fn mbstowcs(noalias __pwcs: [*c]wchar_t, noalias __s: [*c]const u8, __n: usize) usize;
pub extern fn wcstombs(noalias __s: [*c]u8, noalias __pwcs: [*c]const wchar_t, __n: usize) usize;
pub extern fn rpmatch(__response: [*c]const u8) c_int;
pub extern fn getsubopt(noalias __optionp: [*c][*c]u8, noalias __tokens: [*c]const [*c]u8, noalias __valuep: [*c][*c]u8) c_int;
pub extern fn posix_openpt(__oflag: c_int) c_int;
pub extern fn grantpt(__fd: c_int) c_int;
pub extern fn unlockpt(__fd: c_int) c_int;
pub extern fn ptsname(__fd: c_int) [*c]u8;
pub extern fn ptsname_r(__fd: c_int, __buf: [*c]u8, __buflen: usize) c_int;
pub extern fn getpt() c_int;
pub extern fn getloadavg(__loadavg: [*c]f64, __nelem: c_int) c_int;
pub const _ISupper: c_int = 256;
pub const _ISlower: c_int = 512;
pub const _ISalpha: c_int = 1024;
pub const _ISdigit: c_int = 2048;
pub const _ISxdigit: c_int = 4096;
pub const _ISspace: c_int = 8192;
pub const _ISprint: c_int = 16384;
pub const _ISgraph: c_int = 32768;
pub const _ISblank: c_int = 1;
pub const _IScntrl: c_int = 2;
pub const _ISpunct: c_int = 4;
pub const _ISalnum: c_int = 8;
const enum_unnamed_8 = c_uint;
pub extern fn __ctype_b_loc() [*c][*c]const c_ushort;
pub extern fn __ctype_tolower_loc() [*c][*c]const __int32_t;
pub extern fn __ctype_toupper_loc() [*c][*c]const __int32_t;
pub extern fn isalnum(c_int) c_int;
pub extern fn isalpha(c_int) c_int;
pub extern fn iscntrl(c_int) c_int;
pub extern fn isdigit(c_int) c_int;
pub extern fn islower(c_int) c_int;
pub extern fn isgraph(c_int) c_int;
pub extern fn isprint(c_int) c_int;
pub extern fn ispunct(c_int) c_int;
pub extern fn isspace(c_int) c_int;
pub extern fn isupper(c_int) c_int;
pub extern fn isxdigit(c_int) c_int;
pub extern fn tolower(__c: c_int) c_int;
pub extern fn toupper(__c: c_int) c_int;
pub extern fn isblank(c_int) c_int;
pub extern fn isctype(__c: c_int, __mask: c_int) c_int;
pub extern fn isascii(__c: c_int) c_int;
pub extern fn toascii(__c: c_int) c_int;
pub extern fn _toupper(c_int) c_int;
pub extern fn _tolower(c_int) c_int;
pub extern fn isalnum_l(c_int, locale_t) c_int;
pub extern fn isalpha_l(c_int, locale_t) c_int;
pub extern fn iscntrl_l(c_int, locale_t) c_int;
pub extern fn isdigit_l(c_int, locale_t) c_int;
pub extern fn islower_l(c_int, locale_t) c_int;
pub extern fn isgraph_l(c_int, locale_t) c_int;
pub extern fn isprint_l(c_int, locale_t) c_int;
pub extern fn ispunct_l(c_int, locale_t) c_int;
pub extern fn isspace_l(c_int, locale_t) c_int;
pub extern fn isupper_l(c_int, locale_t) c_int;
pub extern fn isxdigit_l(c_int, locale_t) c_int;
pub extern fn isblank_l(c_int, locale_t) c_int;
pub extern fn __tolower_l(__c: c_int, __l: locale_t) c_int;
pub extern fn tolower_l(__c: c_int, __l: locale_t) c_int;
pub extern fn __toupper_l(__c: c_int, __l: locale_t) c_int;
pub extern fn toupper_l(__c: c_int, __l: locale_t) c_int;
pub extern fn __errno_location() [*c]c_int;
pub extern var program_invocation_name: [*c]u8;
pub extern var program_invocation_short_name: [*c]u8;
pub const error_t = c_int;
pub extern fn memcpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memmove(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn memccpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn memset(__s: ?*anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn memcmp(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: c_ulong) c_int;
pub extern fn __memcmpeq(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: usize) c_int;
pub extern fn memchr(__s: ?*const anyopaque, __c: c_int, __n: c_ulong) ?*anyopaque;
pub extern fn rawmemchr(__s: ?*const anyopaque, __c: c_int) ?*anyopaque;
pub extern fn memrchr(__s: ?*const anyopaque, __c: c_int, __n: usize) ?*anyopaque;
pub extern fn strcpy(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strncpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strcat(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn strncat(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strcmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strncmp(__s1: [*c]const u8, __s2: [*c]const u8, __n: c_ulong) c_int;
pub extern fn strcoll(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strxfrm(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) c_ulong;
pub extern fn strcoll_l(__s1: [*c]const u8, __s2: [*c]const u8, __l: locale_t) c_int;
pub extern fn strxfrm_l(__dest: [*c]u8, __src: [*c]const u8, __n: usize, __l: locale_t) usize;
pub extern fn strdup(__s: [*c]const u8) [*c]u8;
pub extern fn strndup(__string: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strrchr(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strchrnul(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn strcspn(__s: [*c]const u8, __reject: [*c]const u8) c_ulong;
pub extern fn strspn(__s: [*c]const u8, __accept: [*c]const u8) c_ulong;
pub extern fn strpbrk(__s: [*c]const u8, __accept: [*c]const u8) [*c]u8;
pub extern fn strstr(__haystack: [*c]const u8, __needle: [*c]const u8) [*c]u8;
pub extern fn strtok(__s: [*c]u8, __delim: [*c]const u8) [*c]u8;
pub extern fn __strtok_r(noalias __s: [*c]u8, noalias __delim: [*c]const u8, noalias __save_ptr: [*c][*c]u8) [*c]u8;
pub extern fn strtok_r(noalias __s: [*c]u8, noalias __delim: [*c]const u8, noalias __save_ptr: [*c][*c]u8) [*c]u8;
pub extern fn strcasestr(__haystack: [*c]const u8, __needle: [*c]const u8) [*c]u8;
pub extern fn memmem(__haystack: ?*const anyopaque, __haystacklen: usize, __needle: ?*const anyopaque, __needlelen: usize) ?*anyopaque;
pub extern fn __mempcpy(noalias __dest: ?*anyopaque, noalias __src: ?*const anyopaque, __n: usize) ?*anyopaque;
pub extern fn mempcpy(__dest: ?*anyopaque, __src: ?*const anyopaque, __n: c_ulong) ?*anyopaque;
pub extern fn strlen(__s: [*c]const u8) c_ulong;
pub extern fn strnlen(__string: [*c]const u8, __maxlen: usize) usize;
pub extern fn strerror(__errnum: c_int) [*c]u8;
pub extern fn strerror_r(__errnum: c_int, __buf: [*c]u8, __buflen: usize) [*c]u8;
pub extern fn strerrordesc_np(__err: c_int) [*c]const u8;
pub extern fn strerrorname_np(__err: c_int) [*c]const u8;
pub extern fn strerror_l(__errnum: c_int, __l: locale_t) [*c]u8;
pub extern fn bcmp(__s1: ?*const anyopaque, __s2: ?*const anyopaque, __n: c_ulong) c_int;
pub extern fn bcopy(__src: ?*const anyopaque, __dest: ?*anyopaque, __n: c_ulong) void;
pub extern fn bzero(__s: ?*anyopaque, __n: c_ulong) void;
pub extern fn index(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn rindex(__s: [*c]const u8, __c: c_int) [*c]u8;
pub extern fn ffs(__i: c_int) c_int;
pub extern fn ffsl(__l: c_long) c_int;
pub extern fn ffsll(__ll: c_longlong) c_int;
pub extern fn strcasecmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strncasecmp(__s1: [*c]const u8, __s2: [*c]const u8, __n: c_ulong) c_int;
pub extern fn strcasecmp_l(__s1: [*c]const u8, __s2: [*c]const u8, __loc: locale_t) c_int;
pub extern fn strncasecmp_l(__s1: [*c]const u8, __s2: [*c]const u8, __n: usize, __loc: locale_t) c_int;
pub extern fn explicit_bzero(__s: ?*anyopaque, __n: usize) void;
pub extern fn strsep(noalias __stringp: [*c][*c]u8, noalias __delim: [*c]const u8) [*c]u8;
pub extern fn strsignal(__sig: c_int) [*c]u8;
pub extern fn sigabbrev_np(__sig: c_int) [*c]const u8;
pub extern fn sigdescr_np(__sig: c_int) [*c]const u8;
pub extern fn __stpcpy(noalias __dest: [*c]u8, noalias __src: [*c]const u8) [*c]u8;
pub extern fn stpcpy(__dest: [*c]u8, __src: [*c]const u8) [*c]u8;
pub extern fn __stpncpy(noalias __dest: [*c]u8, noalias __src: [*c]const u8, __n: usize) [*c]u8;
pub extern fn stpncpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) [*c]u8;
pub extern fn strlcpy(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) c_ulong;
pub extern fn strlcat(__dest: [*c]u8, __src: [*c]const u8, __n: c_ulong) c_ulong;
pub extern fn strverscmp(__s1: [*c]const u8, __s2: [*c]const u8) c_int;
pub extern fn strfry(__string: [*c]u8) [*c]u8;
pub extern fn memfrob(__s: ?*anyopaque, __n: usize) ?*anyopaque;
pub extern fn basename(__filename: [*c]const u8) [*c]u8;
pub const sig_atomic_t = __sig_atomic_t;
pub const union_sigval = extern union {
    sival_int: c_int,
    sival_ptr: ?*anyopaque,
};
pub const __sigval_t = union_sigval;
const struct_unnamed_10 = extern struct {
    si_pid: __pid_t = @import("std").mem.zeroes(__pid_t),
    si_uid: __uid_t = @import("std").mem.zeroes(__uid_t),
};
const struct_unnamed_11 = extern struct {
    si_tid: c_int = @import("std").mem.zeroes(c_int),
    si_overrun: c_int = @import("std").mem.zeroes(c_int),
    si_sigval: __sigval_t = @import("std").mem.zeroes(__sigval_t),
};
const struct_unnamed_12 = extern struct {
    si_pid: __pid_t = @import("std").mem.zeroes(__pid_t),
    si_uid: __uid_t = @import("std").mem.zeroes(__uid_t),
    si_sigval: __sigval_t = @import("std").mem.zeroes(__sigval_t),
};
const struct_unnamed_13 = extern struct {
    si_pid: __pid_t = @import("std").mem.zeroes(__pid_t),
    si_uid: __uid_t = @import("std").mem.zeroes(__uid_t),
    si_status: c_int = @import("std").mem.zeroes(c_int),
    si_utime: __clock_t = @import("std").mem.zeroes(__clock_t),
    si_stime: __clock_t = @import("std").mem.zeroes(__clock_t),
};
const struct_unnamed_16 = extern struct {
    _lower: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    _upper: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
const union_unnamed_15 = extern union {
    _addr_bnd: struct_unnamed_16,
    _pkey: __uint32_t,
};
const struct_unnamed_14 = extern struct {
    si_addr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    si_addr_lsb: c_short = @import("std").mem.zeroes(c_short),
    _bounds: union_unnamed_15 = @import("std").mem.zeroes(union_unnamed_15),
};
const struct_unnamed_17 = extern struct {
    si_band: c_long = @import("std").mem.zeroes(c_long),
    si_fd: c_int = @import("std").mem.zeroes(c_int),
};
const struct_unnamed_18 = extern struct {
    _call_addr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    _syscall: c_int = @import("std").mem.zeroes(c_int),
    _arch: c_uint = @import("std").mem.zeroes(c_uint),
};
const union_unnamed_9 = extern union {
    _pad: [28]c_int,
    _kill: struct_unnamed_10,
    _timer: struct_unnamed_11,
    _rt: struct_unnamed_12,
    _sigchld: struct_unnamed_13,
    _sigfault: struct_unnamed_14,
    _sigpoll: struct_unnamed_17,
    _sigsys: struct_unnamed_18,
};
pub const siginfo_t = extern struct {
    si_signo: c_int = @import("std").mem.zeroes(c_int),
    si_errno: c_int = @import("std").mem.zeroes(c_int),
    si_code: c_int = @import("std").mem.zeroes(c_int),
    __pad0: c_int = @import("std").mem.zeroes(c_int),
    _sifields: union_unnamed_9 = @import("std").mem.zeroes(union_unnamed_9),
};
pub const SI_ASYNCNL: c_int = -60;
pub const SI_DETHREAD: c_int = -7;
pub const SI_TKILL: c_int = -6;
pub const SI_SIGIO: c_int = -5;
pub const SI_ASYNCIO: c_int = -4;
pub const SI_MESGQ: c_int = -3;
pub const SI_TIMER: c_int = -2;
pub const SI_QUEUE: c_int = -1;
pub const SI_USER: c_int = 0;
pub const SI_KERNEL: c_int = 128;
const enum_unnamed_19 = c_int;
pub const ILL_ILLOPC: c_int = 1;
pub const ILL_ILLOPN: c_int = 2;
pub const ILL_ILLADR: c_int = 3;
pub const ILL_ILLTRP: c_int = 4;
pub const ILL_PRVOPC: c_int = 5;
pub const ILL_PRVREG: c_int = 6;
pub const ILL_COPROC: c_int = 7;
pub const ILL_BADSTK: c_int = 8;
pub const ILL_BADIADDR: c_int = 9;
const enum_unnamed_20 = c_uint;
pub const FPE_INTDIV: c_int = 1;
pub const FPE_INTOVF: c_int = 2;
pub const FPE_FLTDIV: c_int = 3;
pub const FPE_FLTOVF: c_int = 4;
pub const FPE_FLTUND: c_int = 5;
pub const FPE_FLTRES: c_int = 6;
pub const FPE_FLTINV: c_int = 7;
pub const FPE_FLTSUB: c_int = 8;
pub const FPE_FLTUNK: c_int = 14;
pub const FPE_CONDTRAP: c_int = 15;
const enum_unnamed_21 = c_uint;
pub const SEGV_MAPERR: c_int = 1;
pub const SEGV_ACCERR: c_int = 2;
pub const SEGV_BNDERR: c_int = 3;
pub const SEGV_PKUERR: c_int = 4;
pub const SEGV_ACCADI: c_int = 5;
pub const SEGV_ADIDERR: c_int = 6;
pub const SEGV_ADIPERR: c_int = 7;
pub const SEGV_MTEAERR: c_int = 8;
pub const SEGV_MTESERR: c_int = 9;
pub const SEGV_CPERR: c_int = 10;
const enum_unnamed_22 = c_uint;
pub const BUS_ADRALN: c_int = 1;
pub const BUS_ADRERR: c_int = 2;
pub const BUS_OBJERR: c_int = 3;
pub const BUS_MCEERR_AR: c_int = 4;
pub const BUS_MCEERR_AO: c_int = 5;
const enum_unnamed_23 = c_uint;
pub const TRAP_BRKPT: c_int = 1;
pub const TRAP_TRACE: c_int = 2;
pub const TRAP_BRANCH: c_int = 3;
pub const TRAP_HWBKPT: c_int = 4;
pub const TRAP_UNK: c_int = 5;
const enum_unnamed_24 = c_uint;
pub const CLD_EXITED: c_int = 1;
pub const CLD_KILLED: c_int = 2;
pub const CLD_DUMPED: c_int = 3;
pub const CLD_TRAPPED: c_int = 4;
pub const CLD_STOPPED: c_int = 5;
pub const CLD_CONTINUED: c_int = 6;
const enum_unnamed_25 = c_uint;
pub const POLL_IN: c_int = 1;
pub const POLL_OUT: c_int = 2;
pub const POLL_MSG: c_int = 3;
pub const POLL_ERR: c_int = 4;
pub const POLL_PRI: c_int = 5;
pub const POLL_HUP: c_int = 6;
const enum_unnamed_26 = c_uint;
pub const sigval_t = __sigval_t;
const struct_unnamed_28 = extern struct {
    _function: ?*const fn (__sigval_t) callconv(.c) void = @import("std").mem.zeroes(?*const fn (__sigval_t) callconv(.c) void),
    _attribute: [*c]pthread_attr_t = @import("std").mem.zeroes([*c]pthread_attr_t),
};
const union_unnamed_27 = extern union {
    _pad: [12]c_int,
    _tid: __pid_t,
    _sigev_thread: struct_unnamed_28,
};
pub const struct_sigevent = extern struct {
    sigev_value: __sigval_t = @import("std").mem.zeroes(__sigval_t),
    sigev_signo: c_int = @import("std").mem.zeroes(c_int),
    sigev_notify: c_int = @import("std").mem.zeroes(c_int),
    _sigev_un: union_unnamed_27 = @import("std").mem.zeroes(union_unnamed_27),
};
pub const sigevent_t = struct_sigevent;
pub const SIGEV_SIGNAL: c_int = 0;
pub const SIGEV_NONE: c_int = 1;
pub const SIGEV_THREAD: c_int = 2;
pub const SIGEV_THREAD_ID: c_int = 4;
const enum_unnamed_29 = c_uint;
pub const __sighandler_t = ?*const fn (c_int) callconv(.c) void;
pub extern fn __sysv_signal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn sysv_signal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn signal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn kill(__pid: __pid_t, __sig: c_int) c_int;
pub extern fn killpg(__pgrp: __pid_t, __sig: c_int) c_int;
pub extern fn raise(__sig: c_int) c_int;
pub extern fn ssignal(__sig: c_int, __handler: __sighandler_t) __sighandler_t;
pub extern fn gsignal(__sig: c_int) c_int;
pub extern fn psignal(__sig: c_int, __s: [*c]const u8) void;
pub extern fn psiginfo(__pinfo: [*c]const siginfo_t, __s: [*c]const u8) void;
pub extern fn sigpause(__sig: c_int) c_int;
pub extern fn sigblock(__mask: c_int) c_int;
pub extern fn sigsetmask(__mask: c_int) c_int;
pub extern fn siggetmask() c_int;
pub const sighandler_t = __sighandler_t;
pub const sig_t = __sighandler_t;
pub extern fn sigemptyset(__set: [*c]sigset_t) c_int;
pub extern fn sigfillset(__set: [*c]sigset_t) c_int;
pub extern fn sigaddset(__set: [*c]sigset_t, __signo: c_int) c_int;
pub extern fn sigdelset(__set: [*c]sigset_t, __signo: c_int) c_int;
pub extern fn sigismember(__set: [*c]const sigset_t, __signo: c_int) c_int;
pub extern fn sigisemptyset(__set: [*c]const sigset_t) c_int;
pub extern fn sigandset(__set: [*c]sigset_t, __left: [*c]const sigset_t, __right: [*c]const sigset_t) c_int;
pub extern fn sigorset(__set: [*c]sigset_t, __left: [*c]const sigset_t, __right: [*c]const sigset_t) c_int;
const union_unnamed_30 = extern union {
    sa_handler: __sighandler_t,
    sa_sigaction: ?*const fn (c_int, [*c]siginfo_t, ?*anyopaque) callconv(.c) void,
};
pub const struct_sigaction = extern struct {
    __sigaction_handler: union_unnamed_30 = @import("std").mem.zeroes(union_unnamed_30),
    sa_mask: __sigset_t = @import("std").mem.zeroes(__sigset_t),
    sa_flags: c_int = @import("std").mem.zeroes(c_int),
    sa_restorer: ?*const fn () callconv(.c) void = @import("std").mem.zeroes(?*const fn () callconv(.c) void),
};
pub extern fn sigprocmask(__how: c_int, noalias __set: [*c]const sigset_t, noalias __oset: [*c]sigset_t) c_int;
pub extern fn sigsuspend(__set: [*c]const sigset_t) c_int;
pub extern fn sigaction(__sig: c_int, noalias __act: [*c]const struct_sigaction, noalias __oact: [*c]struct_sigaction) c_int;
pub extern fn sigpending(__set: [*c]sigset_t) c_int;
pub extern fn sigwait(noalias __set: [*c]const sigset_t, noalias __sig: [*c]c_int) c_int;
pub extern fn sigwaitinfo(noalias __set: [*c]const sigset_t, noalias __info: [*c]siginfo_t) c_int;
pub extern fn sigtimedwait(noalias __set: [*c]const sigset_t, noalias __info: [*c]siginfo_t, noalias __timeout: [*c]const struct_timespec) c_int;
pub extern fn sigqueue(__pid: __pid_t, __sig: c_int, __val: union_sigval) c_int;
pub const struct__fpx_sw_bytes = extern struct {
    magic1: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    extended_size: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    xstate_bv: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    xstate_size: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    __glibc_reserved1: [7]__uint32_t = @import("std").mem.zeroes([7]__uint32_t),
};
pub const struct__fpreg = extern struct {
    significand: [4]c_ushort = @import("std").mem.zeroes([4]c_ushort),
    exponent: c_ushort = @import("std").mem.zeroes(c_ushort),
};
pub const struct__fpxreg = extern struct {
    significand: [4]c_ushort = @import("std").mem.zeroes([4]c_ushort),
    exponent: c_ushort = @import("std").mem.zeroes(c_ushort),
    __glibc_reserved1: [3]c_ushort = @import("std").mem.zeroes([3]c_ushort),
};
pub const struct__xmmreg = extern struct {
    element: [4]__uint32_t = @import("std").mem.zeroes([4]__uint32_t),
};
pub const struct__fpstate = extern struct {
    cwd: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    swd: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    ftw: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    fop: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    rip: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rdp: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    mxcsr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    mxcr_mask: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    _st: [8]struct__fpxreg = @import("std").mem.zeroes([8]struct__fpxreg),
    _xmm: [16]struct__xmmreg = @import("std").mem.zeroes([16]struct__xmmreg),
    __glibc_reserved1: [24]__uint32_t = @import("std").mem.zeroes([24]__uint32_t),
};
const union_unnamed_31 = extern union {
    fpstate: [*c]struct__fpstate,
    __fpstate_word: __uint64_t,
};
pub const struct_sigcontext = extern struct {
    r8: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r9: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r10: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r11: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r12: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r13: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r14: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    r15: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rdi: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rsi: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rbp: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rbx: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rdx: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rax: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rcx: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rsp: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rip: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    eflags: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    cs: c_ushort = @import("std").mem.zeroes(c_ushort),
    gs: c_ushort = @import("std").mem.zeroes(c_ushort),
    fs: c_ushort = @import("std").mem.zeroes(c_ushort),
    __pad0: c_ushort = @import("std").mem.zeroes(c_ushort),
    err: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    trapno: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    oldmask: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    cr2: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    unnamed_0: union_unnamed_31 = @import("std").mem.zeroes(union_unnamed_31),
    __reserved1: [8]__uint64_t = @import("std").mem.zeroes([8]__uint64_t),
};
pub const struct__xsave_hdr = extern struct {
    xstate_bv: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    __glibc_reserved1: [2]__uint64_t = @import("std").mem.zeroes([2]__uint64_t),
    __glibc_reserved2: [5]__uint64_t = @import("std").mem.zeroes([5]__uint64_t),
};
pub const struct__ymmh_state = extern struct {
    ymmh_space: [64]__uint32_t = @import("std").mem.zeroes([64]__uint32_t),
};
pub const struct__xstate = extern struct {
    fpstate: struct__fpstate = @import("std").mem.zeroes(struct__fpstate),
    xstate_hdr: struct__xsave_hdr = @import("std").mem.zeroes(struct__xsave_hdr),
    ymmh: struct__ymmh_state = @import("std").mem.zeroes(struct__ymmh_state),
};
pub extern fn sigreturn(__scp: [*c]struct_sigcontext) c_int;
pub const stack_t = extern struct {
    ss_sp: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    ss_flags: c_int = @import("std").mem.zeroes(c_int),
    ss_size: usize = @import("std").mem.zeroes(usize),
};
pub const greg_t = c_longlong;
pub const gregset_t = [23]greg_t;
pub const REG_R8: c_int = 0;
pub const REG_R9: c_int = 1;
pub const REG_R10: c_int = 2;
pub const REG_R11: c_int = 3;
pub const REG_R12: c_int = 4;
pub const REG_R13: c_int = 5;
pub const REG_R14: c_int = 6;
pub const REG_R15: c_int = 7;
pub const REG_RDI: c_int = 8;
pub const REG_RSI: c_int = 9;
pub const REG_RBP: c_int = 10;
pub const REG_RBX: c_int = 11;
pub const REG_RDX: c_int = 12;
pub const REG_RAX: c_int = 13;
pub const REG_RCX: c_int = 14;
pub const REG_RSP: c_int = 15;
pub const REG_RIP: c_int = 16;
pub const REG_EFL: c_int = 17;
pub const REG_CSGSFS: c_int = 18;
pub const REG_ERR: c_int = 19;
pub const REG_TRAPNO: c_int = 20;
pub const REG_OLDMASK: c_int = 21;
pub const REG_CR2: c_int = 22;
const enum_unnamed_32 = c_uint;
pub const struct__libc_fpxreg = extern struct {
    significand: [4]c_ushort = @import("std").mem.zeroes([4]c_ushort),
    exponent: c_ushort = @import("std").mem.zeroes(c_ushort),
    __glibc_reserved1: [3]c_ushort = @import("std").mem.zeroes([3]c_ushort),
};
pub const struct__libc_xmmreg = extern struct {
    element: [4]__uint32_t = @import("std").mem.zeroes([4]__uint32_t),
};
pub const struct__libc_fpstate = extern struct {
    cwd: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    swd: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    ftw: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    fop: __uint16_t = @import("std").mem.zeroes(__uint16_t),
    rip: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    rdp: __uint64_t = @import("std").mem.zeroes(__uint64_t),
    mxcsr: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    mxcr_mask: __uint32_t = @import("std").mem.zeroes(__uint32_t),
    _st: [8]struct__libc_fpxreg = @import("std").mem.zeroes([8]struct__libc_fpxreg),
    _xmm: [16]struct__libc_xmmreg = @import("std").mem.zeroes([16]struct__libc_xmmreg),
    __glibc_reserved1: [24]__uint32_t = @import("std").mem.zeroes([24]__uint32_t),
};
pub const fpregset_t = [*c]struct__libc_fpstate;
pub const mcontext_t = extern struct {
    gregs: gregset_t = @import("std").mem.zeroes(gregset_t),
    fpregs: fpregset_t = @import("std").mem.zeroes(fpregset_t),
    __reserved1: [8]c_ulonglong = @import("std").mem.zeroes([8]c_ulonglong),
};
pub const struct_ucontext_t = extern struct {
    uc_flags: c_ulong = @import("std").mem.zeroes(c_ulong),
    uc_link: [*c]struct_ucontext_t = @import("std").mem.zeroes([*c]struct_ucontext_t),
    uc_stack: stack_t = @import("std").mem.zeroes(stack_t),
    uc_mcontext: mcontext_t = @import("std").mem.zeroes(mcontext_t),
    uc_sigmask: sigset_t = @import("std").mem.zeroes(sigset_t),
    __fpregs_mem: struct__libc_fpstate = @import("std").mem.zeroes(struct__libc_fpstate),
    __ssp: [4]c_ulonglong = @import("std").mem.zeroes([4]c_ulonglong),
};
pub const ucontext_t = struct_ucontext_t;
pub extern fn siginterrupt(__sig: c_int, __interrupt: c_int) c_int;
pub const SS_ONSTACK: c_int = 1;
pub const SS_DISABLE: c_int = 2;
const enum_unnamed_33 = c_uint;
pub extern fn sigaltstack(noalias __ss: [*c]const stack_t, noalias __oss: [*c]stack_t) c_int;
pub const struct_sigstack = extern struct {
    ss_sp: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    ss_onstack: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn sigstack(__ss: [*c]struct_sigstack, __oss: [*c]struct_sigstack) c_int;
pub extern fn sighold(__sig: c_int) c_int;
pub extern fn sigrelse(__sig: c_int) c_int;
pub extern fn sigignore(__sig: c_int) c_int;
pub extern fn sigset(__sig: c_int, __disp: __sighandler_t) __sighandler_t;
pub extern fn pthread_sigmask(__how: c_int, noalias __newmask: [*c]const __sigset_t, noalias __oldmask: [*c]__sigset_t) c_int;
pub extern fn pthread_kill(__threadid: pthread_t, __signo: c_int) c_int;
pub extern fn pthread_sigqueue(__threadid: pthread_t, __signo: c_int, __value: union_sigval) c_int;
pub extern fn __libc_current_sigrtmin() c_int;
pub extern fn __libc_current_sigrtmax() c_int;
pub extern fn tgkill(__tgid: __pid_t, __tid: __pid_t, __signal: c_int) c_int;
pub const struct_passwd = extern struct {
    pw_name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    pw_passwd: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    pw_uid: __uid_t = @import("std").mem.zeroes(__uid_t),
    pw_gid: __gid_t = @import("std").mem.zeroes(__gid_t),
    pw_gecos: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    pw_dir: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    pw_shell: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub extern fn setpwent() void;
pub extern fn endpwent() void;
pub extern fn getpwent() [*c]struct_passwd;
pub extern fn fgetpwent(__stream: [*c]FILE) [*c]struct_passwd;
pub extern fn putpwent(noalias __p: [*c]const struct_passwd, noalias __f: [*c]FILE) c_int;
pub extern fn getpwuid(__uid: __uid_t) [*c]struct_passwd;
pub extern fn getpwnam(__name: [*c]const u8) [*c]struct_passwd;
pub extern fn getpwent_r(noalias __resultbuf: [*c]struct_passwd, noalias __buffer: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_passwd) c_int;
pub extern fn getpwuid_r(__uid: __uid_t, noalias __resultbuf: [*c]struct_passwd, noalias __buffer: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_passwd) c_int;
pub extern fn getpwnam_r(noalias __name: [*c]const u8, noalias __resultbuf: [*c]struct_passwd, noalias __buffer: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_passwd) c_int;
pub extern fn fgetpwent_r(noalias __stream: [*c]FILE, noalias __resultbuf: [*c]struct_passwd, noalias __buffer: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_passwd) c_int;
pub extern fn getpw(__uid: __uid_t, __buffer: [*c]u8) c_int;
pub const struct_group = extern struct {
    gr_name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    gr_passwd: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    gr_gid: __gid_t = @import("std").mem.zeroes(__gid_t),
    gr_mem: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
};
pub extern fn setgrent() void;
pub extern fn endgrent() void;
pub extern fn getgrent() [*c]struct_group;
pub extern fn fgetgrent(__stream: [*c]FILE) [*c]struct_group;
pub extern fn putgrent(noalias __p: [*c]const struct_group, noalias __f: [*c]FILE) c_int;
pub extern fn getgrgid(__gid: __gid_t) [*c]struct_group;
pub extern fn getgrnam(__name: [*c]const u8) [*c]struct_group;
pub extern fn getgrent_r(noalias __resultbuf: [*c]struct_group, noalias __buffer: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_group) c_int;
pub extern fn getgrgid_r(__gid: __gid_t, noalias __resultbuf: [*c]struct_group, noalias __buffer: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_group) c_int;
pub extern fn getgrnam_r(noalias __name: [*c]const u8, noalias __resultbuf: [*c]struct_group, noalias __buffer: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_group) c_int;
pub extern fn fgetgrent_r(noalias __stream: [*c]FILE, noalias __resultbuf: [*c]struct_group, noalias __buffer: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_group) c_int;
pub extern fn setgroups(__n: usize, __groups: [*c]const __gid_t) c_int;
pub extern fn getgrouplist(__user: [*c]const u8, __group: __gid_t, __groups: [*c]__gid_t, __ngroups: [*c]c_int) c_int;
pub extern fn initgroups(__user: [*c]const u8, __group: __gid_t) c_int;
pub const struct_dirent = extern struct {
    d_ino: __ino64_t = @import("std").mem.zeroes(__ino64_t),
    d_off: __off64_t = @import("std").mem.zeroes(__off64_t),
    d_reclen: c_ushort = @import("std").mem.zeroes(c_ushort),
    d_type: u8 = @import("std").mem.zeroes(u8),
    d_name: [256]u8 = @import("std").mem.zeroes([256]u8),
};
pub const struct_dirent64 = extern struct {
    d_ino: __ino64_t = @import("std").mem.zeroes(__ino64_t),
    d_off: __off64_t = @import("std").mem.zeroes(__off64_t),
    d_reclen: c_ushort = @import("std").mem.zeroes(c_ushort),
    d_type: u8 = @import("std").mem.zeroes(u8),
    d_name: [256]u8 = @import("std").mem.zeroes([256]u8),
};
pub const DT_UNKNOWN: c_int = 0;
pub const DT_FIFO: c_int = 1;
pub const DT_CHR: c_int = 2;
pub const DT_DIR: c_int = 4;
pub const DT_BLK: c_int = 6;
pub const DT_REG: c_int = 8;
pub const DT_LNK: c_int = 10;
pub const DT_SOCK: c_int = 12;
pub const DT_WHT: c_int = 14;
const enum_unnamed_34 = c_uint;
pub const struct___dirstream = opaque {};
pub const DIR = struct___dirstream;
pub extern fn closedir(__dirp: ?*DIR) c_int;
pub extern fn opendir(__name: [*c]const u8) ?*DIR;
pub extern fn fdopendir(__fd: c_int) ?*DIR;
pub extern fn readdir(__dirp: ?*DIR) [*c]struct_dirent;
pub extern fn readdir64(__dirp: ?*DIR) [*c]struct_dirent64;
pub extern fn readdir_r(noalias __dirp: ?*DIR, noalias __entry: [*c]struct_dirent, noalias __result: [*c][*c]struct_dirent) c_int;
pub extern fn readdir64_r(noalias __dirp: ?*DIR, noalias __entry: [*c]struct_dirent64, noalias __result: [*c][*c]struct_dirent64) c_int;
pub extern fn rewinddir(__dirp: ?*DIR) void;
pub extern fn seekdir(__dirp: ?*DIR, __pos: c_long) void;
pub extern fn telldir(__dirp: ?*DIR) c_long;
pub extern fn dirfd(__dirp: ?*DIR) c_int;
pub extern fn __sysconf(__name: c_int) c_long;
pub extern fn scandir(noalias __dir: [*c]const u8, noalias __namelist: [*c][*c][*c]struct_dirent, __selector: ?*const fn ([*c]const struct_dirent) callconv(.c) c_int, __cmp: ?*const fn ([*c][*c]const struct_dirent, [*c][*c]const struct_dirent) callconv(.c) c_int) c_int;
pub extern fn scandir64(noalias __dir: [*c]const u8, noalias __namelist: [*c][*c][*c]struct_dirent64, __selector: ?*const fn ([*c]const struct_dirent64) callconv(.c) c_int, __cmp: ?*const fn ([*c][*c]const struct_dirent64, [*c][*c]const struct_dirent64) callconv(.c) c_int) c_int;
pub extern fn scandirat(__dfd: c_int, noalias __dir: [*c]const u8, noalias __namelist: [*c][*c][*c]struct_dirent, __selector: ?*const fn ([*c]const struct_dirent) callconv(.c) c_int, __cmp: ?*const fn ([*c][*c]const struct_dirent, [*c][*c]const struct_dirent) callconv(.c) c_int) c_int;
pub extern fn scandirat64(__dfd: c_int, noalias __dir: [*c]const u8, noalias __namelist: [*c][*c][*c]struct_dirent64, __selector: ?*const fn ([*c]const struct_dirent64) callconv(.c) c_int, __cmp: ?*const fn ([*c][*c]const struct_dirent64, [*c][*c]const struct_dirent64) callconv(.c) c_int) c_int;
pub extern fn alphasort(__e1: [*c][*c]const struct_dirent, __e2: [*c][*c]const struct_dirent) c_int;
pub extern fn alphasort64(__e1: [*c][*c]const struct_dirent64, __e2: [*c][*c]const struct_dirent64) c_int;
pub extern fn getdirentries(__fd: c_int, noalias __buf: [*c]u8, __nbytes: usize, noalias __basep: [*c]__off64_t) __ssize_t;
pub extern fn getdirentries64(__fd: c_int, noalias __buf: [*c]u8, __nbytes: usize, noalias __basep: [*c]__off64_t) __ssize_t;
pub extern fn versionsort(__e1: [*c][*c]const struct_dirent, __e2: [*c][*c]const struct_dirent) c_int;
pub extern fn versionsort64(__e1: [*c][*c]const struct_dirent64, __e2: [*c][*c]const struct_dirent64) c_int;
pub extern fn getdents64(__fd: c_int, __buffer: ?*anyopaque, __length: usize) __ssize_t;
pub const __size_t = c_ulong;
pub const struct_stat = extern struct {
    st_dev: __dev_t = @import("std").mem.zeroes(__dev_t),
    st_ino: __ino_t = @import("std").mem.zeroes(__ino_t),
    st_nlink: __nlink_t = @import("std").mem.zeroes(__nlink_t),
    st_mode: __mode_t = @import("std").mem.zeroes(__mode_t),
    st_uid: __uid_t = @import("std").mem.zeroes(__uid_t),
    st_gid: __gid_t = @import("std").mem.zeroes(__gid_t),
    __pad0: c_int = @import("std").mem.zeroes(c_int),
    st_rdev: __dev_t = @import("std").mem.zeroes(__dev_t),
    st_size: __off_t = @import("std").mem.zeroes(__off_t),
    st_blksize: __blksize_t = @import("std").mem.zeroes(__blksize_t),
    st_blocks: __blkcnt_t = @import("std").mem.zeroes(__blkcnt_t),
    st_atim: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    st_mtim: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    st_ctim: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    __glibc_reserved: [3]__syscall_slong_t = @import("std").mem.zeroes([3]__syscall_slong_t),
};
pub const glob_t = extern struct {
    gl_pathc: __size_t = @import("std").mem.zeroes(__size_t),
    gl_pathv: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
    gl_offs: __size_t = @import("std").mem.zeroes(__size_t),
    gl_flags: c_int = @import("std").mem.zeroes(c_int),
    gl_closedir: ?*const fn (?*anyopaque) callconv(.c) void = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) void),
    gl_readdir: ?*const fn (?*anyopaque) callconv(.c) [*c]struct_dirent = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) [*c]struct_dirent),
    gl_opendir: ?*const fn ([*c]const u8) callconv(.c) ?*anyopaque = @import("std").mem.zeroes(?*const fn ([*c]const u8) callconv(.c) ?*anyopaque),
    gl_lstat: ?*const fn (noalias [*c]const u8, noalias [*c]struct_stat) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (noalias [*c]const u8, noalias [*c]struct_stat) callconv(.c) c_int),
    gl_stat: ?*const fn (noalias [*c]const u8, noalias [*c]struct_stat) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (noalias [*c]const u8, noalias [*c]struct_stat) callconv(.c) c_int),
};
pub const struct_stat64 = extern struct {
    st_dev: __dev_t = @import("std").mem.zeroes(__dev_t),
    st_ino: __ino64_t = @import("std").mem.zeroes(__ino64_t),
    st_nlink: __nlink_t = @import("std").mem.zeroes(__nlink_t),
    st_mode: __mode_t = @import("std").mem.zeroes(__mode_t),
    st_uid: __uid_t = @import("std").mem.zeroes(__uid_t),
    st_gid: __gid_t = @import("std").mem.zeroes(__gid_t),
    __pad0: c_int = @import("std").mem.zeroes(c_int),
    st_rdev: __dev_t = @import("std").mem.zeroes(__dev_t),
    st_size: __off_t = @import("std").mem.zeroes(__off_t),
    st_blksize: __blksize_t = @import("std").mem.zeroes(__blksize_t),
    st_blocks: __blkcnt64_t = @import("std").mem.zeroes(__blkcnt64_t),
    st_atim: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    st_mtim: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    st_ctim: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    __glibc_reserved: [3]__syscall_slong_t = @import("std").mem.zeroes([3]__syscall_slong_t),
};
pub const glob64_t = extern struct {
    gl_pathc: __size_t = @import("std").mem.zeroes(__size_t),
    gl_pathv: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
    gl_offs: __size_t = @import("std").mem.zeroes(__size_t),
    gl_flags: c_int = @import("std").mem.zeroes(c_int),
    gl_closedir: ?*const fn (?*anyopaque) callconv(.c) void = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) void),
    gl_readdir: ?*const fn (?*anyopaque) callconv(.c) [*c]struct_dirent64 = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) [*c]struct_dirent64),
    gl_opendir: ?*const fn ([*c]const u8) callconv(.c) ?*anyopaque = @import("std").mem.zeroes(?*const fn ([*c]const u8) callconv(.c) ?*anyopaque),
    gl_lstat: ?*const fn (noalias [*c]const u8, noalias [*c]struct_stat64) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (noalias [*c]const u8, noalias [*c]struct_stat64) callconv(.c) c_int),
    gl_stat: ?*const fn (noalias [*c]const u8, noalias [*c]struct_stat64) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (noalias [*c]const u8, noalias [*c]struct_stat64) callconv(.c) c_int),
};
pub extern fn glob(noalias __pattern: [*c]const u8, __flags: c_int, __errfunc: ?*const fn ([*c]const u8, c_int) callconv(.c) c_int, noalias __pglob: [*c]glob_t) c_int;
pub extern fn globfree(__pglob: [*c]glob_t) void;
pub extern fn glob64(noalias __pattern: [*c]const u8, __flags: c_int, __errfunc: ?*const fn ([*c]const u8, c_int) callconv(.c) c_int, noalias __pglob: [*c]glob64_t) c_int;
pub extern fn globfree64(__pglob: [*c]glob64_t) void;
pub extern fn glob_pattern_p(__pattern: [*c]const u8, __quote: c_int) c_int;
pub const struct_statfs = extern struct {
    f_type: __fsword_t = @import("std").mem.zeroes(__fsword_t),
    f_bsize: __fsword_t = @import("std").mem.zeroes(__fsword_t),
    f_blocks: __fsblkcnt64_t = @import("std").mem.zeroes(__fsblkcnt64_t),
    f_bfree: __fsblkcnt64_t = @import("std").mem.zeroes(__fsblkcnt64_t),
    f_bavail: __fsblkcnt64_t = @import("std").mem.zeroes(__fsblkcnt64_t),
    f_files: __fsfilcnt64_t = @import("std").mem.zeroes(__fsfilcnt64_t),
    f_ffree: __fsfilcnt64_t = @import("std").mem.zeroes(__fsfilcnt64_t),
    f_fsid: __fsid_t = @import("std").mem.zeroes(__fsid_t),
    f_namelen: __fsword_t = @import("std").mem.zeroes(__fsword_t),
    f_frsize: __fsword_t = @import("std").mem.zeroes(__fsword_t),
    f_flags: __fsword_t = @import("std").mem.zeroes(__fsword_t),
    f_spare: [4]__fsword_t = @import("std").mem.zeroes([4]__fsword_t),
};
pub const struct_statfs64 = extern struct {
    f_type: __fsword_t = @import("std").mem.zeroes(__fsword_t),
    f_bsize: __fsword_t = @import("std").mem.zeroes(__fsword_t),
    f_blocks: __fsblkcnt64_t = @import("std").mem.zeroes(__fsblkcnt64_t),
    f_bfree: __fsblkcnt64_t = @import("std").mem.zeroes(__fsblkcnt64_t),
    f_bavail: __fsblkcnt64_t = @import("std").mem.zeroes(__fsblkcnt64_t),
    f_files: __fsfilcnt64_t = @import("std").mem.zeroes(__fsfilcnt64_t),
    f_ffree: __fsfilcnt64_t = @import("std").mem.zeroes(__fsfilcnt64_t),
    f_fsid: __fsid_t = @import("std").mem.zeroes(__fsid_t),
    f_namelen: __fsword_t = @import("std").mem.zeroes(__fsword_t),
    f_frsize: __fsword_t = @import("std").mem.zeroes(__fsword_t),
    f_flags: __fsword_t = @import("std").mem.zeroes(__fsword_t),
    f_spare: [4]__fsword_t = @import("std").mem.zeroes([4]__fsword_t),
};
pub extern fn statfs(__file: [*c]const u8, __buf: [*c]struct_statfs) c_int;
pub extern fn statfs64(__file: [*c]const u8, __buf: [*c]struct_statfs64) c_int;
pub extern fn fstatfs(__fildes: c_int, __buf: [*c]struct_statfs) c_int;
pub extern fn fstatfs64(__fildes: c_int, __buf: [*c]struct_statfs64) c_int;
pub const struct_iovec = extern struct {
    iov_base: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    iov_len: usize = @import("std").mem.zeroes(usize),
};
pub extern fn readv(__fd: c_int, __iovec: [*c]const struct_iovec, __count: c_int) isize;
pub extern fn writev(__fd: c_int, __iovec: [*c]const struct_iovec, __count: c_int) isize;
pub extern fn preadv(__fd: c_int, __iovec: [*c]const struct_iovec, __count: c_int, __offset: __off64_t) isize;
pub extern fn pwritev(__fd: c_int, __iovec: [*c]const struct_iovec, __count: c_int, __offset: __off64_t) isize;
pub extern fn preadv64(__fd: c_int, __iovec: [*c]const struct_iovec, __count: c_int, __offset: __off64_t) isize;
pub extern fn pwritev64(__fd: c_int, __iovec: [*c]const struct_iovec, __count: c_int, __offset: __off64_t) isize;
pub extern fn pwritev2(__fd: c_int, __iovec: [*c]const struct_iovec, __count: c_int, __offset: __off64_t, __flags: c_int) isize;
pub extern fn preadv2(__fd: c_int, __iovec: [*c]const struct_iovec, __count: c_int, __offset: __off64_t, __flags: c_int) isize;
pub extern fn preadv64v2(__fp: c_int, __iovec: [*c]const struct_iovec, __count: c_int, __offset: __off64_t, ___flags: c_int) isize;
pub extern fn pwritev64v2(__fd: c_int, __iodev: [*c]const struct_iovec, __count: c_int, __offset: __off64_t, __flags: c_int) isize;
pub extern fn process_vm_readv(__pid: pid_t, __lvec: [*c]const struct_iovec, __liovcnt: c_ulong, __rvec: [*c]const struct_iovec, __riovcnt: c_ulong, __flags: c_ulong) isize;
pub extern fn process_vm_writev(__pid: pid_t, __lvec: [*c]const struct_iovec, __liovcnt: c_ulong, __rvec: [*c]const struct_iovec, __riovcnt: c_ulong, __flags: c_ulong) isize;
pub extern fn stat(noalias __file: [*c]const u8, noalias __buf: [*c]struct_stat) c_int;
pub extern fn fstat(__fd: c_int, __buf: [*c]struct_stat) c_int;
pub extern fn stat64(noalias __file: [*c]const u8, noalias __buf: [*c]struct_stat64) c_int;
pub extern fn fstat64(__fd: c_int, __buf: [*c]struct_stat64) c_int;
pub extern fn fstatat(__fd: c_int, noalias __file: [*c]const u8, noalias __buf: [*c]struct_stat, __flag: c_int) c_int;
pub extern fn fstatat64(__fd: c_int, noalias __file: [*c]const u8, noalias __buf: [*c]struct_stat64, __flag: c_int) c_int;
pub extern fn lstat(noalias __file: [*c]const u8, noalias __buf: [*c]struct_stat) c_int;
pub extern fn lstat64(noalias __file: [*c]const u8, noalias __buf: [*c]struct_stat64) c_int;
pub extern fn chmod(__file: [*c]const u8, __mode: __mode_t) c_int;
pub extern fn lchmod(__file: [*c]const u8, __mode: __mode_t) c_int;
pub extern fn fchmod(__fd: c_int, __mode: __mode_t) c_int;
pub extern fn fchmodat(__fd: c_int, __file: [*c]const u8, __mode: __mode_t, __flag: c_int) c_int;
pub extern fn umask(__mask: __mode_t) __mode_t;
pub extern fn getumask() __mode_t;
pub extern fn mkdir(__path: [*c]const u8, __mode: __mode_t) c_int;
pub extern fn mkdirat(__fd: c_int, __path: [*c]const u8, __mode: __mode_t) c_int;
pub extern fn mknod(__path: [*c]const u8, __mode: __mode_t, __dev: __dev_t) c_int;
pub extern fn mknodat(__fd: c_int, __path: [*c]const u8, __mode: __mode_t, __dev: __dev_t) c_int;
pub extern fn mkfifo(__path: [*c]const u8, __mode: __mode_t) c_int;
pub extern fn mkfifoat(__fd: c_int, __path: [*c]const u8, __mode: __mode_t) c_int;
pub extern fn utimensat(__fd: c_int, __path: [*c]const u8, __times: [*c]const struct_timespec, __flags: c_int) c_int;
pub extern fn futimens(__fd: c_int, __times: [*c]const struct_timespec) c_int;
pub const __s8 = i8;
pub const __u8 = u8;
pub const __s16 = c_short;
pub const __u16 = c_ushort;
pub const __s32 = c_int;
pub const __u32 = c_uint;
pub const __s64 = c_longlong;
pub const __u64 = c_ulonglong;
pub const __kernel_fd_set = extern struct {
    fds_bits: [16]c_ulong = @import("std").mem.zeroes([16]c_ulong),
};
pub const __kernel_sighandler_t = ?*const fn (c_int) callconv(.c) void;
pub const __kernel_key_t = c_int;
pub const __kernel_mqd_t = c_int;
pub const __kernel_old_uid_t = c_ushort;
pub const __kernel_old_gid_t = c_ushort;
pub const __kernel_old_dev_t = c_ulong;
pub const __kernel_long_t = c_long;
pub const __kernel_ulong_t = c_ulong;
pub const __kernel_ino_t = __kernel_ulong_t;
pub const __kernel_mode_t = c_uint;
pub const __kernel_pid_t = c_int;
pub const __kernel_ipc_pid_t = c_int;
pub const __kernel_uid_t = c_uint;
pub const __kernel_gid_t = c_uint;
pub const __kernel_suseconds_t = __kernel_long_t;
pub const __kernel_daddr_t = c_int;
pub const __kernel_uid32_t = c_uint;
pub const __kernel_gid32_t = c_uint;
pub const __kernel_size_t = __kernel_ulong_t;
pub const __kernel_ssize_t = __kernel_long_t;
pub const __kernel_ptrdiff_t = __kernel_long_t;
pub const __kernel_fsid_t = extern struct {
    val: [2]c_int = @import("std").mem.zeroes([2]c_int),
};
pub const __kernel_off_t = __kernel_long_t;
pub const __kernel_loff_t = c_longlong;
pub const __kernel_old_time_t = __kernel_long_t;
pub const __kernel_time_t = __kernel_long_t;
pub const __kernel_time64_t = c_longlong;
pub const __kernel_clock_t = __kernel_long_t;
pub const __kernel_timer_t = c_int;
pub const __kernel_clockid_t = c_int;
pub const __kernel_caddr_t = [*c]u8;
pub const __kernel_uid16_t = c_ushort;
pub const __kernel_gid16_t = c_ushort;
pub const __s128 = i128;
pub const __u128 = u128;
pub const __le16 = __u16;
pub const __be16 = __u16;
pub const __le32 = __u32;
pub const __be32 = __u32;
pub const __le64 = __u64;
pub const __be64 = __u64;
pub const __sum16 = __u16;
pub const __wsum = __u32;
pub const __poll_t = c_uint;
pub const struct_statx_timestamp = extern struct {
    tv_sec: __s64 = @import("std").mem.zeroes(__s64),
    tv_nsec: __u32 = @import("std").mem.zeroes(__u32),
    __reserved: __s32 = @import("std").mem.zeroes(__s32),
};
pub const struct_statx = extern struct {
    stx_mask: __u32 = @import("std").mem.zeroes(__u32),
    stx_blksize: __u32 = @import("std").mem.zeroes(__u32),
    stx_attributes: __u64 = @import("std").mem.zeroes(__u64),
    stx_nlink: __u32 = @import("std").mem.zeroes(__u32),
    stx_uid: __u32 = @import("std").mem.zeroes(__u32),
    stx_gid: __u32 = @import("std").mem.zeroes(__u32),
    stx_mode: __u16 = @import("std").mem.zeroes(__u16),
    __spare0: [1]__u16 = @import("std").mem.zeroes([1]__u16),
    stx_ino: __u64 = @import("std").mem.zeroes(__u64),
    stx_size: __u64 = @import("std").mem.zeroes(__u64),
    stx_blocks: __u64 = @import("std").mem.zeroes(__u64),
    stx_attributes_mask: __u64 = @import("std").mem.zeroes(__u64),
    stx_atime: struct_statx_timestamp = @import("std").mem.zeroes(struct_statx_timestamp),
    stx_btime: struct_statx_timestamp = @import("std").mem.zeroes(struct_statx_timestamp),
    stx_ctime: struct_statx_timestamp = @import("std").mem.zeroes(struct_statx_timestamp),
    stx_mtime: struct_statx_timestamp = @import("std").mem.zeroes(struct_statx_timestamp),
    stx_rdev_major: __u32 = @import("std").mem.zeroes(__u32),
    stx_rdev_minor: __u32 = @import("std").mem.zeroes(__u32),
    stx_dev_major: __u32 = @import("std").mem.zeroes(__u32),
    stx_dev_minor: __u32 = @import("std").mem.zeroes(__u32),
    stx_mnt_id: __u64 = @import("std").mem.zeroes(__u64),
    stx_dio_mem_align: __u32 = @import("std").mem.zeroes(__u32),
    stx_dio_offset_align: __u32 = @import("std").mem.zeroes(__u32),
    stx_subvol: __u64 = @import("std").mem.zeroes(__u64),
    __spare3: [11]__u64 = @import("std").mem.zeroes([11]__u64),
};
pub extern fn statx(__dirfd: c_int, noalias __path: [*c]const u8, __flags: c_int, __mask: c_uint, noalias __buf: [*c]struct_statx) c_int;
pub const struct_flock = extern struct {
    l_type: c_short = @import("std").mem.zeroes(c_short),
    l_whence: c_short = @import("std").mem.zeroes(c_short),
    l_start: __off64_t = @import("std").mem.zeroes(__off64_t),
    l_len: __off64_t = @import("std").mem.zeroes(__off64_t),
    l_pid: __pid_t = @import("std").mem.zeroes(__pid_t),
};
pub const struct_flock64 = extern struct {
    l_type: c_short = @import("std").mem.zeroes(c_short),
    l_whence: c_short = @import("std").mem.zeroes(c_short),
    l_start: __off64_t = @import("std").mem.zeroes(__off64_t),
    l_len: __off64_t = @import("std").mem.zeroes(__off64_t),
    l_pid: __pid_t = @import("std").mem.zeroes(__pid_t),
};
pub const F_OWNER_TID: c_int = 0;
pub const F_OWNER_PID: c_int = 1;
pub const F_OWNER_PGRP: c_int = 2;
pub const F_OWNER_GID: c_int = 2;
pub const enum___pid_type = c_uint;
pub const struct_f_owner_ex = extern struct {
    type: enum___pid_type = @import("std").mem.zeroes(enum___pid_type),
    pid: __pid_t = @import("std").mem.zeroes(__pid_t),
};
pub const struct_file_handle = extern struct {
    handle_bytes: c_uint align(4) = @import("std").mem.zeroes(c_uint),
    handle_type: c_int = @import("std").mem.zeroes(c_int),
    pub fn f_handle(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        return @as(ReturnType, @ptrCast(@alignCast(@as(Intermediate, @ptrCast(self)) + 8)));
    }
};
pub extern fn readahead(__fd: c_int, __offset: __off64_t, __count: usize) __ssize_t;
pub extern fn sync_file_range(__fd: c_int, __offset: __off64_t, __count: __off64_t, __flags: c_uint) c_int;
pub extern fn vmsplice(__fdout: c_int, __iov: [*c]const struct_iovec, __count: usize, __flags: c_uint) __ssize_t;
pub extern fn splice(__fdin: c_int, __offin: [*c]__off64_t, __fdout: c_int, __offout: [*c]__off64_t, __len: usize, __flags: c_uint) __ssize_t;
pub extern fn tee(__fdin: c_int, __fdout: c_int, __len: usize, __flags: c_uint) __ssize_t;
pub extern fn fallocate(__fd: c_int, __mode: c_int, __offset: __off64_t, __len: __off64_t) c_int;
pub extern fn fallocate64(__fd: c_int, __mode: c_int, __offset: __off64_t, __len: __off64_t) c_int;
pub extern fn name_to_handle_at(__dfd: c_int, __name: [*c]const u8, __handle: [*c]struct_file_handle, __mnt_id: [*c]c_int, __flags: c_int) c_int;
pub extern fn open_by_handle_at(__mountdirfd: c_int, __handle: [*c]struct_file_handle, __flags: c_int) c_int;
pub extern fn fcntl(__fd: c_int, __cmd: c_int, ...) c_int;
pub extern fn fcntl64(__fd: c_int, __cmd: c_int, ...) c_int;
pub extern fn open(__file: [*c]const u8, __oflag: c_int, ...) c_int;
pub extern fn open64(__file: [*c]const u8, __oflag: c_int, ...) c_int;
pub extern fn openat(__fd: c_int, __file: [*c]const u8, __oflag: c_int, ...) c_int;
pub extern fn openat64(__fd: c_int, __file: [*c]const u8, __oflag: c_int, ...) c_int;
pub extern fn creat(__file: [*c]const u8, __mode: mode_t) c_int;
pub extern fn creat64(__file: [*c]const u8, __mode: mode_t) c_int;
pub extern fn posix_fadvise(__fd: c_int, __offset: __off64_t, __len: __off64_t, __advise: c_int) c_int;
pub extern fn posix_fadvise64(__fd: c_int, __offset: off64_t, __len: off64_t, __advise: c_int) c_int;
pub extern fn posix_fallocate(__fd: c_int, __offset: __off64_t, __len: __off64_t) c_int;
pub extern fn posix_fallocate64(__fd: c_int, __offset: off64_t, __len: off64_t) c_int;
pub const P_ALL: c_int = 0;
pub const P_PID: c_int = 1;
pub const P_PGID: c_int = 2;
pub const P_PIDFD: c_int = 3;
pub const idtype_t = c_uint;
pub extern fn wait(__stat_loc: [*c]c_int) __pid_t;
pub extern fn waitpid(__pid: __pid_t, __stat_loc: [*c]c_int, __options: c_int) __pid_t;
pub extern fn waitid(__idtype: idtype_t, __id: __id_t, __infop: [*c]siginfo_t, __options: c_int) c_int;
const union_unnamed_35 = extern union {
    ru_maxrss: c_long,
    __ru_maxrss_word: __syscall_slong_t,
};
const union_unnamed_36 = extern union {
    ru_ixrss: c_long,
    __ru_ixrss_word: __syscall_slong_t,
};
const union_unnamed_37 = extern union {
    ru_idrss: c_long,
    __ru_idrss_word: __syscall_slong_t,
};
const union_unnamed_38 = extern union {
    ru_isrss: c_long,
    __ru_isrss_word: __syscall_slong_t,
};
const union_unnamed_39 = extern union {
    ru_minflt: c_long,
    __ru_minflt_word: __syscall_slong_t,
};
const union_unnamed_40 = extern union {
    ru_majflt: c_long,
    __ru_majflt_word: __syscall_slong_t,
};
const union_unnamed_41 = extern union {
    ru_nswap: c_long,
    __ru_nswap_word: __syscall_slong_t,
};
const union_unnamed_42 = extern union {
    ru_inblock: c_long,
    __ru_inblock_word: __syscall_slong_t,
};
const union_unnamed_43 = extern union {
    ru_oublock: c_long,
    __ru_oublock_word: __syscall_slong_t,
};
const union_unnamed_44 = extern union {
    ru_msgsnd: c_long,
    __ru_msgsnd_word: __syscall_slong_t,
};
const union_unnamed_45 = extern union {
    ru_msgrcv: c_long,
    __ru_msgrcv_word: __syscall_slong_t,
};
const union_unnamed_46 = extern union {
    ru_nsignals: c_long,
    __ru_nsignals_word: __syscall_slong_t,
};
const union_unnamed_47 = extern union {
    ru_nvcsw: c_long,
    __ru_nvcsw_word: __syscall_slong_t,
};
const union_unnamed_48 = extern union {
    ru_nivcsw: c_long,
    __ru_nivcsw_word: __syscall_slong_t,
};
pub const struct_rusage = extern struct {
    ru_utime: struct_timeval = @import("std").mem.zeroes(struct_timeval),
    ru_stime: struct_timeval = @import("std").mem.zeroes(struct_timeval),
    unnamed_0: union_unnamed_35 = @import("std").mem.zeroes(union_unnamed_35),
    unnamed_1: union_unnamed_36 = @import("std").mem.zeroes(union_unnamed_36),
    unnamed_2: union_unnamed_37 = @import("std").mem.zeroes(union_unnamed_37),
    unnamed_3: union_unnamed_38 = @import("std").mem.zeroes(union_unnamed_38),
    unnamed_4: union_unnamed_39 = @import("std").mem.zeroes(union_unnamed_39),
    unnamed_5: union_unnamed_40 = @import("std").mem.zeroes(union_unnamed_40),
    unnamed_6: union_unnamed_41 = @import("std").mem.zeroes(union_unnamed_41),
    unnamed_7: union_unnamed_42 = @import("std").mem.zeroes(union_unnamed_42),
    unnamed_8: union_unnamed_43 = @import("std").mem.zeroes(union_unnamed_43),
    unnamed_9: union_unnamed_44 = @import("std").mem.zeroes(union_unnamed_44),
    unnamed_10: union_unnamed_45 = @import("std").mem.zeroes(union_unnamed_45),
    unnamed_11: union_unnamed_46 = @import("std").mem.zeroes(union_unnamed_46),
    unnamed_12: union_unnamed_47 = @import("std").mem.zeroes(union_unnamed_47),
    unnamed_13: union_unnamed_48 = @import("std").mem.zeroes(union_unnamed_48),
};
pub extern fn wait3(__stat_loc: [*c]c_int, __options: c_int, __usage: [*c]struct_rusage) __pid_t;
pub extern fn wait4(__pid: __pid_t, __stat_loc: [*c]c_int, __options: c_int, __usage: [*c]struct_rusage) __pid_t;
pub extern fn memfd_create(__name: [*c]const u8, __flags: c_uint) c_int;
pub extern fn mlock2(__addr: ?*const anyopaque, __length: usize, __flags: c_uint) c_int;
pub extern fn pkey_alloc(__flags: c_uint, __access_rights: c_uint) c_int;
pub extern fn pkey_set(__key: c_int, __access_rights: c_uint) c_int;
pub extern fn pkey_get(__key: c_int) c_int;
pub extern fn pkey_free(__key: c_int) c_int;
pub extern fn pkey_mprotect(__addr: ?*anyopaque, __len: usize, __prot: c_int, __pkey: c_int) c_int;
pub extern fn mmap(__addr: ?*anyopaque, __len: usize, __prot: c_int, __flags: c_int, __fd: c_int, __offset: __off64_t) ?*anyopaque;
pub extern fn mmap64(__addr: ?*anyopaque, __len: usize, __prot: c_int, __flags: c_int, __fd: c_int, __offset: __off64_t) ?*anyopaque;
pub extern fn munmap(__addr: ?*anyopaque, __len: usize) c_int;
pub extern fn mprotect(__addr: ?*anyopaque, __len: usize, __prot: c_int) c_int;
pub extern fn msync(__addr: ?*anyopaque, __len: usize, __flags: c_int) c_int;
pub extern fn madvise(__addr: ?*anyopaque, __len: usize, __advice: c_int) c_int;
pub extern fn posix_madvise(__addr: ?*anyopaque, __len: usize, __advice: c_int) c_int;
pub extern fn mlock(__addr: ?*const anyopaque, __len: usize) c_int;
pub extern fn munlock(__addr: ?*const anyopaque, __len: usize) c_int;
pub extern fn mlockall(__flags: c_int) c_int;
pub extern fn munlockall() c_int;
pub extern fn mincore(__start: ?*anyopaque, __len: usize, __vec: [*c]u8) c_int;
pub extern fn mremap(__addr: ?*anyopaque, __old_len: usize, __new_len: usize, __flags: c_int, ...) ?*anyopaque;
pub extern fn remap_file_pages(__start: ?*anyopaque, __size: usize, __prot: c_int, __pgoff: usize, __flags: c_int) c_int;
pub extern fn shm_open(__name: [*c]const u8, __oflag: c_int, __mode: mode_t) c_int;
pub extern fn shm_unlink(__name: [*c]const u8) c_int;
pub extern fn process_madvise(__pid_fd: c_int, __iov: [*c]const struct_iovec, __count: usize, __advice: c_int, __flags: c_uint) __ssize_t;
pub extern fn process_mrelease(pidfd: c_int, flags: c_uint) c_int;
pub const RLIMIT_CPU: c_int = 0;
pub const RLIMIT_FSIZE: c_int = 1;
pub const RLIMIT_DATA: c_int = 2;
pub const RLIMIT_STACK: c_int = 3;
pub const RLIMIT_CORE: c_int = 4;
pub const __RLIMIT_RSS: c_int = 5;
pub const RLIMIT_NOFILE: c_int = 7;
pub const __RLIMIT_OFILE: c_int = 7;
pub const RLIMIT_AS: c_int = 9;
pub const __RLIMIT_NPROC: c_int = 6;
pub const __RLIMIT_MEMLOCK: c_int = 8;
pub const __RLIMIT_LOCKS: c_int = 10;
pub const __RLIMIT_SIGPENDING: c_int = 11;
pub const __RLIMIT_MSGQUEUE: c_int = 12;
pub const __RLIMIT_NICE: c_int = 13;
pub const __RLIMIT_RTPRIO: c_int = 14;
pub const __RLIMIT_RTTIME: c_int = 15;
pub const __RLIMIT_NLIMITS: c_int = 16;
pub const __RLIM_NLIMITS: c_int = 16;
pub const enum___rlimit_resource = c_uint;
pub const rlim_t = __rlim64_t;
pub const rlim64_t = __rlim64_t;
pub const struct_rlimit = extern struct {
    rlim_cur: rlim_t = @import("std").mem.zeroes(rlim_t),
    rlim_max: rlim_t = @import("std").mem.zeroes(rlim_t),
};
pub const struct_rlimit64 = extern struct {
    rlim_cur: rlim64_t = @import("std").mem.zeroes(rlim64_t),
    rlim_max: rlim64_t = @import("std").mem.zeroes(rlim64_t),
};
pub const RUSAGE_SELF: c_int = 0;
pub const RUSAGE_CHILDREN: c_int = -1;
pub const RUSAGE_THREAD: c_int = 1;
pub const enum___rusage_who = c_int;
pub const PRIO_PROCESS: c_int = 0;
pub const PRIO_PGRP: c_int = 1;
pub const PRIO_USER: c_int = 2;
pub const enum___priority_which = c_uint;
pub extern fn prlimit(__pid: __pid_t, __resource: enum___rlimit_resource, __new_limit: [*c]const struct_rlimit, __old_limit: [*c]struct_rlimit) c_int;
pub extern fn prlimit64(__pid: __pid_t, __resource: enum___rlimit_resource, __new_limit: [*c]const struct_rlimit64, __old_limit: [*c]struct_rlimit64) c_int;
pub const __rlimit_resource_t = enum___rlimit_resource;
pub const __rusage_who_t = enum___rusage_who;
pub const __priority_which_t = enum___priority_which;
pub extern fn getrlimit(__resource: __rlimit_resource_t, __rlimits: [*c]struct_rlimit) c_int;
pub extern fn getrlimit64(__resource: __rlimit_resource_t, __rlimits: [*c]struct_rlimit64) c_int;
pub extern fn setrlimit(__resource: __rlimit_resource_t, __rlimits: [*c]const struct_rlimit) c_int;
pub extern fn setrlimit64(__resource: __rlimit_resource_t, __rlimits: [*c]const struct_rlimit64) c_int;
pub extern fn getrusage(__who: __rusage_who_t, __usage: [*c]struct_rusage) c_int;
pub extern fn getpriority(__which: __priority_which_t, __who: id_t) c_int;
pub extern fn setpriority(__which: __priority_which_t, __who: id_t, __prio: c_int) c_int;
pub const struct_sched_param = extern struct {
    sched_priority: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn clone(__fn: ?*const fn (?*anyopaque) callconv(.c) c_int, __child_stack: ?*anyopaque, __flags: c_int, __arg: ?*anyopaque, ...) c_int;
pub extern fn unshare(__flags: c_int) c_int;
pub extern fn sched_getcpu() c_int;
pub extern fn getcpu([*c]c_uint, [*c]c_uint) c_int;
pub extern fn setns(__fd: c_int, __nstype: c_int) c_int;
pub const __cpu_mask = c_ulong;
pub const cpu_set_t = extern struct {
    __bits: [16]__cpu_mask = @import("std").mem.zeroes([16]__cpu_mask),
};
pub extern fn __sched_cpucount(__setsize: usize, __setp: [*c]const cpu_set_t) c_int;
pub extern fn __sched_cpualloc(__count: usize) [*c]cpu_set_t;
pub extern fn __sched_cpufree(__set: [*c]cpu_set_t) void;
pub extern fn sched_setparam(__pid: __pid_t, __param: [*c]const struct_sched_param) c_int;
pub extern fn sched_getparam(__pid: __pid_t, __param: [*c]struct_sched_param) c_int;
pub extern fn sched_setscheduler(__pid: __pid_t, __policy: c_int, __param: [*c]const struct_sched_param) c_int;
pub extern fn sched_getscheduler(__pid: __pid_t) c_int;
pub extern fn sched_yield() c_int;
pub extern fn sched_get_priority_max(__algorithm: c_int) c_int;
pub extern fn sched_get_priority_min(__algorithm: c_int) c_int;
pub extern fn sched_rr_get_interval(__pid: __pid_t, __t: [*c]struct_timespec) c_int;
pub extern fn sched_setaffinity(__pid: __pid_t, __cpusetsize: usize, __cpuset: [*c]const cpu_set_t) c_int;
pub extern fn sched_getaffinity(__pid: __pid_t, __cpusetsize: usize, __cpuset: [*c]cpu_set_t) c_int;
pub const SOCK_STREAM: c_int = 1;
pub const SOCK_DGRAM: c_int = 2;
pub const SOCK_RAW: c_int = 3;
pub const SOCK_RDM: c_int = 4;
pub const SOCK_SEQPACKET: c_int = 5;
pub const SOCK_DCCP: c_int = 6;
pub const SOCK_PACKET: c_int = 10;
pub const SOCK_CLOEXEC: c_int = 524288;
pub const SOCK_NONBLOCK: c_int = 2048;
pub const enum___socket_type = c_uint;
pub const sa_family_t = c_ushort;
pub const struct_sockaddr = extern struct {
    sa_family: sa_family_t = @import("std").mem.zeroes(sa_family_t),
    sa_data: [14]u8 = @import("std").mem.zeroes([14]u8),
};
pub const struct_sockaddr_storage = extern struct {
    ss_family: sa_family_t = @import("std").mem.zeroes(sa_family_t),
    __ss_padding: [118]u8 = @import("std").mem.zeroes([118]u8),
    __ss_align: c_ulong = @import("std").mem.zeroes(c_ulong),
};
pub const MSG_OOB: c_int = 1;
pub const MSG_PEEK: c_int = 2;
pub const MSG_DONTROUTE: c_int = 4;
pub const MSG_TRYHARD: c_int = 4;
pub const MSG_CTRUNC: c_int = 8;
pub const MSG_PROXY: c_int = 16;
pub const MSG_TRUNC: c_int = 32;
pub const MSG_DONTWAIT: c_int = 64;
pub const MSG_EOR: c_int = 128;
pub const MSG_WAITALL: c_int = 256;
pub const MSG_FIN: c_int = 512;
pub const MSG_SYN: c_int = 1024;
pub const MSG_CONFIRM: c_int = 2048;
pub const MSG_RST: c_int = 4096;
pub const MSG_ERRQUEUE: c_int = 8192;
pub const MSG_NOSIGNAL: c_int = 16384;
pub const MSG_MORE: c_int = 32768;
pub const MSG_WAITFORONE: c_int = 65536;
pub const MSG_BATCH: c_int = 262144;
pub const MSG_ZEROCOPY: c_int = 67108864;
pub const MSG_FASTOPEN: c_int = 536870912;
pub const MSG_CMSG_CLOEXEC: c_int = 1073741824;
const enum_unnamed_49 = c_uint;
pub const struct_msghdr = extern struct {
    msg_name: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    msg_namelen: socklen_t = @import("std").mem.zeroes(socklen_t),
    msg_iov: [*c]struct_iovec = @import("std").mem.zeroes([*c]struct_iovec),
    msg_iovlen: usize = @import("std").mem.zeroes(usize),
    msg_control: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    msg_controllen: usize = @import("std").mem.zeroes(usize),
    msg_flags: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_cmsghdr = extern struct {
    cmsg_len: usize align(8) = @import("std").mem.zeroes(usize),
    cmsg_level: c_int = @import("std").mem.zeroes(c_int),
    cmsg_type: c_int = @import("std").mem.zeroes(c_int),
    pub fn __cmsg_data(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        return @as(ReturnType, @ptrCast(@alignCast(@as(Intermediate, @ptrCast(self)) + 16)));
    }
};
pub extern fn __cmsg_nxthdr(__mhdr: [*c]struct_msghdr, __cmsg: [*c]struct_cmsghdr) [*c]struct_cmsghdr;
pub const SCM_RIGHTS: c_int = 1;
pub const SCM_CREDENTIALS: c_int = 2;
pub const SCM_SECURITY: c_int = 3;
pub const SCM_PIDFD: c_int = 4;
const enum_unnamed_50 = c_uint;
pub const struct_ucred = extern struct {
    pid: pid_t = @import("std").mem.zeroes(pid_t),
    uid: uid_t = @import("std").mem.zeroes(uid_t),
    gid: gid_t = @import("std").mem.zeroes(gid_t),
};
pub const struct_linger = extern struct {
    l_onoff: c_int = @import("std").mem.zeroes(c_int),
    l_linger: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_osockaddr = extern struct {
    sa_family: c_ushort = @import("std").mem.zeroes(c_ushort),
    sa_data: [14]u8 = @import("std").mem.zeroes([14]u8),
};
pub const SHUT_RD: c_int = 0;
pub const SHUT_WR: c_int = 1;
pub const SHUT_RDWR: c_int = 2;
const enum_unnamed_51 = c_uint;
pub const struct_sockaddr_at_52 = opaque {};
pub const struct_sockaddr_ax25_53 = opaque {};
pub const struct_sockaddr_dl_54 = opaque {};
pub const struct_sockaddr_eon_55 = opaque {};
pub const in_port_t = u16;
pub const in_addr_t = u32;
pub const struct_in_addr = extern struct {
    s_addr: in_addr_t = @import("std").mem.zeroes(in_addr_t),
};
pub const struct_sockaddr_in = extern struct {
    sin_family: sa_family_t = @import("std").mem.zeroes(sa_family_t),
    sin_port: in_port_t = @import("std").mem.zeroes(in_port_t),
    sin_addr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    sin_zero: [8]u8 = @import("std").mem.zeroes([8]u8),
};
const union_unnamed_56 = extern union {
    __u6_addr8: [16]u8,
    __u6_addr16: [8]u16,
    __u6_addr32: [4]u32,
};
pub const struct_in6_addr = extern struct {
    __in6_u: union_unnamed_56 = @import("std").mem.zeroes(union_unnamed_56),
};
pub const struct_sockaddr_in6 = extern struct {
    sin6_family: sa_family_t = @import("std").mem.zeroes(sa_family_t),
    sin6_port: in_port_t = @import("std").mem.zeroes(in_port_t),
    sin6_flowinfo: u32 = @import("std").mem.zeroes(u32),
    sin6_addr: struct_in6_addr = @import("std").mem.zeroes(struct_in6_addr),
    sin6_scope_id: u32 = @import("std").mem.zeroes(u32),
};
pub const struct_sockaddr_inarp_57 = opaque {};
pub const struct_sockaddr_ipx_58 = opaque {};
pub const struct_sockaddr_iso_59 = opaque {};
pub const struct_sockaddr_ns_60 = opaque {};
pub const struct_sockaddr_un = extern struct {
    sun_family: sa_family_t = @import("std").mem.zeroes(sa_family_t),
    sun_path: [108]u8 = @import("std").mem.zeroes([108]u8),
};
pub const struct_sockaddr_x25_61 = opaque {};
pub const __SOCKADDR_ARG = extern union {
    __sockaddr__: [*c]struct_sockaddr,
    __sockaddr_at__: ?*struct_sockaddr_at_52,
    __sockaddr_ax25__: ?*struct_sockaddr_ax25_53,
    __sockaddr_dl__: ?*struct_sockaddr_dl_54,
    __sockaddr_eon__: ?*struct_sockaddr_eon_55,
    __sockaddr_in__: [*c]struct_sockaddr_in,
    __sockaddr_in6__: [*c]struct_sockaddr_in6,
    __sockaddr_inarp__: ?*struct_sockaddr_inarp_57,
    __sockaddr_ipx__: ?*struct_sockaddr_ipx_58,
    __sockaddr_iso__: ?*struct_sockaddr_iso_59,
    __sockaddr_ns__: ?*struct_sockaddr_ns_60,
    __sockaddr_un__: [*c]struct_sockaddr_un,
    __sockaddr_x25__: ?*struct_sockaddr_x25_61,
};
pub const __CONST_SOCKADDR_ARG = extern union {
    __sockaddr__: [*c]const struct_sockaddr,
    __sockaddr_at__: ?*const struct_sockaddr_at_52,
    __sockaddr_ax25__: ?*const struct_sockaddr_ax25_53,
    __sockaddr_dl__: ?*const struct_sockaddr_dl_54,
    __sockaddr_eon__: ?*const struct_sockaddr_eon_55,
    __sockaddr_in__: [*c]const struct_sockaddr_in,
    __sockaddr_in6__: [*c]const struct_sockaddr_in6,
    __sockaddr_inarp__: ?*const struct_sockaddr_inarp_57,
    __sockaddr_ipx__: ?*const struct_sockaddr_ipx_58,
    __sockaddr_iso__: ?*const struct_sockaddr_iso_59,
    __sockaddr_ns__: ?*const struct_sockaddr_ns_60,
    __sockaddr_un__: [*c]const struct_sockaddr_un,
    __sockaddr_x25__: ?*const struct_sockaddr_x25_61,
};
pub const struct_mmsghdr = extern struct {
    msg_hdr: struct_msghdr = @import("std").mem.zeroes(struct_msghdr),
    msg_len: c_uint = @import("std").mem.zeroes(c_uint),
};
pub extern fn socket(__domain: c_int, __type: c_int, __protocol: c_int) c_int;
pub extern fn socketpair(__domain: c_int, __type: c_int, __protocol: c_int, __fds: [*c]c_int) c_int;
pub extern fn bind(__fd: c_int, __addr: __CONST_SOCKADDR_ARG, __len: socklen_t) c_int;
pub extern fn getsockname(__fd: c_int, __addr: __SOCKADDR_ARG, noalias __len: [*c]socklen_t) c_int;
pub extern fn connect(__fd: c_int, __addr: __CONST_SOCKADDR_ARG, __len: socklen_t) c_int;
pub extern fn getpeername(__fd: c_int, __addr: __SOCKADDR_ARG, noalias __len: [*c]socklen_t) c_int;
pub extern fn send(__fd: c_int, __buf: ?*const anyopaque, __n: usize, __flags: c_int) isize;
pub extern fn recv(__fd: c_int, __buf: ?*anyopaque, __n: usize, __flags: c_int) isize;
pub extern fn sendto(__fd: c_int, __buf: ?*const anyopaque, __n: usize, __flags: c_int, __addr: __CONST_SOCKADDR_ARG, __addr_len: socklen_t) isize;
pub extern fn recvfrom(__fd: c_int, noalias __buf: ?*anyopaque, __n: usize, __flags: c_int, __addr: __SOCKADDR_ARG, noalias __addr_len: [*c]socklen_t) isize;
pub extern fn sendmsg(__fd: c_int, __message: [*c]const struct_msghdr, __flags: c_int) isize;
pub extern fn sendmmsg(__fd: c_int, __vmessages: [*c]struct_mmsghdr, __vlen: c_uint, __flags: c_int) c_int;
pub extern fn recvmsg(__fd: c_int, __message: [*c]struct_msghdr, __flags: c_int) isize;
pub extern fn recvmmsg(__fd: c_int, __vmessages: [*c]struct_mmsghdr, __vlen: c_uint, __flags: c_int, __tmo: [*c]struct_timespec) c_int;
pub extern fn getsockopt(__fd: c_int, __level: c_int, __optname: c_int, noalias __optval: ?*anyopaque, noalias __optlen: [*c]socklen_t) c_int;
pub extern fn setsockopt(__fd: c_int, __level: c_int, __optname: c_int, __optval: ?*const anyopaque, __optlen: socklen_t) c_int;
pub extern fn listen(__fd: c_int, __n: c_int) c_int;
pub extern fn accept(__fd: c_int, __addr: __SOCKADDR_ARG, noalias __addr_len: [*c]socklen_t) c_int;
pub extern fn accept4(__fd: c_int, __addr: __SOCKADDR_ARG, noalias __addr_len: [*c]socklen_t, __flags: c_int) c_int;
pub extern fn shutdown(__fd: c_int, __how: c_int) c_int;
pub extern fn sockatmark(__fd: c_int) c_int;
pub extern fn isfdtype(__fd: c_int, __fdtype: c_int) c_int;
pub const struct_ip_opts = extern struct {
    ip_dst: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    ip_opts: [40]u8 = @import("std").mem.zeroes([40]u8),
};
pub const struct_in_pktinfo = extern struct {
    ipi_ifindex: c_int = @import("std").mem.zeroes(c_int),
    ipi_spec_dst: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    ipi_addr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
};
pub const IPPROTO_IP: c_int = 0;
pub const IPPROTO_ICMP: c_int = 1;
pub const IPPROTO_IGMP: c_int = 2;
pub const IPPROTO_IPIP: c_int = 4;
pub const IPPROTO_TCP: c_int = 6;
pub const IPPROTO_EGP: c_int = 8;
pub const IPPROTO_PUP: c_int = 12;
pub const IPPROTO_UDP: c_int = 17;
pub const IPPROTO_IDP: c_int = 22;
pub const IPPROTO_TP: c_int = 29;
pub const IPPROTO_DCCP: c_int = 33;
pub const IPPROTO_IPV6: c_int = 41;
pub const IPPROTO_RSVP: c_int = 46;
pub const IPPROTO_GRE: c_int = 47;
pub const IPPROTO_ESP: c_int = 50;
pub const IPPROTO_AH: c_int = 51;
pub const IPPROTO_MTP: c_int = 92;
pub const IPPROTO_BEETPH: c_int = 94;
pub const IPPROTO_ENCAP: c_int = 98;
pub const IPPROTO_PIM: c_int = 103;
pub const IPPROTO_COMP: c_int = 108;
pub const IPPROTO_L2TP: c_int = 115;
pub const IPPROTO_SCTP: c_int = 132;
pub const IPPROTO_UDPLITE: c_int = 136;
pub const IPPROTO_MPLS: c_int = 137;
pub const IPPROTO_ETHERNET: c_int = 143;
pub const IPPROTO_RAW: c_int = 255;
pub const IPPROTO_MPTCP: c_int = 262;
pub const IPPROTO_MAX: c_int = 263;
const enum_unnamed_62 = c_uint;
pub const IPPROTO_HOPOPTS: c_int = 0;
pub const IPPROTO_ROUTING: c_int = 43;
pub const IPPROTO_FRAGMENT: c_int = 44;
pub const IPPROTO_ICMPV6: c_int = 58;
pub const IPPROTO_NONE: c_int = 59;
pub const IPPROTO_DSTOPTS: c_int = 60;
pub const IPPROTO_MH: c_int = 135;
const enum_unnamed_63 = c_uint;
pub const IPPORT_ECHO: c_int = 7;
pub const IPPORT_DISCARD: c_int = 9;
pub const IPPORT_SYSTAT: c_int = 11;
pub const IPPORT_DAYTIME: c_int = 13;
pub const IPPORT_NETSTAT: c_int = 15;
pub const IPPORT_FTP: c_int = 21;
pub const IPPORT_TELNET: c_int = 23;
pub const IPPORT_SMTP: c_int = 25;
pub const IPPORT_TIMESERVER: c_int = 37;
pub const IPPORT_NAMESERVER: c_int = 42;
pub const IPPORT_WHOIS: c_int = 43;
pub const IPPORT_MTP: c_int = 57;
pub const IPPORT_TFTP: c_int = 69;
pub const IPPORT_RJE: c_int = 77;
pub const IPPORT_FINGER: c_int = 79;
pub const IPPORT_TTYLINK: c_int = 87;
pub const IPPORT_SUPDUP: c_int = 95;
pub const IPPORT_EXECSERVER: c_int = 512;
pub const IPPORT_LOGINSERVER: c_int = 513;
pub const IPPORT_CMDSERVER: c_int = 514;
pub const IPPORT_EFSSERVER: c_int = 520;
pub const IPPORT_BIFFUDP: c_int = 512;
pub const IPPORT_WHOSERVER: c_int = 513;
pub const IPPORT_ROUTESERVER: c_int = 520;
pub const IPPORT_RESERVED: c_int = 1024;
pub const IPPORT_USERRESERVED: c_int = 5000;
const enum_unnamed_64 = c_uint;
pub extern const in6addr_any: struct_in6_addr;
pub extern const in6addr_loopback: struct_in6_addr;
pub const struct_ip_mreq = extern struct {
    imr_multiaddr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imr_interface: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
};
pub const struct_ip_mreqn = extern struct {
    imr_multiaddr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imr_address: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imr_ifindex: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_ip_mreq_source = extern struct {
    imr_multiaddr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imr_interface: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imr_sourceaddr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
};
pub const struct_ipv6_mreq = extern struct {
    ipv6mr_multiaddr: struct_in6_addr = @import("std").mem.zeroes(struct_in6_addr),
    ipv6mr_interface: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct_group_req = extern struct {
    gr_interface: u32 = @import("std").mem.zeroes(u32),
    gr_group: struct_sockaddr_storage = @import("std").mem.zeroes(struct_sockaddr_storage),
};
pub const struct_group_source_req = extern struct {
    gsr_interface: u32 = @import("std").mem.zeroes(u32),
    gsr_group: struct_sockaddr_storage = @import("std").mem.zeroes(struct_sockaddr_storage),
    gsr_source: struct_sockaddr_storage = @import("std").mem.zeroes(struct_sockaddr_storage),
};
pub const struct_ip_msfilter = extern struct {
    imsf_multiaddr: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imsf_interface: struct_in_addr = @import("std").mem.zeroes(struct_in_addr),
    imsf_fmode: u32 = @import("std").mem.zeroes(u32),
    imsf_numsrc: u32 = @import("std").mem.zeroes(u32),
    imsf_slist: [1]struct_in_addr = @import("std").mem.zeroes([1]struct_in_addr),
};
pub const struct_group_filter = extern struct {
    gf_interface: u32 = @import("std").mem.zeroes(u32),
    gf_group: struct_sockaddr_storage = @import("std").mem.zeroes(struct_sockaddr_storage),
    gf_fmode: u32 = @import("std").mem.zeroes(u32),
    gf_numsrc: u32 = @import("std").mem.zeroes(u32),
    gf_slist: [1]struct_sockaddr_storage = @import("std").mem.zeroes([1]struct_sockaddr_storage),
};
pub extern fn ntohl(__netlong: u32) u32;
pub extern fn ntohs(__netshort: u16) u16;
pub extern fn htonl(__hostlong: u32) u32;
pub extern fn htons(__hostshort: u16) u16;
pub extern fn bindresvport(__sockfd: c_int, __sock_in: [*c]struct_sockaddr_in) c_int;
pub extern fn bindresvport6(__sockfd: c_int, __sock_in: [*c]struct_sockaddr_in6) c_int;
pub const struct_in6_pktinfo = extern struct {
    ipi6_addr: struct_in6_addr = @import("std").mem.zeroes(struct_in6_addr),
    ipi6_ifindex: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct_ip6_mtuinfo = extern struct {
    ip6m_addr: struct_sockaddr_in6 = @import("std").mem.zeroes(struct_sockaddr_in6),
    ip6m_mtu: u32 = @import("std").mem.zeroes(u32),
};
pub extern fn inet6_option_space(__nbytes: c_int) c_int;
pub extern fn inet6_option_init(__bp: ?*anyopaque, __cmsgp: [*c][*c]struct_cmsghdr, __type: c_int) c_int;
pub extern fn inet6_option_append(__cmsg: [*c]struct_cmsghdr, __typep: [*c]const u8, __multx: c_int, __plusy: c_int) c_int;
pub extern fn inet6_option_alloc(__cmsg: [*c]struct_cmsghdr, __datalen: c_int, __multx: c_int, __plusy: c_int) [*c]u8;
pub extern fn inet6_option_next(__cmsg: [*c]const struct_cmsghdr, __tptrp: [*c][*c]u8) c_int;
pub extern fn inet6_option_find(__cmsg: [*c]const struct_cmsghdr, __tptrp: [*c][*c]u8, __type: c_int) c_int;
pub extern fn inet6_opt_init(__extbuf: ?*anyopaque, __extlen: socklen_t) c_int;
pub extern fn inet6_opt_append(__extbuf: ?*anyopaque, __extlen: socklen_t, __offset: c_int, __type: u8, __len: socklen_t, __align: u8, __databufp: [*c]?*anyopaque) c_int;
pub extern fn inet6_opt_finish(__extbuf: ?*anyopaque, __extlen: socklen_t, __offset: c_int) c_int;
pub extern fn inet6_opt_set_val(__databuf: ?*anyopaque, __offset: c_int, __val: ?*anyopaque, __vallen: socklen_t) c_int;
pub extern fn inet6_opt_next(__extbuf: ?*anyopaque, __extlen: socklen_t, __offset: c_int, __typep: [*c]u8, __lenp: [*c]socklen_t, __databufp: [*c]?*anyopaque) c_int;
pub extern fn inet6_opt_find(__extbuf: ?*anyopaque, __extlen: socklen_t, __offset: c_int, __type: u8, __lenp: [*c]socklen_t, __databufp: [*c]?*anyopaque) c_int;
pub extern fn inet6_opt_get_val(__databuf: ?*anyopaque, __offset: c_int, __val: ?*anyopaque, __vallen: socklen_t) c_int;
pub extern fn inet6_rth_space(__type: c_int, __segments: c_int) socklen_t;
pub extern fn inet6_rth_init(__bp: ?*anyopaque, __bp_len: socklen_t, __type: c_int, __segments: c_int) ?*anyopaque;
pub extern fn inet6_rth_add(__bp: ?*anyopaque, __addr: [*c]const struct_in6_addr) c_int;
pub extern fn inet6_rth_reverse(__in: ?*const anyopaque, __out: ?*anyopaque) c_int;
pub extern fn inet6_rth_segments(__bp: ?*const anyopaque) c_int;
pub extern fn inet6_rth_getaddr(__bp: ?*const anyopaque, __index: c_int) [*c]struct_in6_addr;
pub extern fn getipv4sourcefilter(__s: c_int, __interface_addr: struct_in_addr, __group: struct_in_addr, __fmode: [*c]u32, __numsrc: [*c]u32, __slist: [*c]struct_in_addr) c_int;
pub extern fn setipv4sourcefilter(__s: c_int, __interface_addr: struct_in_addr, __group: struct_in_addr, __fmode: u32, __numsrc: u32, __slist: [*c]const struct_in_addr) c_int;
pub extern fn getsourcefilter(__s: c_int, __interface_addr: u32, __group: [*c]const struct_sockaddr, __grouplen: socklen_t, __fmode: [*c]u32, __numsrc: [*c]u32, __slist: [*c]struct_sockaddr_storage) c_int;
pub extern fn setsourcefilter(__s: c_int, __interface_addr: u32, __group: [*c]const struct_sockaddr, __grouplen: socklen_t, __fmode: u32, __numsrc: u32, __slist: [*c]const struct_sockaddr_storage) c_int;
pub const int_least8_t = __int_least8_t;
pub const int_least16_t = __int_least16_t;
pub const int_least32_t = __int_least32_t;
pub const int_least64_t = __int_least64_t;
pub const uint_least8_t = __uint_least8_t;
pub const uint_least16_t = __uint_least16_t;
pub const uint_least32_t = __uint_least32_t;
pub const uint_least64_t = __uint_least64_t;
pub const int_fast8_t = i8;
pub const int_fast16_t = c_long;
pub const int_fast32_t = c_long;
pub const int_fast64_t = c_long;
pub const uint_fast8_t = u8;
pub const uint_fast16_t = c_ulong;
pub const uint_fast32_t = c_ulong;
pub const uint_fast64_t = c_ulong;
pub const intmax_t = __intmax_t;
pub const uintmax_t = __uintmax_t;
pub const tcp_seq = u32;
// /usr/include/netinet/tcp.h:109:10: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_66 = opaque {};
// /usr/include/netinet/tcp.h:134:11: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_67 = opaque {};
const union_unnamed_65 = extern union {
    unnamed_0: struct_unnamed_66,
    unnamed_1: struct_unnamed_67,
};
pub const struct_tcphdr = extern struct {
    unnamed_0: union_unnamed_65 = @import("std").mem.zeroes(union_unnamed_65),
};
pub const TCP_ESTABLISHED: c_int = 1;
pub const TCP_SYN_SENT: c_int = 2;
pub const TCP_SYN_RECV: c_int = 3;
pub const TCP_FIN_WAIT1: c_int = 4;
pub const TCP_FIN_WAIT2: c_int = 5;
pub const TCP_TIME_WAIT: c_int = 6;
pub const TCP_CLOSE: c_int = 7;
pub const TCP_CLOSE_WAIT: c_int = 8;
pub const TCP_LAST_ACK: c_int = 9;
pub const TCP_LISTEN: c_int = 10;
pub const TCP_CLOSING: c_int = 11;
const enum_unnamed_68 = c_uint;
pub const TCP_CA_Open: c_int = 0;
pub const TCP_CA_Disorder: c_int = 1;
pub const TCP_CA_CWR: c_int = 2;
pub const TCP_CA_Recovery: c_int = 3;
pub const TCP_CA_Loss: c_int = 4;
pub const enum_tcp_ca_state = c_uint;
// /usr/include/netinet/tcp.h:234:11: warning: struct demoted to opaque type - has bitfield
pub const struct_tcp_info = opaque {};
pub const struct_tcp_md5sig = extern struct {
    tcpm_addr: struct_sockaddr_storage = @import("std").mem.zeroes(struct_sockaddr_storage),
    tcpm_flags: u8 = @import("std").mem.zeroes(u8),
    tcpm_prefixlen: u8 = @import("std").mem.zeroes(u8),
    tcpm_keylen: u16 = @import("std").mem.zeroes(u16),
    tcpm_ifindex: c_int = @import("std").mem.zeroes(c_int),
    tcpm_key: [80]u8 = @import("std").mem.zeroes([80]u8),
};
pub const struct_tcp_repair_opt = extern struct {
    opt_code: u32 = @import("std").mem.zeroes(u32),
    opt_val: u32 = @import("std").mem.zeroes(u32),
};
pub const TCP_NO_QUEUE: c_int = 0;
pub const TCP_RECV_QUEUE: c_int = 1;
pub const TCP_SEND_QUEUE: c_int = 2;
pub const TCP_QUEUES_NR: c_int = 3;
const enum_unnamed_69 = c_uint;
pub const struct_tcp_cookie_transactions = extern struct {
    tcpct_flags: u16 = @import("std").mem.zeroes(u16),
    __tcpct_pad1: u8 = @import("std").mem.zeroes(u8),
    tcpct_cookie_desired: u8 = @import("std").mem.zeroes(u8),
    tcpct_s_data_desired: u16 = @import("std").mem.zeroes(u16),
    tcpct_used: u16 = @import("std").mem.zeroes(u16),
    tcpct_value: [536]u8 = @import("std").mem.zeroes([536]u8),
};
pub const struct_tcp_repair_window = extern struct {
    snd_wl1: u32 = @import("std").mem.zeroes(u32),
    snd_wnd: u32 = @import("std").mem.zeroes(u32),
    max_window: u32 = @import("std").mem.zeroes(u32),
    rcv_wnd: u32 = @import("std").mem.zeroes(u32),
    rcv_wup: u32 = @import("std").mem.zeroes(u32),
};
pub const struct_tcp_zerocopy_receive = extern struct {
    address: u64 = @import("std").mem.zeroes(u64),
    length: u32 = @import("std").mem.zeroes(u32),
    recv_skip_hint: u32 = @import("std").mem.zeroes(u32),
};
pub extern fn inet_addr(__cp: [*c]const u8) in_addr_t;
pub extern fn inet_lnaof(__in: struct_in_addr) in_addr_t;
pub extern fn inet_makeaddr(__net: in_addr_t, __host: in_addr_t) struct_in_addr;
pub extern fn inet_netof(__in: struct_in_addr) in_addr_t;
pub extern fn inet_network(__cp: [*c]const u8) in_addr_t;
pub extern fn inet_ntoa(__in: struct_in_addr) [*c]u8;
pub extern fn inet_pton(__af: c_int, noalias __cp: [*c]const u8, noalias __buf: ?*anyopaque) c_int;
pub extern fn inet_ntop(__af: c_int, noalias __cp: ?*const anyopaque, noalias __buf: [*c]u8, __len: socklen_t) [*c]const u8;
pub extern fn inet_aton(__cp: [*c]const u8, __inp: [*c]struct_in_addr) c_int;
pub extern fn inet_neta(__net: in_addr_t, __buf: [*c]u8, __len: usize) [*c]u8;
pub extern fn inet_net_ntop(__af: c_int, __cp: ?*const anyopaque, __bits: c_int, __buf: [*c]u8, __len: usize) [*c]u8;
pub extern fn inet_net_pton(__af: c_int, __cp: [*c]const u8, __buf: ?*anyopaque, __len: usize) c_int;
pub extern fn inet_nsap_addr(__cp: [*c]const u8, __buf: [*c]u8, __len: c_int) c_uint;
pub extern fn inet_nsap_ntoa(__len: c_int, __cp: [*c]const u8, __buf: [*c]u8) [*c]u8;
pub const struct_rpcent = extern struct {
    r_name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    r_aliases: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
    r_number: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn setrpcent(__stayopen: c_int) void;
pub extern fn endrpcent() void;
pub extern fn getrpcbyname(__name: [*c]const u8) [*c]struct_rpcent;
pub extern fn getrpcbynumber(__number: c_int) [*c]struct_rpcent;
pub extern fn getrpcent() [*c]struct_rpcent;
pub extern fn getrpcbyname_r(__name: [*c]const u8, __result_buf: [*c]struct_rpcent, __buffer: [*c]u8, __buflen: usize, __result: [*c][*c]struct_rpcent) c_int;
pub extern fn getrpcbynumber_r(__number: c_int, __result_buf: [*c]struct_rpcent, __buffer: [*c]u8, __buflen: usize, __result: [*c][*c]struct_rpcent) c_int;
pub extern fn getrpcent_r(__result_buf: [*c]struct_rpcent, __buffer: [*c]u8, __buflen: usize, __result: [*c][*c]struct_rpcent) c_int;
pub const struct_netent = extern struct {
    n_name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    n_aliases: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
    n_addrtype: c_int = @import("std").mem.zeroes(c_int),
    n_net: u32 = @import("std").mem.zeroes(u32),
};
pub extern fn __h_errno_location() [*c]c_int;
pub extern fn herror(__str: [*c]const u8) void;
pub extern fn hstrerror(__err_num: c_int) [*c]const u8;
pub const struct_hostent = extern struct {
    h_name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    h_aliases: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
    h_addrtype: c_int = @import("std").mem.zeroes(c_int),
    h_length: c_int = @import("std").mem.zeroes(c_int),
    h_addr_list: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
};
pub extern fn sethostent(__stay_open: c_int) void;
pub extern fn endhostent() void;
pub extern fn gethostent() [*c]struct_hostent;
pub extern fn gethostbyaddr(__addr: ?*const anyopaque, __len: __socklen_t, __type: c_int) [*c]struct_hostent;
pub extern fn gethostbyname(__name: [*c]const u8) [*c]struct_hostent;
pub extern fn gethostbyname2(__name: [*c]const u8, __af: c_int) [*c]struct_hostent;
pub extern fn gethostent_r(noalias __result_buf: [*c]struct_hostent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_hostent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn gethostbyaddr_r(noalias __addr: ?*const anyopaque, __len: __socklen_t, __type: c_int, noalias __result_buf: [*c]struct_hostent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_hostent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn gethostbyname_r(noalias __name: [*c]const u8, noalias __result_buf: [*c]struct_hostent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_hostent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn gethostbyname2_r(noalias __name: [*c]const u8, __af: c_int, noalias __result_buf: [*c]struct_hostent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_hostent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn setnetent(__stay_open: c_int) void;
pub extern fn endnetent() void;
pub extern fn getnetent() [*c]struct_netent;
pub extern fn getnetbyaddr(__net: u32, __type: c_int) [*c]struct_netent;
pub extern fn getnetbyname(__name: [*c]const u8) [*c]struct_netent;
pub extern fn getnetent_r(noalias __result_buf: [*c]struct_netent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_netent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn getnetbyaddr_r(__net: u32, __type: c_int, noalias __result_buf: [*c]struct_netent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_netent, noalias __h_errnop: [*c]c_int) c_int;
pub extern fn getnetbyname_r(noalias __name: [*c]const u8, noalias __result_buf: [*c]struct_netent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_netent, noalias __h_errnop: [*c]c_int) c_int;
pub const struct_servent = extern struct {
    s_name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    s_aliases: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
    s_port: c_int = @import("std").mem.zeroes(c_int),
    s_proto: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub extern fn setservent(__stay_open: c_int) void;
pub extern fn endservent() void;
pub extern fn getservent() [*c]struct_servent;
pub extern fn getservbyname(__name: [*c]const u8, __proto: [*c]const u8) [*c]struct_servent;
pub extern fn getservbyport(__port: c_int, __proto: [*c]const u8) [*c]struct_servent;
pub extern fn getservent_r(noalias __result_buf: [*c]struct_servent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_servent) c_int;
pub extern fn getservbyname_r(noalias __name: [*c]const u8, noalias __proto: [*c]const u8, noalias __result_buf: [*c]struct_servent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_servent) c_int;
pub extern fn getservbyport_r(__port: c_int, noalias __proto: [*c]const u8, noalias __result_buf: [*c]struct_servent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_servent) c_int;
pub const struct_protoent = extern struct {
    p_name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    p_aliases: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
    p_proto: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn setprotoent(__stay_open: c_int) void;
pub extern fn endprotoent() void;
pub extern fn getprotoent() [*c]struct_protoent;
pub extern fn getprotobyname(__name: [*c]const u8) [*c]struct_protoent;
pub extern fn getprotobynumber(__proto: c_int) [*c]struct_protoent;
pub extern fn getprotoent_r(noalias __result_buf: [*c]struct_protoent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_protoent) c_int;
pub extern fn getprotobyname_r(noalias __name: [*c]const u8, noalias __result_buf: [*c]struct_protoent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_protoent) c_int;
pub extern fn getprotobynumber_r(__proto: c_int, noalias __result_buf: [*c]struct_protoent, noalias __buf: [*c]u8, __buflen: usize, noalias __result: [*c][*c]struct_protoent) c_int;
pub extern fn setnetgrent(__netgroup: [*c]const u8) c_int;
pub extern fn endnetgrent() void;
pub extern fn getnetgrent(noalias __hostp: [*c][*c]u8, noalias __userp: [*c][*c]u8, noalias __domainp: [*c][*c]u8) c_int;
pub extern fn innetgr(__netgroup: [*c]const u8, __host: [*c]const u8, __user: [*c]const u8, __domain: [*c]const u8) c_int;
pub extern fn getnetgrent_r(noalias __hostp: [*c][*c]u8, noalias __userp: [*c][*c]u8, noalias __domainp: [*c][*c]u8, noalias __buffer: [*c]u8, __buflen: usize) c_int;
pub extern fn rcmd(noalias __ahost: [*c][*c]u8, __rport: c_ushort, noalias __locuser: [*c]const u8, noalias __remuser: [*c]const u8, noalias __cmd: [*c]const u8, noalias __fd2p: [*c]c_int) c_int;
pub extern fn rcmd_af(noalias __ahost: [*c][*c]u8, __rport: c_ushort, noalias __locuser: [*c]const u8, noalias __remuser: [*c]const u8, noalias __cmd: [*c]const u8, noalias __fd2p: [*c]c_int, __af: sa_family_t) c_int;
pub extern fn rexec(noalias __ahost: [*c][*c]u8, __rport: c_int, noalias __name: [*c]const u8, noalias __pass: [*c]const u8, noalias __cmd: [*c]const u8, noalias __fd2p: [*c]c_int) c_int;
pub extern fn rexec_af(noalias __ahost: [*c][*c]u8, __rport: c_int, noalias __name: [*c]const u8, noalias __pass: [*c]const u8, noalias __cmd: [*c]const u8, noalias __fd2p: [*c]c_int, __af: sa_family_t) c_int;
pub extern fn ruserok(__rhost: [*c]const u8, __suser: c_int, __remuser: [*c]const u8, __locuser: [*c]const u8) c_int;
pub extern fn ruserok_af(__rhost: [*c]const u8, __suser: c_int, __remuser: [*c]const u8, __locuser: [*c]const u8, __af: sa_family_t) c_int;
pub extern fn iruserok(__raddr: u32, __suser: c_int, __remuser: [*c]const u8, __locuser: [*c]const u8) c_int;
pub extern fn iruserok_af(__raddr: ?*const anyopaque, __suser: c_int, __remuser: [*c]const u8, __locuser: [*c]const u8, __af: sa_family_t) c_int;
pub extern fn rresvport(__alport: [*c]c_int) c_int;
pub extern fn rresvport_af(__alport: [*c]c_int, __af: sa_family_t) c_int;
pub const struct_addrinfo = extern struct {
    ai_flags: c_int = @import("std").mem.zeroes(c_int),
    ai_family: c_int = @import("std").mem.zeroes(c_int),
    ai_socktype: c_int = @import("std").mem.zeroes(c_int),
    ai_protocol: c_int = @import("std").mem.zeroes(c_int),
    ai_addrlen: socklen_t = @import("std").mem.zeroes(socklen_t),
    ai_addr: [*c]struct_sockaddr = @import("std").mem.zeroes([*c]struct_sockaddr),
    ai_canonname: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    ai_next: [*c]struct_addrinfo = @import("std").mem.zeroes([*c]struct_addrinfo),
};
pub const struct_gaicb = extern struct {
    ar_name: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    ar_service: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    ar_request: [*c]const struct_addrinfo = @import("std").mem.zeroes([*c]const struct_addrinfo),
    ar_result: [*c]struct_addrinfo = @import("std").mem.zeroes([*c]struct_addrinfo),
    __return: c_int = @import("std").mem.zeroes(c_int),
    __glibc_reserved: [5]c_int = @import("std").mem.zeroes([5]c_int),
};
pub extern fn getaddrinfo(noalias __name: [*c]const u8, noalias __service: [*c]const u8, noalias __req: [*c]const struct_addrinfo, noalias __pai: [*c][*c]struct_addrinfo) c_int;
pub extern fn freeaddrinfo(__ai: [*c]struct_addrinfo) void;
pub extern fn gai_strerror(__ecode: c_int) [*c]const u8;
pub extern fn getnameinfo(noalias __sa: [*c]const struct_sockaddr, __salen: socklen_t, noalias __host: [*c]u8, __hostlen: socklen_t, noalias __serv: [*c]u8, __servlen: socklen_t, __flags: c_int) c_int;
pub extern fn getaddrinfo_a(__mode: c_int, noalias __list: [*c][*c]struct_gaicb, __ent: c_int, noalias __sig: [*c]struct_sigevent) c_int;
pub extern fn gai_suspend(__list: [*c]const [*c]const struct_gaicb, __ent: c_int, __timeout: [*c]const struct_timespec) c_int;
pub extern fn gai_error(__req: [*c]struct_gaicb) c_int;
pub extern fn gai_cancel(__gaicbp: [*c]struct_gaicb) c_int;
// /usr/include/bits/timex.h:81:3: warning: struct demoted to opaque type - has bitfield
pub const struct_timex = opaque {};
pub extern fn clock_adjtime(__clock_id: __clockid_t, __utx: ?*struct_timex) c_int;
pub const struct_tm = extern struct {
    tm_sec: c_int = @import("std").mem.zeroes(c_int),
    tm_min: c_int = @import("std").mem.zeroes(c_int),
    tm_hour: c_int = @import("std").mem.zeroes(c_int),
    tm_mday: c_int = @import("std").mem.zeroes(c_int),
    tm_mon: c_int = @import("std").mem.zeroes(c_int),
    tm_year: c_int = @import("std").mem.zeroes(c_int),
    tm_wday: c_int = @import("std").mem.zeroes(c_int),
    tm_yday: c_int = @import("std").mem.zeroes(c_int),
    tm_isdst: c_int = @import("std").mem.zeroes(c_int),
    tm_gmtoff: c_long = @import("std").mem.zeroes(c_long),
    tm_zone: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const struct_itimerspec = extern struct {
    it_interval: struct_timespec = @import("std").mem.zeroes(struct_timespec),
    it_value: struct_timespec = @import("std").mem.zeroes(struct_timespec),
};
pub extern fn clock() clock_t;
pub extern fn time(__timer: [*c]time_t) time_t;
pub extern fn difftime(__time1: time_t, __time0: time_t) f64;
pub extern fn mktime(__tp: [*c]struct_tm) time_t;
pub extern fn strftime(noalias __s: [*c]u8, __maxsize: usize, noalias __format: [*c]const u8, noalias __tp: [*c]const struct_tm) usize;
pub extern fn strptime(noalias __s: [*c]const u8, noalias __fmt: [*c]const u8, __tp: [*c]struct_tm) [*c]u8;
pub extern fn strftime_l(noalias __s: [*c]u8, __maxsize: usize, noalias __format: [*c]const u8, noalias __tp: [*c]const struct_tm, __loc: locale_t) usize;
pub extern fn strptime_l(noalias __s: [*c]const u8, noalias __fmt: [*c]const u8, __tp: [*c]struct_tm, __loc: locale_t) [*c]u8;
pub extern fn gmtime(__timer: [*c]const time_t) [*c]struct_tm;
pub extern fn localtime(__timer: [*c]const time_t) [*c]struct_tm;
pub extern fn gmtime_r(noalias __timer: [*c]const time_t, noalias __tp: [*c]struct_tm) [*c]struct_tm;
pub extern fn localtime_r(noalias __timer: [*c]const time_t, noalias __tp: [*c]struct_tm) [*c]struct_tm;
pub extern fn asctime(__tp: [*c]const struct_tm) [*c]u8;
pub extern fn ctime(__timer: [*c]const time_t) [*c]u8;
pub extern fn asctime_r(noalias __tp: [*c]const struct_tm, noalias __buf: [*c]u8) [*c]u8;
pub extern fn ctime_r(noalias __timer: [*c]const time_t, noalias __buf: [*c]u8) [*c]u8;
pub extern var __tzname: [2][*c]u8;
pub extern var __daylight: c_int;
pub extern var __timezone: c_long;
pub extern var tzname: [2][*c]u8;
pub extern fn tzset() void;
pub extern var daylight: c_int;
pub extern var timezone: c_long;
pub extern fn timegm(__tp: [*c]struct_tm) time_t;
pub extern fn timelocal(__tp: [*c]struct_tm) time_t;
pub extern fn dysize(__year: c_int) c_int;
pub extern fn nanosleep(__requested_time: [*c]const struct_timespec, __remaining: [*c]struct_timespec) c_int;
pub extern fn clock_getres(__clock_id: clockid_t, __res: [*c]struct_timespec) c_int;
pub extern fn clock_gettime(__clock_id: clockid_t, __tp: [*c]struct_timespec) c_int;
pub extern fn clock_settime(__clock_id: clockid_t, __tp: [*c]const struct_timespec) c_int;
pub extern fn clock_nanosleep(__clock_id: clockid_t, __flags: c_int, __req: [*c]const struct_timespec, __rem: [*c]struct_timespec) c_int;
pub extern fn clock_getcpuclockid(__pid: pid_t, __clock_id: [*c]clockid_t) c_int;
pub extern fn timer_create(__clock_id: clockid_t, noalias __evp: [*c]struct_sigevent, noalias __timerid: [*c]timer_t) c_int;
pub extern fn timer_delete(__timerid: timer_t) c_int;
pub extern fn timer_settime(__timerid: timer_t, __flags: c_int, noalias __value: [*c]const struct_itimerspec, noalias __ovalue: [*c]struct_itimerspec) c_int;
pub extern fn timer_gettime(__timerid: timer_t, __value: [*c]struct_itimerspec) c_int;
pub extern fn timer_getoverrun(__timerid: timer_t) c_int;
pub extern fn timespec_get(__ts: [*c]struct_timespec, __base: c_int) c_int;
pub extern fn timespec_getres(__ts: [*c]struct_timespec, __base: c_int) c_int;
pub extern var getdate_err: c_int;
pub extern fn getdate(__string: [*c]const u8) [*c]struct_tm;
pub extern fn getdate_r(noalias __string: [*c]const u8, noalias __resbufp: [*c]struct_tm) c_int;
pub extern fn memalign(__alignment: c_ulong, __size: c_ulong) ?*anyopaque;
pub extern fn pvalloc(__size: usize) ?*anyopaque;
pub const struct_mallinfo = extern struct {
    arena: c_int = @import("std").mem.zeroes(c_int),
    ordblks: c_int = @import("std").mem.zeroes(c_int),
    smblks: c_int = @import("std").mem.zeroes(c_int),
    hblks: c_int = @import("std").mem.zeroes(c_int),
    hblkhd: c_int = @import("std").mem.zeroes(c_int),
    usmblks: c_int = @import("std").mem.zeroes(c_int),
    fsmblks: c_int = @import("std").mem.zeroes(c_int),
    uordblks: c_int = @import("std").mem.zeroes(c_int),
    fordblks: c_int = @import("std").mem.zeroes(c_int),
    keepcost: c_int = @import("std").mem.zeroes(c_int),
};
pub const struct_mallinfo2 = extern struct {
    arena: usize = @import("std").mem.zeroes(usize),
    ordblks: usize = @import("std").mem.zeroes(usize),
    smblks: usize = @import("std").mem.zeroes(usize),
    hblks: usize = @import("std").mem.zeroes(usize),
    hblkhd: usize = @import("std").mem.zeroes(usize),
    usmblks: usize = @import("std").mem.zeroes(usize),
    fsmblks: usize = @import("std").mem.zeroes(usize),
    uordblks: usize = @import("std").mem.zeroes(usize),
    fordblks: usize = @import("std").mem.zeroes(usize),
    keepcost: usize = @import("std").mem.zeroes(usize),
};
pub extern fn mallinfo() struct_mallinfo;
pub extern fn mallinfo2() struct_mallinfo2;
pub extern fn mallopt(__param: c_int, __val: c_int) c_int;
pub extern fn malloc_trim(__pad: usize) c_int;
pub extern fn malloc_usable_size(__ptr: ?*anyopaque) usize;
pub extern fn malloc_stats() void;
pub extern fn malloc_info(__options: c_int, __fp: [*c]FILE) c_int;
pub const struct_winsize = extern struct {
    ws_row: c_ushort = @import("std").mem.zeroes(c_ushort),
    ws_col: c_ushort = @import("std").mem.zeroes(c_ushort),
    ws_xpixel: c_ushort = @import("std").mem.zeroes(c_ushort),
    ws_ypixel: c_ushort = @import("std").mem.zeroes(c_ushort),
};
pub const struct_termio = extern struct {
    c_iflag: c_ushort = @import("std").mem.zeroes(c_ushort),
    c_oflag: c_ushort = @import("std").mem.zeroes(c_ushort),
    c_cflag: c_ushort = @import("std").mem.zeroes(c_ushort),
    c_lflag: c_ushort = @import("std").mem.zeroes(c_ushort),
    c_line: u8 = @import("std").mem.zeroes(u8),
    c_cc: [8]u8 = @import("std").mem.zeroes([8]u8),
};
pub extern fn ioctl(__fd: c_int, __request: c_ulong, ...) c_int;
pub const struct_crypt_data = extern struct {
    output: [384]u8 = @import("std").mem.zeroes([384]u8),
    setting: [384]u8 = @import("std").mem.zeroes([384]u8),
    input: [512]u8 = @import("std").mem.zeroes([512]u8),
    reserved: [767]u8 = @import("std").mem.zeroes([767]u8),
    initialized: u8 = @import("std").mem.zeroes(u8),
    internal: [30720]u8 = @import("std").mem.zeroes([30720]u8),
};
pub extern fn crypt_r(__phrase: [*c]const u8, __setting: [*c]const u8, noalias __data: [*c]struct_crypt_data) [*c]u8;
pub extern fn crypt_rn(__phrase: [*c]const u8, __setting: [*c]const u8, __data: ?*anyopaque, __size: c_int) [*c]u8;
pub extern fn crypt_ra(__phrase: [*c]const u8, __setting: [*c]const u8, __data: [*c]?*anyopaque, __size: [*c]c_int) [*c]u8;
pub extern fn crypt_gensalt(__prefix: [*c]const u8, __count: c_ulong, __rbytes: [*c]const u8, __nrbytes: c_int) [*c]u8;
pub extern fn crypt_gensalt_rn(__prefix: [*c]const u8, __count: c_ulong, __rbytes: [*c]const u8, __nrbytes: c_int, __output: [*c]u8, __output_size: c_int) [*c]u8;
pub extern fn crypt_gensalt_r(__prefix: [*c]const u8, __count: c_ulong, __rbytes: [*c]const u8, __nrbytes: c_int, __output: [*c]u8, __output_size: c_int) [*c]u8;
pub extern fn crypt_gensalt_ra(__prefix: [*c]const u8, __count: c_ulong, __rbytes: [*c]const u8, __nrbytes: c_int) [*c]u8;
pub extern fn crypt_checksalt(__setting: [*c]const u8) c_int;
pub extern fn crypt_preferred_method() [*c]const u8;
pub const struct_utsname = extern struct {
    sysname: [65]u8 = @import("std").mem.zeroes([65]u8),
    nodename: [65]u8 = @import("std").mem.zeroes([65]u8),
    release: [65]u8 = @import("std").mem.zeroes([65]u8),
    version: [65]u8 = @import("std").mem.zeroes([65]u8),
    machine: [65]u8 = @import("std").mem.zeroes([65]u8),
    domainname: [65]u8 = @import("std").mem.zeroes([65]u8),
};
pub extern fn uname(__name: [*c]struct_utsname) c_int;
pub extern fn _dl_mcount_wrapper_check(__selfpc: ?*anyopaque) void;
pub const Lmid_t = c_long;
pub extern fn dlopen(__file: [*c]const u8, __mode: c_int) ?*anyopaque;
pub extern fn dlclose(__handle: ?*anyopaque) c_int;
pub extern fn dlsym(noalias __handle: ?*anyopaque, noalias __name: [*c]const u8) ?*anyopaque;
pub extern fn dlmopen(__nsid: Lmid_t, __file: [*c]const u8, __mode: c_int) ?*anyopaque;
pub extern fn dlvsym(noalias __handle: ?*anyopaque, noalias __name: [*c]const u8, noalias __version: [*c]const u8) ?*anyopaque;
pub extern fn dlerror() [*c]u8;
pub const Dl_info = extern struct {
    dli_fname: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    dli_fbase: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    dli_sname: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    dli_saddr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub extern fn dladdr(__address: ?*const anyopaque, __info: [*c]Dl_info) c_int;
pub extern fn dladdr1(__address: ?*const anyopaque, __info: [*c]Dl_info, __extra_info: [*c]?*anyopaque, __flags: c_int) c_int;
pub const RTLD_DL_SYMENT: c_int = 1;
pub const RTLD_DL_LINKMAP: c_int = 2;
const enum_unnamed_70 = c_uint;
pub extern fn dlinfo(noalias __handle: ?*anyopaque, __request: c_int, noalias __arg: ?*anyopaque) c_int;
pub const RTLD_DI_LMID: c_int = 1;
pub const RTLD_DI_LINKMAP: c_int = 2;
pub const RTLD_DI_CONFIGADDR: c_int = 3;
pub const RTLD_DI_SERINFO: c_int = 4;
pub const RTLD_DI_SERINFOSIZE: c_int = 5;
pub const RTLD_DI_ORIGIN: c_int = 6;
pub const RTLD_DI_PROFILENAME: c_int = 7;
pub const RTLD_DI_PROFILEOUT: c_int = 8;
pub const RTLD_DI_TLS_MODID: c_int = 9;
pub const RTLD_DI_TLS_DATA: c_int = 10;
pub const RTLD_DI_PHDR: c_int = 11;
pub const RTLD_DI_MAX: c_int = 11;
const enum_unnamed_71 = c_uint;
pub const Dl_serpath = extern struct {
    dls_name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    dls_flags: c_uint = @import("std").mem.zeroes(c_uint),
};
const union_unnamed_72 = extern union {
    dls_serpath: [0]Dl_serpath,
    __dls_serpath_pad: [1]Dl_serpath,
};
pub const Dl_serinfo = extern struct {
    dls_size: usize = @import("std").mem.zeroes(usize),
    dls_cnt: c_uint = @import("std").mem.zeroes(c_uint),
    unnamed_0: union_unnamed_72 = @import("std").mem.zeroes(union_unnamed_72),
};
pub const struct_link_map_73 = opaque {};
pub const struct_dl_find_object = extern struct {
    dlfo_flags: c_ulonglong = @import("std").mem.zeroes(c_ulonglong),
    dlfo_map_start: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    dlfo_map_end: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    dlfo_link_map: ?*struct_link_map_73 = @import("std").mem.zeroes(?*struct_link_map_73),
    dlfo_eh_frame: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    __dflo_reserved: [7]c_ulonglong = @import("std").mem.zeroes([7]c_ulonglong),
};
pub extern fn _dl_find_object(__address: ?*anyopaque, __result: [*c]struct_dl_find_object) c_int;
pub const sem_t = extern union {
    __size: [32]u8,
    __align: c_long,
};
pub extern fn sem_init(__sem: [*c]sem_t, __pshared: c_int, __value: c_uint) c_int;
pub extern fn sem_destroy(__sem: [*c]sem_t) c_int;
pub extern fn sem_open(__name: [*c]const u8, __oflag: c_int, ...) [*c]sem_t;
pub extern fn sem_close(__sem: [*c]sem_t) c_int;
pub extern fn sem_unlink(__name: [*c]const u8) c_int;
pub extern fn sem_wait(__sem: [*c]sem_t) c_int;
pub extern fn sem_timedwait(noalias __sem: [*c]sem_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn sem_clockwait(noalias __sem: [*c]sem_t, clock: clockid_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn sem_trywait(__sem: [*c]sem_t) c_int;
pub extern fn sem_post(__sem: [*c]sem_t) c_int;
pub extern fn sem_getvalue(noalias __sem: [*c]sem_t, noalias __sval: [*c]c_int) c_int;
pub const struct_prctl_mm_map = extern struct {
    start_code: __u64 = @import("std").mem.zeroes(__u64),
    end_code: __u64 = @import("std").mem.zeroes(__u64),
    start_data: __u64 = @import("std").mem.zeroes(__u64),
    end_data: __u64 = @import("std").mem.zeroes(__u64),
    start_brk: __u64 = @import("std").mem.zeroes(__u64),
    brk: __u64 = @import("std").mem.zeroes(__u64),
    start_stack: __u64 = @import("std").mem.zeroes(__u64),
    arg_start: __u64 = @import("std").mem.zeroes(__u64),
    arg_end: __u64 = @import("std").mem.zeroes(__u64),
    env_start: __u64 = @import("std").mem.zeroes(__u64),
    env_end: __u64 = @import("std").mem.zeroes(__u64),
    auxv: [*c]__u64 = @import("std").mem.zeroes([*c]__u64),
    auxv_size: __u32 = @import("std").mem.zeroes(__u32),
    exe_fd: __u32 = @import("std").mem.zeroes(__u32),
};
pub extern fn prctl(__option: c_int, ...) c_int;
pub extern fn sendfile(__out_fd: c_int, __in_fd: c_int, __offset: [*c]__off64_t, __count: usize) isize;
pub extern fn sendfile64(__out_fd: c_int, __in_fd: c_int, __offset: [*c]__off64_t, __count: usize) isize;
pub const EPOLL_CLOEXEC: c_int = 524288;
const enum_unnamed_74 = c_uint;
pub const EPOLLIN: c_int = 1;
pub const EPOLLPRI: c_int = 2;
pub const EPOLLOUT: c_int = 4;
pub const EPOLLRDNORM: c_int = 64;
pub const EPOLLRDBAND: c_int = 128;
pub const EPOLLWRNORM: c_int = 256;
pub const EPOLLWRBAND: c_int = 512;
pub const EPOLLMSG: c_int = 1024;
pub const EPOLLERR: c_int = 8;
pub const EPOLLHUP: c_int = 16;
pub const EPOLLRDHUP: c_int = 8192;
pub const EPOLLEXCLUSIVE: c_int = 268435456;
pub const EPOLLWAKEUP: c_int = 536870912;
pub const EPOLLONESHOT: c_int = 1073741824;
pub const EPOLLET: c_uint = 2147483648;
pub const enum_EPOLL_EVENTS = c_uint;
pub const union_epoll_data = extern union {
    ptr: ?*anyopaque,
    fd: c_int,
    u32: u32,
    u64: u64,
};
pub const epoll_data_t = union_epoll_data;
pub const struct_epoll_event = extern struct {
    events: u32 align(1) = @import("std").mem.zeroes(u32),
    data: epoll_data_t align(1) = @import("std").mem.zeroes(epoll_data_t),
};
pub const struct_epoll_params = extern struct {
    busy_poll_usecs: u32 = @import("std").mem.zeroes(u32),
    busy_poll_budget: u16 = @import("std").mem.zeroes(u16),
    prefer_busy_poll: u8 = @import("std").mem.zeroes(u8),
    __pad: u8 = @import("std").mem.zeroes(u8),
};
pub extern fn epoll_create(__size: c_int) c_int;
pub extern fn epoll_create1(__flags: c_int) c_int;
pub extern fn epoll_ctl(__epfd: c_int, __op: c_int, __fd: c_int, __event: [*c]struct_epoll_event) c_int;
pub extern fn epoll_wait(__epfd: c_int, __events: [*c]struct_epoll_event, __maxevents: c_int, __timeout: c_int) c_int;
pub extern fn epoll_pwait(__epfd: c_int, __events: [*c]struct_epoll_event, __maxevents: c_int, __timeout: c_int, __ss: [*c]const __sigset_t) c_int;
pub extern fn epoll_pwait2(__epfd: c_int, __events: [*c]struct_epoll_event, __maxevents: c_int, __timeout: [*c]const struct_timespec, __ss: [*c]const __sigset_t) c_int;
pub const EFD_SEMAPHORE: c_int = 1;
pub const EFD_CLOEXEC: c_int = 524288;
pub const EFD_NONBLOCK: c_int = 2048;
const enum_unnamed_75 = c_uint;
pub const eventfd_t = u64;
pub extern fn eventfd(__count: c_uint, __flags: c_int) c_int;
pub extern fn eventfd_read(__fd: c_int, __value: [*c]eventfd_t) c_int;
pub extern fn eventfd_write(__fd: c_int, __value: eventfd_t) c_int;
pub const struct___user_cap_header_struct = extern struct {
    version: __u32 = @import("std").mem.zeroes(__u32),
    pid: c_int = @import("std").mem.zeroes(c_int),
};
pub const cap_user_header_t = [*c]struct___user_cap_header_struct;
pub const struct___user_cap_data_struct = extern struct {
    effective: __u32 = @import("std").mem.zeroes(__u32),
    permitted: __u32 = @import("std").mem.zeroes(__u32),
    inheritable: __u32 = @import("std").mem.zeroes(__u32),
};
pub const cap_user_data_t = [*c]struct___user_cap_data_struct;
const struct_unnamed_76 = extern struct {
    permitted: __le32 = @import("std").mem.zeroes(__le32),
    inheritable: __le32 = @import("std").mem.zeroes(__le32),
};
pub const struct_vfs_cap_data = extern struct {
    magic_etc: __le32 = @import("std").mem.zeroes(__le32),
    data: [2]struct_unnamed_76 = @import("std").mem.zeroes([2]struct_unnamed_76),
};
const struct_unnamed_77 = extern struct {
    permitted: __le32 = @import("std").mem.zeroes(__le32),
    inheritable: __le32 = @import("std").mem.zeroes(__le32),
};
pub const struct_vfs_ns_cap_data = extern struct {
    magic_etc: __le32 = @import("std").mem.zeroes(__le32),
    data: [2]struct_unnamed_77 = @import("std").mem.zeroes([2]struct_unnamed_77),
    rootid: __le32 = @import("std").mem.zeroes(__le32),
};
const struct_unnamed_79 = extern struct {
    uh_sport: u16 = @import("std").mem.zeroes(u16),
    uh_dport: u16 = @import("std").mem.zeroes(u16),
    uh_ulen: u16 = @import("std").mem.zeroes(u16),
    uh_sum: u16 = @import("std").mem.zeroes(u16),
};
const struct_unnamed_80 = extern struct {
    source: u16 = @import("std").mem.zeroes(u16),
    dest: u16 = @import("std").mem.zeroes(u16),
    len: u16 = @import("std").mem.zeroes(u16),
    check: u16 = @import("std").mem.zeroes(u16),
};
const union_unnamed_78 = extern union {
    unnamed_0: struct_unnamed_79,
    unnamed_1: struct_unnamed_80,
};
pub const struct_udphdr = extern struct {
    unnamed_0: union_unnamed_78 = @import("std").mem.zeroes(union_unnamed_78),
};
pub const ngx_int_t = isize;
pub const ngx_uint_t = usize;
pub const ngx_flag_t = isize;
pub const ngx_buf_tag_t = ?*anyopaque;
pub const ngx_fd_t = c_int;
pub const ngx_file_info_t = struct_stat;
pub const struct_ngx_open_file_s = extern struct {
    fd: ngx_fd_t = @import("std").mem.zeroes(ngx_fd_t),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    flush: ?*const fn ([*c]ngx_open_file_t, [*c]ngx_log_t) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]ngx_open_file_t, [*c]ngx_log_t) callconv(.c) void),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const ngx_open_file_t = struct_ngx_open_file_s;
pub const ngx_atomic_uint_t = c_ulong;
pub const ngx_log_handler_pt = ?*const fn ([*c]ngx_log_t, [*c]u_char, usize) callconv(.c) [*c]u_char;
pub const ngx_log_writer_pt = ?*const fn ([*c]ngx_log_t, ngx_uint_t, [*c]u_char, usize) callconv(.c) void;
pub const struct_ngx_log_s = extern struct {
    log_level: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    file: [*c]ngx_open_file_t = @import("std").mem.zeroes([*c]ngx_open_file_t),
    connection: ngx_atomic_uint_t = @import("std").mem.zeroes(ngx_atomic_uint_t),
    disk_full_time: time_t = @import("std").mem.zeroes(time_t),
    handler: ngx_log_handler_pt = @import("std").mem.zeroes(ngx_log_handler_pt),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    writer: ngx_log_writer_pt = @import("std").mem.zeroes(ngx_log_writer_pt),
    wdata: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    action: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    next: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
};
pub const ngx_log_t = struct_ngx_log_s;
const struct_ngx_file_flags_s = packed struct {
    valid_info: bool,
    directio: bool,
    padding: u30,
};
pub const struct_ngx_file_s = extern struct {
    fd: ngx_fd_t = @import("std").mem.zeroes(ngx_fd_t),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    info: ngx_file_info_t = @import("std").mem.zeroes(ngx_file_info_t),
    offset: off_t = @import("std").mem.zeroes(off_t),
    sys_offset: off_t = @import("std").mem.zeroes(off_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    flags: struct_ngx_file_flags_s = @import("std").mem.zeroes(struct_ngx_file_flags_s),
};
pub const ngx_file_t = struct_ngx_file_s;
const struct_ngx_buf_flags_s = packed struct {
    temporary: bool,
    memory: bool,
    mmap: bool,
    recycled: bool,
    in_file: bool,
    flush: bool,
    sync: bool,
    last_buf: bool,
    last_in_chain: bool,
    last_shadow: bool,
    temp_file: bool,
    padding: u21,
};
pub const struct_ngx_buf_s = extern struct {
    pos: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    last: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    file_pos: off_t = @import("std").mem.zeroes(off_t),
    file_last: off_t = @import("std").mem.zeroes(off_t),
    start: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    tag: ngx_buf_tag_t = @import("std").mem.zeroes(ngx_buf_tag_t),
    file: [*c]ngx_file_t = @import("std").mem.zeroes([*c]ngx_file_t),
    shadow: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    flags: struct_ngx_buf_flags_s = @import("std").mem.zeroes(struct_ngx_buf_flags_s),
    num: c_int = @import("std").mem.zeroes(c_int),
};
pub const ngx_buf_t = struct_ngx_buf_s;
pub const struct_ngx_chain_s = extern struct {
    buf: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    next: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
};
pub const ngx_chain_t = struct_ngx_chain_s;
pub const struct_ngx_pool_large_s = extern struct {
    next: [*c]ngx_pool_large_t = @import("std").mem.zeroes([*c]ngx_pool_large_t),
    alloc: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const ngx_pool_large_t = struct_ngx_pool_large_s;
pub const ngx_pool_cleanup_pt = ?*const fn (?*anyopaque) callconv(.c) void;
pub const struct_ngx_pool_cleanup_s = extern struct {
    handler: ngx_pool_cleanup_pt = @import("std").mem.zeroes(ngx_pool_cleanup_pt),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    next: [*c]ngx_pool_cleanup_t = @import("std").mem.zeroes([*c]ngx_pool_cleanup_t),
};
pub const ngx_pool_cleanup_t = struct_ngx_pool_cleanup_s;
pub const struct_ngx_pool_s = extern struct {
    d: ngx_pool_data_t = @import("std").mem.zeroes(ngx_pool_data_t),
    max: usize = @import("std").mem.zeroes(usize),
    current: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    chain: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    large: [*c]ngx_pool_large_t = @import("std").mem.zeroes([*c]ngx_pool_large_t),
    cleanup: [*c]ngx_pool_cleanup_t = @import("std").mem.zeroes([*c]ngx_pool_cleanup_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
};
pub const ngx_pool_t = struct_ngx_pool_s;
pub const ngx_event_handler_pt = ?*const fn ([*c]ngx_event_t) callconv(.c) void;
pub const ngx_rbtree_key_t = ngx_uint_t;
pub const struct_ngx_rbtree_node_s = extern struct {
    key: ngx_rbtree_key_t = @import("std").mem.zeroes(ngx_rbtree_key_t),
    left: [*c]ngx_rbtree_node_t = @import("std").mem.zeroes([*c]ngx_rbtree_node_t),
    right: [*c]ngx_rbtree_node_t = @import("std").mem.zeroes([*c]ngx_rbtree_node_t),
    parent: [*c]ngx_rbtree_node_t = @import("std").mem.zeroes([*c]ngx_rbtree_node_t),
    color: u_char = @import("std").mem.zeroes(u_char),
    data: u_char = @import("std").mem.zeroes(u_char),
};
pub const ngx_rbtree_node_t = struct_ngx_rbtree_node_s;
pub const struct_ngx_queue_s = extern struct {
    prev: [*c]ngx_queue_t = @import("std").mem.zeroes([*c]ngx_queue_t),
    next: [*c]ngx_queue_t = @import("std").mem.zeroes([*c]ngx_queue_t),
};
pub const ngx_queue_t = struct_ngx_queue_s;
const struct_ngx_event_flags_s = packed struct {
    write: bool,
    accept: bool,
    instance: bool,
    active: bool,
    disabled: bool,
    ready: bool,
    oneshot: bool,
    complete: bool,
    eof: bool,
    @"error": bool,
    timedout: bool,
    timer_set: bool,
    delayed: bool,
    deferred_accept: bool,
    pending_eof: bool,
    posted: bool,
    closed: bool,
    channel: bool,
    resovler: bool,
    cancelable: bool,
    padding: u12,
};
pub const struct_ngx_event_s = extern struct {
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    flags: struct_ngx_event_flags_s = @import("std").mem.zeroes(struct_ngx_event_flags_s),
    available: c_int = @import("std").mem.zeroes(c_int),
    handler: ngx_event_handler_pt = @import("std").mem.zeroes(ngx_event_handler_pt),
    index: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    timer: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
};
pub const ngx_event_t = struct_ngx_event_s;
pub const ngx_socket_t = c_int;
pub const ngx_recv_pt = ?*const fn ([*c]ngx_connection_t, [*c]u_char, usize) callconv(.c) isize;
pub const ngx_send_pt = ?*const fn ([*c]ngx_connection_t, [*c]u_char, usize) callconv(.c) isize;
pub const ngx_recv_chain_pt = ?*const fn ([*c]ngx_connection_t, [*c]ngx_chain_t, off_t) callconv(.c) isize;
pub const ngx_send_chain_pt = ?*const fn ([*c]ngx_connection_t, [*c]ngx_chain_t, off_t) callconv(.c) [*c]ngx_chain_t;
pub const ngx_connection_handler_pt = ?*const fn ([*c]ngx_connection_t) callconv(.c) void;
pub const ngx_rbtree_insert_pt = ?*const fn ([*c]ngx_rbtree_node_t, [*c]ngx_rbtree_node_t, [*c]ngx_rbtree_node_t) callconv(.c) void;
pub const struct_ngx_rbtree_s = extern struct {
    root: [*c]ngx_rbtree_node_t = @import("std").mem.zeroes([*c]ngx_rbtree_node_t),
    sentinel: [*c]ngx_rbtree_node_t = @import("std").mem.zeroes([*c]ngx_rbtree_node_t),
    insert: ngx_rbtree_insert_pt = @import("std").mem.zeroes(ngx_rbtree_insert_pt),
};
pub const ngx_rbtree_t = struct_ngx_rbtree_s;
const struct_ngx_listening_flags_s = packed struct {
    open: bool,
    remain: bool,
    ignore: bool,
    bound: bool,
    inherited: bool,
    nonblocking_accept: bool,
    listen: bool,
    nonblocking: bool,
    shared: bool,
    addr_ntop: bool,
    wildcard: bool,
    ipv6only: bool,
    reuseport: bool,
    add_reuseport: bool,
    keepalive: u2,
    quic: bool,
    deferred_accept: bool,
    delete_deferred: bool,
    add_deferred: bool,
    padding: u12,
};
pub const struct_ngx_listening_s = extern struct {
    fd: ngx_socket_t = @import("std").mem.zeroes(ngx_socket_t),
    sockaddr: [*c]struct_sockaddr = @import("std").mem.zeroes([*c]struct_sockaddr),
    socklen: socklen_t = @import("std").mem.zeroes(socklen_t),
    addr_text_max_len: usize = @import("std").mem.zeroes(usize),
    addr_text: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    type: c_int = @import("std").mem.zeroes(c_int),
    backlog: c_int = @import("std").mem.zeroes(c_int),
    rcvbuf: c_int = @import("std").mem.zeroes(c_int),
    sndbuf: c_int = @import("std").mem.zeroes(c_int),
    keepidle: c_int = @import("std").mem.zeroes(c_int),
    keepintvl: c_int = @import("std").mem.zeroes(c_int),
    keepcnt: c_int = @import("std").mem.zeroes(c_int),
    handler: ?*const fn ([*c]ngx_connection_t) callconv(.c) void = @import("std").mem.zeroes(ngx_connection_handler_pt),
    servers: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    log: ngx_log_t = @import("std").mem.zeroes(ngx_log_t),
    logp: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    pool_size: usize = @import("std").mem.zeroes(usize),
    post_accept_buffer_size: usize = @import("std").mem.zeroes(usize),
    previous: [*c]ngx_listening_t = @import("std").mem.zeroes([*c]ngx_listening_t),
    connection: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    rbtree: ngx_rbtree_t = @import("std").mem.zeroes(ngx_rbtree_t),
    sentinel: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    worker: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    flags: struct_ngx_listening_flags_s = @import("std").mem.zeroes(struct_ngx_listening_flags_s),
    fastopen: c_int = @import("std").mem.zeroes(c_int),
};
pub const ngx_listening_t = struct_ngx_listening_s;
pub const struct_ngx_proxy_protocol_s = extern struct {
    src_addr: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    dst_addr: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    src_port: in_port_t = @import("std").mem.zeroes(in_port_t),
    dst_port: in_port_t = @import("std").mem.zeroes(in_port_t),
    tlvs: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub const ngx_proxy_protocol_t = struct_ngx_proxy_protocol_s;
pub const struct_ssl_st = opaque {};
pub const SSL = struct_ssl_st;
pub const struct_ssl_ctx_st = opaque {};
pub const SSL_CTX = struct_ssl_ctx_st;
pub const struct_ssl_session_st = opaque {};
pub const SSL_SESSION = struct_ssl_session_st;
pub const struct_ngx_ssl_ocsp_s = opaque {};
pub const ngx_ssl_ocsp_t = struct_ngx_ssl_ocsp_s;
const struct_ngx_ssl_connection_flags_s = packed struct {
    handshaked: bool,
    handshake_rejected: bool,
    renegotiation: bool,
    buffer: bool,
    sendilfe: bool,
    no_wait_shutdown: bool,
    no_send_shutdown: bool,
    shutdown_without_free: bool,
    handshake_buffer_set: bool,
    session_timeout_set: bool,
    try_early_data: bool,
    in_early: bool,
    in_ocsp: bool,
    early_preread: bool,
    write_blocked: bool,
    padding: u17,
};
pub const struct_ngx_ssl_connection_s = extern struct {
    connection: ?*SSL = @import("std").mem.zeroes(?*SSL),
    session_ctx: ?*SSL_CTX = @import("std").mem.zeroes(?*SSL_CTX),
    last: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    buf: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    buffer_size: usize = @import("std").mem.zeroes(usize),
    handler: ngx_connection_handler_pt = @import("std").mem.zeroes(ngx_connection_handler_pt),
    session: ?*SSL_SESSION = @import("std").mem.zeroes(?*SSL_SESSION),
    save_session: ngx_connection_handler_pt = @import("std").mem.zeroes(ngx_connection_handler_pt),
    saved_read_handler: ngx_event_handler_pt = @import("std").mem.zeroes(ngx_event_handler_pt),
    saved_write_handler: ngx_event_handler_pt = @import("std").mem.zeroes(ngx_event_handler_pt),
    ocsp: ?*ngx_ssl_ocsp_t = @import("std").mem.zeroes(?*ngx_ssl_ocsp_t),
    early_buf: u_char = @import("std").mem.zeroes(u_char),
    flags: struct_ngx_ssl_connection_flags_s = @import("std").mem.zeroes(struct_ngx_ssl_connection_flags_s),
};
pub const ngx_ssl_connection_t = struct_ngx_ssl_connection_s;
pub const struct_ngx_udp_connection_s = extern struct {
    node: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    connection: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    buffer: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    key: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub const ngx_udp_connection_t = struct_ngx_udp_connection_s;
pub const ngx_msec_t = ngx_rbtree_key_t;
const struct_ngx_connection_flags_s = packed struct {
    buffered: u8,
    log_error: u3,
    timedout: bool,
    @"error": bool,
    destroyed: bool,
    pipeline: bool,
    idle: bool,
    resuable: bool,
    close: bool,
    shared: bool,
    snedfile: bool,
    sndlowat: bool,
    tcp_nodelay: u2,
    tcp_nopush: u2,
    need_last_buf: bool,
    need_flush_buf: bool,
    padding: u5,
};
pub const struct_ngx_connection_s = extern struct {
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    read: [*c]ngx_event_t = @import("std").mem.zeroes([*c]ngx_event_t),
    write: [*c]ngx_event_t = @import("std").mem.zeroes([*c]ngx_event_t),
    fd: ngx_socket_t = @import("std").mem.zeroes(ngx_socket_t),
    recv: ngx_recv_pt = @import("std").mem.zeroes(ngx_recv_pt),
    send: ngx_send_pt = @import("std").mem.zeroes(ngx_send_pt),
    recv_chain: ngx_recv_chain_pt = @import("std").mem.zeroes(ngx_recv_chain_pt),
    send_chain: ngx_send_chain_pt = @import("std").mem.zeroes(ngx_send_chain_pt),
    listening: [*c]ngx_listening_t = @import("std").mem.zeroes([*c]ngx_listening_t),
    sent: off_t = @import("std").mem.zeroes(off_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    type: c_int = @import("std").mem.zeroes(c_int),
    sockaddr: [*c]struct_sockaddr = @import("std").mem.zeroes([*c]struct_sockaddr),
    socklen: socklen_t = @import("std").mem.zeroes(socklen_t),
    addr_text: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    proxy_protocol: [*c]ngx_proxy_protocol_t = @import("std").mem.zeroes([*c]ngx_proxy_protocol_t),
    ssl: [*c]ngx_ssl_connection_t = @import("std").mem.zeroes([*c]ngx_ssl_connection_t),
    udp: [*c]ngx_udp_connection_t = @import("std").mem.zeroes([*c]ngx_udp_connection_t),
    local_sockaddr: [*c]struct_sockaddr = @import("std").mem.zeroes([*c]struct_sockaddr),
    local_socklen: socklen_t = @import("std").mem.zeroes(socklen_t),
    buffer: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    number: ngx_atomic_uint_t = @import("std").mem.zeroes(ngx_atomic_uint_t),
    start_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    requests: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    flags: struct_ngx_connection_flags_s = @import("std").mem.zeroes(struct_ngx_connection_flags_s),
};
pub const ngx_connection_t = struct_ngx_connection_s;
pub const ngx_module_t = struct_ngx_module_s;
pub const struct_ngx_cycle_s = extern struct {
    conf_ctx: [*c][*c][*c]?*anyopaque = @import("std").mem.zeroes([*c][*c][*c]?*anyopaque),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    new_log: ngx_log_t = @import("std").mem.zeroes(ngx_log_t),
    log_use_stderr: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    files: [*c][*c]ngx_connection_t = @import("std").mem.zeroes([*c][*c]ngx_connection_t),
    free_connections: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    free_connection_n: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    modules: [*c][*c]ngx_module_t = @import("std").mem.zeroes([*c][*c]ngx_module_t),
    modules_n: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    modules_used: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    reusable_connections_queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    reusable_connections_n: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    connections_reuse_time: time_t = @import("std").mem.zeroes(time_t),
    listening: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    paths: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    config_dump: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    config_dump_rbtree: ngx_rbtree_t = @import("std").mem.zeroes(ngx_rbtree_t),
    config_dump_sentinel: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    open_files: ngx_list_t = @import("std").mem.zeroes(ngx_list_t),
    shared_memory: ngx_list_t = @import("std").mem.zeroes(ngx_list_t),
    connection_n: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    files_n: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    connections: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    read_events: [*c]ngx_event_t = @import("std").mem.zeroes([*c]ngx_event_t),
    write_events: [*c]ngx_event_t = @import("std").mem.zeroes([*c]ngx_event_t),
    old_cycle: [*c]ngx_cycle_t = @import("std").mem.zeroes([*c]ngx_cycle_t),
    conf_file: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    conf_param: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    conf_prefix: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    prefix: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    error_log: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    lock_file: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    hostname: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub const ngx_cycle_t = struct_ngx_cycle_s;
pub const ngx_conf_handler_pt = ?*const fn ([*c]ngx_conf_t, [*c]ngx_command_t, ?*anyopaque) callconv(.c) [*c]u8;
pub const struct_ngx_conf_s = extern struct {
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    args: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    cycle: [*c]ngx_cycle_t = @import("std").mem.zeroes([*c]ngx_cycle_t),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    temp_pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    conf_file: [*c]ngx_conf_file_t = @import("std").mem.zeroes([*c]ngx_conf_file_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    ctx: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    module_type: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    cmd_type: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    handler: ngx_conf_handler_pt = @import("std").mem.zeroes(ngx_conf_handler_pt),
    handler_conf: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const ngx_conf_t = struct_ngx_conf_s;
pub const struct_ngx_command_s = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    type: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    set: ?*const fn ([*c]ngx_conf_t, [*c]ngx_command_t, ?*anyopaque) callconv(.c) [*c]u8 = @import("std").mem.zeroes(?*const fn ([*c]ngx_conf_t, [*c]ngx_command_t, ?*anyopaque) callconv(.c) [*c]u8),
    conf: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    offset: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    post: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const ngx_command_t = struct_ngx_command_s;
pub const struct_ngx_module_s = extern struct {
    ctx_index: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    index: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    spare0: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    spare1: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    version: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    signature: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    ctx: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    commands: [*c]ngx_command_t = @import("std").mem.zeroes([*c]ngx_command_t),
    type: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    init_master: ?*const fn ([*c]ngx_log_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_log_t) callconv(.c) ngx_int_t),
    init_module: ?*const fn ([*c]ngx_cycle_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t) callconv(.c) ngx_int_t),
    init_process: ?*const fn ([*c]ngx_cycle_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t) callconv(.c) ngx_int_t),
    init_thread: ?*const fn ([*c]ngx_cycle_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t) callconv(.c) ngx_int_t),
    exit_thread: ?*const fn ([*c]ngx_cycle_t) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t) callconv(.c) void),
    exit_process: ?*const fn ([*c]ngx_cycle_t) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t) callconv(.c) void),
    exit_master: ?*const fn ([*c]ngx_cycle_t) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t) callconv(.c) void),
    spare_hook0: usize = @import("std").mem.zeroes(usize),
    spare_hook1: usize = @import("std").mem.zeroes(usize),
    spare_hook2: usize = @import("std").mem.zeroes(usize),
    spare_hook3: usize = @import("std").mem.zeroes(usize),
    spare_hook4: usize = @import("std").mem.zeroes(usize),
    spare_hook5: usize = @import("std").mem.zeroes(usize),
    spare_hook6: usize = @import("std").mem.zeroes(usize),
    spare_hook7: usize = @import("std").mem.zeroes(usize),
};
pub const struct_ngx_event_aio_s = opaque {};
pub const ngx_event_aio_t = struct_ngx_event_aio_s;
pub const struct_ngx_thread_task_s = opaque {};
pub const ngx_thread_task_t = struct_ngx_thread_task_s;
pub const struct_ngx_ssl_s = extern struct {
    ctx: ?*SSL_CTX = @import("std").mem.zeroes(?*SSL_CTX),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    buffer_size: usize = @import("std").mem.zeroes(usize),
    certs: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    staple_rbtree: ngx_rbtree_t = @import("std").mem.zeroes(ngx_rbtree_t),
    staple_sentinel: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
};
pub const ngx_ssl_t = struct_ngx_ssl_s;
pub const struct_ngx_quic_stream_s = opaque {};
pub const ngx_quic_stream_t = struct_ngx_quic_stream_s;
pub const ngx_err_t = c_int;
pub extern fn ngx_strerror(err: ngx_err_t, errstr: [*c]u_char, size: usize) [*c]u_char;
pub extern fn ngx_strerror_init() ngx_int_t;
pub const ngx_atomic_int_t = c_long;
pub const ngx_atomic_t = ngx_atomic_uint_t;
pub extern fn ngx_spinlock(lock: [*c]volatile ngx_atomic_t, value: ngx_atomic_int_t, spin: ngx_uint_t) void;
pub const ngx_rbtree_key_int_t = ngx_int_t;
pub extern fn ngx_rbtree_insert(tree: [*c]ngx_rbtree_t, node: [*c]ngx_rbtree_node_t) void;
pub extern fn ngx_rbtree_delete(tree: [*c]ngx_rbtree_t, node: [*c]ngx_rbtree_node_t) void;
pub extern fn ngx_rbtree_insert_value(root: [*c]ngx_rbtree_node_t, node: [*c]ngx_rbtree_node_t, sentinel: [*c]ngx_rbtree_node_t) void;
pub extern fn ngx_rbtree_insert_timer_value(root: [*c]ngx_rbtree_node_t, node: [*c]ngx_rbtree_node_t, sentinel: [*c]ngx_rbtree_node_t) void;
pub extern fn ngx_rbtree_next(tree: [*c]ngx_rbtree_t, node: [*c]ngx_rbtree_node_t) [*c]ngx_rbtree_node_t;
pub fn ngx_rbtree_min(arg_node: [*c]ngx_rbtree_node_t, arg_sentinel: [*c]ngx_rbtree_node_t) callconv(.c) [*c]ngx_rbtree_node_t {
    var node = arg_node;
    _ = &node;
    var sentinel = arg_sentinel;
    _ = &sentinel;
    while (node.*.left != sentinel) {
        node = node.*.left;
    }
    return node;
}
pub const ngx_msec_int_t = ngx_rbtree_key_int_t;
pub const ngx_tm_t = struct_tm;
pub extern fn ngx_timezone_update() void;
pub extern fn ngx_localtime(s: time_t, tm: [*c]ngx_tm_t) void;
pub extern fn ngx_libc_localtime(s: time_t, tm: [*c]struct_tm) void;
pub extern fn ngx_libc_gmtime(s: time_t, tm: [*c]struct_tm) void;
pub extern fn ngx_nonblocking(s: ngx_socket_t) c_int;
pub extern fn ngx_blocking(s: ngx_socket_t) c_int;
pub extern fn ngx_tcp_nopush(s: ngx_socket_t) c_int;
pub extern fn ngx_tcp_push(s: ngx_socket_t) c_int;
pub const ngx_str_t = extern struct {
    len: usize = @import("std").mem.zeroes(usize),
    data: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
};
pub const ngx_keyval_t = extern struct {
    key: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    value: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
const ngx_variable_value_flags_t = packed struct {
    len: u28,
    valid: bool,
    no_cacheable: bool,
    not_found: bool,
    escape: bool,
};
pub const ngx_variable_value_t = extern struct {
    flags: ngx_variable_value_flags_t = @import("std").mem.zeroes(ngx_variable_value_flags_t),
    data: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
};
pub extern fn ngx_strlow(dst: [*c]u_char, src: [*c]u_char, n: usize) void;
pub extern fn ngx_strnlen(p: [*c]u_char, n: usize) usize;
pub fn ngx_strlchr(arg_p: [*c]u_char, arg_last: [*c]u_char, arg_c: u_char) callconv(.c) [*c]u_char {
    var p = arg_p;
    _ = &p;
    var last = arg_last;
    _ = &last;
    var c = arg_c;
    _ = &c;
    while (p < last) {
        if (@as(c_int, @bitCast(@as(c_uint, p.*))) == @as(c_int, @bitCast(@as(c_uint, c)))) {
            return p;
        }
        p += 1;
    }
    return null;
}
pub extern fn ngx_explicit_memzero(buf: ?*anyopaque, n: usize) void;
pub extern fn ngx_cpystrn(dst: [*c]u_char, src: [*c]u_char, n: usize) [*c]u_char;
pub extern fn ngx_pstrdup(pool: [*c]ngx_pool_t, src: [*c]ngx_str_t) [*c]u_char;
pub extern fn ngx_sprintf(buf: [*c]u_char, fmt: [*c]const u8, ...) [*c]u_char;
pub extern fn ngx_snprintf(buf: [*c]u_char, max: usize, fmt: [*c]const u8, ...) [*c]u_char;
pub extern fn ngx_slprintf(buf: [*c]u_char, last: [*c]u_char, fmt: [*c]const u8, ...) [*c]u_char;
pub extern fn ngx_vslprintf(buf: [*c]u_char, last: [*c]u_char, fmt: [*c]const u8, args: [*c]struct___va_list_tag_5) [*c]u_char;
pub extern fn ngx_strcasecmp(s1: [*c]u_char, s2: [*c]u_char) ngx_int_t;
pub extern fn ngx_strncasecmp(s1: [*c]u_char, s2: [*c]u_char, n: usize) ngx_int_t;
pub extern fn ngx_strnstr(s1: [*c]u_char, s2: [*c]u8, n: usize) [*c]u_char;
pub extern fn ngx_strstrn(s1: [*c]u_char, s2: [*c]u8, n: usize) [*c]u_char;
pub extern fn ngx_strcasestrn(s1: [*c]u_char, s2: [*c]u8, n: usize) [*c]u_char;
pub extern fn ngx_strlcasestrn(s1: [*c]u_char, last: [*c]u_char, s2: [*c]u_char, n: usize) [*c]u_char;
pub extern fn ngx_rstrncmp(s1: [*c]u_char, s2: [*c]u_char, n: usize) ngx_int_t;
pub extern fn ngx_rstrncasecmp(s1: [*c]u_char, s2: [*c]u_char, n: usize) ngx_int_t;
pub extern fn ngx_memn2cmp(s1: [*c]u_char, s2: [*c]u_char, n1: usize, n2: usize) ngx_int_t;
pub extern fn ngx_dns_strcmp(s1: [*c]u_char, s2: [*c]u_char) ngx_int_t;
pub extern fn ngx_filename_cmp(s1: [*c]u_char, s2: [*c]u_char, n: usize) ngx_int_t;
pub extern fn ngx_atoi(line: [*c]u_char, n: usize) ngx_int_t;
pub extern fn ngx_atofp(line: [*c]u_char, n: usize, point: usize) ngx_int_t;
pub extern fn ngx_atosz(line: [*c]u_char, n: usize) isize;
pub extern fn ngx_atoof(line: [*c]u_char, n: usize) off_t;
pub extern fn ngx_atotm(line: [*c]u_char, n: usize) time_t;
pub extern fn ngx_hextoi(line: [*c]u_char, n: usize) ngx_int_t;
pub extern fn ngx_hex_dump(dst: [*c]u_char, src: [*c]u_char, len: usize) [*c]u_char;
pub extern fn ngx_encode_base64(dst: [*c]ngx_str_t, src: [*c]ngx_str_t) void;
pub extern fn ngx_encode_base64url(dst: [*c]ngx_str_t, src: [*c]ngx_str_t) void;
pub extern fn ngx_decode_base64(dst: [*c]ngx_str_t, src: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_decode_base64url(dst: [*c]ngx_str_t, src: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_utf8_decode(p: [*c][*c]u_char, n: usize) u32;
pub extern fn ngx_utf8_length(p: [*c]u_char, n: usize) usize;
pub extern fn ngx_utf8_cpystrn(dst: [*c]u_char, src: [*c]u_char, n: usize, len: usize) [*c]u_char;
pub extern fn ngx_escape_uri(dst: [*c]u_char, src: [*c]u_char, size: usize, @"type": ngx_uint_t) usize;
pub extern fn ngx_unescape_uri(dst: [*c][*c]u_char, src: [*c][*c]u_char, size: usize, @"type": ngx_uint_t) void;
pub extern fn ngx_escape_html(dst: [*c]u_char, src: [*c]u_char, size: usize) usize;
pub extern fn ngx_escape_json(dst: [*c]u_char, src: [*c]u_char, size: usize) usize;
pub const ngx_str_node_t = extern struct {
    node: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    str: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub extern fn ngx_str_rbtree_insert_value(temp: [*c]ngx_rbtree_node_t, node: [*c]ngx_rbtree_node_t, sentinel: [*c]ngx_rbtree_node_t) void;
pub extern fn ngx_str_rbtree_lookup(rbtree: [*c]ngx_rbtree_t, name: [*c]ngx_str_t, hash: u32) [*c]ngx_str_node_t;
pub extern fn ngx_sort(base: ?*anyopaque, n: usize, size: usize, cmp: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.c) ngx_int_t) void;
pub const ngx_file_uniq_t = ino_t;
pub const ngx_file_mapping_t = extern struct {
    name: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    size: usize = @import("std").mem.zeroes(usize),
    addr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    fd: ngx_fd_t = @import("std").mem.zeroes(ngx_fd_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
};
const ngx_dir_flags_t = packed struct {
    type: u8,
    valid_info: bool,
    padding: u23,
};
pub const ngx_dir_t = extern struct {
    dir: ?*DIR = @import("std").mem.zeroes(?*DIR),
    de: [*c]struct_dirent = @import("std").mem.zeroes([*c]struct_dirent),
    info: struct_stat = @import("std").mem.zeroes(struct_stat),
    flags: ngx_dir_flags_t = @import("std").mem.zeroes(ngx_dir_flags_t),
};
pub const ngx_glob_t = extern struct {
    n: usize = @import("std").mem.zeroes(usize),
    pglob: glob_t = @import("std").mem.zeroes(glob_t),
    pattern: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    @"test": ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub extern fn ngx_open_tempfile(name: [*c]u_char, persistent: ngx_uint_t, access: ngx_uint_t) ngx_fd_t;
pub extern fn ngx_read_file(file: [*c]ngx_file_t, buf: [*c]u_char, size: usize, offset: off_t) isize;
pub extern fn ngx_write_file(file: [*c]ngx_file_t, buf: [*c]u_char, size: usize, offset: off_t) isize;
pub extern fn ngx_write_chain_to_file(file: [*c]ngx_file_t, ce: [*c]ngx_chain_t, offset: off_t, pool: [*c]ngx_pool_t) isize;
pub fn ngx_write_fd(arg_fd: ngx_fd_t, arg_buf: ?*anyopaque, arg_n: usize) callconv(.c) isize {
    var fd = arg_fd;
    _ = &fd;
    var buf = arg_buf;
    _ = &buf;
    var n = arg_n;
    _ = &n;
    return write(fd, buf, n);
}
pub extern fn ngx_set_file_time(name: [*c]u_char, fd: ngx_fd_t, s: time_t) ngx_int_t;
pub extern fn ngx_create_file_mapping(fm: [*c]ngx_file_mapping_t) ngx_int_t;
pub extern fn ngx_close_file_mapping(fm: [*c]ngx_file_mapping_t) void;
pub extern fn ngx_open_dir(name: [*c]ngx_str_t, dir: [*c]ngx_dir_t) ngx_int_t;
pub extern fn ngx_read_dir(dir: [*c]ngx_dir_t) ngx_int_t;
pub extern fn ngx_open_glob(gl: [*c]ngx_glob_t) ngx_int_t;
pub extern fn ngx_read_glob(gl: [*c]ngx_glob_t, name: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_close_glob(gl: [*c]ngx_glob_t) void;
pub extern fn ngx_trylock_fd(fd: ngx_fd_t) ngx_err_t;
pub extern fn ngx_lock_fd(fd: ngx_fd_t) ngx_err_t;
pub extern fn ngx_unlock_fd(fd: ngx_fd_t) ngx_err_t;
pub extern fn ngx_read_ahead(fd: ngx_fd_t, n: usize) ngx_int_t;
pub extern fn ngx_directio_on(fd: ngx_fd_t) ngx_int_t;
pub extern fn ngx_directio_off(fd: ngx_fd_t) ngx_int_t;
pub extern fn ngx_fs_bsize(name: [*c]u_char) usize;
pub extern fn ngx_fs_available(name: [*c]u_char) off_t;
pub const ngx_shm_t = extern struct {
    addr: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    size: usize = @import("std").mem.zeroes(usize),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    exists: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub extern fn ngx_shm_alloc(shm: [*c]ngx_shm_t) ngx_int_t;
pub extern fn ngx_shm_free(shm: [*c]ngx_shm_t) void;
pub const ngx_cpuset_t = cpu_set_t;
pub extern fn ngx_setaffinity(cpu_affinity: [*c]ngx_cpuset_t, log: [*c]ngx_log_t) void;
pub extern fn ngx_init_setproctitle(log: [*c]ngx_log_t) ngx_int_t;
pub extern fn ngx_setproctitle(title: [*c]u8) void;
pub const ngx_pid_t = pid_t;
pub const ngx_spawn_proc_pt = ?*const fn ([*c]ngx_cycle_t, ?*anyopaque) callconv(.c) void;
const ngx_process_flags_t = packed struct {
    respawn: bool,
    just_spawn: bool,
    detached: bool,
    exiting: bool,
    exited: bool,
    padding: u27,
};
pub const ngx_process_t = extern struct {
    pid: ngx_pid_t = @import("std").mem.zeroes(ngx_pid_t),
    status: c_int = @import("std").mem.zeroes(c_int),
    channel: [2]ngx_socket_t = @import("std").mem.zeroes([2]ngx_socket_t),
    proc: ngx_spawn_proc_pt = @import("std").mem.zeroes(ngx_spawn_proc_pt),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    flags: ngx_process_flags_t = @import("std").mem.zeroes(ngx_process_flags_t),
};
pub const ngx_exec_ctx_t = extern struct {
    path: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    argv: [*c]const [*c]u8 = @import("std").mem.zeroes([*c]const [*c]u8),
    envp: [*c]const [*c]u8 = @import("std").mem.zeroes([*c]const [*c]u8),
};
pub extern fn ngx_spawn_process(cycle: [*c]ngx_cycle_t, proc: ngx_spawn_proc_pt, data: ?*anyopaque, name: [*c]u8, respawn: ngx_int_t) ngx_pid_t;
pub extern fn ngx_execute(cycle: [*c]ngx_cycle_t, ctx: [*c]ngx_exec_ctx_t) ngx_pid_t;
pub extern fn ngx_init_signals(log: [*c]ngx_log_t) ngx_int_t;
pub extern fn ngx_debug_point() void;
pub extern var ngx_argc: c_int;
pub extern var ngx_argv: [*c][*c]u8;
pub extern var ngx_os_argv: [*c][*c]u8;
pub extern var ngx_pid: ngx_pid_t;
pub extern var ngx_parent: ngx_pid_t;
pub extern var ngx_channel: ngx_socket_t;
pub extern var ngx_process_slot: ngx_int_t;
pub extern var ngx_last_process: ngx_int_t;
pub extern var ngx_processes: [1024]ngx_process_t;
pub const ngx_uid_t = uid_t;
pub const ngx_gid_t = gid_t;
pub extern fn ngx_libc_crypt(pool: [*c]ngx_pool_t, key: [*c]u_char, salt: [*c]u_char, encrypted: [*c][*c]u_char) ngx_int_t;
pub extern fn ngx_dlerror() [*c]u8;
pub extern fn ngx_parse_size(line: [*c]ngx_str_t) isize;
pub extern fn ngx_parse_offset(line: [*c]ngx_str_t) off_t;
pub extern fn ngx_parse_time(line: [*c]ngx_str_t, is_sec: ngx_uint_t) ngx_int_t;
pub extern fn ngx_parse_http_time(value: [*c]u_char, len: usize) time_t;
pub extern fn ngx_log_error_core(level: ngx_uint_t, log: [*c]ngx_log_t, err: ngx_err_t, fmt: [*c]const u8, ...) void;
pub extern fn ngx_log_init(prefix: [*c]u_char, error_log: [*c]u_char) [*c]ngx_log_t;
pub extern fn ngx_log_abort(err: ngx_err_t, fmt: [*c]const u8, ...) void;
pub extern fn ngx_log_stderr(err: ngx_err_t, fmt: [*c]const u8, ...) void;
pub extern fn ngx_log_errno(buf: [*c]u_char, last: [*c]u_char, err: ngx_err_t) [*c]u_char;
pub extern fn ngx_log_open_default(cycle: [*c]ngx_cycle_t) ngx_int_t;
pub extern fn ngx_log_redirect_stderr(cycle: [*c]ngx_cycle_t) ngx_int_t;
pub extern fn ngx_log_get_file_log(head: [*c]ngx_log_t) [*c]ngx_log_t;
pub extern fn ngx_log_set_log(cf: [*c]ngx_conf_t, head: [*c][*c]ngx_log_t) [*c]u8;
pub fn ngx_write_stderr(arg_text: [*c]u8) callconv(.c) void {
    var text = arg_text;
    _ = &text;
    _ = ngx_write_fd(@as(c_int, 2), @as(?*anyopaque, @ptrCast(text)), strlen(@as([*c]const u8, @ptrCast(@alignCast(text)))));
}
pub fn ngx_write_stdout(arg_text: [*c]u8) callconv(.c) void {
    var text = arg_text;
    _ = &text;
    _ = ngx_write_fd(@as(c_int, 1), @as(?*anyopaque, @ptrCast(text)), strlen(@as([*c]const u8, @ptrCast(@alignCast(text)))));
}
pub extern var ngx_errlog_module: ngx_module_t;
pub extern var ngx_use_stderr: ngx_uint_t;
pub extern fn ngx_alloc(size: usize, log: [*c]ngx_log_t) ?*anyopaque;
pub extern fn ngx_calloc(size: usize, log: [*c]ngx_log_t) ?*anyopaque;
pub extern fn ngx_memalign(alignment: usize, size: usize, log: [*c]ngx_log_t) ?*anyopaque;
pub extern var ngx_pagesize: ngx_uint_t;
pub extern var ngx_pagesize_shift: ngx_uint_t;
pub extern var ngx_cacheline_size: ngx_uint_t;
pub const ngx_pool_data_t = extern struct {
    last: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    next: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    failed: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_pool_cleanup_file_t = extern struct {
    fd: ngx_fd_t = @import("std").mem.zeroes(ngx_fd_t),
    name: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
};
pub extern fn ngx_create_pool(size: usize, log: [*c]ngx_log_t) [*c]ngx_pool_t;
pub extern fn ngx_destroy_pool(pool: [*c]ngx_pool_t) void;
pub extern fn ngx_reset_pool(pool: [*c]ngx_pool_t) void;
pub extern fn ngx_palloc(pool: [*c]ngx_pool_t, size: usize) ?*anyopaque;
pub extern fn ngx_pnalloc(pool: [*c]ngx_pool_t, size: usize) ?*anyopaque;
pub extern fn ngx_pcalloc(pool: [*c]ngx_pool_t, size: usize) ?*anyopaque;
pub extern fn ngx_pmemalign(pool: [*c]ngx_pool_t, size: usize, alignment: usize) ?*anyopaque;
pub extern fn ngx_pfree(pool: [*c]ngx_pool_t, p: ?*anyopaque) ngx_int_t;
pub extern fn ngx_pool_cleanup_add(p: [*c]ngx_pool_t, size: usize) [*c]ngx_pool_cleanup_t;
pub extern fn ngx_pool_run_cleanup_file(p: [*c]ngx_pool_t, fd: ngx_fd_t) void;
pub extern fn ngx_pool_cleanup_file(data: ?*anyopaque) void;
pub extern fn ngx_pool_delete_file(data: ?*anyopaque) void;
pub const ngx_bufs_t = extern struct {
    num: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    size: usize = @import("std").mem.zeroes(usize),
};
pub const ngx_output_chain_filter_pt = ?*const fn (?*anyopaque, [*c]ngx_chain_t) callconv(.c) ngx_int_t;
const struct_ngx_output_chain_ctx_flags_s = packed struct {
    sendfile: bool,
    directio: bool,
    unaligned: bool,
    need_in_memory: bool,
    need_in_temp: bool,
    aio: bool,
    padding: u26,
};
pub const struct_ngx_output_chain_ctx_s = extern struct {
    buf: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    in: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    free: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    busy: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    flags: struct_ngx_output_chain_ctx_flags_s = @import("std").mem.zeroes(struct_ngx_output_chain_ctx_flags_s),
    alignment: off_t = @import("std").mem.zeroes(off_t),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    allocated: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    bufs: ngx_bufs_t = @import("std").mem.zeroes(ngx_bufs_t),
    tag: ngx_buf_tag_t = @import("std").mem.zeroes(ngx_buf_tag_t),
    output_filter: ngx_output_chain_filter_pt = @import("std").mem.zeroes(ngx_output_chain_filter_pt),
    filter_ctx: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const ngx_output_chain_ctx_t = struct_ngx_output_chain_ctx_s;
pub const ngx_output_chain_aio_pt = ?*const fn ([*c]ngx_output_chain_ctx_t, [*c]ngx_file_t) callconv(.c) void;
pub const ngx_chain_writer_ctx_t = extern struct {
    out: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    last: [*c][*c]ngx_chain_t = @import("std").mem.zeroes([*c][*c]ngx_chain_t),
    connection: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    limit: off_t = @import("std").mem.zeroes(off_t),
};
pub extern fn ngx_create_temp_buf(pool: [*c]ngx_pool_t, size: usize) [*c]ngx_buf_t;
pub extern fn ngx_create_chain_of_bufs(pool: [*c]ngx_pool_t, bufs: [*c]ngx_bufs_t) [*c]ngx_chain_t;
pub extern fn ngx_alloc_chain_link(pool: [*c]ngx_pool_t) [*c]ngx_chain_t;
pub extern fn ngx_output_chain(ctx: [*c]ngx_output_chain_ctx_t, in: [*c]ngx_chain_t) ngx_int_t;
pub extern fn ngx_chain_writer(ctx: ?*anyopaque, in: [*c]ngx_chain_t) ngx_int_t;
pub extern fn ngx_chain_add_copy(pool: [*c]ngx_pool_t, chain: [*c][*c]ngx_chain_t, in: [*c]ngx_chain_t) ngx_int_t;
pub extern fn ngx_chain_get_free_buf(p: [*c]ngx_pool_t, free: [*c][*c]ngx_chain_t) [*c]ngx_chain_t;
pub extern fn ngx_chain_update_chains(p: [*c]ngx_pool_t, free: [*c][*c]ngx_chain_t, busy: [*c][*c]ngx_chain_t, out: [*c][*c]ngx_chain_t, tag: ngx_buf_tag_t) void;
pub extern fn ngx_chain_coalesce_file(in: [*c][*c]ngx_chain_t, limit: off_t) off_t;
pub extern fn ngx_chain_update_sent(in: [*c]ngx_chain_t, sent: off_t) [*c]ngx_chain_t;
pub extern fn ngx_queue_middle(queue: [*c]ngx_queue_t) [*c]ngx_queue_t;
pub extern fn ngx_queue_sort(queue: [*c]ngx_queue_t, cmp: ?*const fn ([*c]const ngx_queue_t, [*c]const ngx_queue_t) callconv(.c) ngx_int_t) void;
pub const ngx_array_t = extern struct {
    elts: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    nelts: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    size: usize = @import("std").mem.zeroes(usize),
    nalloc: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
};
pub extern fn ngx_array_create(p: [*c]ngx_pool_t, n: ngx_uint_t, size: usize) [*c]ngx_array_t;
pub extern fn ngx_array_destroy(a: [*c]ngx_array_t) void;
pub extern fn ngx_array_push(a: [*c]ngx_array_t) ?*anyopaque;
pub extern fn ngx_array_push_n(a: [*c]ngx_array_t, n: ngx_uint_t) ?*anyopaque;
pub fn ngx_array_init(arg_array: [*c]ngx_array_t, arg_pool: [*c]ngx_pool_t, arg_n: ngx_uint_t, arg_size: usize) callconv(.c) ngx_int_t {
    var array = arg_array;
    _ = &array;
    var pool = arg_pool;
    _ = &pool;
    var n = arg_n;
    _ = &n;
    var size = arg_size;
    _ = &size;
    array.*.nelts = 0;
    array.*.size = size;
    array.*.nalloc = n;
    array.*.pool = pool;
    array.*.elts = ngx_palloc(pool, n *% size);
    if (array.*.elts == @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))) {
        return @as(ngx_int_t, @bitCast(@as(c_long, -@as(c_int, 1))));
    }
    return 0;
}
pub const ngx_list_part_t = struct_ngx_list_part_s;
pub const struct_ngx_list_part_s = extern struct {
    elts: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    nelts: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    next: [*c]ngx_list_part_t = @import("std").mem.zeroes([*c]ngx_list_part_t),
};
pub const ngx_list_t = extern struct {
    last: [*c]ngx_list_part_t = @import("std").mem.zeroes([*c]ngx_list_part_t),
    part: ngx_list_part_t = @import("std").mem.zeroes(ngx_list_part_t),
    size: usize = @import("std").mem.zeroes(usize),
    nalloc: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
};
pub extern fn ngx_list_create(pool: [*c]ngx_pool_t, n: ngx_uint_t, size: usize) [*c]ngx_list_t;
pub fn ngx_list_init(arg_list: [*c]ngx_list_t, arg_pool: [*c]ngx_pool_t, arg_n: ngx_uint_t, arg_size: usize) callconv(.c) ngx_int_t {
    var list = arg_list;
    _ = &list;
    var pool = arg_pool;
    _ = &pool;
    var n = arg_n;
    _ = &n;
    var size = arg_size;
    _ = &size;
    list.*.part.elts = ngx_palloc(pool, n *% size);
    if (list.*.part.elts == @as(?*anyopaque, @ptrFromInt(@as(c_int, 0)))) {
        return @as(ngx_int_t, @bitCast(@as(c_long, -@as(c_int, 1))));
    }
    list.*.part.nelts = 0;
    list.*.part.next = null;
    list.*.last = &list.*.part;
    list.*.size = size;
    list.*.nalloc = n;
    list.*.pool = pool;
    return 0;
}
pub extern fn ngx_list_push(list: [*c]ngx_list_t) ?*anyopaque;
pub const ngx_hash_elt_t = extern struct {
    value: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    len: u_short = @import("std").mem.zeroes(u_short),
    name: [1]u_char = @import("std").mem.zeroes([1]u_char),
};
pub const ngx_hash_t = extern struct {
    buckets: [*c][*c]ngx_hash_elt_t = @import("std").mem.zeroes([*c][*c]ngx_hash_elt_t),
    size: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_hash_wildcard_t = extern struct {
    hash: ngx_hash_t = @import("std").mem.zeroes(ngx_hash_t),
    value: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const ngx_hash_key_t = extern struct {
    key: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    key_hash: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    value: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const ngx_hash_key_pt = ?*const fn ([*c]u_char, usize) callconv(.c) ngx_uint_t;
pub const ngx_hash_combined_t = extern struct {
    hash: ngx_hash_t = @import("std").mem.zeroes(ngx_hash_t),
    wc_head: [*c]ngx_hash_wildcard_t = @import("std").mem.zeroes([*c]ngx_hash_wildcard_t),
    wc_tail: [*c]ngx_hash_wildcard_t = @import("std").mem.zeroes([*c]ngx_hash_wildcard_t),
};
pub const ngx_hash_init_t = extern struct {
    hash: [*c]ngx_hash_t = @import("std").mem.zeroes([*c]ngx_hash_t),
    key: ngx_hash_key_pt = @import("std").mem.zeroes(ngx_hash_key_pt),
    max_size: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    bucket_size: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    temp_pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
};
pub const ngx_hash_keys_arrays_t = extern struct {
    hsize: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    temp_pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    keys: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    keys_hash: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    dns_wc_head: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    dns_wc_head_hash: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    dns_wc_tail: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    dns_wc_tail_hash: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
};
pub const ngx_table_elt_t = struct_ngx_table_elt_s;
pub const struct_ngx_table_elt_s = extern struct {
    hash: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    key: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    value: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    lowcase_key: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    next: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
};
pub extern fn ngx_hash_find(hash: [*c]ngx_hash_t, key: ngx_uint_t, name: [*c]u_char, len: usize) ?*anyopaque;
pub extern fn ngx_hash_find_wc_head(hwc: [*c]ngx_hash_wildcard_t, name: [*c]u_char, len: usize) ?*anyopaque;
pub extern fn ngx_hash_find_wc_tail(hwc: [*c]ngx_hash_wildcard_t, name: [*c]u_char, len: usize) ?*anyopaque;
pub extern fn ngx_hash_find_combined(hash: [*c]ngx_hash_combined_t, key: ngx_uint_t, name: [*c]u_char, len: usize) ?*anyopaque;
pub extern fn ngx_hash_init(hinit: [*c]ngx_hash_init_t, names: [*c]ngx_hash_key_t, nelts: ngx_uint_t) ngx_int_t;
pub extern fn ngx_hash_wildcard_init(hinit: [*c]ngx_hash_init_t, names: [*c]ngx_hash_key_t, nelts: ngx_uint_t) ngx_int_t;
pub extern fn ngx_hash_key(data: [*c]u_char, len: usize) ngx_uint_t;
pub extern fn ngx_hash_key_lc(data: [*c]u_char, len: usize) ngx_uint_t;
pub extern fn ngx_hash_strlow(dst: [*c]u_char, src: [*c]u_char, n: usize) ngx_uint_t;
pub extern fn ngx_hash_keys_array_init(ha: [*c]ngx_hash_keys_arrays_t, @"type": ngx_uint_t) ngx_int_t;
pub extern fn ngx_hash_add_key(ha: [*c]ngx_hash_keys_arrays_t, key: [*c]ngx_str_t, value: ?*anyopaque, flags: ngx_uint_t) ngx_int_t;
pub const ngx_path_manager_pt = ?*const fn (?*anyopaque) callconv(.c) ngx_msec_t;
pub const ngx_path_purger_pt = ?*const fn (?*anyopaque) callconv(.c) ngx_msec_t;
pub const ngx_path_loader_pt = ?*const fn (?*anyopaque) callconv(.c) void;
pub const ngx_path_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    len: usize = @import("std").mem.zeroes(usize),
    level: [3]usize = @import("std").mem.zeroes([3]usize),
    manager: ngx_path_manager_pt = @import("std").mem.zeroes(ngx_path_manager_pt),
    purger: ngx_path_purger_pt = @import("std").mem.zeroes(ngx_path_purger_pt),
    loader: ngx_path_loader_pt = @import("std").mem.zeroes(ngx_path_loader_pt),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    conf_file: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    line: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_path_init_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    level: [3]usize = @import("std").mem.zeroes([3]usize),
};
const ngx_temp_file_flags_t = packed struct {
    log_level: u8,
    persistent: bool,
    clean: bool,
    thread_write: bool,
    padding: u21,
};
pub const ngx_temp_file_t = extern struct {
    file: ngx_file_t = @import("std").mem.zeroes(ngx_file_t),
    offset: off_t = @import("std").mem.zeroes(off_t),
    path: [*c]ngx_path_t = @import("std").mem.zeroes([*c]ngx_path_t),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    warn: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    access: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    flags: ngx_temp_file_flags_t = @import("std").mem.zeroes(ngx_temp_file_flags_t),
};
const ngx_ext_rename_file_flags_t = packed struct {
    create_path: bool,
    delete_file: bool,
    padding: u30,
};
pub const ngx_ext_rename_file_t = extern struct {
    access: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    path_access: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    time: time_t = @import("std").mem.zeroes(time_t),
    fd: ngx_fd_t = @import("std").mem.zeroes(ngx_fd_t),
    flags: ngx_ext_rename_file_flags_t = @import("std").mem.zeroes(ngx_ext_rename_file_flags_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
};
pub const ngx_copy_file_t = extern struct {
    size: off_t = @import("std").mem.zeroes(off_t),
    buf_size: usize = @import("std").mem.zeroes(usize),
    access: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    time: time_t = @import("std").mem.zeroes(time_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
};
pub const ngx_tree_init_handler_pt = ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) ngx_int_t;
pub const ngx_tree_ctx_t = struct_ngx_tree_ctx_s;
pub const ngx_tree_handler_pt = ?*const fn ([*c]ngx_tree_ctx_t, [*c]ngx_str_t) callconv(.c) ngx_int_t;
pub const struct_ngx_tree_ctx_s = extern struct {
    size: off_t = @import("std").mem.zeroes(off_t),
    fs_size: off_t = @import("std").mem.zeroes(off_t),
    access: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    mtime: time_t = @import("std").mem.zeroes(time_t),
    init_handler: ngx_tree_init_handler_pt = @import("std").mem.zeroes(ngx_tree_init_handler_pt),
    file_handler: ngx_tree_handler_pt = @import("std").mem.zeroes(ngx_tree_handler_pt),
    pre_tree_handler: ngx_tree_handler_pt = @import("std").mem.zeroes(ngx_tree_handler_pt),
    post_tree_handler: ngx_tree_handler_pt = @import("std").mem.zeroes(ngx_tree_handler_pt),
    spec_handler: ngx_tree_handler_pt = @import("std").mem.zeroes(ngx_tree_handler_pt),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    alloc: usize = @import("std").mem.zeroes(usize),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
};
pub extern fn ngx_get_full_name(pool: [*c]ngx_pool_t, prefix: [*c]ngx_str_t, name: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_write_chain_to_temp_file(tf: [*c]ngx_temp_file_t, chain: [*c]ngx_chain_t) isize;
pub extern fn ngx_create_temp_file(file: [*c]ngx_file_t, path: [*c]ngx_path_t, pool: [*c]ngx_pool_t, persistent: ngx_uint_t, clean: ngx_uint_t, access: ngx_uint_t) ngx_int_t;
pub extern fn ngx_create_hashed_filename(path: [*c]ngx_path_t, file: [*c]u_char, len: usize) void;
pub extern fn ngx_create_path(file: [*c]ngx_file_t, path: [*c]ngx_path_t) ngx_int_t;
pub extern fn ngx_create_full_path(dir: [*c]u_char, access: ngx_uint_t) ngx_err_t;
pub extern fn ngx_add_path(cf: [*c]ngx_conf_t, slot: [*c][*c]ngx_path_t) ngx_int_t;
pub extern fn ngx_create_paths(cycle: [*c]ngx_cycle_t, user: ngx_uid_t) ngx_int_t;
pub extern fn ngx_ext_rename_file(src: [*c]ngx_str_t, to: [*c]ngx_str_t, ext: [*c]ngx_ext_rename_file_t) ngx_int_t;
pub extern fn ngx_copy_file(from: [*c]u_char, to: [*c]u_char, cf: [*c]ngx_copy_file_t) ngx_int_t;
pub extern fn ngx_walk_tree(ctx: [*c]ngx_tree_ctx_t, tree: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_next_temp_number(collision: ngx_uint_t) ngx_atomic_uint_t;
pub extern fn ngx_conf_set_path_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_merge_path_value(cf: [*c]ngx_conf_t, path: [*c][*c]ngx_path_t, prev: [*c]ngx_path_t, init: [*c]ngx_path_init_t) [*c]u8;
pub extern fn ngx_conf_set_access_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern var ngx_temp_number: [*c]volatile ngx_atomic_t;
pub extern var ngx_random_number: ngx_atomic_int_t;
pub fn ngx_crc(arg_data: [*c]u_char, arg_len: usize) callconv(.c) u32 {
    var data = arg_data;
    _ = &data;
    var len = arg_len;
    _ = &len;
    var sum: u32 = undefined;
    _ = &sum;
    {
        sum = 0;
        while (len != 0) : (len -%= 1) {
            sum = (sum >> @intCast(1)) | (sum << @intCast(31));
            sum +%= @as(u32, @bitCast(@as(c_uint, (blk: {
                const ref = &data;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).*)));
        }
    }
    return sum;
}
pub extern var ngx_crc32_table_short: [*c]u32;
pub const ngx_crc32_table256: [*c]u32 = @extern([*c]u32, .{
    .name = "ngx_crc32_table256",
});
pub fn ngx_crc32_short(arg_p: [*c]u_char, arg_len: usize) callconv(.c) u32 {
    var p = arg_p;
    _ = &p;
    var len = arg_len;
    _ = &len;
    var c: u_char = undefined;
    _ = &c;
    var crc: u32 = undefined;
    _ = &crc;
    crc = 4294967295;
    while ((blk: {
        const ref = &len;
        const tmp = ref.*;
        ref.* -%= 1;
        break :blk tmp;
    }) != 0) {
        c = (blk: {
            const ref = &p;
            const tmp = ref.*;
            ref.* += 1;
            break :blk tmp;
        }).*;
        crc = ngx_crc32_table_short[(crc ^ @as(u32, @bitCast(@as(c_int, @bitCast(@as(c_uint, c))) & @as(c_int, 15)))) & @as(u32, @bitCast(@as(c_int, 15)))] ^ (crc >> @intCast(4));
        crc = ngx_crc32_table_short[(crc ^ @as(u32, @bitCast(@as(c_int, @bitCast(@as(c_uint, c))) >> @intCast(4)))) & @as(u32, @bitCast(@as(c_int, 15)))] ^ (crc >> @intCast(4));
    }
    return crc ^ @as(c_uint, 4294967295);
}
pub fn ngx_crc32_long(arg_p: [*c]u_char, arg_len: usize) callconv(.c) u32 {
    var p = arg_p;
    _ = &p;
    var len = arg_len;
    _ = &len;
    var crc: u32 = undefined;
    _ = &crc;
    crc = 4294967295;
    while ((blk: {
        const ref = &len;
        const tmp = ref.*;
        ref.* -%= 1;
        break :blk tmp;
    }) != 0) {
        crc = ngx_crc32_table256[
            (crc ^ @as(u32, @bitCast(@as(c_uint, (blk: {
                const ref = &p;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).*)))) & @as(u32, @bitCast(@as(c_int, 255)))
        ] ^ (crc >> @intCast(8));
    }
    return crc ^ @as(c_uint, 4294967295);
}
pub fn ngx_crc32_update(arg_crc: [*c]u32, arg_p: [*c]u_char, arg_len: usize) callconv(.c) void {
    var crc = arg_crc;
    _ = &crc;
    var p = arg_p;
    _ = &p;
    var len = arg_len;
    _ = &len;
    var c: u32 = undefined;
    _ = &c;
    c = crc.*;
    while ((blk: {
        const ref = &len;
        const tmp = ref.*;
        ref.* -%= 1;
        break :blk tmp;
    }) != 0) {
        c = ngx_crc32_table256[
            (c ^ @as(u32, @bitCast(@as(c_uint, (blk: {
                const ref = &p;
                const tmp = ref.*;
                ref.* += 1;
                break :blk tmp;
            }).*)))) & @as(u32, @bitCast(@as(c_int, 255)))
        ] ^ (c >> @intCast(8));
    }
    crc.* = c;
}
pub extern fn ngx_crc32_table_init() ngx_int_t;
pub extern fn ngx_murmur_hash2(data: [*c]u_char, len: usize) u32;
pub const __gwchar_t = c_int;
pub const imaxdiv_t = extern struct {
    quot: c_long = @import("std").mem.zeroes(c_long),
    rem: c_long = @import("std").mem.zeroes(c_long),
};
pub extern fn imaxabs(__n: intmax_t) intmax_t;
pub extern fn imaxdiv(__numer: intmax_t, __denom: intmax_t) imaxdiv_t;
pub extern fn strtoimax(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) intmax_t;
pub extern fn strtoumax(noalias __nptr: [*c]const u8, noalias __endptr: [*c][*c]u8, __base: c_int) uintmax_t;
pub extern fn wcstoimax(noalias __nptr: [*c]const __gwchar_t, noalias __endptr: [*c][*c]__gwchar_t, __base: c_int) intmax_t;
pub extern fn wcstoumax(noalias __nptr: [*c]const __gwchar_t, noalias __endptr: [*c][*c]__gwchar_t, __base: c_int) uintmax_t;
pub const PCRE2_UCHAR8 = u8;
pub const PCRE2_UCHAR16 = u16;
pub const PCRE2_UCHAR32 = u32;
pub const PCRE2_SPTR8 = [*c]const PCRE2_UCHAR8;
pub const PCRE2_SPTR16 = [*c]const PCRE2_UCHAR16;
pub const PCRE2_SPTR32 = [*c]const PCRE2_UCHAR32;
pub const struct_pcre2_real_general_context_8 = opaque {};
pub const pcre2_general_context_8 = struct_pcre2_real_general_context_8;
pub const struct_pcre2_real_compile_context_8 = opaque {};
pub const pcre2_compile_context_8 = struct_pcre2_real_compile_context_8;
pub const struct_pcre2_real_match_context_8 = opaque {};
pub const pcre2_match_context_8 = struct_pcre2_real_match_context_8;
pub const struct_pcre2_real_convert_context_8 = opaque {};
pub const pcre2_convert_context_8 = struct_pcre2_real_convert_context_8;
pub const struct_pcre2_real_code_8 = opaque {};
pub const pcre2_code_8 = struct_pcre2_real_code_8;
pub const struct_pcre2_real_match_data_8 = opaque {};
pub const pcre2_match_data_8 = struct_pcre2_real_match_data_8;
pub const struct_pcre2_real_jit_stack_8 = opaque {};
pub const pcre2_jit_stack_8 = struct_pcre2_real_jit_stack_8;
pub const pcre2_jit_callback_8 = ?*const fn (?*anyopaque) callconv(.c) ?*pcre2_jit_stack_8;
pub const struct_pcre2_callout_block_8 = extern struct {
    version: u32 = @import("std").mem.zeroes(u32),
    callout_number: u32 = @import("std").mem.zeroes(u32),
    capture_top: u32 = @import("std").mem.zeroes(u32),
    capture_last: u32 = @import("std").mem.zeroes(u32),
    offset_vector: [*c]usize = @import("std").mem.zeroes([*c]usize),
    mark: PCRE2_SPTR8 = @import("std").mem.zeroes(PCRE2_SPTR8),
    subject: PCRE2_SPTR8 = @import("std").mem.zeroes(PCRE2_SPTR8),
    subject_length: usize = @import("std").mem.zeroes(usize),
    start_match: usize = @import("std").mem.zeroes(usize),
    current_position: usize = @import("std").mem.zeroes(usize),
    pattern_position: usize = @import("std").mem.zeroes(usize),
    next_item_length: usize = @import("std").mem.zeroes(usize),
    callout_string_offset: usize = @import("std").mem.zeroes(usize),
    callout_string_length: usize = @import("std").mem.zeroes(usize),
    callout_string: PCRE2_SPTR8 = @import("std").mem.zeroes(PCRE2_SPTR8),
    callout_flags: u32 = @import("std").mem.zeroes(u32),
};
pub const pcre2_callout_block_8 = struct_pcre2_callout_block_8;
pub const struct_pcre2_callout_enumerate_block_8 = extern struct {
    version: u32 = @import("std").mem.zeroes(u32),
    pattern_position: usize = @import("std").mem.zeroes(usize),
    next_item_length: usize = @import("std").mem.zeroes(usize),
    callout_number: u32 = @import("std").mem.zeroes(u32),
    callout_string_offset: usize = @import("std").mem.zeroes(usize),
    callout_string_length: usize = @import("std").mem.zeroes(usize),
    callout_string: PCRE2_SPTR8 = @import("std").mem.zeroes(PCRE2_SPTR8),
};
pub const pcre2_callout_enumerate_block_8 = struct_pcre2_callout_enumerate_block_8;
pub const struct_pcre2_substitute_callout_block_8 = extern struct {
    version: u32 = @import("std").mem.zeroes(u32),
    input: PCRE2_SPTR8 = @import("std").mem.zeroes(PCRE2_SPTR8),
    output: PCRE2_SPTR8 = @import("std").mem.zeroes(PCRE2_SPTR8),
    output_offsets: [2]usize = @import("std").mem.zeroes([2]usize),
    ovector: [*c]usize = @import("std").mem.zeroes([*c]usize),
    oveccount: u32 = @import("std").mem.zeroes(u32),
    subscount: u32 = @import("std").mem.zeroes(u32),
};
pub const pcre2_substitute_callout_block_8 = struct_pcre2_substitute_callout_block_8;
pub extern fn pcre2_config_8(u32, ?*anyopaque) c_int;
pub extern fn pcre2_general_context_copy_8(?*pcre2_general_context_8) ?*pcre2_general_context_8;
pub extern fn pcre2_general_context_create_8(?*const fn (usize, ?*anyopaque) callconv(.c) ?*anyopaque, ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) void, ?*anyopaque) ?*pcre2_general_context_8;
pub extern fn pcre2_general_context_free_8(?*pcre2_general_context_8) void;
pub extern fn pcre2_compile_context_copy_8(?*pcre2_compile_context_8) ?*pcre2_compile_context_8;
pub extern fn pcre2_compile_context_create_8(?*pcre2_general_context_8) ?*pcre2_compile_context_8;
pub extern fn pcre2_compile_context_free_8(?*pcre2_compile_context_8) void;
pub extern fn pcre2_set_bsr_8(?*pcre2_compile_context_8, u32) c_int;
pub extern fn pcre2_set_character_tables_8(?*pcre2_compile_context_8, [*c]const u8) c_int;
pub extern fn pcre2_set_compile_extra_options_8(?*pcre2_compile_context_8, u32) c_int;
pub extern fn pcre2_set_max_pattern_length_8(?*pcre2_compile_context_8, usize) c_int;
pub extern fn pcre2_set_max_pattern_compiled_length_8(?*pcre2_compile_context_8, usize) c_int;
pub extern fn pcre2_set_max_varlookbehind_8(?*pcre2_compile_context_8, u32) c_int;
pub extern fn pcre2_set_newline_8(?*pcre2_compile_context_8, u32) c_int;
pub extern fn pcre2_set_parens_nest_limit_8(?*pcre2_compile_context_8, u32) c_int;
pub extern fn pcre2_set_compile_recursion_guard_8(?*pcre2_compile_context_8, ?*const fn (u32, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_convert_context_copy_8(?*pcre2_convert_context_8) ?*pcre2_convert_context_8;
pub extern fn pcre2_convert_context_create_8(?*pcre2_general_context_8) ?*pcre2_convert_context_8;
pub extern fn pcre2_convert_context_free_8(?*pcre2_convert_context_8) void;
pub extern fn pcre2_set_glob_escape_8(?*pcre2_convert_context_8, u32) c_int;
pub extern fn pcre2_set_glob_separator_8(?*pcre2_convert_context_8, u32) c_int;
pub extern fn pcre2_pattern_convert_8(PCRE2_SPTR8, usize, u32, [*c][*c]PCRE2_UCHAR8, [*c]usize, ?*pcre2_convert_context_8) c_int;
pub extern fn pcre2_converted_pattern_free_8([*c]PCRE2_UCHAR8) void;
pub extern fn pcre2_match_context_copy_8(?*pcre2_match_context_8) ?*pcre2_match_context_8;
pub extern fn pcre2_match_context_create_8(?*pcre2_general_context_8) ?*pcre2_match_context_8;
pub extern fn pcre2_match_context_free_8(?*pcre2_match_context_8) void;
pub extern fn pcre2_set_callout_8(?*pcre2_match_context_8, ?*const fn ([*c]pcre2_callout_block_8, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_set_substitute_callout_8(?*pcre2_match_context_8, ?*const fn ([*c]pcre2_substitute_callout_block_8, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_set_depth_limit_8(?*pcre2_match_context_8, u32) c_int;
pub extern fn pcre2_set_heap_limit_8(?*pcre2_match_context_8, u32) c_int;
pub extern fn pcre2_set_match_limit_8(?*pcre2_match_context_8, u32) c_int;
pub extern fn pcre2_set_offset_limit_8(?*pcre2_match_context_8, usize) c_int;
pub extern fn pcre2_set_recursion_limit_8(?*pcre2_match_context_8, u32) c_int;
pub extern fn pcre2_set_recursion_memory_management_8(?*pcre2_match_context_8, ?*const fn (usize, ?*anyopaque) callconv(.c) ?*anyopaque, ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) void, ?*anyopaque) c_int;
pub extern fn pcre2_compile_8(PCRE2_SPTR8, usize, u32, [*c]c_int, [*c]usize, ?*pcre2_compile_context_8) ?*pcre2_code_8;
pub extern fn pcre2_code_free_8(?*pcre2_code_8) void;
pub extern fn pcre2_code_copy_8(?*const pcre2_code_8) ?*pcre2_code_8;
pub extern fn pcre2_code_copy_with_tables_8(?*const pcre2_code_8) ?*pcre2_code_8;
pub extern fn pcre2_pattern_info_8(?*const pcre2_code_8, u32, ?*anyopaque) c_int;
pub extern fn pcre2_callout_enumerate_8(?*const pcre2_code_8, ?*const fn ([*c]pcre2_callout_enumerate_block_8, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_match_data_create_8(u32, ?*pcre2_general_context_8) ?*pcre2_match_data_8;
pub extern fn pcre2_match_data_create_from_pattern_8(?*const pcre2_code_8, ?*pcre2_general_context_8) ?*pcre2_match_data_8;
pub extern fn pcre2_dfa_match_8(?*const pcre2_code_8, PCRE2_SPTR8, usize, usize, u32, ?*pcre2_match_data_8, ?*pcre2_match_context_8, [*c]c_int, usize) c_int;
pub extern fn pcre2_match_8(?*const pcre2_code_8, PCRE2_SPTR8, usize, usize, u32, ?*pcre2_match_data_8, ?*pcre2_match_context_8) c_int;
pub extern fn pcre2_match_data_free_8(?*pcre2_match_data_8) void;
pub extern fn pcre2_get_mark_8(?*pcre2_match_data_8) PCRE2_SPTR8;
pub extern fn pcre2_get_match_data_size_8(?*pcre2_match_data_8) usize;
pub extern fn pcre2_get_match_data_heapframes_size_8(?*pcre2_match_data_8) usize;
pub extern fn pcre2_get_ovector_count_8(?*pcre2_match_data_8) u32;
pub extern fn pcre2_get_ovector_pointer_8(?*pcre2_match_data_8) [*c]usize;
pub extern fn pcre2_get_startchar_8(?*pcre2_match_data_8) usize;
pub extern fn pcre2_substring_copy_byname_8(?*pcre2_match_data_8, PCRE2_SPTR8, [*c]PCRE2_UCHAR8, [*c]usize) c_int;
pub extern fn pcre2_substring_copy_bynumber_8(?*pcre2_match_data_8, u32, [*c]PCRE2_UCHAR8, [*c]usize) c_int;
pub extern fn pcre2_substring_free_8([*c]PCRE2_UCHAR8) void;
pub extern fn pcre2_substring_get_byname_8(?*pcre2_match_data_8, PCRE2_SPTR8, [*c][*c]PCRE2_UCHAR8, [*c]usize) c_int;
pub extern fn pcre2_substring_get_bynumber_8(?*pcre2_match_data_8, u32, [*c][*c]PCRE2_UCHAR8, [*c]usize) c_int;
pub extern fn pcre2_substring_length_byname_8(?*pcre2_match_data_8, PCRE2_SPTR8, [*c]usize) c_int;
pub extern fn pcre2_substring_length_bynumber_8(?*pcre2_match_data_8, u32, [*c]usize) c_int;
pub extern fn pcre2_substring_nametable_scan_8(?*const pcre2_code_8, PCRE2_SPTR8, [*c]PCRE2_SPTR8, [*c]PCRE2_SPTR8) c_int;
pub extern fn pcre2_substring_number_from_name_8(?*const pcre2_code_8, PCRE2_SPTR8) c_int;
pub extern fn pcre2_substring_list_free_8([*c][*c]PCRE2_UCHAR8) void;
pub extern fn pcre2_substring_list_get_8(?*pcre2_match_data_8, [*c][*c][*c]PCRE2_UCHAR8, [*c][*c]usize) c_int;
pub extern fn pcre2_serialize_encode_8([*c]?*const pcre2_code_8, i32, [*c][*c]u8, [*c]usize, ?*pcre2_general_context_8) i32;
pub extern fn pcre2_serialize_decode_8([*c]?*pcre2_code_8, i32, [*c]const u8, ?*pcre2_general_context_8) i32;
pub extern fn pcre2_serialize_get_number_of_codes_8([*c]const u8) i32;
pub extern fn pcre2_serialize_free_8([*c]u8) void;
pub extern fn pcre2_substitute_8(?*const pcre2_code_8, PCRE2_SPTR8, usize, usize, u32, ?*pcre2_match_data_8, ?*pcre2_match_context_8, PCRE2_SPTR8, usize, [*c]PCRE2_UCHAR8, [*c]usize) c_int;
pub extern fn pcre2_jit_compile_8(?*pcre2_code_8, u32) c_int;
pub extern fn pcre2_jit_match_8(?*const pcre2_code_8, PCRE2_SPTR8, usize, usize, u32, ?*pcre2_match_data_8, ?*pcre2_match_context_8) c_int;
pub extern fn pcre2_jit_free_unused_memory_8(?*pcre2_general_context_8) void;
pub extern fn pcre2_jit_stack_create_8(usize, usize, ?*pcre2_general_context_8) ?*pcre2_jit_stack_8;
pub extern fn pcre2_jit_stack_assign_8(?*pcre2_match_context_8, pcre2_jit_callback_8, ?*anyopaque) void;
pub extern fn pcre2_jit_stack_free_8(?*pcre2_jit_stack_8) void;
pub extern fn pcre2_get_error_message_8(c_int, [*c]PCRE2_UCHAR8, usize) c_int;
pub extern fn pcre2_maketables_8(?*pcre2_general_context_8) [*c]const u8;
pub extern fn pcre2_maketables_free_8(?*pcre2_general_context_8, [*c]const u8) void;
pub const struct_pcre2_real_general_context_16 = opaque {};
pub const pcre2_general_context_16 = struct_pcre2_real_general_context_16;
pub const struct_pcre2_real_compile_context_16 = opaque {};
pub const pcre2_compile_context_16 = struct_pcre2_real_compile_context_16;
pub const struct_pcre2_real_match_context_16 = opaque {};
pub const pcre2_match_context_16 = struct_pcre2_real_match_context_16;
pub const struct_pcre2_real_convert_context_16 = opaque {};
pub const pcre2_convert_context_16 = struct_pcre2_real_convert_context_16;
pub const struct_pcre2_real_code_16 = opaque {};
pub const pcre2_code_16 = struct_pcre2_real_code_16;
pub const struct_pcre2_real_match_data_16 = opaque {};
pub const pcre2_match_data_16 = struct_pcre2_real_match_data_16;
pub const struct_pcre2_real_jit_stack_16 = opaque {};
pub const pcre2_jit_stack_16 = struct_pcre2_real_jit_stack_16;
pub const pcre2_jit_callback_16 = ?*const fn (?*anyopaque) callconv(.c) ?*pcre2_jit_stack_16;
pub const struct_pcre2_callout_block_16 = extern struct {
    version: u32 = @import("std").mem.zeroes(u32),
    callout_number: u32 = @import("std").mem.zeroes(u32),
    capture_top: u32 = @import("std").mem.zeroes(u32),
    capture_last: u32 = @import("std").mem.zeroes(u32),
    offset_vector: [*c]usize = @import("std").mem.zeroes([*c]usize),
    mark: PCRE2_SPTR16 = @import("std").mem.zeroes(PCRE2_SPTR16),
    subject: PCRE2_SPTR16 = @import("std").mem.zeroes(PCRE2_SPTR16),
    subject_length: usize = @import("std").mem.zeroes(usize),
    start_match: usize = @import("std").mem.zeroes(usize),
    current_position: usize = @import("std").mem.zeroes(usize),
    pattern_position: usize = @import("std").mem.zeroes(usize),
    next_item_length: usize = @import("std").mem.zeroes(usize),
    callout_string_offset: usize = @import("std").mem.zeroes(usize),
    callout_string_length: usize = @import("std").mem.zeroes(usize),
    callout_string: PCRE2_SPTR16 = @import("std").mem.zeroes(PCRE2_SPTR16),
    callout_flags: u32 = @import("std").mem.zeroes(u32),
};
pub const pcre2_callout_block_16 = struct_pcre2_callout_block_16;
pub const struct_pcre2_callout_enumerate_block_16 = extern struct {
    version: u32 = @import("std").mem.zeroes(u32),
    pattern_position: usize = @import("std").mem.zeroes(usize),
    next_item_length: usize = @import("std").mem.zeroes(usize),
    callout_number: u32 = @import("std").mem.zeroes(u32),
    callout_string_offset: usize = @import("std").mem.zeroes(usize),
    callout_string_length: usize = @import("std").mem.zeroes(usize),
    callout_string: PCRE2_SPTR16 = @import("std").mem.zeroes(PCRE2_SPTR16),
};
pub const pcre2_callout_enumerate_block_16 = struct_pcre2_callout_enumerate_block_16;
pub const struct_pcre2_substitute_callout_block_16 = extern struct {
    version: u32 = @import("std").mem.zeroes(u32),
    input: PCRE2_SPTR16 = @import("std").mem.zeroes(PCRE2_SPTR16),
    output: PCRE2_SPTR16 = @import("std").mem.zeroes(PCRE2_SPTR16),
    output_offsets: [2]usize = @import("std").mem.zeroes([2]usize),
    ovector: [*c]usize = @import("std").mem.zeroes([*c]usize),
    oveccount: u32 = @import("std").mem.zeroes(u32),
    subscount: u32 = @import("std").mem.zeroes(u32),
};
pub const pcre2_substitute_callout_block_16 = struct_pcre2_substitute_callout_block_16;
pub extern fn pcre2_config_16(u32, ?*anyopaque) c_int;
pub extern fn pcre2_general_context_copy_16(?*pcre2_general_context_16) ?*pcre2_general_context_16;
pub extern fn pcre2_general_context_create_16(?*const fn (usize, ?*anyopaque) callconv(.c) ?*anyopaque, ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) void, ?*anyopaque) ?*pcre2_general_context_16;
pub extern fn pcre2_general_context_free_16(?*pcre2_general_context_16) void;
pub extern fn pcre2_compile_context_copy_16(?*pcre2_compile_context_16) ?*pcre2_compile_context_16;
pub extern fn pcre2_compile_context_create_16(?*pcre2_general_context_16) ?*pcre2_compile_context_16;
pub extern fn pcre2_compile_context_free_16(?*pcre2_compile_context_16) void;
pub extern fn pcre2_set_bsr_16(?*pcre2_compile_context_16, u32) c_int;
pub extern fn pcre2_set_character_tables_16(?*pcre2_compile_context_16, [*c]const u8) c_int;
pub extern fn pcre2_set_compile_extra_options_16(?*pcre2_compile_context_16, u32) c_int;
pub extern fn pcre2_set_max_pattern_length_16(?*pcre2_compile_context_16, usize) c_int;
pub extern fn pcre2_set_max_pattern_compiled_length_16(?*pcre2_compile_context_16, usize) c_int;
pub extern fn pcre2_set_max_varlookbehind_16(?*pcre2_compile_context_16, u32) c_int;
pub extern fn pcre2_set_newline_16(?*pcre2_compile_context_16, u32) c_int;
pub extern fn pcre2_set_parens_nest_limit_16(?*pcre2_compile_context_16, u32) c_int;
pub extern fn pcre2_set_compile_recursion_guard_16(?*pcre2_compile_context_16, ?*const fn (u32, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_convert_context_copy_16(?*pcre2_convert_context_16) ?*pcre2_convert_context_16;
pub extern fn pcre2_convert_context_create_16(?*pcre2_general_context_16) ?*pcre2_convert_context_16;
pub extern fn pcre2_convert_context_free_16(?*pcre2_convert_context_16) void;
pub extern fn pcre2_set_glob_escape_16(?*pcre2_convert_context_16, u32) c_int;
pub extern fn pcre2_set_glob_separator_16(?*pcre2_convert_context_16, u32) c_int;
pub extern fn pcre2_pattern_convert_16(PCRE2_SPTR16, usize, u32, [*c][*c]PCRE2_UCHAR16, [*c]usize, ?*pcre2_convert_context_16) c_int;
pub extern fn pcre2_converted_pattern_free_16([*c]PCRE2_UCHAR16) void;
pub extern fn pcre2_match_context_copy_16(?*pcre2_match_context_16) ?*pcre2_match_context_16;
pub extern fn pcre2_match_context_create_16(?*pcre2_general_context_16) ?*pcre2_match_context_16;
pub extern fn pcre2_match_context_free_16(?*pcre2_match_context_16) void;
pub extern fn pcre2_set_callout_16(?*pcre2_match_context_16, ?*const fn ([*c]pcre2_callout_block_16, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_set_substitute_callout_16(?*pcre2_match_context_16, ?*const fn ([*c]pcre2_substitute_callout_block_16, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_set_depth_limit_16(?*pcre2_match_context_16, u32) c_int;
pub extern fn pcre2_set_heap_limit_16(?*pcre2_match_context_16, u32) c_int;
pub extern fn pcre2_set_match_limit_16(?*pcre2_match_context_16, u32) c_int;
pub extern fn pcre2_set_offset_limit_16(?*pcre2_match_context_16, usize) c_int;
pub extern fn pcre2_set_recursion_limit_16(?*pcre2_match_context_16, u32) c_int;
pub extern fn pcre2_set_recursion_memory_management_16(?*pcre2_match_context_16, ?*const fn (usize, ?*anyopaque) callconv(.c) ?*anyopaque, ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) void, ?*anyopaque) c_int;
pub extern fn pcre2_compile_16(PCRE2_SPTR16, usize, u32, [*c]c_int, [*c]usize, ?*pcre2_compile_context_16) ?*pcre2_code_16;
pub extern fn pcre2_code_free_16(?*pcre2_code_16) void;
pub extern fn pcre2_code_copy_16(?*const pcre2_code_16) ?*pcre2_code_16;
pub extern fn pcre2_code_copy_with_tables_16(?*const pcre2_code_16) ?*pcre2_code_16;
pub extern fn pcre2_pattern_info_16(?*const pcre2_code_16, u32, ?*anyopaque) c_int;
pub extern fn pcre2_callout_enumerate_16(?*const pcre2_code_16, ?*const fn ([*c]pcre2_callout_enumerate_block_16, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_match_data_create_16(u32, ?*pcre2_general_context_16) ?*pcre2_match_data_16;
pub extern fn pcre2_match_data_create_from_pattern_16(?*const pcre2_code_16, ?*pcre2_general_context_16) ?*pcre2_match_data_16;
pub extern fn pcre2_dfa_match_16(?*const pcre2_code_16, PCRE2_SPTR16, usize, usize, u32, ?*pcre2_match_data_16, ?*pcre2_match_context_16, [*c]c_int, usize) c_int;
pub extern fn pcre2_match_16(?*const pcre2_code_16, PCRE2_SPTR16, usize, usize, u32, ?*pcre2_match_data_16, ?*pcre2_match_context_16) c_int;
pub extern fn pcre2_match_data_free_16(?*pcre2_match_data_16) void;
pub extern fn pcre2_get_mark_16(?*pcre2_match_data_16) PCRE2_SPTR16;
pub extern fn pcre2_get_match_data_size_16(?*pcre2_match_data_16) usize;
pub extern fn pcre2_get_match_data_heapframes_size_16(?*pcre2_match_data_16) usize;
pub extern fn pcre2_get_ovector_count_16(?*pcre2_match_data_16) u32;
pub extern fn pcre2_get_ovector_pointer_16(?*pcre2_match_data_16) [*c]usize;
pub extern fn pcre2_get_startchar_16(?*pcre2_match_data_16) usize;
pub extern fn pcre2_substring_copy_byname_16(?*pcre2_match_data_16, PCRE2_SPTR16, [*c]PCRE2_UCHAR16, [*c]usize) c_int;
pub extern fn pcre2_substring_copy_bynumber_16(?*pcre2_match_data_16, u32, [*c]PCRE2_UCHAR16, [*c]usize) c_int;
pub extern fn pcre2_substring_free_16([*c]PCRE2_UCHAR16) void;
pub extern fn pcre2_substring_get_byname_16(?*pcre2_match_data_16, PCRE2_SPTR16, [*c][*c]PCRE2_UCHAR16, [*c]usize) c_int;
pub extern fn pcre2_substring_get_bynumber_16(?*pcre2_match_data_16, u32, [*c][*c]PCRE2_UCHAR16, [*c]usize) c_int;
pub extern fn pcre2_substring_length_byname_16(?*pcre2_match_data_16, PCRE2_SPTR16, [*c]usize) c_int;
pub extern fn pcre2_substring_length_bynumber_16(?*pcre2_match_data_16, u32, [*c]usize) c_int;
pub extern fn pcre2_substring_nametable_scan_16(?*const pcre2_code_16, PCRE2_SPTR16, [*c]PCRE2_SPTR16, [*c]PCRE2_SPTR16) c_int;
pub extern fn pcre2_substring_number_from_name_16(?*const pcre2_code_16, PCRE2_SPTR16) c_int;
pub extern fn pcre2_substring_list_free_16([*c][*c]PCRE2_UCHAR16) void;
pub extern fn pcre2_substring_list_get_16(?*pcre2_match_data_16, [*c][*c][*c]PCRE2_UCHAR16, [*c][*c]usize) c_int;
pub extern fn pcre2_serialize_encode_16([*c]?*const pcre2_code_16, i32, [*c][*c]u8, [*c]usize, ?*pcre2_general_context_16) i32;
pub extern fn pcre2_serialize_decode_16([*c]?*pcre2_code_16, i32, [*c]const u8, ?*pcre2_general_context_16) i32;
pub extern fn pcre2_serialize_get_number_of_codes_16([*c]const u8) i32;
pub extern fn pcre2_serialize_free_16([*c]u8) void;
pub extern fn pcre2_substitute_16(?*const pcre2_code_16, PCRE2_SPTR16, usize, usize, u32, ?*pcre2_match_data_16, ?*pcre2_match_context_16, PCRE2_SPTR16, usize, [*c]PCRE2_UCHAR16, [*c]usize) c_int;
pub extern fn pcre2_jit_compile_16(?*pcre2_code_16, u32) c_int;
pub extern fn pcre2_jit_match_16(?*const pcre2_code_16, PCRE2_SPTR16, usize, usize, u32, ?*pcre2_match_data_16, ?*pcre2_match_context_16) c_int;
pub extern fn pcre2_jit_free_unused_memory_16(?*pcre2_general_context_16) void;
pub extern fn pcre2_jit_stack_create_16(usize, usize, ?*pcre2_general_context_16) ?*pcre2_jit_stack_16;
pub extern fn pcre2_jit_stack_assign_16(?*pcre2_match_context_16, pcre2_jit_callback_16, ?*anyopaque) void;
pub extern fn pcre2_jit_stack_free_16(?*pcre2_jit_stack_16) void;
pub extern fn pcre2_get_error_message_16(c_int, [*c]PCRE2_UCHAR16, usize) c_int;
pub extern fn pcre2_maketables_16(?*pcre2_general_context_16) [*c]const u8;
pub extern fn pcre2_maketables_free_16(?*pcre2_general_context_16, [*c]const u8) void;
pub const struct_pcre2_real_general_context_32 = opaque {};
pub const pcre2_general_context_32 = struct_pcre2_real_general_context_32;
pub const struct_pcre2_real_compile_context_32 = opaque {};
pub const pcre2_compile_context_32 = struct_pcre2_real_compile_context_32;
pub const struct_pcre2_real_match_context_32 = opaque {};
pub const pcre2_match_context_32 = struct_pcre2_real_match_context_32;
pub const struct_pcre2_real_convert_context_32 = opaque {};
pub const pcre2_convert_context_32 = struct_pcre2_real_convert_context_32;
pub const struct_pcre2_real_code_32 = opaque {};
pub const pcre2_code_32 = struct_pcre2_real_code_32;
pub const struct_pcre2_real_match_data_32 = opaque {};
pub const pcre2_match_data_32 = struct_pcre2_real_match_data_32;
pub const struct_pcre2_real_jit_stack_32 = opaque {};
pub const pcre2_jit_stack_32 = struct_pcre2_real_jit_stack_32;
pub const pcre2_jit_callback_32 = ?*const fn (?*anyopaque) callconv(.c) ?*pcre2_jit_stack_32;
pub const struct_pcre2_callout_block_32 = extern struct {
    version: u32 = @import("std").mem.zeroes(u32),
    callout_number: u32 = @import("std").mem.zeroes(u32),
    capture_top: u32 = @import("std").mem.zeroes(u32),
    capture_last: u32 = @import("std").mem.zeroes(u32),
    offset_vector: [*c]usize = @import("std").mem.zeroes([*c]usize),
    mark: PCRE2_SPTR32 = @import("std").mem.zeroes(PCRE2_SPTR32),
    subject: PCRE2_SPTR32 = @import("std").mem.zeroes(PCRE2_SPTR32),
    subject_length: usize = @import("std").mem.zeroes(usize),
    start_match: usize = @import("std").mem.zeroes(usize),
    current_position: usize = @import("std").mem.zeroes(usize),
    pattern_position: usize = @import("std").mem.zeroes(usize),
    next_item_length: usize = @import("std").mem.zeroes(usize),
    callout_string_offset: usize = @import("std").mem.zeroes(usize),
    callout_string_length: usize = @import("std").mem.zeroes(usize),
    callout_string: PCRE2_SPTR32 = @import("std").mem.zeroes(PCRE2_SPTR32),
    callout_flags: u32 = @import("std").mem.zeroes(u32),
};
pub const pcre2_callout_block_32 = struct_pcre2_callout_block_32;
pub const struct_pcre2_callout_enumerate_block_32 = extern struct {
    version: u32 = @import("std").mem.zeroes(u32),
    pattern_position: usize = @import("std").mem.zeroes(usize),
    next_item_length: usize = @import("std").mem.zeroes(usize),
    callout_number: u32 = @import("std").mem.zeroes(u32),
    callout_string_offset: usize = @import("std").mem.zeroes(usize),
    callout_string_length: usize = @import("std").mem.zeroes(usize),
    callout_string: PCRE2_SPTR32 = @import("std").mem.zeroes(PCRE2_SPTR32),
};
pub const pcre2_callout_enumerate_block_32 = struct_pcre2_callout_enumerate_block_32;
pub const struct_pcre2_substitute_callout_block_32 = extern struct {
    version: u32 = @import("std").mem.zeroes(u32),
    input: PCRE2_SPTR32 = @import("std").mem.zeroes(PCRE2_SPTR32),
    output: PCRE2_SPTR32 = @import("std").mem.zeroes(PCRE2_SPTR32),
    output_offsets: [2]usize = @import("std").mem.zeroes([2]usize),
    ovector: [*c]usize = @import("std").mem.zeroes([*c]usize),
    oveccount: u32 = @import("std").mem.zeroes(u32),
    subscount: u32 = @import("std").mem.zeroes(u32),
};
pub const pcre2_substitute_callout_block_32 = struct_pcre2_substitute_callout_block_32;
pub extern fn pcre2_config_32(u32, ?*anyopaque) c_int;
pub extern fn pcre2_general_context_copy_32(?*pcre2_general_context_32) ?*pcre2_general_context_32;
pub extern fn pcre2_general_context_create_32(?*const fn (usize, ?*anyopaque) callconv(.c) ?*anyopaque, ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) void, ?*anyopaque) ?*pcre2_general_context_32;
pub extern fn pcre2_general_context_free_32(?*pcre2_general_context_32) void;
pub extern fn pcre2_compile_context_copy_32(?*pcre2_compile_context_32) ?*pcre2_compile_context_32;
pub extern fn pcre2_compile_context_create_32(?*pcre2_general_context_32) ?*pcre2_compile_context_32;
pub extern fn pcre2_compile_context_free_32(?*pcre2_compile_context_32) void;
pub extern fn pcre2_set_bsr_32(?*pcre2_compile_context_32, u32) c_int;
pub extern fn pcre2_set_character_tables_32(?*pcre2_compile_context_32, [*c]const u8) c_int;
pub extern fn pcre2_set_compile_extra_options_32(?*pcre2_compile_context_32, u32) c_int;
pub extern fn pcre2_set_max_pattern_length_32(?*pcre2_compile_context_32, usize) c_int;
pub extern fn pcre2_set_max_pattern_compiled_length_32(?*pcre2_compile_context_32, usize) c_int;
pub extern fn pcre2_set_max_varlookbehind_32(?*pcre2_compile_context_32, u32) c_int;
pub extern fn pcre2_set_newline_32(?*pcre2_compile_context_32, u32) c_int;
pub extern fn pcre2_set_parens_nest_limit_32(?*pcre2_compile_context_32, u32) c_int;
pub extern fn pcre2_set_compile_recursion_guard_32(?*pcre2_compile_context_32, ?*const fn (u32, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_convert_context_copy_32(?*pcre2_convert_context_32) ?*pcre2_convert_context_32;
pub extern fn pcre2_convert_context_create_32(?*pcre2_general_context_32) ?*pcre2_convert_context_32;
pub extern fn pcre2_convert_context_free_32(?*pcre2_convert_context_32) void;
pub extern fn pcre2_set_glob_escape_32(?*pcre2_convert_context_32, u32) c_int;
pub extern fn pcre2_set_glob_separator_32(?*pcre2_convert_context_32, u32) c_int;
pub extern fn pcre2_pattern_convert_32(PCRE2_SPTR32, usize, u32, [*c][*c]PCRE2_UCHAR32, [*c]usize, ?*pcre2_convert_context_32) c_int;
pub extern fn pcre2_converted_pattern_free_32([*c]PCRE2_UCHAR32) void;
pub extern fn pcre2_match_context_copy_32(?*pcre2_match_context_32) ?*pcre2_match_context_32;
pub extern fn pcre2_match_context_create_32(?*pcre2_general_context_32) ?*pcre2_match_context_32;
pub extern fn pcre2_match_context_free_32(?*pcre2_match_context_32) void;
pub extern fn pcre2_set_callout_32(?*pcre2_match_context_32, ?*const fn ([*c]pcre2_callout_block_32, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_set_substitute_callout_32(?*pcre2_match_context_32, ?*const fn ([*c]pcre2_substitute_callout_block_32, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_set_depth_limit_32(?*pcre2_match_context_32, u32) c_int;
pub extern fn pcre2_set_heap_limit_32(?*pcre2_match_context_32, u32) c_int;
pub extern fn pcre2_set_match_limit_32(?*pcre2_match_context_32, u32) c_int;
pub extern fn pcre2_set_offset_limit_32(?*pcre2_match_context_32, usize) c_int;
pub extern fn pcre2_set_recursion_limit_32(?*pcre2_match_context_32, u32) c_int;
pub extern fn pcre2_set_recursion_memory_management_32(?*pcre2_match_context_32, ?*const fn (usize, ?*anyopaque) callconv(.c) ?*anyopaque, ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) void, ?*anyopaque) c_int;
pub extern fn pcre2_compile_32(PCRE2_SPTR32, usize, u32, [*c]c_int, [*c]usize, ?*pcre2_compile_context_32) ?*pcre2_code_32;
pub extern fn pcre2_code_free_32(?*pcre2_code_32) void;
pub extern fn pcre2_code_copy_32(?*const pcre2_code_32) ?*pcre2_code_32;
pub extern fn pcre2_code_copy_with_tables_32(?*const pcre2_code_32) ?*pcre2_code_32;
pub extern fn pcre2_pattern_info_32(?*const pcre2_code_32, u32, ?*anyopaque) c_int;
pub extern fn pcre2_callout_enumerate_32(?*const pcre2_code_32, ?*const fn ([*c]pcre2_callout_enumerate_block_32, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) c_int;
pub extern fn pcre2_match_data_create_32(u32, ?*pcre2_general_context_32) ?*pcre2_match_data_32;
pub extern fn pcre2_match_data_create_from_pattern_32(?*const pcre2_code_32, ?*pcre2_general_context_32) ?*pcre2_match_data_32;
pub extern fn pcre2_dfa_match_32(?*const pcre2_code_32, PCRE2_SPTR32, usize, usize, u32, ?*pcre2_match_data_32, ?*pcre2_match_context_32, [*c]c_int, usize) c_int;
pub extern fn pcre2_match_32(?*const pcre2_code_32, PCRE2_SPTR32, usize, usize, u32, ?*pcre2_match_data_32, ?*pcre2_match_context_32) c_int;
pub extern fn pcre2_match_data_free_32(?*pcre2_match_data_32) void;
pub extern fn pcre2_get_mark_32(?*pcre2_match_data_32) PCRE2_SPTR32;
pub extern fn pcre2_get_match_data_size_32(?*pcre2_match_data_32) usize;
pub extern fn pcre2_get_match_data_heapframes_size_32(?*pcre2_match_data_32) usize;
pub extern fn pcre2_get_ovector_count_32(?*pcre2_match_data_32) u32;
pub extern fn pcre2_get_ovector_pointer_32(?*pcre2_match_data_32) [*c]usize;
pub extern fn pcre2_get_startchar_32(?*pcre2_match_data_32) usize;
pub extern fn pcre2_substring_copy_byname_32(?*pcre2_match_data_32, PCRE2_SPTR32, [*c]PCRE2_UCHAR32, [*c]usize) c_int;
pub extern fn pcre2_substring_copy_bynumber_32(?*pcre2_match_data_32, u32, [*c]PCRE2_UCHAR32, [*c]usize) c_int;
pub extern fn pcre2_substring_free_32([*c]PCRE2_UCHAR32) void;
pub extern fn pcre2_substring_get_byname_32(?*pcre2_match_data_32, PCRE2_SPTR32, [*c][*c]PCRE2_UCHAR32, [*c]usize) c_int;
pub extern fn pcre2_substring_get_bynumber_32(?*pcre2_match_data_32, u32, [*c][*c]PCRE2_UCHAR32, [*c]usize) c_int;
pub extern fn pcre2_substring_length_byname_32(?*pcre2_match_data_32, PCRE2_SPTR32, [*c]usize) c_int;
pub extern fn pcre2_substring_length_bynumber_32(?*pcre2_match_data_32, u32, [*c]usize) c_int;
pub extern fn pcre2_substring_nametable_scan_32(?*const pcre2_code_32, PCRE2_SPTR32, [*c]PCRE2_SPTR32, [*c]PCRE2_SPTR32) c_int;
pub extern fn pcre2_substring_number_from_name_32(?*const pcre2_code_32, PCRE2_SPTR32) c_int;
pub extern fn pcre2_substring_list_free_32([*c][*c]PCRE2_UCHAR32) void;
pub extern fn pcre2_substring_list_get_32(?*pcre2_match_data_32, [*c][*c][*c]PCRE2_UCHAR32, [*c][*c]usize) c_int;
pub extern fn pcre2_serialize_encode_32([*c]?*const pcre2_code_32, i32, [*c][*c]u8, [*c]usize, ?*pcre2_general_context_32) i32;
pub extern fn pcre2_serialize_decode_32([*c]?*pcre2_code_32, i32, [*c]const u8, ?*pcre2_general_context_32) i32;
pub extern fn pcre2_serialize_get_number_of_codes_32([*c]const u8) i32;
pub extern fn pcre2_serialize_free_32([*c]u8) void;
pub extern fn pcre2_substitute_32(?*const pcre2_code_32, PCRE2_SPTR32, usize, usize, u32, ?*pcre2_match_data_32, ?*pcre2_match_context_32, PCRE2_SPTR32, usize, [*c]PCRE2_UCHAR32, [*c]usize) c_int;
pub extern fn pcre2_jit_compile_32(?*pcre2_code_32, u32) c_int;
pub extern fn pcre2_jit_match_32(?*const pcre2_code_32, PCRE2_SPTR32, usize, usize, u32, ?*pcre2_match_data_32, ?*pcre2_match_context_32) c_int;
pub extern fn pcre2_jit_free_unused_memory_32(?*pcre2_general_context_32) void;
pub extern fn pcre2_jit_stack_create_32(usize, usize, ?*pcre2_general_context_32) ?*pcre2_jit_stack_32;
pub extern fn pcre2_jit_stack_assign_32(?*pcre2_match_context_32, pcre2_jit_callback_32, ?*anyopaque) void;
pub extern fn pcre2_jit_stack_free_32(?*pcre2_jit_stack_32) void;
pub extern fn pcre2_get_error_message_32(c_int, [*c]PCRE2_UCHAR32, usize) c_int;
pub extern fn pcre2_maketables_32(?*pcre2_general_context_32) [*c]const u8;
pub extern fn pcre2_maketables_free_32(?*pcre2_general_context_32, [*c]const u8) void;
pub const ngx_regex_t = pcre2_code_8;
pub const ngx_regex_compile_t = extern struct {
    pattern: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    options: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    regex: ?*ngx_regex_t = @import("std").mem.zeroes(?*ngx_regex_t),
    captures: c_int = @import("std").mem.zeroes(c_int),
    named_captures: c_int = @import("std").mem.zeroes(c_int),
    name_size: c_int = @import("std").mem.zeroes(c_int),
    names: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    err: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub const ngx_regex_elt_t = extern struct {
    regex: ?*ngx_regex_t = @import("std").mem.zeroes(?*ngx_regex_t),
    name: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
};
pub extern fn ngx_regex_init() void;
pub extern fn ngx_regex_compile(rc: [*c]ngx_regex_compile_t) ngx_int_t;
pub extern fn ngx_regex_exec(re: ?*ngx_regex_t, s: [*c]ngx_str_t, captures: [*c]c_int, size: ngx_uint_t) ngx_int_t;
pub extern fn ngx_regex_exec_array(a: [*c]ngx_array_t, s: [*c]ngx_str_t, log: [*c]ngx_log_t) ngx_int_t;
pub const ngx_radix_node_t = struct_ngx_radix_node_s;
pub const struct_ngx_radix_node_s = extern struct {
    right: [*c]ngx_radix_node_t = @import("std").mem.zeroes([*c]ngx_radix_node_t),
    left: [*c]ngx_radix_node_t = @import("std").mem.zeroes([*c]ngx_radix_node_t),
    parent: [*c]ngx_radix_node_t = @import("std").mem.zeroes([*c]ngx_radix_node_t),
    value: usize = @import("std").mem.zeroes(usize),
};
pub const ngx_radix_tree_t = extern struct {
    root: [*c]ngx_radix_node_t = @import("std").mem.zeroes([*c]ngx_radix_node_t),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    free: [*c]ngx_radix_node_t = @import("std").mem.zeroes([*c]ngx_radix_node_t),
    start: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    size: usize = @import("std").mem.zeroes(usize),
};
pub extern fn ngx_radix_tree_create(pool: [*c]ngx_pool_t, preallocate: ngx_int_t) [*c]ngx_radix_tree_t;
pub extern fn ngx_radix32tree_insert(tree: [*c]ngx_radix_tree_t, key: u32, mask: u32, value: usize) ngx_int_t;
pub extern fn ngx_radix32tree_delete(tree: [*c]ngx_radix_tree_t, key: u32, mask: u32) ngx_int_t;
pub extern fn ngx_radix32tree_find(tree: [*c]ngx_radix_tree_t, key: u32) usize;
pub extern fn ngx_radix128tree_insert(tree: [*c]ngx_radix_tree_t, key: [*c]u_char, mask: [*c]u_char, value: usize) ngx_int_t;
pub extern fn ngx_radix128tree_delete(tree: [*c]ngx_radix_tree_t, key: [*c]u_char, mask: [*c]u_char) ngx_int_t;
pub extern fn ngx_radix128tree_find(tree: [*c]ngx_radix_tree_t, key: [*c]u_char) usize;
pub const ngx_time_t = extern struct {
    sec: time_t = @import("std").mem.zeroes(time_t),
    msec: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    gmtoff: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
};
pub extern fn ngx_time_init() void;
pub extern fn ngx_time_update() void;
pub extern fn ngx_time_sigsafe_update() void;
pub extern fn ngx_http_time(buf: [*c]u_char, t: time_t) [*c]u_char;
pub extern fn ngx_http_cookie_time(buf: [*c]u_char, t: time_t) [*c]u_char;
pub extern fn ngx_gmtime(t: time_t, tp: [*c]ngx_tm_t) void;
pub extern fn ngx_next_time(when: time_t) time_t;
pub extern var ngx_cached_time: [*c]volatile ngx_time_t;
pub extern var ngx_cached_err_log_time: ngx_str_t;
pub extern var ngx_cached_http_time: ngx_str_t;
pub extern var ngx_cached_http_log_time: ngx_str_t;
pub extern var ngx_cached_http_log_iso8601: ngx_str_t;
pub extern var ngx_cached_syslog_time: ngx_str_t;
pub extern var ngx_current_msec: ngx_msec_t;
pub extern fn ngx_rwlock_wlock(lock: [*c]volatile ngx_atomic_t) void;
pub extern fn ngx_rwlock_rlock(lock: [*c]volatile ngx_atomic_t) void;
pub extern fn ngx_rwlock_unlock(lock: [*c]volatile ngx_atomic_t) void;
pub extern fn ngx_rwlock_downgrade(lock: [*c]volatile ngx_atomic_t) void;
pub const ngx_shmtx_sh_t = extern struct {
    lock: ngx_atomic_t = @import("std").mem.zeroes(ngx_atomic_t),
    wait: ngx_atomic_t = @import("std").mem.zeroes(ngx_atomic_t),
};
pub const ngx_shmtx_t = extern struct {
    lock: [*c]volatile ngx_atomic_t = @import("std").mem.zeroes([*c]volatile ngx_atomic_t),
    wait: [*c]volatile ngx_atomic_t = @import("std").mem.zeroes([*c]volatile ngx_atomic_t),
    semaphore: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    sem: sem_t = @import("std").mem.zeroes(sem_t),
    spin: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub extern fn ngx_shmtx_create(mtx: [*c]ngx_shmtx_t, addr: [*c]ngx_shmtx_sh_t, name: [*c]u_char) ngx_int_t;
pub extern fn ngx_shmtx_destroy(mtx: [*c]ngx_shmtx_t) void;
pub extern fn ngx_shmtx_trylock(mtx: [*c]ngx_shmtx_t) ngx_uint_t;
pub extern fn ngx_shmtx_lock(mtx: [*c]ngx_shmtx_t) void;
pub extern fn ngx_shmtx_unlock(mtx: [*c]ngx_shmtx_t) void;
pub extern fn ngx_shmtx_force_unlock(mtx: [*c]ngx_shmtx_t, pid: ngx_pid_t) ngx_uint_t;
pub const ngx_slab_page_t = struct_ngx_slab_page_s;
pub const struct_ngx_slab_page_s = extern struct {
    slab: usize = @import("std").mem.zeroes(usize),
    next: [*c]ngx_slab_page_t = @import("std").mem.zeroes([*c]ngx_slab_page_t),
    prev: usize = @import("std").mem.zeroes(usize),
};
pub const ngx_slab_stat_t = extern struct {
    total: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    used: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    reqs: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    fails: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
const ngx_slab_pool_flags_t = packed struct {
    log_nomem: bool,
    padding: u31,
};
pub const ngx_slab_pool_t = extern struct {
    lock: ngx_shmtx_sh_t = @import("std").mem.zeroes(ngx_shmtx_sh_t),
    min_size: usize = @import("std").mem.zeroes(usize),
    min_shift: usize = @import("std").mem.zeroes(usize),
    pages: [*c]ngx_slab_page_t = @import("std").mem.zeroes([*c]ngx_slab_page_t),
    last: [*c]ngx_slab_page_t = @import("std").mem.zeroes([*c]ngx_slab_page_t),
    free: ngx_slab_page_t = @import("std").mem.zeroes(ngx_slab_page_t),
    stats: [*c]ngx_slab_stat_t = @import("std").mem.zeroes([*c]ngx_slab_stat_t),
    pfree: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    start: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    mutex: ngx_shmtx_t = @import("std").mem.zeroes(ngx_shmtx_t),
    log_ctx: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    zero: u_char = @import("std").mem.zeroes(u_char),
    flags: ngx_slab_pool_flags_t = @import("std").mem.zeroes(ngx_slab_pool_flags_t),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    addr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub extern fn ngx_slab_sizes_init() void;
pub extern fn ngx_slab_init(pool: [*c]ngx_slab_pool_t) void;
pub extern fn ngx_slab_alloc(pool: [*c]ngx_slab_pool_t, size: usize) ?*anyopaque;
pub extern fn ngx_slab_alloc_locked(pool: [*c]ngx_slab_pool_t, size: usize) ?*anyopaque;
pub extern fn ngx_slab_calloc(pool: [*c]ngx_slab_pool_t, size: usize) ?*anyopaque;
pub extern fn ngx_slab_calloc_locked(pool: [*c]ngx_slab_pool_t, size: usize) ?*anyopaque;
pub extern fn ngx_slab_free(pool: [*c]ngx_slab_pool_t, p: ?*anyopaque) void;
pub extern fn ngx_slab_free_locked(pool: [*c]ngx_slab_pool_t, p: ?*anyopaque) void;
pub const ngx_sockaddr_t = extern union {
    sockaddr: struct_sockaddr,
    sockaddr_in: struct_sockaddr_in,
    sockaddr_in6: struct_sockaddr_in6,
    sockaddr_un: struct_sockaddr_un,
};
pub const ngx_in_cidr_t = extern struct {
    addr: in_addr_t = @import("std").mem.zeroes(in_addr_t),
    mask: in_addr_t = @import("std").mem.zeroes(in_addr_t),
};
pub const ngx_in6_cidr_t = extern struct {
    addr: struct_in6_addr = @import("std").mem.zeroes(struct_in6_addr),
    mask: struct_in6_addr = @import("std").mem.zeroes(struct_in6_addr),
};
const union_unnamed_81 = extern union {
    in: ngx_in_cidr_t,
    in6: ngx_in6_cidr_t,
};
pub const ngx_cidr_t = extern struct {
    family: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    u: union_unnamed_81 = @import("std").mem.zeroes(union_unnamed_81),
};
pub const ngx_addr_t = extern struct {
    sockaddr: [*c]struct_sockaddr = @import("std").mem.zeroes([*c]struct_sockaddr),
    socklen: socklen_t = @import("std").mem.zeroes(socklen_t),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
const ngx_url_flags_t = packed struct {
    listen: bool,
    uri_part: bool,
    no_resolve: bool,
    no_port: bool,
    wildcard: bool,
    padding: u27,
};
pub const ngx_url_t = extern struct {
    url: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    host: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    port_text: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    uri: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    port: in_port_t = @import("std").mem.zeroes(in_port_t),
    default_port: in_port_t = @import("std").mem.zeroes(in_port_t),
    last_port: in_port_t = @import("std").mem.zeroes(in_port_t),
    family: c_int = @import("std").mem.zeroes(c_int),
    flags: ngx_url_flags_t = @import("std").mem.zeroes(ngx_url_flags_t),
    socklen: socklen_t = @import("std").mem.zeroes(socklen_t),
    sockaddr: ngx_sockaddr_t = @import("std").mem.zeroes(ngx_sockaddr_t),
    addrs: [*c]ngx_addr_t = @import("std").mem.zeroes([*c]ngx_addr_t),
    naddrs: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    err: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub extern fn ngx_inet_addr(text: [*c]u_char, len: usize) in_addr_t;
pub extern fn ngx_inet6_addr(p: [*c]u_char, len: usize, addr: [*c]u_char) ngx_int_t;
pub extern fn ngx_inet6_ntop(p: [*c]u_char, text: [*c]u_char, len: usize) usize;
pub extern fn ngx_sock_ntop(sa: [*c]struct_sockaddr, socklen: socklen_t, text: [*c]u_char, len: usize, port: ngx_uint_t) usize;
pub extern fn ngx_inet_ntop(family: c_int, addr: ?*anyopaque, text: [*c]u_char, len: usize) usize;
pub extern fn ngx_ptocidr(text: [*c]ngx_str_t, cidr: [*c]ngx_cidr_t) ngx_int_t;
pub extern fn ngx_cidr_match(sa: [*c]struct_sockaddr, cidrs: [*c]ngx_array_t) ngx_int_t;
pub extern fn ngx_parse_addr(pool: [*c]ngx_pool_t, addr: [*c]ngx_addr_t, text: [*c]u_char, len: usize) ngx_int_t;
pub extern fn ngx_parse_addr_port(pool: [*c]ngx_pool_t, addr: [*c]ngx_addr_t, text: [*c]u_char, len: usize) ngx_int_t;
pub extern fn ngx_parse_url(pool: [*c]ngx_pool_t, u: [*c]ngx_url_t) ngx_int_t;
pub extern fn ngx_inet_resolve_host(pool: [*c]ngx_pool_t, u: [*c]ngx_url_t) ngx_int_t;
pub extern fn ngx_cmp_sockaddr(sa1: [*c]struct_sockaddr, slen1: socklen_t, sa2: [*c]struct_sockaddr, slen2: socklen_t, cmp_port: ngx_uint_t) ngx_int_t;
pub extern fn ngx_inet_get_port(sa: [*c]struct_sockaddr) in_port_t;
pub extern fn ngx_inet_set_port(sa: [*c]struct_sockaddr, port: in_port_t) void;
pub extern fn ngx_inet_wildcard(sa: [*c]struct_sockaddr) ngx_uint_t;
pub const ngx_shm_zone_t = struct_ngx_shm_zone_s;
pub const ngx_shm_zone_init_pt = ?*const fn ([*c]ngx_shm_zone_t, ?*anyopaque) callconv(.c) ngx_int_t;
pub const struct_ngx_shm_zone_s = extern struct {
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    shm: ngx_shm_t = @import("std").mem.zeroes(ngx_shm_t),
    init: ngx_shm_zone_init_pt = @import("std").mem.zeroes(ngx_shm_zone_init_pt),
    tag: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    sync: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    noreuse: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_core_conf_t = extern struct {
    daemon: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    master: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    timer_resolution: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    shutdown_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    worker_processes: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    debug_points: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    rlimit_nofile: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    rlimit_core: off_t = @import("std").mem.zeroes(off_t),
    priority: c_int = @import("std").mem.zeroes(c_int),
    cpu_affinity_auto: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    cpu_affinity_n: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    cpu_affinity: [*c]ngx_cpuset_t = @import("std").mem.zeroes([*c]ngx_cpuset_t),
    username: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    user: ngx_uid_t = @import("std").mem.zeroes(ngx_uid_t),
    group: ngx_gid_t = @import("std").mem.zeroes(ngx_gid_t),
    working_directory: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    lock_file: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    pid: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    oldpid: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    env: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    environment: [*c][*c]u8 = @import("std").mem.zeroes([*c][*c]u8),
    transparent: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub extern fn ngx_init_cycle(old_cycle: [*c]ngx_cycle_t) [*c]ngx_cycle_t;
pub extern fn ngx_create_pidfile(name: [*c]ngx_str_t, log: [*c]ngx_log_t) ngx_int_t;
pub extern fn ngx_delete_pidfile(cycle: [*c]ngx_cycle_t) void;
pub extern fn ngx_signal_process(cycle: [*c]ngx_cycle_t, sig: [*c]u8) ngx_int_t;
pub extern fn ngx_reopen_files(cycle: [*c]ngx_cycle_t, user: ngx_uid_t) void;
pub extern fn ngx_set_environment(cycle: [*c]ngx_cycle_t, last: [*c]ngx_uint_t) [*c][*c]u8;
pub extern fn ngx_exec_new_binary(cycle: [*c]ngx_cycle_t, argv: [*c]const [*c]u8) ngx_pid_t;
pub extern fn ngx_get_cpu_affinity(n: ngx_uint_t) [*c]ngx_cpuset_t;
pub extern fn ngx_shared_memory_add(cf: [*c]ngx_conf_t, name: [*c]ngx_str_t, size: usize, tag: ?*anyopaque) [*c]ngx_shm_zone_t;
pub extern fn ngx_set_shutdown_timer(cycle: [*c]ngx_cycle_t) void;
pub extern var ngx_cycle: [*c]volatile ngx_cycle_t;
pub extern var ngx_old_cycles: ngx_array_t;
pub extern var ngx_core_module: ngx_module_t;
pub extern var ngx_test_config: ngx_uint_t;
pub extern var ngx_dump_config: ngx_uint_t;
pub extern var ngx_quiet_mode: ngx_uint_t;
const struct_ngx_resolver_flags_s = packed struct {
    ipv4: bool,
    ipv6: bool,
    padding: u30,
};
pub const struct_ngx_resolver_s = extern struct {
    event: [*c]ngx_event_t = @import("std").mem.zeroes([*c]ngx_event_t),
    dummy: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    ident: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    connections: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    last_connection: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    name_rbtree: ngx_rbtree_t = @import("std").mem.zeroes(ngx_rbtree_t),
    name_sentinel: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    srv_rbtree: ngx_rbtree_t = @import("std").mem.zeroes(ngx_rbtree_t),
    srv_sentinel: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    addr_rbtree: ngx_rbtree_t = @import("std").mem.zeroes(ngx_rbtree_t),
    addr_sentinel: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    name_resend_queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    srv_resend_queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    addr_resend_queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    name_expire_queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    srv_expire_queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    addr_expire_queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    flags: struct_ngx_resolver_flags_s = @import("std").mem.zeroes(struct_ngx_resolver_flags_s),
    addr6_rbtree: ngx_rbtree_t = @import("std").mem.zeroes(ngx_rbtree_t),
    addr6_sentinel: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    addr6_resend_queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    addr6_expire_queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    resend_timeout: time_t = @import("std").mem.zeroes(time_t),
    tcp_timeout: time_t = @import("std").mem.zeroes(time_t),
    expire: time_t = @import("std").mem.zeroes(time_t),
    valid: time_t = @import("std").mem.zeroes(time_t),
    log_level: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_resolver_t = struct_ngx_resolver_s;
pub const ngx_resolver_connection_t = extern struct {
    udp: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    tcp: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    sockaddr: [*c]struct_sockaddr = @import("std").mem.zeroes([*c]struct_sockaddr),
    socklen: socklen_t = @import("std").mem.zeroes(socklen_t),
    server: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    log: ngx_log_t = @import("std").mem.zeroes(ngx_log_t),
    read_buf: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    write_buf: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    resolver: [*c]ngx_resolver_t = @import("std").mem.zeroes([*c]ngx_resolver_t),
};
pub const ngx_resolver_ctx_t = struct_ngx_resolver_ctx_s;
pub const ngx_resolver_handler_pt = ?*const fn ([*c]ngx_resolver_ctx_t) callconv(.c) void;
const struct_ngx_resolver_ctx_flags_s = packed struct {
    quick: bool,
    @"async": bool,
    cancelable: bool,
    padding: u29,
};
pub const struct_ngx_resolver_ctx_s = extern struct {
    next: [*c]ngx_resolver_ctx_t = @import("std").mem.zeroes([*c]ngx_resolver_ctx_t),
    resolver: [*c]ngx_resolver_t = @import("std").mem.zeroes([*c]ngx_resolver_t),
    node: [*c]ngx_resolver_node_t = @import("std").mem.zeroes([*c]ngx_resolver_node_t),
    ident: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    state: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    service: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    valid: time_t = @import("std").mem.zeroes(time_t),
    naddrs: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    addrs: [*c]ngx_resolver_addr_t = @import("std").mem.zeroes([*c]ngx_resolver_addr_t),
    addr: ngx_resolver_addr_t = @import("std").mem.zeroes(ngx_resolver_addr_t),
    sin: struct_sockaddr_in = @import("std").mem.zeroes(struct_sockaddr_in),
    count: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    nsrvs: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    srvs: [*c]ngx_resolver_srv_name_t = @import("std").mem.zeroes([*c]ngx_resolver_srv_name_t),
    handler: ngx_resolver_handler_pt = @import("std").mem.zeroes(ngx_resolver_handler_pt),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    flags: struct_ngx_resolver_ctx_flags_s = @import("std").mem.zeroes(struct_ngx_resolver_ctx_flags_s),
    recursion: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    event: [*c]ngx_event_t = @import("std").mem.zeroes([*c]ngx_event_t),
};
pub const ngx_resolver_addr_t = extern struct {
    sockaddr: [*c]struct_sockaddr = @import("std").mem.zeroes([*c]struct_sockaddr),
    socklen: socklen_t = @import("std").mem.zeroes(socklen_t),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    priority: u_short = @import("std").mem.zeroes(u_short),
    weight: u_short = @import("std").mem.zeroes(u_short),
};
pub const ngx_resolver_srv_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    priority: u_short = @import("std").mem.zeroes(u_short),
    weight: u_short = @import("std").mem.zeroes(u_short),
    port: u_short = @import("std").mem.zeroes(u_short),
};
pub const ngx_resolver_srv_name_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    priority: u_short = @import("std").mem.zeroes(u_short),
    weight: u_short = @import("std").mem.zeroes(u_short),
    port: u_short = @import("std").mem.zeroes(u_short),
    ctx: [*c]ngx_resolver_ctx_t = @import("std").mem.zeroes([*c]ngx_resolver_ctx_t),
    state: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    naddrs: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    addrs: [*c]ngx_addr_t = @import("std").mem.zeroes([*c]ngx_addr_t),
};
const union_unnamed_82 = extern union {
    addr: in_addr_t,
    addrs: [*c]in_addr_t,
    cname: [*c]u_char,
    srvs: [*c]ngx_resolver_srv_t,
};
const union_unnamed_83 = extern union {
    addr6: struct_in6_addr,
    addrs6: [*c]struct_in6_addr,
};
const ngx_resolver_node_flags_t = packed struct {
    tcp: bool,
    tcp6: bool,
    padding: u30,
};
pub const ngx_resolver_node_t = extern struct {
    node: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    name: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    addr6: struct_in6_addr = @import("std").mem.zeroes(struct_in6_addr),
    nlen: u_short = @import("std").mem.zeroes(u_short),
    qlen: u_short = @import("std").mem.zeroes(u_short),
    query: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    query6: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    u: union_unnamed_82 = @import("std").mem.zeroes(union_unnamed_82),
    code: u_char = @import("std").mem.zeroes(u_char),
    naddrs: u_short = @import("std").mem.zeroes(u_short),
    nsrvs: u_short = @import("std").mem.zeroes(u_short),
    cnlen: u_short = @import("std").mem.zeroes(u_short),
    u6: union_unnamed_83 = @import("std").mem.zeroes(union_unnamed_83),
    naddrs6: u_short = @import("std").mem.zeroes(u_short),
    expire: time_t = @import("std").mem.zeroes(time_t),
    valid: time_t = @import("std").mem.zeroes(time_t),
    ttl: u32 = @import("std").mem.zeroes(u32),
    flags: ngx_resolver_node_flags_t = @import("std").mem.zeroes(ngx_resolver_node_flags_t),
    last_connection: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    waiting: [*c]ngx_resolver_ctx_t = @import("std").mem.zeroes([*c]ngx_resolver_ctx_t),
};
pub extern fn ngx_resolver_create(cf: [*c]ngx_conf_t, names: [*c]ngx_str_t, n: ngx_uint_t) [*c]ngx_resolver_t;
pub extern fn ngx_resolve_start(r: [*c]ngx_resolver_t, temp: [*c]ngx_resolver_ctx_t) [*c]ngx_resolver_ctx_t;
pub extern fn ngx_resolve_name(ctx: [*c]ngx_resolver_ctx_t) ngx_int_t;
pub extern fn ngx_resolve_name_done(ctx: [*c]ngx_resolver_ctx_t) void;
pub extern fn ngx_resolve_addr(ctx: [*c]ngx_resolver_ctx_t) ngx_int_t;
pub extern fn ngx_resolve_addr_done(ctx: [*c]ngx_resolver_ctx_t) void;
pub extern fn ngx_resolver_strerror(err: ngx_int_t) [*c]u8;
pub const ossl_intmax_t = intmax_t;
pub const ossl_uintmax_t = uintmax_t;
pub const struct_stack_st = opaque {};
pub const OPENSSL_STACK = struct_stack_st;
pub const OPENSSL_sk_compfunc = ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.c) c_int;
pub const OPENSSL_sk_freefunc = ?*const fn (?*anyopaque) callconv(.c) void;
pub const OPENSSL_sk_copyfunc = ?*const fn (?*const anyopaque) callconv(.c) ?*anyopaque;
pub extern fn OPENSSL_sk_num(?*const OPENSSL_STACK) c_int;
pub extern fn OPENSSL_sk_value(?*const OPENSSL_STACK, c_int) ?*anyopaque;
pub extern fn OPENSSL_sk_set(st: ?*OPENSSL_STACK, i: c_int, data: ?*const anyopaque) ?*anyopaque;
pub extern fn OPENSSL_sk_new(cmp: OPENSSL_sk_compfunc) ?*OPENSSL_STACK;
pub extern fn OPENSSL_sk_new_null() ?*OPENSSL_STACK;
pub extern fn OPENSSL_sk_new_reserve(c: OPENSSL_sk_compfunc, n: c_int) ?*OPENSSL_STACK;
pub extern fn OPENSSL_sk_reserve(st: ?*OPENSSL_STACK, n: c_int) c_int;
pub extern fn OPENSSL_sk_free(?*OPENSSL_STACK) void;
pub extern fn OPENSSL_sk_pop_free(st: ?*OPENSSL_STACK, func: ?*const fn (?*anyopaque) callconv(.c) void) void;
pub extern fn OPENSSL_sk_deep_copy(?*const OPENSSL_STACK, c: OPENSSL_sk_copyfunc, f: OPENSSL_sk_freefunc) ?*OPENSSL_STACK;
pub extern fn OPENSSL_sk_insert(sk: ?*OPENSSL_STACK, data: ?*const anyopaque, where: c_int) c_int;
pub extern fn OPENSSL_sk_delete(st: ?*OPENSSL_STACK, loc: c_int) ?*anyopaque;
pub extern fn OPENSSL_sk_delete_ptr(st: ?*OPENSSL_STACK, p: ?*const anyopaque) ?*anyopaque;
pub extern fn OPENSSL_sk_find(st: ?*OPENSSL_STACK, data: ?*const anyopaque) c_int;
pub extern fn OPENSSL_sk_find_ex(st: ?*OPENSSL_STACK, data: ?*const anyopaque) c_int;
pub extern fn OPENSSL_sk_find_all(st: ?*OPENSSL_STACK, data: ?*const anyopaque, pnum: [*c]c_int) c_int;
pub extern fn OPENSSL_sk_push(st: ?*OPENSSL_STACK, data: ?*const anyopaque) c_int;
pub extern fn OPENSSL_sk_unshift(st: ?*OPENSSL_STACK, data: ?*const anyopaque) c_int;
pub extern fn OPENSSL_sk_shift(st: ?*OPENSSL_STACK) ?*anyopaque;
pub extern fn OPENSSL_sk_pop(st: ?*OPENSSL_STACK) ?*anyopaque;
pub extern fn OPENSSL_sk_zero(st: ?*OPENSSL_STACK) void;
pub extern fn OPENSSL_sk_set_cmp_func(sk: ?*OPENSSL_STACK, cmp: OPENSSL_sk_compfunc) OPENSSL_sk_compfunc;
pub extern fn OPENSSL_sk_dup(st: ?*const OPENSSL_STACK) ?*OPENSSL_STACK;
pub extern fn OPENSSL_sk_sort(st: ?*OPENSSL_STACK) void;
pub extern fn OPENSSL_sk_is_sorted(st: ?*const OPENSSL_STACK) c_int;
pub const OPENSSL_STRING = [*c]u8;
pub const OPENSSL_CSTRING = [*c]const u8;
pub const struct_stack_st_OPENSSL_STRING = opaque {};
pub const sk_OPENSSL_STRING_compfunc = ?*const fn ([*c]const [*c]const u8, [*c]const [*c]const u8) callconv(.c) c_int;
pub const sk_OPENSSL_STRING_freefunc = ?*const fn ([*c]u8) callconv(.c) void;
pub const sk_OPENSSL_STRING_copyfunc = ?*const fn ([*c]const u8) callconv(.c) [*c]u8;
pub fn ossl_check_OPENSSL_STRING_type(arg_ptr: [*c]u8) callconv(.c) [*c]u8 {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_STRING_sk_type(arg_sk: ?*const struct_stack_st_OPENSSL_STRING) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_STRING_sk_type(arg_sk: ?*struct_stack_st_OPENSSL_STRING) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_STRING_compfunc_type(arg_cmp: sk_OPENSSL_STRING_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OPENSSL_STRING_copyfunc_type(arg_cpy: sk_OPENSSL_STRING_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_OPENSSL_STRING_freefunc_type(arg_fr: sk_OPENSSL_STRING_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_OPENSSL_CSTRING = opaque {};
pub const sk_OPENSSL_CSTRING_compfunc = ?*const fn ([*c]const [*c]const u8, [*c]const [*c]const u8) callconv(.c) c_int;
pub const sk_OPENSSL_CSTRING_freefunc = ?*const fn ([*c]u8) callconv(.c) void;
pub const sk_OPENSSL_CSTRING_copyfunc = ?*const fn ([*c]const u8) callconv(.c) [*c]u8;
pub fn ossl_check_OPENSSL_CSTRING_type(arg_ptr: [*c]const u8) callconv(.c) [*c]const u8 {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_CSTRING_sk_type(arg_sk: ?*const struct_stack_st_OPENSSL_CSTRING) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_CSTRING_sk_type(arg_sk: ?*struct_stack_st_OPENSSL_CSTRING) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_CSTRING_compfunc_type(arg_cmp: sk_OPENSSL_CSTRING_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OPENSSL_CSTRING_copyfunc_type(arg_cpy: sk_OPENSSL_CSTRING_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_OPENSSL_CSTRING_freefunc_type(arg_fr: sk_OPENSSL_CSTRING_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const OPENSSL_BLOCK = ?*anyopaque;
pub const struct_stack_st_OPENSSL_BLOCK = opaque {};
pub const sk_OPENSSL_BLOCK_compfunc = ?*const fn ([*c]const ?*const anyopaque, [*c]const ?*const anyopaque) callconv(.c) c_int;
pub const sk_OPENSSL_BLOCK_freefunc = ?*const fn (?*anyopaque) callconv(.c) void;
pub const sk_OPENSSL_BLOCK_copyfunc = ?*const fn (?*const anyopaque) callconv(.c) ?*anyopaque;
pub fn ossl_check_OPENSSL_BLOCK_type(arg_ptr: ?*anyopaque) callconv(.c) ?*anyopaque {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_BLOCK_sk_type(arg_sk: ?*const struct_stack_st_OPENSSL_BLOCK) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_BLOCK_sk_type(arg_sk: ?*struct_stack_st_OPENSSL_BLOCK) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OPENSSL_BLOCK_compfunc_type(arg_cmp: sk_OPENSSL_BLOCK_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OPENSSL_BLOCK_copyfunc_type(arg_cpy: sk_OPENSSL_BLOCK_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_OPENSSL_BLOCK_freefunc_type(arg_fr: sk_OPENSSL_BLOCK_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_ossl_provider_st = opaque {};
pub const OSSL_PROVIDER = struct_ossl_provider_st;
pub const struct_asn1_string_st = extern struct {
    length: c_int = @import("std").mem.zeroes(c_int),
    type: c_int = @import("std").mem.zeroes(c_int),
    data: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    flags: c_long = @import("std").mem.zeroes(c_long),
};
pub const ASN1_INTEGER = struct_asn1_string_st;
pub const ASN1_ENUMERATED = struct_asn1_string_st;
pub const ASN1_BIT_STRING = struct_asn1_string_st;
pub const ASN1_OCTET_STRING = struct_asn1_string_st;
pub const ASN1_PRINTABLESTRING = struct_asn1_string_st;
pub const ASN1_T61STRING = struct_asn1_string_st;
pub const ASN1_IA5STRING = struct_asn1_string_st;
pub const ASN1_GENERALSTRING = struct_asn1_string_st;
pub const ASN1_UNIVERSALSTRING = struct_asn1_string_st;
pub const ASN1_BMPSTRING = struct_asn1_string_st;
pub const ASN1_UTCTIME = struct_asn1_string_st;
pub const ASN1_TIME = struct_asn1_string_st;
pub const ASN1_GENERALIZEDTIME = struct_asn1_string_st;
pub const ASN1_VISIBLESTRING = struct_asn1_string_st;
pub const ASN1_UTF8STRING = struct_asn1_string_st;
pub const ASN1_STRING = struct_asn1_string_st;
pub const ASN1_BOOLEAN = c_int;
pub const ASN1_NULL = c_int;
pub const struct_asn1_object_st = opaque {};
pub const ASN1_OBJECT = struct_asn1_object_st;
pub const struct_ASN1_VALUE_st = opaque {};
pub const ASN1_VALUE = struct_ASN1_VALUE_st;
const union_unnamed_84 = extern union {
    ptr: [*c]u8,
    boolean: ASN1_BOOLEAN,
    asn1_string: [*c]ASN1_STRING,
    object: ?*ASN1_OBJECT,
    integer: [*c]ASN1_INTEGER,
    enumerated: [*c]ASN1_ENUMERATED,
    bit_string: [*c]ASN1_BIT_STRING,
    octet_string: [*c]ASN1_OCTET_STRING,
    printablestring: [*c]ASN1_PRINTABLESTRING,
    t61string: [*c]ASN1_T61STRING,
    ia5string: [*c]ASN1_IA5STRING,
    generalstring: [*c]ASN1_GENERALSTRING,
    bmpstring: [*c]ASN1_BMPSTRING,
    universalstring: [*c]ASN1_UNIVERSALSTRING,
    utctime: [*c]ASN1_UTCTIME,
    generalizedtime: [*c]ASN1_GENERALIZEDTIME,
    visiblestring: [*c]ASN1_VISIBLESTRING,
    utf8string: [*c]ASN1_UTF8STRING,
    set: [*c]ASN1_STRING,
    sequence: [*c]ASN1_STRING,
    asn1_value: ?*ASN1_VALUE,
};
pub const struct_asn1_type_st = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    value: union_unnamed_84 = @import("std").mem.zeroes(union_unnamed_84),
};
pub const ASN1_TYPE = struct_asn1_type_st;
pub const struct_asn1_string_table_st = extern struct {
    nid: c_int = @import("std").mem.zeroes(c_int),
    minsize: c_long = @import("std").mem.zeroes(c_long),
    maxsize: c_long = @import("std").mem.zeroes(c_long),
    mask: c_ulong = @import("std").mem.zeroes(c_ulong),
    flags: c_ulong = @import("std").mem.zeroes(c_ulong),
};
pub const ASN1_STRING_TABLE = struct_asn1_string_table_st;
pub const struct_ASN1_ITEM_st = opaque {};
pub const ASN1_ITEM = struct_ASN1_ITEM_st;
pub const struct_asn1_pctx_st = opaque {};
pub const ASN1_PCTX = struct_asn1_pctx_st;
pub const struct_asn1_sctx_st = opaque {};
pub const ASN1_SCTX = struct_asn1_sctx_st;
pub const struct_bio_st = opaque {};
pub const BIO = struct_bio_st;
pub const struct_bignum_st = opaque {};
pub const BIGNUM = struct_bignum_st;
pub const struct_bignum_ctx = opaque {};
pub const BN_CTX = struct_bignum_ctx;
pub const struct_bn_blinding_st = opaque {};
pub const BN_BLINDING = struct_bn_blinding_st;
pub const struct_bn_mont_ctx_st = opaque {};
pub const BN_MONT_CTX = struct_bn_mont_ctx_st;
pub const struct_bn_recp_ctx_st = opaque {};
pub const BN_RECP_CTX = struct_bn_recp_ctx_st;
pub const struct_bn_gencb_st = opaque {};
pub const BN_GENCB = struct_bn_gencb_st;
pub const struct_buf_mem_st = extern struct {
    length: usize = @import("std").mem.zeroes(usize),
    data: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    max: usize = @import("std").mem.zeroes(usize),
    flags: c_ulong = @import("std").mem.zeroes(c_ulong),
};
pub const BUF_MEM = struct_buf_mem_st;
pub const struct_stack_st_BIGNUM = opaque {};
pub const struct_stack_st_BIGNUM_const = opaque {};
pub const struct_err_state_st = extern struct {
    err_flags: [16]c_int = @import("std").mem.zeroes([16]c_int),
    err_marks: [16]c_int = @import("std").mem.zeroes([16]c_int),
    err_buffer: [16]c_ulong = @import("std").mem.zeroes([16]c_ulong),
    err_data: [16][*c]u8 = @import("std").mem.zeroes([16][*c]u8),
    err_data_size: [16]usize = @import("std").mem.zeroes([16]usize),
    err_data_flags: [16]c_int = @import("std").mem.zeroes([16]c_int),
    err_file: [16][*c]u8 = @import("std").mem.zeroes([16][*c]u8),
    err_line: [16]c_int = @import("std").mem.zeroes([16]c_int),
    err_func: [16][*c]u8 = @import("std").mem.zeroes([16][*c]u8),
    top: c_int = @import("std").mem.zeroes(c_int),
    bottom: c_int = @import("std").mem.zeroes(c_int),
};
pub const ERR_STATE = struct_err_state_st;
pub const struct_evp_cipher_st = opaque {};
pub const EVP_CIPHER = struct_evp_cipher_st;
pub const struct_evp_cipher_ctx_st = opaque {};
pub const EVP_CIPHER_CTX = struct_evp_cipher_ctx_st;
pub const struct_evp_md_st = opaque {};
pub const EVP_MD = struct_evp_md_st;
pub const struct_evp_md_ctx_st = opaque {};
pub const EVP_MD_CTX = struct_evp_md_ctx_st;
pub const struct_evp_mac_st = opaque {};
pub const EVP_MAC = struct_evp_mac_st;
pub const struct_evp_mac_ctx_st = opaque {};
pub const EVP_MAC_CTX = struct_evp_mac_ctx_st;
pub const struct_evp_pkey_st = opaque {};
pub const EVP_PKEY = struct_evp_pkey_st;
pub const struct_evp_pkey_asn1_method_st = opaque {};
pub const EVP_PKEY_ASN1_METHOD = struct_evp_pkey_asn1_method_st;
pub const struct_evp_pkey_method_st = opaque {};
pub const EVP_PKEY_METHOD = struct_evp_pkey_method_st;
pub const struct_evp_pkey_ctx_st = opaque {};
pub const EVP_PKEY_CTX = struct_evp_pkey_ctx_st;
pub const struct_evp_keymgmt_st = opaque {};
pub const EVP_KEYMGMT = struct_evp_keymgmt_st;
pub const struct_evp_kdf_st = opaque {};
pub const EVP_KDF = struct_evp_kdf_st;
pub const struct_evp_kdf_ctx_st = opaque {};
pub const EVP_KDF_CTX = struct_evp_kdf_ctx_st;
pub const struct_evp_rand_st = opaque {};
pub const EVP_RAND = struct_evp_rand_st;
pub const struct_evp_rand_ctx_st = opaque {};
pub const EVP_RAND_CTX = struct_evp_rand_ctx_st;
pub const struct_evp_keyexch_st = opaque {};
pub const EVP_KEYEXCH = struct_evp_keyexch_st;
pub const struct_evp_signature_st = opaque {};
pub const EVP_SIGNATURE = struct_evp_signature_st;
pub const struct_evp_asym_cipher_st = opaque {};
pub const EVP_ASYM_CIPHER = struct_evp_asym_cipher_st;
pub const struct_evp_kem_st = opaque {};
pub const EVP_KEM = struct_evp_kem_st;
pub const struct_evp_Encode_Ctx_st = opaque {};
pub const EVP_ENCODE_CTX = struct_evp_Encode_Ctx_st;
pub const struct_hmac_ctx_st = opaque {};
pub const HMAC_CTX = struct_hmac_ctx_st;
pub const struct_dh_st = opaque {};
pub const DH = struct_dh_st;
pub const struct_dh_method = opaque {};
pub const DH_METHOD = struct_dh_method;
pub const struct_dsa_st = opaque {};
pub const DSA = struct_dsa_st;
pub const struct_dsa_method = opaque {};
pub const DSA_METHOD = struct_dsa_method;
pub const struct_rsa_st = opaque {};
pub const RSA = struct_rsa_st;
pub const struct_rsa_meth_st = opaque {};
pub const RSA_METHOD = struct_rsa_meth_st;
pub const struct_X509_algor_st = extern struct {
    algorithm: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    parameter: [*c]ASN1_TYPE = @import("std").mem.zeroes([*c]ASN1_TYPE),
};
pub const X509_ALGOR = struct_X509_algor_st;
pub const struct_rsa_pss_params_st = extern struct {
    hashAlgorithm: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    maskGenAlgorithm: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    saltLength: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    trailerField: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    maskHash: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
};
pub const RSA_PSS_PARAMS = struct_rsa_pss_params_st;
pub const struct_ec_key_st = opaque {};
pub const EC_KEY = struct_ec_key_st;
pub const struct_ec_key_method_st = opaque {};
pub const EC_KEY_METHOD = struct_ec_key_method_st;
pub const struct_rand_meth_st = extern struct {
    seed: ?*const fn (?*const anyopaque, c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*const anyopaque, c_int) callconv(.c) c_int),
    bytes: ?*const fn ([*c]u8, c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]u8, c_int) callconv(.c) c_int),
    cleanup: ?*const fn () callconv(.c) void = @import("std").mem.zeroes(?*const fn () callconv(.c) void),
    add: ?*const fn (?*const anyopaque, c_int, f64) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn (?*const anyopaque, c_int, f64) callconv(.c) c_int),
    pseudorand: ?*const fn ([*c]u8, c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]u8, c_int) callconv(.c) c_int),
    status: ?*const fn () callconv(.c) c_int = @import("std").mem.zeroes(?*const fn () callconv(.c) c_int),
};
pub const RAND_METHOD = struct_rand_meth_st;
pub const struct_rand_drbg_st = opaque {};
pub const RAND_DRBG = struct_rand_drbg_st;
pub const struct_ssl_dane_st = opaque {};
pub const SSL_DANE = struct_ssl_dane_st;
pub const struct_x509_st = opaque {};
pub const X509 = struct_x509_st;
pub const struct_X509_crl_st = opaque {};
pub const X509_CRL = struct_X509_crl_st;
pub const struct_x509_crl_method_st = opaque {};
pub const X509_CRL_METHOD = struct_x509_crl_method_st;
pub const struct_x509_revoked_st = opaque {};
pub const X509_REVOKED = struct_x509_revoked_st;
pub const struct_X509_name_st = opaque {};
pub const X509_NAME = struct_X509_name_st;
pub const struct_X509_pubkey_st = opaque {};
pub const X509_PUBKEY = struct_X509_pubkey_st;
pub const struct_x509_store_st = opaque {};
pub const X509_STORE = struct_x509_store_st;
pub const struct_x509_store_ctx_st = opaque {};
pub const X509_STORE_CTX = struct_x509_store_ctx_st;
pub const struct_x509_object_st = opaque {};
pub const X509_OBJECT = struct_x509_object_st;
pub const struct_x509_lookup_st = opaque {};
pub const X509_LOOKUP = struct_x509_lookup_st;
pub const struct_x509_lookup_method_st = opaque {};
pub const X509_LOOKUP_METHOD = struct_x509_lookup_method_st;
pub const struct_X509_VERIFY_PARAM_st = opaque {};
pub const X509_VERIFY_PARAM = struct_X509_VERIFY_PARAM_st;
pub const struct_x509_sig_info_st = opaque {};
pub const X509_SIG_INFO = struct_x509_sig_info_st;
pub const struct_pkcs8_priv_key_info_st = opaque {};
pub const PKCS8_PRIV_KEY_INFO = struct_pkcs8_priv_key_info_st;
pub const struct_X509_req_st = opaque {};
pub const X509_REQ = struct_X509_req_st;
pub const struct_stack_st_CONF_VALUE = opaque {};
pub const struct_X509V3_CONF_METHOD_st = extern struct {
    get_string: ?*const fn (?*anyopaque, [*c]const u8, [*c]const u8) callconv(.c) [*c]u8 = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]const u8, [*c]const u8) callconv(.c) [*c]u8),
    get_section: ?*const fn (?*anyopaque, [*c]const u8) callconv(.c) ?*struct_stack_st_CONF_VALUE = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]const u8) callconv(.c) ?*struct_stack_st_CONF_VALUE),
    free_string: ?*const fn (?*anyopaque, [*c]u8) callconv(.c) void = @import("std").mem.zeroes(?*const fn (?*anyopaque, [*c]u8) callconv(.c) void),
    free_section: ?*const fn (?*anyopaque, ?*struct_stack_st_CONF_VALUE) callconv(.c) void = @import("std").mem.zeroes(?*const fn (?*anyopaque, ?*struct_stack_st_CONF_VALUE) callconv(.c) void),
};
pub const X509V3_CONF_METHOD = struct_X509V3_CONF_METHOD_st;
pub const struct_v3_ext_ctx = extern struct {
    flags: c_int = @import("std").mem.zeroes(c_int),
    issuer_cert: ?*X509 = @import("std").mem.zeroes(?*X509),
    subject_cert: ?*X509 = @import("std").mem.zeroes(?*X509),
    subject_req: ?*X509_REQ = @import("std").mem.zeroes(?*X509_REQ),
    crl: ?*X509_CRL = @import("std").mem.zeroes(?*X509_CRL),
    db_meth: [*c]X509V3_CONF_METHOD = @import("std").mem.zeroes([*c]X509V3_CONF_METHOD),
    db: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    issuer_pkey: ?*EVP_PKEY = @import("std").mem.zeroes(?*EVP_PKEY),
};
pub const X509V3_CTX = struct_v3_ext_ctx;
pub const CONF = struct_conf_st;
pub const struct_conf_method_st = extern struct {
    name: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    create: ?*const fn ([*c]CONF_METHOD) callconv(.c) [*c]CONF = @import("std").mem.zeroes(?*const fn ([*c]CONF_METHOD) callconv(.c) [*c]CONF),
    init: ?*const fn ([*c]CONF) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]CONF) callconv(.c) c_int),
    destroy: ?*const fn ([*c]CONF) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]CONF) callconv(.c) c_int),
    destroy_data: ?*const fn ([*c]CONF) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]CONF) callconv(.c) c_int),
    load_bio: ?*const fn ([*c]CONF, ?*BIO, [*c]c_long) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]CONF, ?*BIO, [*c]c_long) callconv(.c) c_int),
    dump: ?*const fn ([*c]const CONF, ?*BIO) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const CONF, ?*BIO) callconv(.c) c_int),
    is_number: ?*const fn ([*c]const CONF, u8) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const CONF, u8) callconv(.c) c_int),
    to_int: ?*const fn ([*c]const CONF, u8) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const CONF, u8) callconv(.c) c_int),
    load: ?*const fn ([*c]CONF, [*c]const u8, [*c]c_long) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]CONF, [*c]const u8, [*c]c_long) callconv(.c) c_int),
};
pub const CONF_METHOD = struct_conf_method_st;
pub const union_lh_CONF_VALUE_dummy_85 = extern union {
    d1: ?*anyopaque,
    d2: c_ulong,
    d3: c_int,
};
pub const struct_lhash_st_CONF_VALUE = extern struct {
    dummy: union_lh_CONF_VALUE_dummy_85 = @import("std").mem.zeroes(union_lh_CONF_VALUE_dummy_85),
};
pub const struct_ossl_lib_ctx_st = opaque {};
pub const OSSL_LIB_CTX = struct_ossl_lib_ctx_st;
pub const struct_conf_st = extern struct {
    meth: [*c]CONF_METHOD = @import("std").mem.zeroes([*c]CONF_METHOD),
    meth_data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    data: [*c]struct_lhash_st_CONF_VALUE = @import("std").mem.zeroes([*c]struct_lhash_st_CONF_VALUE),
    flag_dollarid: c_int = @import("std").mem.zeroes(c_int),
    flag_abspath: c_int = @import("std").mem.zeroes(c_int),
    includedir: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    libctx: ?*OSSL_LIB_CTX = @import("std").mem.zeroes(?*OSSL_LIB_CTX),
};
pub const struct_ossl_init_settings_st = opaque {};
pub const OPENSSL_INIT_SETTINGS = struct_ossl_init_settings_st;
pub const struct_ui_st = opaque {};
pub const UI = struct_ui_st;
pub const struct_ui_method_st = opaque {};
pub const UI_METHOD = struct_ui_method_st;
pub const struct_engine_st = opaque {};
pub const ENGINE = struct_engine_st;
pub const struct_comp_ctx_st = opaque {};
pub const COMP_CTX = struct_comp_ctx_st;
pub const struct_comp_method_st = opaque {};
pub const COMP_METHOD = struct_comp_method_st;
pub const struct_X509_POLICY_NODE_st = opaque {};
pub const X509_POLICY_NODE = struct_X509_POLICY_NODE_st;
pub const struct_X509_POLICY_LEVEL_st = opaque {};
pub const X509_POLICY_LEVEL = struct_X509_POLICY_LEVEL_st;
pub const struct_X509_POLICY_TREE_st = opaque {};
pub const X509_POLICY_TREE = struct_X509_POLICY_TREE_st;
pub const struct_X509_POLICY_CACHE_st = opaque {};
pub const X509_POLICY_CACHE = struct_X509_POLICY_CACHE_st;
pub const struct_stack_st_GENERAL_NAME = opaque {};
pub const GENERAL_NAMES = struct_stack_st_GENERAL_NAME;
pub const struct_AUTHORITY_KEYID_st = extern struct {
    keyid: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    issuer: ?*GENERAL_NAMES = @import("std").mem.zeroes(?*GENERAL_NAMES),
    serial: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const AUTHORITY_KEYID = struct_AUTHORITY_KEYID_st;
pub const struct_stack_st_X509_NAME_ENTRY = opaque {};
const union_unnamed_86 = extern union {
    fullname: ?*GENERAL_NAMES,
    relativename: ?*struct_stack_st_X509_NAME_ENTRY,
};
pub const struct_DIST_POINT_NAME_st = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    name: union_unnamed_86 = @import("std").mem.zeroes(union_unnamed_86),
    dpname: ?*X509_NAME = @import("std").mem.zeroes(?*X509_NAME),
};
pub const DIST_POINT_NAME = struct_DIST_POINT_NAME_st;
pub const struct_DIST_POINT_st = extern struct {
    distpoint: [*c]DIST_POINT_NAME = @import("std").mem.zeroes([*c]DIST_POINT_NAME),
    reasons: [*c]ASN1_BIT_STRING = @import("std").mem.zeroes([*c]ASN1_BIT_STRING),
    CRLissuer: ?*GENERAL_NAMES = @import("std").mem.zeroes(?*GENERAL_NAMES),
    dp_reasons: c_int = @import("std").mem.zeroes(c_int),
};
pub const DIST_POINT = struct_DIST_POINT_st;
pub const struct_ISSUING_DIST_POINT_st = extern struct {
    distpoint: [*c]DIST_POINT_NAME = @import("std").mem.zeroes([*c]DIST_POINT_NAME),
    onlyuser: c_int = @import("std").mem.zeroes(c_int),
    onlyCA: c_int = @import("std").mem.zeroes(c_int),
    onlysomereasons: [*c]ASN1_BIT_STRING = @import("std").mem.zeroes([*c]ASN1_BIT_STRING),
    indirectCRL: c_int = @import("std").mem.zeroes(c_int),
    onlyattr: c_int = @import("std").mem.zeroes(c_int),
};
pub const ISSUING_DIST_POINT = struct_ISSUING_DIST_POINT_st;
pub const struct_stack_st_GENERAL_SUBTREE = opaque {};
pub const struct_NAME_CONSTRAINTS_st = extern struct {
    permittedSubtrees: ?*struct_stack_st_GENERAL_SUBTREE = @import("std").mem.zeroes(?*struct_stack_st_GENERAL_SUBTREE),
    excludedSubtrees: ?*struct_stack_st_GENERAL_SUBTREE = @import("std").mem.zeroes(?*struct_stack_st_GENERAL_SUBTREE),
};
pub const NAME_CONSTRAINTS = struct_NAME_CONSTRAINTS_st;
pub const struct_stack_st_void = opaque {};
pub const struct_crypto_ex_data_st = extern struct {
    ctx: ?*OSSL_LIB_CTX = @import("std").mem.zeroes(?*OSSL_LIB_CTX),
    sk: ?*struct_stack_st_void = @import("std").mem.zeroes(?*struct_stack_st_void),
};
pub const CRYPTO_EX_DATA = struct_crypto_ex_data_st;
pub const struct_ossl_http_req_ctx_st = opaque {};
pub const OSSL_HTTP_REQ_CTX = struct_ossl_http_req_ctx_st;
pub const struct_ocsp_response_st = opaque {};
pub const OCSP_RESPONSE = struct_ocsp_response_st;
pub const struct_ocsp_responder_id_st = opaque {};
pub const OCSP_RESPID = struct_ocsp_responder_id_st;
pub const struct_sct_st = opaque {};
pub const SCT = struct_sct_st;
pub const struct_sct_ctx_st = opaque {};
pub const SCT_CTX = struct_sct_ctx_st;
pub const struct_ctlog_st = opaque {};
pub const CTLOG = struct_ctlog_st;
pub const struct_ctlog_store_st = opaque {};
pub const CTLOG_STORE = struct_ctlog_store_st;
pub const struct_ct_policy_eval_ctx_st = opaque {};
pub const CT_POLICY_EVAL_CTX = struct_ct_policy_eval_ctx_st;
pub const struct_ossl_store_info_st = opaque {};
pub const OSSL_STORE_INFO = struct_ossl_store_info_st;
pub const struct_ossl_store_search_st = opaque {};
pub const OSSL_STORE_SEARCH = struct_ossl_store_search_st;
pub const struct_ossl_dispatch_st = extern struct {
    function_id: c_int = @import("std").mem.zeroes(c_int),
    function: ?*const fn () callconv(.c) void = @import("std").mem.zeroes(?*const fn () callconv(.c) void),
};
pub const OSSL_DISPATCH = struct_ossl_dispatch_st;
pub const struct_ossl_item_st = extern struct {
    id: c_uint = @import("std").mem.zeroes(c_uint),
    ptr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const OSSL_ITEM = struct_ossl_item_st;
pub const struct_ossl_algorithm_st = extern struct {
    algorithm_names: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    property_definition: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    implementation: [*c]const OSSL_DISPATCH = @import("std").mem.zeroes([*c]const OSSL_DISPATCH),
    algorithm_description: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const OSSL_ALGORITHM = struct_ossl_algorithm_st;
pub const struct_ossl_param_st = extern struct {
    key: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    data_type: c_uint = @import("std").mem.zeroes(c_uint),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    data_size: usize = @import("std").mem.zeroes(usize),
    return_size: usize = @import("std").mem.zeroes(usize),
};
pub const OSSL_PARAM = struct_ossl_param_st;
pub const struct_ossl_param_bld_st = opaque {};
pub const OSSL_PARAM_BLD = struct_ossl_param_bld_st;
pub const pem_password_cb = fn ([*c]u8, c_int, c_int, ?*anyopaque) callconv(.c) c_int;
pub const struct_ossl_encoder_st = opaque {};
pub const OSSL_ENCODER = struct_ossl_encoder_st;
pub const struct_ossl_encoder_ctx_st = opaque {};
pub const OSSL_ENCODER_CTX = struct_ossl_encoder_ctx_st;
pub const struct_ossl_decoder_st = opaque {};
pub const OSSL_DECODER = struct_ossl_decoder_st;
pub const struct_ossl_decoder_ctx_st = opaque {};
pub const OSSL_DECODER_CTX = struct_ossl_decoder_ctx_st;
pub const struct_ossl_self_test_st = opaque {};
pub const OSSL_SELF_TEST = struct_ossl_self_test_st;
pub extern fn ERR_load_ASN1_strings() c_int;
pub extern fn ERR_load_ASYNC_strings() c_int;
pub extern fn ERR_load_BIO_strings() c_int;
pub extern fn ERR_load_BN_strings() c_int;
pub extern fn ERR_load_BUF_strings() c_int;
pub extern fn ERR_load_CMS_strings() c_int;
pub extern fn ERR_load_COMP_strings() c_int;
pub extern fn ERR_load_CONF_strings() c_int;
pub extern fn ERR_load_CRYPTO_strings() c_int;
pub extern fn ERR_load_CT_strings() c_int;
pub extern fn ERR_load_DH_strings() c_int;
pub extern fn ERR_load_DSA_strings() c_int;
pub extern fn ERR_load_EC_strings() c_int;
pub extern fn ERR_load_ENGINE_strings() c_int;
pub extern fn ERR_load_ERR_strings() c_int;
pub extern fn ERR_load_EVP_strings() c_int;
pub extern fn ERR_load_KDF_strings() c_int;
pub extern fn ERR_load_OBJ_strings() c_int;
pub extern fn ERR_load_OCSP_strings() c_int;
pub extern fn ERR_load_PEM_strings() c_int;
pub extern fn ERR_load_PKCS12_strings() c_int;
pub extern fn ERR_load_PKCS7_strings() c_int;
pub extern fn ERR_load_RAND_strings() c_int;
pub extern fn ERR_load_RSA_strings() c_int;
pub extern fn ERR_load_OSSL_STORE_strings() c_int;
pub extern fn ERR_load_TS_strings() c_int;
pub extern fn ERR_load_UI_strings() c_int;
pub extern fn ERR_load_X509_strings() c_int;
pub extern fn ERR_load_X509V3_strings() c_int;
pub const struct_ossl_core_handle_st = opaque {};
pub const OSSL_CORE_HANDLE = struct_ossl_core_handle_st;
pub const struct_openssl_core_ctx_st = opaque {};
pub const OPENSSL_CORE_CTX = struct_openssl_core_ctx_st;
pub const struct_ossl_core_bio_st = opaque {};
pub const OSSL_CORE_BIO = struct_ossl_core_bio_st;
pub const OSSL_thread_stop_handler_fn = ?*const fn (?*anyopaque) callconv(.c) void;
pub const OSSL_provider_init_fn = fn (?*const OSSL_CORE_HANDLE, [*c]const OSSL_DISPATCH, [*c][*c]const OSSL_DISPATCH, [*c]?*anyopaque) callconv(.c) c_int;
pub const OSSL_provider_init = @compileError("unable to resolve function type clang.TypeClass.Elaborated");
// /usr/include/openssl/core.h:201:38
pub const OSSL_CALLBACK = fn ([*c]const OSSL_PARAM, ?*anyopaque) callconv(.c) c_int;
pub const OSSL_INOUT_CALLBACK = fn ([*c]const OSSL_PARAM, [*c]OSSL_PARAM, ?*anyopaque) callconv(.c) c_int;
pub const OSSL_PASSPHRASE_CALLBACK = fn ([*c]u8, usize, [*c]usize, [*c]const OSSL_PARAM, ?*anyopaque) callconv(.c) c_int;
pub const CRYPTO_dynlock = extern struct {
    dummy: c_int = @import("std").mem.zeroes(c_int),
};
pub const CRYPTO_RWLOCK = anyopaque;
pub extern fn CRYPTO_THREAD_lock_new() ?*CRYPTO_RWLOCK;
pub extern fn CRYPTO_THREAD_read_lock(lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_THREAD_write_lock(lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_THREAD_unlock(lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_THREAD_lock_free(lock: ?*CRYPTO_RWLOCK) void;
pub extern fn CRYPTO_atomic_add(val: [*c]c_int, amount: c_int, ret: [*c]c_int, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_add64(val: [*c]u64, op: u64, ret: [*c]u64, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_and(val: [*c]u64, op: u64, ret: [*c]u64, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_or(val: [*c]u64, op: u64, ret: [*c]u64, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_load(val: [*c]u64, ret: [*c]u64, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_load_int(val: [*c]c_int, ret: [*c]c_int, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn CRYPTO_atomic_store(dst: [*c]u64, val: u64, lock: ?*CRYPTO_RWLOCK) c_int;
pub extern fn OPENSSL_strlcpy(dst: [*c]u8, src: [*c]const u8, siz: usize) usize;
pub extern fn OPENSSL_strlcat(dst: [*c]u8, src: [*c]const u8, siz: usize) usize;
pub extern fn OPENSSL_strnlen(str: [*c]const u8, maxlen: usize) usize;
pub extern fn OPENSSL_strtoul(str: [*c]const u8, endptr: [*c][*c]u8, base: c_int, num: [*c]c_ulong) c_int;
pub extern fn OPENSSL_buf2hexstr_ex(str: [*c]u8, str_n: usize, strlength: [*c]usize, buf: [*c]const u8, buflen: usize, sep: u8) c_int;
pub extern fn OPENSSL_buf2hexstr(buf: [*c]const u8, buflen: c_long) [*c]u8;
pub extern fn OPENSSL_hexstr2buf_ex(buf: [*c]u8, buf_n: usize, buflen: [*c]usize, str: [*c]const u8, sep: u8) c_int;
pub extern fn OPENSSL_hexstr2buf(str: [*c]const u8, buflen: [*c]c_long) [*c]u8;
pub extern fn OPENSSL_hexchar2int(c: u8) c_int;
pub extern fn OPENSSL_strcasecmp(s1: [*c]const u8, s2: [*c]const u8) c_int;
pub extern fn OPENSSL_strncasecmp(s1: [*c]const u8, s2: [*c]const u8, n: usize) c_int;
pub extern fn OPENSSL_version_major() c_uint;
pub extern fn OPENSSL_version_minor() c_uint;
pub extern fn OPENSSL_version_patch() c_uint;
pub extern fn OPENSSL_version_pre_release() [*c]const u8;
pub extern fn OPENSSL_version_build_metadata() [*c]const u8;
pub extern fn OpenSSL_version_num() c_ulong;
pub extern fn OpenSSL_version(@"type": c_int) [*c]const u8;
pub extern fn OPENSSL_info(@"type": c_int) [*c]const u8;
pub extern fn OPENSSL_issetugid() c_int;
pub const sk_void_compfunc = ?*const fn ([*c]const ?*const anyopaque, [*c]const ?*const anyopaque) callconv(.c) c_int;
pub const sk_void_freefunc = ?*const fn (?*anyopaque) callconv(.c) void;
pub const sk_void_copyfunc = ?*const fn (?*const anyopaque) callconv(.c) ?*anyopaque;
pub fn ossl_check_void_type(arg_ptr: ?*anyopaque) callconv(.c) ?*anyopaque {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_void_sk_type(arg_sk: ?*const struct_stack_st_void) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_void_sk_type(arg_sk: ?*struct_stack_st_void) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_void_compfunc_type(arg_cmp: sk_void_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_void_copyfunc_type(arg_cpy: sk_void_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_void_freefunc_type(arg_fr: sk_void_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const CRYPTO_EX_new = fn (?*anyopaque, ?*anyopaque, [*c]CRYPTO_EX_DATA, c_int, c_long, ?*anyopaque) callconv(.c) void;
pub const CRYPTO_EX_free = fn (?*anyopaque, ?*anyopaque, [*c]CRYPTO_EX_DATA, c_int, c_long, ?*anyopaque) callconv(.c) void;
pub const CRYPTO_EX_dup = fn ([*c]CRYPTO_EX_DATA, [*c]const CRYPTO_EX_DATA, [*c]?*anyopaque, c_int, c_long, ?*anyopaque) callconv(.c) c_int;
pub extern fn CRYPTO_get_ex_new_index(class_index: c_int, argl: c_long, argp: ?*anyopaque, new_func: ?*const CRYPTO_EX_new, dup_func: ?*const CRYPTO_EX_dup, free_func: ?*const CRYPTO_EX_free) c_int;
pub extern fn CRYPTO_free_ex_index(class_index: c_int, idx: c_int) c_int;
pub extern fn CRYPTO_new_ex_data(class_index: c_int, obj: ?*anyopaque, ad: [*c]CRYPTO_EX_DATA) c_int;
pub extern fn CRYPTO_dup_ex_data(class_index: c_int, to: [*c]CRYPTO_EX_DATA, from: [*c]const CRYPTO_EX_DATA) c_int;
pub extern fn CRYPTO_free_ex_data(class_index: c_int, obj: ?*anyopaque, ad: [*c]CRYPTO_EX_DATA) void;
pub extern fn CRYPTO_alloc_ex_data(class_index: c_int, obj: ?*anyopaque, ad: [*c]CRYPTO_EX_DATA, idx: c_int) c_int;
pub extern fn CRYPTO_set_ex_data(ad: [*c]CRYPTO_EX_DATA, idx: c_int, val: ?*anyopaque) c_int;
pub extern fn CRYPTO_get_ex_data(ad: [*c]const CRYPTO_EX_DATA, idx: c_int) ?*anyopaque;
pub const struct_crypto_threadid_st = extern struct {
    dummy: c_int = @import("std").mem.zeroes(c_int),
};
pub const CRYPTO_THREADID = struct_crypto_threadid_st;
pub const CRYPTO_malloc_fn = ?*const fn (usize, [*c]const u8, c_int) callconv(.c) ?*anyopaque;
pub const CRYPTO_realloc_fn = ?*const fn (?*anyopaque, usize, [*c]const u8, c_int) callconv(.c) ?*anyopaque;
pub const CRYPTO_free_fn = ?*const fn (?*anyopaque, [*c]const u8, c_int) callconv(.c) void;
pub extern fn CRYPTO_set_mem_functions(malloc_fn: CRYPTO_malloc_fn, realloc_fn: CRYPTO_realloc_fn, free_fn: CRYPTO_free_fn) c_int;
pub extern fn CRYPTO_get_mem_functions(malloc_fn: [*c]CRYPTO_malloc_fn, realloc_fn: [*c]CRYPTO_realloc_fn, free_fn: [*c]CRYPTO_free_fn) void;
pub extern fn CRYPTO_malloc(num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_zalloc(num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_aligned_alloc(num: usize, @"align": usize, freeptr: [*c]?*anyopaque, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_memdup(str: ?*const anyopaque, siz: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_strdup(str: [*c]const u8, file: [*c]const u8, line: c_int) [*c]u8;
pub extern fn CRYPTO_strndup(str: [*c]const u8, s: usize, file: [*c]const u8, line: c_int) [*c]u8;
pub extern fn CRYPTO_free(ptr: ?*anyopaque, file: [*c]const u8, line: c_int) void;
pub extern fn CRYPTO_clear_free(ptr: ?*anyopaque, num: usize, file: [*c]const u8, line: c_int) void;
pub extern fn CRYPTO_realloc(addr: ?*anyopaque, num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_clear_realloc(addr: ?*anyopaque, old_num: usize, num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_secure_malloc_init(sz: usize, minsize: usize) c_int;
pub extern fn CRYPTO_secure_malloc_done() c_int;
pub extern fn CRYPTO_secure_malloc(num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_secure_zalloc(num: usize, file: [*c]const u8, line: c_int) ?*anyopaque;
pub extern fn CRYPTO_secure_free(ptr: ?*anyopaque, file: [*c]const u8, line: c_int) void;
pub extern fn CRYPTO_secure_clear_free(ptr: ?*anyopaque, num: usize, file: [*c]const u8, line: c_int) void;
pub extern fn CRYPTO_secure_allocated(ptr: ?*const anyopaque) c_int;
pub extern fn CRYPTO_secure_malloc_initialized() c_int;
pub extern fn CRYPTO_secure_actual_size(ptr: ?*anyopaque) usize;
pub extern fn CRYPTO_secure_used() usize;
pub extern fn OPENSSL_cleanse(ptr: ?*anyopaque, len: usize) void;
pub extern fn OPENSSL_die(assertion: [*c]const u8, file: [*c]const u8, line: c_int) void;
pub extern fn OPENSSL_isservice() c_int;
pub extern fn OPENSSL_init() void;
pub extern fn OPENSSL_fork_prepare() void;
pub extern fn OPENSSL_fork_parent() void;
pub extern fn OPENSSL_fork_child() void;
pub extern fn OPENSSL_gmtime(timer: [*c]const time_t, result: [*c]struct_tm) [*c]struct_tm;
pub extern fn OPENSSL_gmtime_adj(tm: [*c]struct_tm, offset_day: c_int, offset_sec: c_long) c_int;
pub extern fn OPENSSL_gmtime_diff(pday: [*c]c_int, psec: [*c]c_int, from: [*c]const struct_tm, to: [*c]const struct_tm) c_int;
pub extern fn CRYPTO_memcmp(in_a: ?*const anyopaque, in_b: ?*const anyopaque, len: usize) c_int;
pub extern fn OPENSSL_cleanup() void;
pub extern fn OPENSSL_init_crypto(opts: u64, settings: ?*const OPENSSL_INIT_SETTINGS) c_int;
pub extern fn OPENSSL_atexit(handler: ?*const fn () callconv(.c) void) c_int;
pub extern fn OPENSSL_thread_stop() void;
pub extern fn OPENSSL_thread_stop_ex(ctx: ?*OSSL_LIB_CTX) void;
pub extern fn OPENSSL_INIT_new() ?*OPENSSL_INIT_SETTINGS;
pub extern fn OPENSSL_INIT_set_config_filename(settings: ?*OPENSSL_INIT_SETTINGS, config_filename: [*c]const u8) c_int;
pub extern fn OPENSSL_INIT_set_config_file_flags(settings: ?*OPENSSL_INIT_SETTINGS, flags: c_ulong) void;
pub extern fn OPENSSL_INIT_set_config_appname(settings: ?*OPENSSL_INIT_SETTINGS, config_appname: [*c]const u8) c_int;
pub extern fn OPENSSL_INIT_free(settings: ?*OPENSSL_INIT_SETTINGS) void;
pub const __jmp_buf = [8]c_long;
pub const struct___jmp_buf_tag = extern struct {
    __jmpbuf: __jmp_buf = @import("std").mem.zeroes(__jmp_buf),
    __mask_was_saved: c_int = @import("std").mem.zeroes(c_int),
    __saved_mask: __sigset_t = @import("std").mem.zeroes(__sigset_t),
};
pub const PTHREAD_CREATE_JOINABLE: c_int = 0;
pub const PTHREAD_CREATE_DETACHED: c_int = 1;
const enum_unnamed_87 = c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: c_int = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: c_int = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: c_int = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: c_int = 3;
pub const PTHREAD_MUTEX_NORMAL: c_int = 0;
pub const PTHREAD_MUTEX_RECURSIVE: c_int = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: c_int = 2;
pub const PTHREAD_MUTEX_DEFAULT: c_int = 0;
pub const PTHREAD_MUTEX_FAST_NP: c_int = 0;
const enum_unnamed_88 = c_uint;
pub const PTHREAD_MUTEX_STALLED: c_int = 0;
pub const PTHREAD_MUTEX_STALLED_NP: c_int = 0;
pub const PTHREAD_MUTEX_ROBUST: c_int = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: c_int = 1;
const enum_unnamed_89 = c_uint;
pub const PTHREAD_PRIO_NONE: c_int = 0;
pub const PTHREAD_PRIO_INHERIT: c_int = 1;
pub const PTHREAD_PRIO_PROTECT: c_int = 2;
const enum_unnamed_90 = c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: c_int = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: c_int = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: c_int = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: c_int = 0;
const enum_unnamed_91 = c_uint;
pub const PTHREAD_INHERIT_SCHED: c_int = 0;
pub const PTHREAD_EXPLICIT_SCHED: c_int = 1;
const enum_unnamed_92 = c_uint;
pub const PTHREAD_SCOPE_SYSTEM: c_int = 0;
pub const PTHREAD_SCOPE_PROCESS: c_int = 1;
const enum_unnamed_93 = c_uint;
pub const PTHREAD_PROCESS_PRIVATE: c_int = 0;
pub const PTHREAD_PROCESS_SHARED: c_int = 1;
const enum_unnamed_94 = c_uint;
pub const struct__pthread_cleanup_buffer = extern struct {
    __routine: ?*const fn (?*anyopaque) callconv(.c) void = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) void),
    __arg: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    __canceltype: c_int = @import("std").mem.zeroes(c_int),
    __prev: [*c]struct__pthread_cleanup_buffer = @import("std").mem.zeroes([*c]struct__pthread_cleanup_buffer),
};
pub const PTHREAD_CANCEL_ENABLE: c_int = 0;
pub const PTHREAD_CANCEL_DISABLE: c_int = 1;
const enum_unnamed_95 = c_uint;
pub const PTHREAD_CANCEL_DEFERRED: c_int = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: c_int = 1;
const enum_unnamed_96 = c_uint;
pub extern fn pthread_create(noalias __newthread: [*c]pthread_t, noalias __attr: [*c]const pthread_attr_t, __start_routine: ?*const fn (?*anyopaque) callconv(.c) ?*anyopaque, noalias __arg: ?*anyopaque) c_int;
pub extern fn pthread_exit(__retval: ?*anyopaque) noreturn;
pub extern fn pthread_join(__th: pthread_t, __thread_return: [*c]?*anyopaque) c_int;
pub extern fn pthread_tryjoin_np(__th: pthread_t, __thread_return: [*c]?*anyopaque) c_int;
pub extern fn pthread_timedjoin_np(__th: pthread_t, __thread_return: [*c]?*anyopaque, __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_clockjoin_np(__th: pthread_t, __thread_return: [*c]?*anyopaque, __clockid: clockid_t, __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_detach(__th: pthread_t) c_int;
pub extern fn pthread_self() pthread_t;
pub extern fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) c_int;
pub extern fn pthread_attr_init(__attr: [*c]pthread_attr_t) c_int;
pub extern fn pthread_attr_destroy(__attr: [*c]pthread_attr_t) c_int;
pub extern fn pthread_attr_getdetachstate(__attr: [*c]const pthread_attr_t, __detachstate: [*c]c_int) c_int;
pub extern fn pthread_attr_setdetachstate(__attr: [*c]pthread_attr_t, __detachstate: c_int) c_int;
pub extern fn pthread_attr_getguardsize(__attr: [*c]const pthread_attr_t, __guardsize: [*c]usize) c_int;
pub extern fn pthread_attr_setguardsize(__attr: [*c]pthread_attr_t, __guardsize: usize) c_int;
pub extern fn pthread_attr_getschedparam(noalias __attr: [*c]const pthread_attr_t, noalias __param: [*c]struct_sched_param) c_int;
pub extern fn pthread_attr_setschedparam(noalias __attr: [*c]pthread_attr_t, noalias __param: [*c]const struct_sched_param) c_int;
pub extern fn pthread_attr_getschedpolicy(noalias __attr: [*c]const pthread_attr_t, noalias __policy: [*c]c_int) c_int;
pub extern fn pthread_attr_setschedpolicy(__attr: [*c]pthread_attr_t, __policy: c_int) c_int;
pub extern fn pthread_attr_getinheritsched(noalias __attr: [*c]const pthread_attr_t, noalias __inherit: [*c]c_int) c_int;
pub extern fn pthread_attr_setinheritsched(__attr: [*c]pthread_attr_t, __inherit: c_int) c_int;
pub extern fn pthread_attr_getscope(noalias __attr: [*c]const pthread_attr_t, noalias __scope: [*c]c_int) c_int;
pub extern fn pthread_attr_setscope(__attr: [*c]pthread_attr_t, __scope: c_int) c_int;
pub extern fn pthread_attr_getstackaddr(noalias __attr: [*c]const pthread_attr_t, noalias __stackaddr: [*c]?*anyopaque) c_int;
pub extern fn pthread_attr_setstackaddr(__attr: [*c]pthread_attr_t, __stackaddr: ?*anyopaque) c_int;
pub extern fn pthread_attr_getstacksize(noalias __attr: [*c]const pthread_attr_t, noalias __stacksize: [*c]usize) c_int;
pub extern fn pthread_attr_setstacksize(__attr: [*c]pthread_attr_t, __stacksize: usize) c_int;
pub extern fn pthread_attr_getstack(noalias __attr: [*c]const pthread_attr_t, noalias __stackaddr: [*c]?*anyopaque, noalias __stacksize: [*c]usize) c_int;
pub extern fn pthread_attr_setstack(__attr: [*c]pthread_attr_t, __stackaddr: ?*anyopaque, __stacksize: usize) c_int;
pub extern fn pthread_attr_setaffinity_np(__attr: [*c]pthread_attr_t, __cpusetsize: usize, __cpuset: [*c]const cpu_set_t) c_int;
pub extern fn pthread_attr_getaffinity_np(__attr: [*c]const pthread_attr_t, __cpusetsize: usize, __cpuset: [*c]cpu_set_t) c_int;
pub extern fn pthread_getattr_default_np(__attr: [*c]pthread_attr_t) c_int;
pub extern fn pthread_attr_setsigmask_np(__attr: [*c]pthread_attr_t, sigmask: [*c]const __sigset_t) c_int;
pub extern fn pthread_attr_getsigmask_np(__attr: [*c]const pthread_attr_t, sigmask: [*c]__sigset_t) c_int;
pub extern fn pthread_setattr_default_np(__attr: [*c]const pthread_attr_t) c_int;
pub extern fn pthread_getattr_np(__th: pthread_t, __attr: [*c]pthread_attr_t) c_int;
pub extern fn pthread_setschedparam(__target_thread: pthread_t, __policy: c_int, __param: [*c]const struct_sched_param) c_int;
pub extern fn pthread_getschedparam(__target_thread: pthread_t, noalias __policy: [*c]c_int, noalias __param: [*c]struct_sched_param) c_int;
pub extern fn pthread_setschedprio(__target_thread: pthread_t, __prio: c_int) c_int;
pub extern fn pthread_getname_np(__target_thread: pthread_t, __buf: [*c]u8, __buflen: usize) c_int;
pub extern fn pthread_setname_np(__target_thread: pthread_t, __name: [*c]const u8) c_int;
pub extern fn pthread_getconcurrency() c_int;
pub extern fn pthread_setconcurrency(__level: c_int) c_int;
pub extern fn pthread_yield() c_int;
pub extern fn pthread_setaffinity_np(__th: pthread_t, __cpusetsize: usize, __cpuset: [*c]const cpu_set_t) c_int;
pub extern fn pthread_getaffinity_np(__th: pthread_t, __cpusetsize: usize, __cpuset: [*c]cpu_set_t) c_int;
pub extern fn pthread_once(__once_control: [*c]pthread_once_t, __init_routine: ?*const fn () callconv(.c) void) c_int;
pub extern fn pthread_setcancelstate(__state: c_int, __oldstate: [*c]c_int) c_int;
pub extern fn pthread_setcanceltype(__type: c_int, __oldtype: [*c]c_int) c_int;
pub extern fn pthread_cancel(__th: pthread_t) c_int;
pub extern fn pthread_testcancel() void;
pub const struct___cancel_jmp_buf_tag = extern struct {
    __cancel_jmp_buf: __jmp_buf = @import("std").mem.zeroes(__jmp_buf),
    __mask_was_saved: c_int = @import("std").mem.zeroes(c_int),
};
pub const __pthread_unwind_buf_t = extern struct {
    __cancel_jmp_buf: [1]struct___cancel_jmp_buf_tag = @import("std").mem.zeroes([1]struct___cancel_jmp_buf_tag),
    __pad: [4]?*anyopaque = @import("std").mem.zeroes([4]?*anyopaque),
};
pub const struct___pthread_cleanup_frame = extern struct {
    __cancel_routine: ?*const fn (?*anyopaque) callconv(.c) void = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) void),
    __cancel_arg: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    __do_it: c_int = @import("std").mem.zeroes(c_int),
    __cancel_type: c_int = @import("std").mem.zeroes(c_int),
};
pub extern fn __pthread_register_cancel(__buf: [*c]__pthread_unwind_buf_t) void;
pub extern fn __pthread_unregister_cancel(__buf: [*c]__pthread_unwind_buf_t) void;
pub extern fn __pthread_register_cancel_defer(__buf: [*c]__pthread_unwind_buf_t) void;
pub extern fn __pthread_unregister_cancel_restore(__buf: [*c]__pthread_unwind_buf_t) void;
pub extern fn __pthread_unwind_next(__buf: [*c]__pthread_unwind_buf_t) noreturn;
pub extern fn __sigsetjmp(__env: [*c]struct___jmp_buf_tag, __savemask: c_int) c_int;
pub extern fn pthread_mutex_init(__mutex: [*c]pthread_mutex_t, __mutexattr: [*c]const pthread_mutexattr_t) c_int;
pub extern fn pthread_mutex_destroy(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_trylock(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_lock(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_timedlock(noalias __mutex: [*c]pthread_mutex_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_mutex_clocklock(noalias __mutex: [*c]pthread_mutex_t, __clockid: clockid_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_mutex_unlock(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_getprioceiling(noalias __mutex: [*c]const pthread_mutex_t, noalias __prioceiling: [*c]c_int) c_int;
pub extern fn pthread_mutex_setprioceiling(noalias __mutex: [*c]pthread_mutex_t, __prioceiling: c_int, noalias __old_ceiling: [*c]c_int) c_int;
pub extern fn pthread_mutex_consistent(__mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutex_consistent_np([*c]pthread_mutex_t) c_int;
pub extern fn pthread_mutexattr_init(__attr: [*c]pthread_mutexattr_t) c_int;
pub extern fn pthread_mutexattr_destroy(__attr: [*c]pthread_mutexattr_t) c_int;
pub extern fn pthread_mutexattr_getpshared(noalias __attr: [*c]const pthread_mutexattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setpshared(__attr: [*c]pthread_mutexattr_t, __pshared: c_int) c_int;
pub extern fn pthread_mutexattr_gettype(noalias __attr: [*c]const pthread_mutexattr_t, noalias __kind: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_settype(__attr: [*c]pthread_mutexattr_t, __kind: c_int) c_int;
pub extern fn pthread_mutexattr_getprotocol(noalias __attr: [*c]const pthread_mutexattr_t, noalias __protocol: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setprotocol(__attr: [*c]pthread_mutexattr_t, __protocol: c_int) c_int;
pub extern fn pthread_mutexattr_getprioceiling(noalias __attr: [*c]const pthread_mutexattr_t, noalias __prioceiling: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setprioceiling(__attr: [*c]pthread_mutexattr_t, __prioceiling: c_int) c_int;
pub extern fn pthread_mutexattr_getrobust(__attr: [*c]const pthread_mutexattr_t, __robustness: [*c]c_int) c_int;
pub extern fn pthread_mutexattr_getrobust_np([*c]pthread_mutexattr_t, [*c]c_int) c_int;
pub extern fn pthread_mutexattr_setrobust(__attr: [*c]pthread_mutexattr_t, __robustness: c_int) c_int;
pub extern fn pthread_mutexattr_setrobust_np([*c]pthread_mutexattr_t, c_int) c_int;
pub extern fn pthread_rwlock_init(noalias __rwlock: [*c]pthread_rwlock_t, noalias __attr: [*c]const pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlock_destroy(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_rdlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_tryrdlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_timedrdlock(noalias __rwlock: [*c]pthread_rwlock_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_rwlock_clockrdlock(noalias __rwlock: [*c]pthread_rwlock_t, __clockid: clockid_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_rwlock_wrlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_trywrlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlock_timedwrlock(noalias __rwlock: [*c]pthread_rwlock_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_rwlock_clockwrlock(noalias __rwlock: [*c]pthread_rwlock_t, __clockid: clockid_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_rwlock_unlock(__rwlock: [*c]pthread_rwlock_t) c_int;
pub extern fn pthread_rwlockattr_init(__attr: [*c]pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlockattr_destroy(__attr: [*c]pthread_rwlockattr_t) c_int;
pub extern fn pthread_rwlockattr_getpshared(noalias __attr: [*c]const pthread_rwlockattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_rwlockattr_setpshared(__attr: [*c]pthread_rwlockattr_t, __pshared: c_int) c_int;
pub extern fn pthread_rwlockattr_getkind_np(noalias __attr: [*c]const pthread_rwlockattr_t, noalias __pref: [*c]c_int) c_int;
pub extern fn pthread_rwlockattr_setkind_np(__attr: [*c]pthread_rwlockattr_t, __pref: c_int) c_int;
pub extern fn pthread_cond_init(noalias __cond: [*c]pthread_cond_t, noalias __cond_attr: [*c]const pthread_condattr_t) c_int;
pub extern fn pthread_cond_destroy(__cond: [*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_signal(__cond: [*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_broadcast(__cond: [*c]pthread_cond_t) c_int;
pub extern fn pthread_cond_wait(noalias __cond: [*c]pthread_cond_t, noalias __mutex: [*c]pthread_mutex_t) c_int;
pub extern fn pthread_cond_timedwait(noalias __cond: [*c]pthread_cond_t, noalias __mutex: [*c]pthread_mutex_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_cond_clockwait(noalias __cond: [*c]pthread_cond_t, noalias __mutex: [*c]pthread_mutex_t, __clock_id: __clockid_t, noalias __abstime: [*c]const struct_timespec) c_int;
pub extern fn pthread_condattr_init(__attr: [*c]pthread_condattr_t) c_int;
pub extern fn pthread_condattr_destroy(__attr: [*c]pthread_condattr_t) c_int;
pub extern fn pthread_condattr_getpshared(noalias __attr: [*c]const pthread_condattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_condattr_setpshared(__attr: [*c]pthread_condattr_t, __pshared: c_int) c_int;
pub extern fn pthread_condattr_getclock(noalias __attr: [*c]const pthread_condattr_t, noalias __clock_id: [*c]__clockid_t) c_int;
pub extern fn pthread_condattr_setclock(__attr: [*c]pthread_condattr_t, __clock_id: __clockid_t) c_int;
pub extern fn pthread_spin_init(__lock: [*c]volatile pthread_spinlock_t, __pshared: c_int) c_int;
pub extern fn pthread_spin_destroy(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_spin_lock(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_spin_trylock(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_spin_unlock(__lock: [*c]volatile pthread_spinlock_t) c_int;
pub extern fn pthread_barrier_init(noalias __barrier: [*c]pthread_barrier_t, noalias __attr: [*c]const pthread_barrierattr_t, __count: c_uint) c_int;
pub extern fn pthread_barrier_destroy(__barrier: [*c]pthread_barrier_t) c_int;
pub extern fn pthread_barrier_wait(__barrier: [*c]pthread_barrier_t) c_int;
pub extern fn pthread_barrierattr_init(__attr: [*c]pthread_barrierattr_t) c_int;
pub extern fn pthread_barrierattr_destroy(__attr: [*c]pthread_barrierattr_t) c_int;
pub extern fn pthread_barrierattr_getpshared(noalias __attr: [*c]const pthread_barrierattr_t, noalias __pshared: [*c]c_int) c_int;
pub extern fn pthread_barrierattr_setpshared(__attr: [*c]pthread_barrierattr_t, __pshared: c_int) c_int;
pub extern fn pthread_key_create(__key: [*c]pthread_key_t, __destr_function: ?*const fn (?*anyopaque) callconv(.c) void) c_int;
pub extern fn pthread_key_delete(__key: pthread_key_t) c_int;
pub extern fn pthread_getspecific(__key: pthread_key_t) ?*anyopaque;
pub extern fn pthread_setspecific(__key: pthread_key_t, __pointer: ?*const anyopaque) c_int;
pub extern fn pthread_getcpuclockid(__thread_id: pthread_t, __clock_id: [*c]__clockid_t) c_int;
pub extern fn pthread_atfork(__prepare: ?*const fn () callconv(.c) void, __parent: ?*const fn () callconv(.c) void, __child: ?*const fn () callconv(.c) void) c_int;
pub const CRYPTO_ONCE = pthread_once_t;
pub const CRYPTO_THREAD_LOCAL = pthread_key_t;
pub const CRYPTO_THREAD_ID = pthread_t;
pub extern fn CRYPTO_THREAD_run_once(once: [*c]CRYPTO_ONCE, init: ?*const fn () callconv(.c) void) c_int;
pub extern fn CRYPTO_THREAD_init_local(key: [*c]CRYPTO_THREAD_LOCAL, cleanup: ?*const fn (?*anyopaque) callconv(.c) void) c_int;
pub extern fn CRYPTO_THREAD_get_local(key: [*c]CRYPTO_THREAD_LOCAL) ?*anyopaque;
pub extern fn CRYPTO_THREAD_set_local(key: [*c]CRYPTO_THREAD_LOCAL, val: ?*anyopaque) c_int;
pub extern fn CRYPTO_THREAD_cleanup_local(key: [*c]CRYPTO_THREAD_LOCAL) c_int;
pub extern fn CRYPTO_THREAD_get_current_id() CRYPTO_THREAD_ID;
pub extern fn CRYPTO_THREAD_compare_id(a: CRYPTO_THREAD_ID, b: CRYPTO_THREAD_ID) c_int;
pub extern fn OSSL_LIB_CTX_new() ?*OSSL_LIB_CTX;
pub extern fn OSSL_LIB_CTX_new_from_dispatch(handle: ?*const OSSL_CORE_HANDLE, in: [*c]const OSSL_DISPATCH) ?*OSSL_LIB_CTX;
pub extern fn OSSL_LIB_CTX_new_child(handle: ?*const OSSL_CORE_HANDLE, in: [*c]const OSSL_DISPATCH) ?*OSSL_LIB_CTX;
pub extern fn OSSL_LIB_CTX_load_config(ctx: ?*OSSL_LIB_CTX, config_file: [*c]const u8) c_int;
pub extern fn OSSL_LIB_CTX_free(?*OSSL_LIB_CTX) void;
pub extern fn OSSL_LIB_CTX_get0_global_default() ?*OSSL_LIB_CTX;
pub extern fn OSSL_LIB_CTX_set0_default(libctx: ?*OSSL_LIB_CTX) ?*OSSL_LIB_CTX;
pub extern fn OSSL_LIB_CTX_get_conf_diagnostics(ctx: ?*OSSL_LIB_CTX) c_int;
pub extern fn OSSL_LIB_CTX_set_conf_diagnostics(ctx: ?*OSSL_LIB_CTX, value: c_int) void;
pub extern fn OSSL_sleep(millis: u64) void;
pub extern fn OSSL_LIB_CTX_get_data(ctx: ?*OSSL_LIB_CTX, index: c_int) ?*anyopaque;
pub extern fn COMP_CTX_new(meth: ?*COMP_METHOD) ?*COMP_CTX;
pub extern fn COMP_CTX_get_method(ctx: ?*const COMP_CTX) ?*const COMP_METHOD;
pub extern fn COMP_CTX_get_type(comp: ?*const COMP_CTX) c_int;
pub extern fn COMP_get_type(meth: ?*const COMP_METHOD) c_int;
pub extern fn COMP_get_name(meth: ?*const COMP_METHOD) [*c]const u8;
pub extern fn COMP_CTX_free(ctx: ?*COMP_CTX) void;
pub extern fn COMP_compress_block(ctx: ?*COMP_CTX, out: [*c]u8, olen: c_int, in: [*c]u8, ilen: c_int) c_int;
pub extern fn COMP_expand_block(ctx: ?*COMP_CTX, out: [*c]u8, olen: c_int, in: [*c]u8, ilen: c_int) c_int;
pub extern fn COMP_zlib() ?*COMP_METHOD;
pub extern fn COMP_zlib_oneshot() ?*COMP_METHOD;
pub extern fn COMP_brotli() ?*COMP_METHOD;
pub extern fn COMP_brotli_oneshot() ?*COMP_METHOD;
pub extern fn COMP_zstd() ?*COMP_METHOD;
pub extern fn COMP_zstd_oneshot() ?*COMP_METHOD;
pub const struct_ssl_comp_st = opaque {};
pub const SSL_COMP = struct_ssl_comp_st;
pub const struct_stack_st_SSL_COMP = opaque {};
pub const sk_SSL_COMP_compfunc = ?*const fn ([*c]const ?*const SSL_COMP, [*c]const ?*const SSL_COMP) callconv(.c) c_int;
pub const sk_SSL_COMP_freefunc = ?*const fn (?*SSL_COMP) callconv(.c) void;
pub const sk_SSL_COMP_copyfunc = ?*const fn (?*const SSL_COMP) callconv(.c) ?*SSL_COMP;
pub fn ossl_check_SSL_COMP_type(arg_ptr: ?*SSL_COMP) callconv(.c) ?*SSL_COMP {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_SSL_COMP_sk_type(arg_sk: ?*const struct_stack_st_SSL_COMP) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SSL_COMP_sk_type(arg_sk: ?*struct_stack_st_SSL_COMP) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SSL_COMP_compfunc_type(arg_cmp: sk_SSL_COMP_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_SSL_COMP_copyfunc_type(arg_cpy: sk_SSL_COMP_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_SSL_COMP_freefunc_type(arg_fr: sk_SSL_COMP_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const union_bio_addr_st = opaque {};
pub const BIO_ADDR = union_bio_addr_st;
pub const struct_bio_addrinfo_st = opaque {};
pub const BIO_ADDRINFO = struct_bio_addrinfo_st;
pub extern fn BIO_get_new_index() c_int;
pub extern fn BIO_set_flags(b: ?*BIO, flags: c_int) void;
pub extern fn BIO_test_flags(b: ?*const BIO, flags: c_int) c_int;
pub extern fn BIO_clear_flags(b: ?*BIO, flags: c_int) void;
pub const BIO_callback_fn = ?*const fn (?*BIO, c_int, [*c]const u8, c_int, c_long, c_long) callconv(.c) c_long;
pub extern fn BIO_get_callback(b: ?*const BIO) BIO_callback_fn;
pub extern fn BIO_set_callback(b: ?*BIO, callback: BIO_callback_fn) void;
pub extern fn BIO_debug_callback(bio: ?*BIO, cmd: c_int, argp: [*c]const u8, argi: c_int, argl: c_long, ret: c_long) c_long;
pub const BIO_callback_fn_ex = ?*const fn (?*BIO, c_int, [*c]const u8, usize, c_int, c_long, c_int, [*c]usize) callconv(.c) c_long;
pub extern fn BIO_get_callback_ex(b: ?*const BIO) BIO_callback_fn_ex;
pub extern fn BIO_set_callback_ex(b: ?*BIO, callback: BIO_callback_fn_ex) void;
pub extern fn BIO_debug_callback_ex(bio: ?*BIO, oper: c_int, argp: [*c]const u8, len: usize, argi: c_int, argl: c_long, ret: c_int, processed: [*c]usize) c_long;
pub extern fn BIO_get_callback_arg(b: ?*const BIO) [*c]u8;
pub extern fn BIO_set_callback_arg(b: ?*BIO, arg: [*c]u8) void;
pub const struct_bio_method_st = opaque {};
pub const BIO_METHOD = struct_bio_method_st;
pub extern fn BIO_method_name(b: ?*const BIO) [*c]const u8;
pub extern fn BIO_method_type(b: ?*const BIO) c_int;
pub const BIO_info_cb = fn (?*BIO, c_int, c_int) callconv(.c) c_int;
pub const bio_info_cb = BIO_info_cb;
pub const struct_stack_st_BIO = opaque {};
pub const sk_BIO_compfunc = ?*const fn ([*c]const ?*const BIO, [*c]const ?*const BIO) callconv(.c) c_int;
pub const sk_BIO_freefunc = ?*const fn (?*BIO) callconv(.c) void;
pub const sk_BIO_copyfunc = ?*const fn (?*const BIO) callconv(.c) ?*BIO;
pub fn ossl_check_BIO_type(arg_ptr: ?*BIO) callconv(.c) ?*BIO {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_BIO_sk_type(arg_sk: ?*const struct_stack_st_BIO) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_BIO_sk_type(arg_sk: ?*struct_stack_st_BIO) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_BIO_compfunc_type(arg_cmp: sk_BIO_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_BIO_copyfunc_type(arg_cpy: sk_BIO_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_BIO_freefunc_type(arg_fr: sk_BIO_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const asn1_ps_func = fn (?*BIO, [*c][*c]u8, [*c]c_int, ?*anyopaque) callconv(.c) c_int;
pub const BIO_dgram_sctp_notification_handler_fn = ?*const fn (?*BIO, ?*anyopaque, ?*anyopaque) callconv(.c) void;
pub const struct_bio_msg_st = extern struct {
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    data_len: usize = @import("std").mem.zeroes(usize),
    peer: ?*BIO_ADDR = @import("std").mem.zeroes(?*BIO_ADDR),
    local: ?*BIO_ADDR = @import("std").mem.zeroes(?*BIO_ADDR),
    flags: u64 = @import("std").mem.zeroes(u64),
};
pub const BIO_MSG = struct_bio_msg_st;
pub const struct_bio_mmsg_cb_args_st = extern struct {
    msg: [*c]BIO_MSG = @import("std").mem.zeroes([*c]BIO_MSG),
    stride: usize = @import("std").mem.zeroes(usize),
    num_msg: usize = @import("std").mem.zeroes(usize),
    flags: u64 = @import("std").mem.zeroes(u64),
    msgs_processed: [*c]usize = @import("std").mem.zeroes([*c]usize),
};
pub const BIO_MMSG_CB_ARGS = struct_bio_mmsg_cb_args_st;
const union_unnamed_97 = extern union {
    fd: c_int,
    custom: ?*anyopaque,
    custom_ui: usize,
    ssl: ?*SSL,
};
pub const struct_bio_poll_descriptor_st = extern struct {
    type: u32 = @import("std").mem.zeroes(u32),
    value: union_unnamed_97 = @import("std").mem.zeroes(union_unnamed_97),
};
pub const BIO_POLL_DESCRIPTOR = struct_bio_poll_descriptor_st;
pub extern fn BIO_ctrl_pending(b: ?*BIO) usize;
pub extern fn BIO_ctrl_wpending(b: ?*BIO) usize;
pub extern fn BIO_ctrl_get_write_guarantee(b: ?*BIO) usize;
pub extern fn BIO_ctrl_get_read_request(b: ?*BIO) usize;
pub extern fn BIO_ctrl_reset_read_request(b: ?*BIO) c_int;
pub extern fn BIO_set_ex_data(bio: ?*BIO, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn BIO_get_ex_data(bio: ?*const BIO, idx: c_int) ?*anyopaque;
pub extern fn BIO_number_read(bio: ?*BIO) u64;
pub extern fn BIO_number_written(bio: ?*BIO) u64;
pub extern fn BIO_asn1_set_prefix(b: ?*BIO, prefix: ?*const asn1_ps_func, prefix_free: ?*const asn1_ps_func) c_int;
pub extern fn BIO_asn1_get_prefix(b: ?*BIO, pprefix: [*c]?*const asn1_ps_func, pprefix_free: [*c]?*const asn1_ps_func) c_int;
pub extern fn BIO_asn1_set_suffix(b: ?*BIO, suffix: ?*const asn1_ps_func, suffix_free: ?*const asn1_ps_func) c_int;
pub extern fn BIO_asn1_get_suffix(b: ?*BIO, psuffix: [*c]?*const asn1_ps_func, psuffix_free: [*c]?*const asn1_ps_func) c_int;
pub extern fn BIO_s_file() ?*const BIO_METHOD;
pub extern fn BIO_new_file(filename: [*c]const u8, mode: [*c]const u8) ?*BIO;
pub extern fn BIO_new_from_core_bio(libctx: ?*OSSL_LIB_CTX, corebio: ?*OSSL_CORE_BIO) ?*BIO;
pub extern fn BIO_new_fp(stream: [*c]FILE, close_flag: c_int) ?*BIO;
pub extern fn BIO_new_ex(libctx: ?*OSSL_LIB_CTX, method: ?*const BIO_METHOD) ?*BIO;
pub extern fn BIO_new(@"type": ?*const BIO_METHOD) ?*BIO;
pub extern fn BIO_free(a: ?*BIO) c_int;
pub extern fn BIO_set_data(a: ?*BIO, ptr: ?*anyopaque) void;
pub extern fn BIO_get_data(a: ?*BIO) ?*anyopaque;
pub extern fn BIO_set_init(a: ?*BIO, init: c_int) void;
pub extern fn BIO_get_init(a: ?*BIO) c_int;
pub extern fn BIO_set_shutdown(a: ?*BIO, shut: c_int) void;
pub extern fn BIO_get_shutdown(a: ?*BIO) c_int;
pub extern fn BIO_vfree(a: ?*BIO) void;
pub extern fn BIO_up_ref(a: ?*BIO) c_int;
pub extern fn BIO_read(b: ?*BIO, data: ?*anyopaque, dlen: c_int) c_int;
pub extern fn BIO_read_ex(b: ?*BIO, data: ?*anyopaque, dlen: usize, readbytes: [*c]usize) c_int;
pub extern fn BIO_recvmmsg(b: ?*BIO, msg: [*c]BIO_MSG, stride: usize, num_msg: usize, flags: u64, msgs_processed: [*c]usize) c_int;
pub extern fn BIO_gets(bp: ?*BIO, buf: [*c]u8, size: c_int) c_int;
pub extern fn BIO_get_line(bio: ?*BIO, buf: [*c]u8, size: c_int) c_int;
pub extern fn BIO_write(b: ?*BIO, data: ?*const anyopaque, dlen: c_int) c_int;
pub extern fn BIO_write_ex(b: ?*BIO, data: ?*const anyopaque, dlen: usize, written: [*c]usize) c_int;
pub extern fn BIO_sendmmsg(b: ?*BIO, msg: [*c]BIO_MSG, stride: usize, num_msg: usize, flags: u64, msgs_processed: [*c]usize) c_int;
pub extern fn BIO_get_rpoll_descriptor(b: ?*BIO, desc: [*c]BIO_POLL_DESCRIPTOR) c_int;
pub extern fn BIO_get_wpoll_descriptor(b: ?*BIO, desc: [*c]BIO_POLL_DESCRIPTOR) c_int;
pub extern fn BIO_puts(bp: ?*BIO, buf: [*c]const u8) c_int;
pub extern fn BIO_indent(b: ?*BIO, indent: c_int, max: c_int) c_int;
pub extern fn BIO_ctrl(bp: ?*BIO, cmd: c_int, larg: c_long, parg: ?*anyopaque) c_long;
pub extern fn BIO_callback_ctrl(b: ?*BIO, cmd: c_int, fp: ?*const BIO_info_cb) c_long;
pub extern fn BIO_ptr_ctrl(bp: ?*BIO, cmd: c_int, larg: c_long) ?*anyopaque;
pub extern fn BIO_int_ctrl(bp: ?*BIO, cmd: c_int, larg: c_long, iarg: c_int) c_long;
pub extern fn BIO_push(b: ?*BIO, append: ?*BIO) ?*BIO;
pub extern fn BIO_pop(b: ?*BIO) ?*BIO;
pub extern fn BIO_free_all(a: ?*BIO) void;
pub extern fn BIO_find_type(b: ?*BIO, bio_type: c_int) ?*BIO;
pub extern fn BIO_next(b: ?*BIO) ?*BIO;
pub extern fn BIO_set_next(b: ?*BIO, next: ?*BIO) void;
pub extern fn BIO_get_retry_BIO(bio: ?*BIO, reason: [*c]c_int) ?*BIO;
pub extern fn BIO_get_retry_reason(bio: ?*BIO) c_int;
pub extern fn BIO_set_retry_reason(bio: ?*BIO, reason: c_int) void;
pub extern fn BIO_dup_chain(in: ?*BIO) ?*BIO;
pub extern fn BIO_nread0(bio: ?*BIO, buf: [*c][*c]u8) c_int;
pub extern fn BIO_nread(bio: ?*BIO, buf: [*c][*c]u8, num: c_int) c_int;
pub extern fn BIO_nwrite0(bio: ?*BIO, buf: [*c][*c]u8) c_int;
pub extern fn BIO_nwrite(bio: ?*BIO, buf: [*c][*c]u8, num: c_int) c_int;
pub extern fn BIO_s_mem() ?*const BIO_METHOD;
pub extern fn BIO_s_dgram_mem() ?*const BIO_METHOD;
pub extern fn BIO_s_secmem() ?*const BIO_METHOD;
pub extern fn BIO_new_mem_buf(buf: ?*const anyopaque, len: c_int) ?*BIO;
pub extern fn BIO_s_socket() ?*const BIO_METHOD;
pub extern fn BIO_s_connect() ?*const BIO_METHOD;
pub extern fn BIO_s_accept() ?*const BIO_METHOD;
pub extern fn BIO_s_fd() ?*const BIO_METHOD;
pub extern fn BIO_s_log() ?*const BIO_METHOD;
pub extern fn BIO_s_bio() ?*const BIO_METHOD;
pub extern fn BIO_s_null() ?*const BIO_METHOD;
pub extern fn BIO_f_null() ?*const BIO_METHOD;
pub extern fn BIO_f_buffer() ?*const BIO_METHOD;
pub extern fn BIO_f_readbuffer() ?*const BIO_METHOD;
pub extern fn BIO_f_linebuffer() ?*const BIO_METHOD;
pub extern fn BIO_f_nbio_test() ?*const BIO_METHOD;
pub extern fn BIO_f_prefix() ?*const BIO_METHOD;
pub extern fn BIO_s_core() ?*const BIO_METHOD;
pub extern fn BIO_s_dgram_pair() ?*const BIO_METHOD;
pub extern fn BIO_s_datagram() ?*const BIO_METHOD;
pub extern fn BIO_dgram_non_fatal_error(@"error": c_int) c_int;
pub extern fn BIO_new_dgram(fd: c_int, close_flag: c_int) ?*BIO;
pub extern fn BIO_sock_should_retry(i: c_int) c_int;
pub extern fn BIO_sock_non_fatal_error(@"error": c_int) c_int;
pub extern fn BIO_err_is_non_fatal(errcode: c_uint) c_int;
pub extern fn BIO_socket_wait(fd: c_int, for_read: c_int, max_time: time_t) c_int;
pub extern fn BIO_wait(bio: ?*BIO, max_time: time_t, nap_milliseconds: c_uint) c_int;
pub extern fn BIO_do_connect_retry(bio: ?*BIO, timeout: c_int, nap_milliseconds: c_int) c_int;
pub extern fn BIO_fd_should_retry(i: c_int) c_int;
pub extern fn BIO_fd_non_fatal_error(@"error": c_int) c_int;
pub extern fn BIO_dump_cb(cb: ?*const fn (?*const anyopaque, usize, ?*anyopaque) callconv(.c) c_int, u: ?*anyopaque, s: ?*const anyopaque, len: c_int) c_int;
pub extern fn BIO_dump_indent_cb(cb: ?*const fn (?*const anyopaque, usize, ?*anyopaque) callconv(.c) c_int, u: ?*anyopaque, s: ?*const anyopaque, len: c_int, indent: c_int) c_int;
pub extern fn BIO_dump(b: ?*BIO, bytes: ?*const anyopaque, len: c_int) c_int;
pub extern fn BIO_dump_indent(b: ?*BIO, bytes: ?*const anyopaque, len: c_int, indent: c_int) c_int;
pub extern fn BIO_dump_fp(fp: [*c]FILE, s: ?*const anyopaque, len: c_int) c_int;
pub extern fn BIO_dump_indent_fp(fp: [*c]FILE, s: ?*const anyopaque, len: c_int, indent: c_int) c_int;
pub extern fn BIO_hex_string(out: ?*BIO, indent: c_int, width: c_int, data: ?*const anyopaque, datalen: c_int) c_int;
pub extern fn BIO_ADDR_new() ?*BIO_ADDR;
pub extern fn BIO_ADDR_copy(dst: ?*BIO_ADDR, src: ?*const BIO_ADDR) c_int;
pub extern fn BIO_ADDR_dup(ap: ?*const BIO_ADDR) ?*BIO_ADDR;
pub extern fn BIO_ADDR_rawmake(ap: ?*BIO_ADDR, family: c_int, where: ?*const anyopaque, wherelen: usize, port: c_ushort) c_int;
pub extern fn BIO_ADDR_free(?*BIO_ADDR) void;
pub extern fn BIO_ADDR_clear(ap: ?*BIO_ADDR) void;
pub extern fn BIO_ADDR_family(ap: ?*const BIO_ADDR) c_int;
pub extern fn BIO_ADDR_rawaddress(ap: ?*const BIO_ADDR, p: ?*anyopaque, l: [*c]usize) c_int;
pub extern fn BIO_ADDR_rawport(ap: ?*const BIO_ADDR) c_ushort;
pub extern fn BIO_ADDR_hostname_string(ap: ?*const BIO_ADDR, numeric: c_int) [*c]u8;
pub extern fn BIO_ADDR_service_string(ap: ?*const BIO_ADDR, numeric: c_int) [*c]u8;
pub extern fn BIO_ADDR_path_string(ap: ?*const BIO_ADDR) [*c]u8;
pub extern fn BIO_ADDRINFO_next(bai: ?*const BIO_ADDRINFO) ?*const BIO_ADDRINFO;
pub extern fn BIO_ADDRINFO_family(bai: ?*const BIO_ADDRINFO) c_int;
pub extern fn BIO_ADDRINFO_socktype(bai: ?*const BIO_ADDRINFO) c_int;
pub extern fn BIO_ADDRINFO_protocol(bai: ?*const BIO_ADDRINFO) c_int;
pub extern fn BIO_ADDRINFO_address(bai: ?*const BIO_ADDRINFO) ?*const BIO_ADDR;
pub extern fn BIO_ADDRINFO_free(bai: ?*BIO_ADDRINFO) void;
pub const BIO_PARSE_PRIO_HOST: c_int = 0;
pub const BIO_PARSE_PRIO_SERV: c_int = 1;
pub const enum_BIO_hostserv_priorities = c_uint;
pub extern fn BIO_parse_hostserv(hostserv: [*c]const u8, host: [*c][*c]u8, service: [*c][*c]u8, hostserv_prio: enum_BIO_hostserv_priorities) c_int;
pub const BIO_LOOKUP_CLIENT: c_int = 0;
pub const BIO_LOOKUP_SERVER: c_int = 1;
pub const enum_BIO_lookup_type = c_uint;
pub extern fn BIO_lookup(host: [*c]const u8, service: [*c]const u8, lookup_type: enum_BIO_lookup_type, family: c_int, socktype: c_int, res: [*c]?*BIO_ADDRINFO) c_int;
pub extern fn BIO_lookup_ex(host: [*c]const u8, service: [*c]const u8, lookup_type: c_int, family: c_int, socktype: c_int, protocol: c_int, res: [*c]?*BIO_ADDRINFO) c_int;
pub extern fn BIO_sock_error(sock: c_int) c_int;
pub extern fn BIO_socket_ioctl(fd: c_int, @"type": c_long, arg: ?*anyopaque) c_int;
pub extern fn BIO_socket_nbio(fd: c_int, mode: c_int) c_int;
pub extern fn BIO_sock_init() c_int;
pub extern fn BIO_set_tcp_ndelay(sock: c_int, turn_on: c_int) c_int;
pub extern fn BIO_gethostbyname(name: [*c]const u8) [*c]struct_hostent;
pub extern fn BIO_get_port(str: [*c]const u8, port_ptr: [*c]c_ushort) c_int;
pub extern fn BIO_get_host_ip(str: [*c]const u8, ip: [*c]u8) c_int;
pub extern fn BIO_get_accept_socket(host_port: [*c]u8, mode: c_int) c_int;
pub extern fn BIO_accept(sock: c_int, ip_port: [*c][*c]u8) c_int;
pub const union_BIO_sock_info_u = extern union {
    addr: ?*BIO_ADDR,
};
pub const BIO_SOCK_INFO_ADDRESS: c_int = 0;
pub const enum_BIO_sock_info_type = c_uint;
pub extern fn BIO_sock_info(sock: c_int, @"type": enum_BIO_sock_info_type, info: [*c]union_BIO_sock_info_u) c_int;
pub extern fn BIO_socket(domain: c_int, socktype: c_int, protocol: c_int, options: c_int) c_int;
pub extern fn BIO_connect(sock: c_int, addr: ?*const BIO_ADDR, options: c_int) c_int;
pub extern fn BIO_bind(sock: c_int, addr: ?*const BIO_ADDR, options: c_int) c_int;
pub extern fn BIO_listen(sock: c_int, addr: ?*const BIO_ADDR, options: c_int) c_int;
pub extern fn BIO_accept_ex(accept_sock: c_int, addr: ?*BIO_ADDR, options: c_int) c_int;
pub extern fn BIO_closesocket(sock: c_int) c_int;
pub extern fn BIO_new_socket(sock: c_int, close_flag: c_int) ?*BIO;
pub extern fn BIO_new_connect(host_port: [*c]const u8) ?*BIO;
pub extern fn BIO_new_accept(host_port: [*c]const u8) ?*BIO;
pub extern fn BIO_new_fd(fd: c_int, close_flag: c_int) ?*BIO;
pub extern fn BIO_new_bio_pair(bio1: [*c]?*BIO, writebuf1: usize, bio2: [*c]?*BIO, writebuf2: usize) c_int;
pub extern fn BIO_new_bio_dgram_pair(bio1: [*c]?*BIO, writebuf1: usize, bio2: [*c]?*BIO, writebuf2: usize) c_int;
pub extern fn BIO_copy_next_retry(b: ?*BIO) void;
pub extern fn BIO_printf(bio: ?*BIO, format: [*c]const u8, ...) c_int;
pub extern fn BIO_vprintf(bio: ?*BIO, format: [*c]const u8, args: [*c]struct___va_list_tag_5) c_int;
pub extern fn BIO_snprintf(buf: [*c]u8, n: usize, format: [*c]const u8, ...) c_int;
pub extern fn BIO_vsnprintf(buf: [*c]u8, n: usize, format: [*c]const u8, args: [*c]struct___va_list_tag_5) c_int;
pub extern fn BIO_meth_new(@"type": c_int, name: [*c]const u8) ?*BIO_METHOD;
pub extern fn BIO_meth_free(biom: ?*BIO_METHOD) void;
pub extern fn BIO_meth_get_write(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]const u8, c_int) callconv(.c) c_int;
pub extern fn BIO_meth_get_write_ex(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]const u8, usize, [*c]usize) callconv(.c) c_int;
pub extern fn BIO_meth_set_write(biom: ?*BIO_METHOD, write: ?*const fn (?*BIO, [*c]const u8, c_int) callconv(.c) c_int) c_int;
pub extern fn BIO_meth_set_write_ex(biom: ?*BIO_METHOD, bwrite: ?*const fn (?*BIO, [*c]const u8, usize, [*c]usize) callconv(.c) c_int) c_int;
pub extern fn BIO_meth_set_sendmmsg(biom: ?*BIO_METHOD, f: ?*const fn (?*BIO, [*c]BIO_MSG, usize, usize, u64, [*c]usize) callconv(.c) c_int) c_int;
pub extern fn BIO_meth_get_sendmmsg(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]BIO_MSG, usize, usize, u64, [*c]usize) callconv(.c) c_int;
pub extern fn BIO_meth_get_read(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]u8, c_int) callconv(.c) c_int;
pub extern fn BIO_meth_get_read_ex(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]u8, usize, [*c]usize) callconv(.c) c_int;
pub extern fn BIO_meth_set_read(biom: ?*BIO_METHOD, read: ?*const fn (?*BIO, [*c]u8, c_int) callconv(.c) c_int) c_int;
pub extern fn BIO_meth_set_read_ex(biom: ?*BIO_METHOD, bread: ?*const fn (?*BIO, [*c]u8, usize, [*c]usize) callconv(.c) c_int) c_int;
pub extern fn BIO_meth_set_recvmmsg(biom: ?*BIO_METHOD, f: ?*const fn (?*BIO, [*c]BIO_MSG, usize, usize, u64, [*c]usize) callconv(.c) c_int) c_int;
pub extern fn BIO_meth_get_recvmmsg(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]BIO_MSG, usize, usize, u64, [*c]usize) callconv(.c) c_int;
pub extern fn BIO_meth_get_puts(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]const u8) callconv(.c) c_int;
pub extern fn BIO_meth_set_puts(biom: ?*BIO_METHOD, puts: ?*const fn (?*BIO, [*c]const u8) callconv(.c) c_int) c_int;
pub extern fn BIO_meth_get_gets(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, [*c]u8, c_int) callconv(.c) c_int;
pub extern fn BIO_meth_set_gets(biom: ?*BIO_METHOD, ossl_gets: ?*const fn (?*BIO, [*c]u8, c_int) callconv(.c) c_int) c_int;
pub extern fn BIO_meth_get_ctrl(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, c_int, c_long, ?*anyopaque) callconv(.c) c_long;
pub extern fn BIO_meth_set_ctrl(biom: ?*BIO_METHOD, ctrl: ?*const fn (?*BIO, c_int, c_long, ?*anyopaque) callconv(.c) c_long) c_int;
pub extern fn BIO_meth_get_create(bion: ?*const BIO_METHOD) ?*const fn (?*BIO) callconv(.c) c_int;
pub extern fn BIO_meth_set_create(biom: ?*BIO_METHOD, create: ?*const fn (?*BIO) callconv(.c) c_int) c_int;
pub extern fn BIO_meth_get_destroy(biom: ?*const BIO_METHOD) ?*const fn (?*BIO) callconv(.c) c_int;
pub extern fn BIO_meth_set_destroy(biom: ?*BIO_METHOD, destroy: ?*const fn (?*BIO) callconv(.c) c_int) c_int;
pub extern fn BIO_meth_get_callback_ctrl(biom: ?*const BIO_METHOD) ?*const fn (?*BIO, c_int, ?*const BIO_info_cb) callconv(.c) c_long;
pub extern fn BIO_meth_set_callback_ctrl(biom: ?*BIO_METHOD, callback_ctrl: ?*const fn (?*BIO, c_int, ?*const BIO_info_cb) callconv(.c) c_long) c_int;
pub extern fn BUF_MEM_new() [*c]BUF_MEM;
pub extern fn BUF_MEM_new_ex(flags: c_ulong) [*c]BUF_MEM;
pub extern fn BUF_MEM_free(a: [*c]BUF_MEM) void;
pub extern fn BUF_MEM_grow(str: [*c]BUF_MEM, len: usize) usize;
pub extern fn BUF_MEM_grow_clean(str: [*c]BUF_MEM, len: usize) usize;
pub extern fn BUF_reverse(out: [*c]u8, in: [*c]const u8, siz: usize) void;
pub extern fn BN_set_flags(b: ?*BIGNUM, n: c_int) void;
pub extern fn BN_get_flags(b: ?*const BIGNUM, n: c_int) c_int;
pub extern fn BN_with_flags(dest: ?*BIGNUM, b: ?*const BIGNUM, flags: c_int) void;
pub extern fn BN_GENCB_call(cb: ?*BN_GENCB, a: c_int, b: c_int) c_int;
pub extern fn BN_GENCB_new() ?*BN_GENCB;
pub extern fn BN_GENCB_free(cb: ?*BN_GENCB) void;
pub extern fn BN_GENCB_set_old(gencb: ?*BN_GENCB, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.c) void, cb_arg: ?*anyopaque) void;
pub extern fn BN_GENCB_set(gencb: ?*BN_GENCB, callback: ?*const fn (c_int, c_int, ?*BN_GENCB) callconv(.c) c_int, cb_arg: ?*anyopaque) void;
pub extern fn BN_GENCB_get_arg(cb: ?*BN_GENCB) ?*anyopaque;
pub extern fn BN_abs_is_word(a: ?*const BIGNUM, w: c_ulong) c_int;
pub extern fn BN_is_zero(a: ?*const BIGNUM) c_int;
pub extern fn BN_is_one(a: ?*const BIGNUM) c_int;
pub extern fn BN_is_word(a: ?*const BIGNUM, w: c_ulong) c_int;
pub extern fn BN_is_odd(a: ?*const BIGNUM) c_int;
pub extern fn BN_zero_ex(a: ?*BIGNUM) void;
pub extern fn BN_value_one() ?*const BIGNUM;
pub extern fn BN_options() [*c]u8;
pub extern fn BN_CTX_new_ex(ctx: ?*OSSL_LIB_CTX) ?*BN_CTX;
pub extern fn BN_CTX_new() ?*BN_CTX;
pub extern fn BN_CTX_secure_new_ex(ctx: ?*OSSL_LIB_CTX) ?*BN_CTX;
pub extern fn BN_CTX_secure_new() ?*BN_CTX;
pub extern fn BN_CTX_free(c: ?*BN_CTX) void;
pub extern fn BN_CTX_start(ctx: ?*BN_CTX) void;
pub extern fn BN_CTX_get(ctx: ?*BN_CTX) ?*BIGNUM;
pub extern fn BN_CTX_end(ctx: ?*BN_CTX) void;
pub extern fn BN_rand_ex(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int, strength: c_uint, ctx: ?*BN_CTX) c_int;
pub extern fn BN_rand(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int) c_int;
pub extern fn BN_priv_rand_ex(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int, strength: c_uint, ctx: ?*BN_CTX) c_int;
pub extern fn BN_priv_rand(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int) c_int;
pub extern fn BN_rand_range_ex(r: ?*BIGNUM, range: ?*const BIGNUM, strength: c_uint, ctx: ?*BN_CTX) c_int;
pub extern fn BN_rand_range(rnd: ?*BIGNUM, range: ?*const BIGNUM) c_int;
pub extern fn BN_priv_rand_range_ex(r: ?*BIGNUM, range: ?*const BIGNUM, strength: c_uint, ctx: ?*BN_CTX) c_int;
pub extern fn BN_priv_rand_range(rnd: ?*BIGNUM, range: ?*const BIGNUM) c_int;
pub extern fn BN_pseudo_rand(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int) c_int;
pub extern fn BN_pseudo_rand_range(rnd: ?*BIGNUM, range: ?*const BIGNUM) c_int;
pub extern fn BN_num_bits(a: ?*const BIGNUM) c_int;
pub extern fn BN_num_bits_word(l: c_ulong) c_int;
pub extern fn BN_security_bits(L: c_int, N: c_int) c_int;
pub extern fn BN_new() ?*BIGNUM;
pub extern fn BN_secure_new() ?*BIGNUM;
pub extern fn BN_clear_free(a: ?*BIGNUM) void;
pub extern fn BN_copy(a: ?*BIGNUM, b: ?*const BIGNUM) ?*BIGNUM;
pub extern fn BN_swap(a: ?*BIGNUM, b: ?*BIGNUM) void;
pub extern fn BN_bin2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_signed_bin2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_bn2bin(a: ?*const BIGNUM, to: [*c]u8) c_int;
pub extern fn BN_bn2binpad(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_signed_bn2bin(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_lebin2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_signed_lebin2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_bn2lebinpad(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_signed_bn2lebin(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_native2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_signed_native2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_bn2nativepad(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_signed_bn2native(a: ?*const BIGNUM, to: [*c]u8, tolen: c_int) c_int;
pub extern fn BN_mpi2bn(s: [*c]const u8, len: c_int, ret: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_bn2mpi(a: ?*const BIGNUM, to: [*c]u8) c_int;
pub extern fn BN_sub(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_usub(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_uadd(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_add(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_mul(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_sqr(r: ?*BIGNUM, a: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_set_negative(b: ?*BIGNUM, n: c_int) void;
pub extern fn BN_is_negative(b: ?*const BIGNUM) c_int;
pub extern fn BN_div(dv: ?*BIGNUM, rem: ?*BIGNUM, m: ?*const BIGNUM, d: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_nnmod(r: ?*BIGNUM, m: ?*const BIGNUM, d: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_add(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_add_quick(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, m: ?*const BIGNUM) c_int;
pub extern fn BN_mod_sub(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_sub_quick(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, m: ?*const BIGNUM) c_int;
pub extern fn BN_mod_mul(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_sqr(r: ?*BIGNUM, a: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_lshift1(r: ?*BIGNUM, a: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_lshift1_quick(r: ?*BIGNUM, a: ?*const BIGNUM, m: ?*const BIGNUM) c_int;
pub extern fn BN_mod_lshift(r: ?*BIGNUM, a: ?*const BIGNUM, n: c_int, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_lshift_quick(r: ?*BIGNUM, a: ?*const BIGNUM, n: c_int, m: ?*const BIGNUM) c_int;
pub extern fn BN_mod_word(a: ?*const BIGNUM, w: c_ulong) c_ulong;
pub extern fn BN_div_word(a: ?*BIGNUM, w: c_ulong) c_ulong;
pub extern fn BN_mul_word(a: ?*BIGNUM, w: c_ulong) c_int;
pub extern fn BN_add_word(a: ?*BIGNUM, w: c_ulong) c_int;
pub extern fn BN_sub_word(a: ?*BIGNUM, w: c_ulong) c_int;
pub extern fn BN_set_word(a: ?*BIGNUM, w: c_ulong) c_int;
pub extern fn BN_get_word(a: ?*const BIGNUM) c_ulong;
pub extern fn BN_cmp(a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_free(a: ?*BIGNUM) void;
pub extern fn BN_is_bit_set(a: ?*const BIGNUM, n: c_int) c_int;
pub extern fn BN_lshift(r: ?*BIGNUM, a: ?*const BIGNUM, n: c_int) c_int;
pub extern fn BN_lshift1(r: ?*BIGNUM, a: ?*const BIGNUM) c_int;
pub extern fn BN_exp(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_exp(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_exp_mont(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX, m_ctx: ?*BN_MONT_CTX) c_int;
pub extern fn BN_mod_exp_mont_consttime(rr: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX, in_mont: ?*BN_MONT_CTX) c_int;
pub extern fn BN_mod_exp_mont_word(r: ?*BIGNUM, a: c_ulong, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX, m_ctx: ?*BN_MONT_CTX) c_int;
pub extern fn BN_mod_exp2_mont(r: ?*BIGNUM, a1: ?*const BIGNUM, p1: ?*const BIGNUM, a2: ?*const BIGNUM, p2: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX, m_ctx: ?*BN_MONT_CTX) c_int;
pub extern fn BN_mod_exp_simple(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_exp_mont_consttime_x2(rr1: ?*BIGNUM, a1: ?*const BIGNUM, p1: ?*const BIGNUM, m1: ?*const BIGNUM, in_mont1: ?*BN_MONT_CTX, rr2: ?*BIGNUM, a2: ?*const BIGNUM, p2: ?*const BIGNUM, m2: ?*const BIGNUM, in_mont2: ?*BN_MONT_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mask_bits(a: ?*BIGNUM, n: c_int) c_int;
pub extern fn BN_print_fp(fp: [*c]FILE, a: ?*const BIGNUM) c_int;
pub extern fn BN_print(bio: ?*BIO, a: ?*const BIGNUM) c_int;
pub extern fn BN_reciprocal(r: ?*BIGNUM, m: ?*const BIGNUM, len: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_rshift(r: ?*BIGNUM, a: ?*const BIGNUM, n: c_int) c_int;
pub extern fn BN_rshift1(r: ?*BIGNUM, a: ?*const BIGNUM) c_int;
pub extern fn BN_clear(a: ?*BIGNUM) void;
pub extern fn BN_dup(a: ?*const BIGNUM) ?*BIGNUM;
pub extern fn BN_ucmp(a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_set_bit(a: ?*BIGNUM, n: c_int) c_int;
pub extern fn BN_clear_bit(a: ?*BIGNUM, n: c_int) c_int;
pub extern fn BN_bn2hex(a: ?*const BIGNUM) [*c]u8;
pub extern fn BN_bn2dec(a: ?*const BIGNUM) [*c]u8;
pub extern fn BN_hex2bn(a: [*c]?*BIGNUM, str: [*c]const u8) c_int;
pub extern fn BN_dec2bn(a: [*c]?*BIGNUM, str: [*c]const u8) c_int;
pub extern fn BN_asc2bn(a: [*c]?*BIGNUM, str: [*c]const u8) c_int;
pub extern fn BN_gcd(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_kronecker(a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_are_coprime(a: ?*BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_inverse(ret: ?*BIGNUM, a: ?*const BIGNUM, n: ?*const BIGNUM, ctx: ?*BN_CTX) ?*BIGNUM;
pub extern fn BN_mod_sqrt(ret: ?*BIGNUM, a: ?*const BIGNUM, n: ?*const BIGNUM, ctx: ?*BN_CTX) ?*BIGNUM;
pub extern fn BN_consttime_swap(swap: c_ulong, a: ?*BIGNUM, b: ?*BIGNUM, nwords: c_int) void;
pub extern fn BN_generate_prime(ret: ?*BIGNUM, bits: c_int, safe: c_int, add: ?*const BIGNUM, rem: ?*const BIGNUM, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.c) void, cb_arg: ?*anyopaque) ?*BIGNUM;
pub extern fn BN_is_prime(p: ?*const BIGNUM, nchecks: c_int, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.c) void, ctx: ?*BN_CTX, cb_arg: ?*anyopaque) c_int;
pub extern fn BN_is_prime_fasttest(p: ?*const BIGNUM, nchecks: c_int, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.c) void, ctx: ?*BN_CTX, cb_arg: ?*anyopaque, do_trial_division: c_int) c_int;
pub extern fn BN_is_prime_ex(p: ?*const BIGNUM, nchecks: c_int, ctx: ?*BN_CTX, cb: ?*BN_GENCB) c_int;
pub extern fn BN_is_prime_fasttest_ex(p: ?*const BIGNUM, nchecks: c_int, ctx: ?*BN_CTX, do_trial_division: c_int, cb: ?*BN_GENCB) c_int;
pub extern fn BN_generate_prime_ex2(ret: ?*BIGNUM, bits: c_int, safe: c_int, add: ?*const BIGNUM, rem: ?*const BIGNUM, cb: ?*BN_GENCB, ctx: ?*BN_CTX) c_int;
pub extern fn BN_generate_prime_ex(ret: ?*BIGNUM, bits: c_int, safe: c_int, add: ?*const BIGNUM, rem: ?*const BIGNUM, cb: ?*BN_GENCB) c_int;
pub extern fn BN_check_prime(p: ?*const BIGNUM, ctx: ?*BN_CTX, cb: ?*BN_GENCB) c_int;
pub extern fn BN_X931_generate_Xpq(Xp: ?*BIGNUM, Xq: ?*BIGNUM, nbits: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_X931_derive_prime_ex(p: ?*BIGNUM, p1: ?*BIGNUM, p2: ?*BIGNUM, Xp: ?*const BIGNUM, Xp1: ?*const BIGNUM, Xp2: ?*const BIGNUM, e: ?*const BIGNUM, ctx: ?*BN_CTX, cb: ?*BN_GENCB) c_int;
pub extern fn BN_X931_generate_prime_ex(p: ?*BIGNUM, p1: ?*BIGNUM, p2: ?*BIGNUM, Xp1: ?*BIGNUM, Xp2: ?*BIGNUM, Xp: ?*const BIGNUM, e: ?*const BIGNUM, ctx: ?*BN_CTX, cb: ?*BN_GENCB) c_int;
pub extern fn BN_MONT_CTX_new() ?*BN_MONT_CTX;
pub extern fn BN_mod_mul_montgomery(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, mont: ?*BN_MONT_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_to_montgomery(r: ?*BIGNUM, a: ?*const BIGNUM, mont: ?*BN_MONT_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_from_montgomery(r: ?*BIGNUM, a: ?*const BIGNUM, mont: ?*BN_MONT_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_MONT_CTX_free(mont: ?*BN_MONT_CTX) void;
pub extern fn BN_MONT_CTX_set(mont: ?*BN_MONT_CTX, mod: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_MONT_CTX_copy(to: ?*BN_MONT_CTX, from: ?*BN_MONT_CTX) ?*BN_MONT_CTX;
pub extern fn BN_MONT_CTX_set_locked(pmont: [*c]?*BN_MONT_CTX, lock: ?*CRYPTO_RWLOCK, mod: ?*const BIGNUM, ctx: ?*BN_CTX) ?*BN_MONT_CTX;
pub extern fn BN_BLINDING_new(A: ?*const BIGNUM, Ai: ?*const BIGNUM, mod: ?*BIGNUM) ?*BN_BLINDING;
pub extern fn BN_BLINDING_free(b: ?*BN_BLINDING) void;
pub extern fn BN_BLINDING_update(b: ?*BN_BLINDING, ctx: ?*BN_CTX) c_int;
pub extern fn BN_BLINDING_convert(n: ?*BIGNUM, b: ?*BN_BLINDING, ctx: ?*BN_CTX) c_int;
pub extern fn BN_BLINDING_invert(n: ?*BIGNUM, b: ?*BN_BLINDING, ctx: ?*BN_CTX) c_int;
pub extern fn BN_BLINDING_convert_ex(n: ?*BIGNUM, r: ?*BIGNUM, b: ?*BN_BLINDING, ?*BN_CTX) c_int;
pub extern fn BN_BLINDING_invert_ex(n: ?*BIGNUM, r: ?*const BIGNUM, b: ?*BN_BLINDING, ?*BN_CTX) c_int;
pub extern fn BN_BLINDING_is_current_thread(b: ?*BN_BLINDING) c_int;
pub extern fn BN_BLINDING_set_current_thread(b: ?*BN_BLINDING) void;
pub extern fn BN_BLINDING_lock(b: ?*BN_BLINDING) c_int;
pub extern fn BN_BLINDING_unlock(b: ?*BN_BLINDING) c_int;
pub extern fn BN_BLINDING_get_flags(?*const BN_BLINDING) c_ulong;
pub extern fn BN_BLINDING_set_flags(?*BN_BLINDING, c_ulong) void;
pub extern fn BN_BLINDING_create_param(b: ?*BN_BLINDING, e: ?*const BIGNUM, m: ?*BIGNUM, ctx: ?*BN_CTX, bn_mod_exp: ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.c) c_int, m_ctx: ?*BN_MONT_CTX) ?*BN_BLINDING;
pub extern fn BN_set_params(mul: c_int, high: c_int, low: c_int, mont: c_int) void;
pub extern fn BN_get_params(which: c_int) c_int;
pub extern fn BN_RECP_CTX_new() ?*BN_RECP_CTX;
pub extern fn BN_RECP_CTX_free(recp: ?*BN_RECP_CTX) void;
pub extern fn BN_RECP_CTX_set(recp: ?*BN_RECP_CTX, rdiv: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_mul_reciprocal(r: ?*BIGNUM, x: ?*const BIGNUM, y: ?*const BIGNUM, recp: ?*BN_RECP_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_mod_exp_recp(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_div_recp(dv: ?*BIGNUM, rem: ?*BIGNUM, m: ?*const BIGNUM, recp: ?*BN_RECP_CTX, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_add(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM) c_int;
pub extern fn BN_GF2m_mod(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM) c_int;
pub extern fn BN_GF2m_mod_mul(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_sqr(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_inv(r: ?*BIGNUM, b: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_div(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_exp(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_sqrt(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_solve_quad(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_arr(r: ?*BIGNUM, a: ?*const BIGNUM, p: [*c]const c_int) c_int;
pub extern fn BN_GF2m_mod_mul_arr(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_sqr_arr(r: ?*BIGNUM, a: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_inv_arr(r: ?*BIGNUM, b: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_div_arr(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_exp_arr(r: ?*BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_sqrt_arr(r: ?*BIGNUM, a: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_mod_solve_quad_arr(r: ?*BIGNUM, a: ?*const BIGNUM, p: [*c]const c_int, ctx: ?*BN_CTX) c_int;
pub extern fn BN_GF2m_poly2arr(a: ?*const BIGNUM, p: [*c]c_int, max: c_int) c_int;
pub extern fn BN_GF2m_arr2poly(p: [*c]const c_int, a: ?*BIGNUM) c_int;
pub extern fn BN_nist_mod_192(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_nist_mod_224(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_nist_mod_256(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_nist_mod_384(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_nist_mod_521(r: ?*BIGNUM, a: ?*const BIGNUM, p: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn BN_get0_nist_prime_192() ?*const BIGNUM;
pub extern fn BN_get0_nist_prime_224() ?*const BIGNUM;
pub extern fn BN_get0_nist_prime_256() ?*const BIGNUM;
pub extern fn BN_get0_nist_prime_384() ?*const BIGNUM;
pub extern fn BN_get0_nist_prime_521() ?*const BIGNUM;
pub extern fn BN_nist_mod_func(p: ?*const BIGNUM) ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX) callconv(.c) c_int;
pub extern fn BN_generate_dsa_nonce(out: ?*BIGNUM, range: ?*const BIGNUM, priv: ?*const BIGNUM, message: [*c]const u8, message_len: usize, ctx: ?*BN_CTX) c_int;
pub extern fn BN_get_rfc2409_prime_768(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc2409_prime_1024(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_1536(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_2048(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_3072(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_4096(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_6144(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_get_rfc3526_prime_8192(bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn BN_bntest_rand(rnd: ?*BIGNUM, bits: c_int, top: c_int, bottom: c_int) c_int;
pub extern fn OSSL_PARAM_locate(p: [*c]OSSL_PARAM, key: [*c]const u8) [*c]OSSL_PARAM;
pub extern fn OSSL_PARAM_locate_const(p: [*c]const OSSL_PARAM, key: [*c]const u8) [*c]const OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_int(key: [*c]const u8, buf: [*c]c_int) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_uint(key: [*c]const u8, buf: [*c]c_uint) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_long(key: [*c]const u8, buf: [*c]c_long) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_ulong(key: [*c]const u8, buf: [*c]c_ulong) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_int32(key: [*c]const u8, buf: [*c]i32) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_uint32(key: [*c]const u8, buf: [*c]u32) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_int64(key: [*c]const u8, buf: [*c]i64) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_uint64(key: [*c]const u8, buf: [*c]u64) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_size_t(key: [*c]const u8, buf: [*c]usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_time_t(key: [*c]const u8, buf: [*c]time_t) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_BN(key: [*c]const u8, buf: [*c]u8, bsize: usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_double(key: [*c]const u8, buf: [*c]f64) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_utf8_string(key: [*c]const u8, buf: [*c]u8, bsize: usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_utf8_ptr(key: [*c]const u8, buf: [*c][*c]u8, bsize: usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_octet_string(key: [*c]const u8, buf: ?*anyopaque, bsize: usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_octet_ptr(key: [*c]const u8, buf: [*c]?*anyopaque, bsize: usize) OSSL_PARAM;
pub extern fn OSSL_PARAM_construct_end() OSSL_PARAM;
pub extern fn OSSL_PARAM_allocate_from_text(to: [*c]OSSL_PARAM, paramdefs: [*c]const OSSL_PARAM, key: [*c]const u8, value: [*c]const u8, value_n: usize, found: [*c]c_int) c_int;
pub extern fn OSSL_PARAM_get_int(p: [*c]const OSSL_PARAM, val: [*c]c_int) c_int;
pub extern fn OSSL_PARAM_get_uint(p: [*c]const OSSL_PARAM, val: [*c]c_uint) c_int;
pub extern fn OSSL_PARAM_get_long(p: [*c]const OSSL_PARAM, val: [*c]c_long) c_int;
pub extern fn OSSL_PARAM_get_ulong(p: [*c]const OSSL_PARAM, val: [*c]c_ulong) c_int;
pub extern fn OSSL_PARAM_get_int32(p: [*c]const OSSL_PARAM, val: [*c]i32) c_int;
pub extern fn OSSL_PARAM_get_uint32(p: [*c]const OSSL_PARAM, val: [*c]u32) c_int;
pub extern fn OSSL_PARAM_get_int64(p: [*c]const OSSL_PARAM, val: [*c]i64) c_int;
pub extern fn OSSL_PARAM_get_uint64(p: [*c]const OSSL_PARAM, val: [*c]u64) c_int;
pub extern fn OSSL_PARAM_get_size_t(p: [*c]const OSSL_PARAM, val: [*c]usize) c_int;
pub extern fn OSSL_PARAM_get_time_t(p: [*c]const OSSL_PARAM, val: [*c]time_t) c_int;
pub extern fn OSSL_PARAM_set_int(p: [*c]OSSL_PARAM, val: c_int) c_int;
pub extern fn OSSL_PARAM_set_uint(p: [*c]OSSL_PARAM, val: c_uint) c_int;
pub extern fn OSSL_PARAM_set_long(p: [*c]OSSL_PARAM, val: c_long) c_int;
pub extern fn OSSL_PARAM_set_ulong(p: [*c]OSSL_PARAM, val: c_ulong) c_int;
pub extern fn OSSL_PARAM_set_int32(p: [*c]OSSL_PARAM, val: i32) c_int;
pub extern fn OSSL_PARAM_set_uint32(p: [*c]OSSL_PARAM, val: u32) c_int;
pub extern fn OSSL_PARAM_set_int64(p: [*c]OSSL_PARAM, val: i64) c_int;
pub extern fn OSSL_PARAM_set_uint64(p: [*c]OSSL_PARAM, val: u64) c_int;
pub extern fn OSSL_PARAM_set_size_t(p: [*c]OSSL_PARAM, val: usize) c_int;
pub extern fn OSSL_PARAM_set_time_t(p: [*c]OSSL_PARAM, val: time_t) c_int;
pub extern fn OSSL_PARAM_get_double(p: [*c]const OSSL_PARAM, val: [*c]f64) c_int;
pub extern fn OSSL_PARAM_set_double(p: [*c]OSSL_PARAM, val: f64) c_int;
pub extern fn OSSL_PARAM_get_BN(p: [*c]const OSSL_PARAM, val: [*c]?*BIGNUM) c_int;
pub extern fn OSSL_PARAM_set_BN(p: [*c]OSSL_PARAM, val: ?*const BIGNUM) c_int;
pub extern fn OSSL_PARAM_get_utf8_string(p: [*c]const OSSL_PARAM, val: [*c][*c]u8, max_len: usize) c_int;
pub extern fn OSSL_PARAM_set_utf8_string(p: [*c]OSSL_PARAM, val: [*c]const u8) c_int;
pub extern fn OSSL_PARAM_get_octet_string(p: [*c]const OSSL_PARAM, val: [*c]?*anyopaque, max_len: usize, used_len: [*c]usize) c_int;
pub extern fn OSSL_PARAM_set_octet_string(p: [*c]OSSL_PARAM, val: ?*const anyopaque, len: usize) c_int;
pub extern fn OSSL_PARAM_get_utf8_ptr(p: [*c]const OSSL_PARAM, val: [*c][*c]const u8) c_int;
pub extern fn OSSL_PARAM_set_utf8_ptr(p: [*c]OSSL_PARAM, val: [*c]const u8) c_int;
pub extern fn OSSL_PARAM_get_octet_ptr(p: [*c]const OSSL_PARAM, val: [*c]?*const anyopaque, used_len: [*c]usize) c_int;
pub extern fn OSSL_PARAM_set_octet_ptr(p: [*c]OSSL_PARAM, val: ?*const anyopaque, used_len: usize) c_int;
pub extern fn OSSL_PARAM_get_utf8_string_ptr(p: [*c]const OSSL_PARAM, val: [*c][*c]const u8) c_int;
pub extern fn OSSL_PARAM_get_octet_string_ptr(p: [*c]const OSSL_PARAM, val: [*c]?*const anyopaque, used_len: [*c]usize) c_int;
pub extern fn OSSL_PARAM_modified(p: [*c]const OSSL_PARAM) c_int;
pub extern fn OSSL_PARAM_set_all_unmodified(p: [*c]OSSL_PARAM) void;
pub extern fn OSSL_PARAM_dup(p: [*c]const OSSL_PARAM) [*c]OSSL_PARAM;
pub extern fn OSSL_PARAM_merge(p1: [*c]const OSSL_PARAM, p2: [*c]const OSSL_PARAM) [*c]OSSL_PARAM;
pub extern fn OSSL_PARAM_free(p: [*c]OSSL_PARAM) void;
pub const OSSL_INDICATOR_CALLBACK = fn ([*c]const u8, [*c]const u8, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub extern fn OSSL_INDICATOR_set_callback(libctx: ?*OSSL_LIB_CTX, cb: ?*const OSSL_INDICATOR_CALLBACK) void;
pub extern fn OSSL_INDICATOR_get_callback(libctx: ?*OSSL_LIB_CTX, cb: [*c]?*const OSSL_INDICATOR_CALLBACK) void;
pub const OSSL_FUNC_core_gettable_params_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_core_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_get_params_fn = fn (?*const OSSL_CORE_HANDLE, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_core_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_thread_start_fn = fn (?*const OSSL_CORE_HANDLE, OSSL_thread_stop_handler_fn, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_core_thread_start(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_thread_start_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_thread_start_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_get_libctx_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.c) ?*OPENSSL_CORE_CTX;
pub fn OSSL_FUNC_core_get_libctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_get_libctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_get_libctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_new_error_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.c) void;
pub fn OSSL_FUNC_core_new_error(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_new_error_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_new_error_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_set_error_debug_fn = fn (?*const OSSL_CORE_HANDLE, [*c]const u8, c_int, [*c]const u8) callconv(.c) void;
pub fn OSSL_FUNC_core_set_error_debug(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_set_error_debug_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_set_error_debug_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_vset_error_fn = fn (?*const OSSL_CORE_HANDLE, u32, [*c]const u8, [*c]struct___va_list_tag_5) callconv(.c) void;
pub fn OSSL_FUNC_core_vset_error(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_vset_error_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_vset_error_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_set_error_mark_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.c) c_int;
pub fn OSSL_FUNC_core_set_error_mark(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_set_error_mark_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_set_error_mark_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_clear_last_error_mark_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.c) c_int;
pub fn OSSL_FUNC_core_clear_last_error_mark(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_clear_last_error_mark_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_clear_last_error_mark_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_pop_error_to_mark_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.c) c_int;
pub fn OSSL_FUNC_core_pop_error_to_mark(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_pop_error_to_mark_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_pop_error_to_mark_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_obj_add_sigid_fn = fn (?*const OSSL_CORE_HANDLE, [*c]const u8, [*c]const u8, [*c]const u8) callconv(.c) c_int;
pub fn OSSL_FUNC_core_obj_add_sigid(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_obj_add_sigid_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_obj_add_sigid_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_core_obj_create_fn = fn (?*const OSSL_CORE_HANDLE, [*c]const u8, [*c]const u8, [*c]const u8) callconv(.c) c_int;
pub fn OSSL_FUNC_core_obj_create(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_core_obj_create_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_core_obj_create_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_malloc_fn = fn (usize, [*c]const u8, c_int) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_malloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_CRYPTO_malloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_malloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_zalloc_fn = fn (usize, [*c]const u8, c_int) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_zalloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_CRYPTO_zalloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_zalloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_free_fn = fn (?*anyopaque, [*c]const u8, c_int) callconv(.c) void;
pub fn OSSL_FUNC_CRYPTO_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_CRYPTO_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_clear_free_fn = fn (?*anyopaque, usize, [*c]const u8, c_int) callconv(.c) void;
pub fn OSSL_FUNC_CRYPTO_clear_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_CRYPTO_clear_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_clear_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_realloc_fn = fn (?*anyopaque, usize, [*c]const u8, c_int) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_realloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_CRYPTO_realloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_realloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_clear_realloc_fn = fn (?*anyopaque, usize, usize, [*c]const u8, c_int) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_clear_realloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_CRYPTO_clear_realloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_clear_realloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_secure_malloc_fn = fn (usize, [*c]const u8, c_int) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_secure_malloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_CRYPTO_secure_malloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_secure_malloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_secure_zalloc_fn = fn (usize, [*c]const u8, c_int) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_CRYPTO_secure_zalloc(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_CRYPTO_secure_zalloc_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_secure_zalloc_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_secure_free_fn = fn (?*anyopaque, [*c]const u8, c_int) callconv(.c) void;
pub fn OSSL_FUNC_CRYPTO_secure_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_CRYPTO_secure_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_secure_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_secure_clear_free_fn = fn (?*anyopaque, usize, [*c]const u8, c_int) callconv(.c) void;
pub fn OSSL_FUNC_CRYPTO_secure_clear_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_CRYPTO_secure_clear_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_secure_clear_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_CRYPTO_secure_allocated_fn = fn (?*const anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_CRYPTO_secure_allocated(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_CRYPTO_secure_allocated_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_CRYPTO_secure_allocated_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_OPENSSL_cleanse_fn = fn (?*anyopaque, usize) callconv(.c) void;
pub fn OSSL_FUNC_OPENSSL_cleanse(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_OPENSSL_cleanse_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_OPENSSL_cleanse_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_new_file_fn = fn ([*c]const u8, [*c]const u8) callconv(.c) ?*OSSL_CORE_BIO;
pub fn OSSL_FUNC_BIO_new_file(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_BIO_new_file_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_new_file_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_new_membuf_fn = fn (?*const anyopaque, c_int) callconv(.c) ?*OSSL_CORE_BIO;
pub fn OSSL_FUNC_BIO_new_membuf(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_BIO_new_membuf_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_new_membuf_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_read_ex_fn = fn (?*OSSL_CORE_BIO, ?*anyopaque, usize, [*c]usize) callconv(.c) c_int;
pub fn OSSL_FUNC_BIO_read_ex(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_BIO_read_ex_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_read_ex_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_write_ex_fn = fn (?*OSSL_CORE_BIO, ?*const anyopaque, usize, [*c]usize) callconv(.c) c_int;
pub fn OSSL_FUNC_BIO_write_ex(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_BIO_write_ex_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_write_ex_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_gets_fn = fn (?*OSSL_CORE_BIO, [*c]u8, c_int) callconv(.c) c_int;
pub fn OSSL_FUNC_BIO_gets(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_BIO_gets_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_gets_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_puts_fn = fn (?*OSSL_CORE_BIO, [*c]const u8) callconv(.c) c_int;
pub fn OSSL_FUNC_BIO_puts(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_BIO_puts_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_puts_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_up_ref_fn = fn (?*OSSL_CORE_BIO) callconv(.c) c_int;
pub fn OSSL_FUNC_BIO_up_ref(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_BIO_up_ref_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_up_ref_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_free_fn = fn (?*OSSL_CORE_BIO) callconv(.c) c_int;
pub fn OSSL_FUNC_BIO_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_BIO_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_vprintf_fn = fn (?*OSSL_CORE_BIO, [*c]const u8, [*c]struct___va_list_tag_5) callconv(.c) c_int;
pub fn OSSL_FUNC_BIO_vprintf(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_BIO_vprintf_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_vprintf_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_vsnprintf_fn = fn ([*c]u8, usize, [*c]const u8, [*c]struct___va_list_tag_5) callconv(.c) c_int;
pub fn OSSL_FUNC_BIO_vsnprintf(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_BIO_vsnprintf_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_vsnprintf_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_BIO_ctrl_fn = fn (?*OSSL_CORE_BIO, c_int, c_long, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_BIO_ctrl(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_BIO_ctrl_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_BIO_ctrl_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_indicator_cb_fn = fn (?*OPENSSL_CORE_CTX, [*c]?*const OSSL_INDICATOR_CALLBACK) callconv(.c) void;
pub fn OSSL_FUNC_indicator_cb(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_indicator_cb_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_indicator_cb_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_self_test_cb_fn = fn (?*OPENSSL_CORE_CTX, [*c]?*const OSSL_CALLBACK, [*c]?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_self_test_cb(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_self_test_cb_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_self_test_cb_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_get_entropy_fn = fn (?*const OSSL_CORE_HANDLE, [*c][*c]u8, c_int, usize, usize) callconv(.c) usize;
pub fn OSSL_FUNC_get_entropy(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_get_entropy_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_get_entropy_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_get_user_entropy_fn = fn (?*const OSSL_CORE_HANDLE, [*c][*c]u8, c_int, usize, usize) callconv(.c) usize;
pub fn OSSL_FUNC_get_user_entropy(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_get_user_entropy_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_get_user_entropy_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cleanup_entropy_fn = fn (?*const OSSL_CORE_HANDLE, [*c]u8, usize) callconv(.c) void;
pub fn OSSL_FUNC_cleanup_entropy(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cleanup_entropy_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cleanup_entropy_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cleanup_user_entropy_fn = fn (?*const OSSL_CORE_HANDLE, [*c]u8, usize) callconv(.c) void;
pub fn OSSL_FUNC_cleanup_user_entropy(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cleanup_user_entropy_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cleanup_user_entropy_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_get_nonce_fn = fn (?*const OSSL_CORE_HANDLE, [*c][*c]u8, usize, usize, ?*const anyopaque, usize) callconv(.c) usize;
pub fn OSSL_FUNC_get_nonce(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_get_nonce_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_get_nonce_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_get_user_nonce_fn = fn (?*const OSSL_CORE_HANDLE, [*c][*c]u8, usize, usize, ?*const anyopaque, usize) callconv(.c) usize;
pub fn OSSL_FUNC_get_user_nonce(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_get_user_nonce_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_get_user_nonce_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cleanup_nonce_fn = fn (?*const OSSL_CORE_HANDLE, [*c]u8, usize) callconv(.c) void;
pub fn OSSL_FUNC_cleanup_nonce(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cleanup_nonce_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cleanup_nonce_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cleanup_user_nonce_fn = fn (?*const OSSL_CORE_HANDLE, [*c]u8, usize) callconv(.c) void;
pub fn OSSL_FUNC_cleanup_user_nonce(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cleanup_user_nonce_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cleanup_user_nonce_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_register_child_cb_fn = fn (?*const OSSL_CORE_HANDLE, ?*const fn (?*const OSSL_CORE_HANDLE, ?*anyopaque) callconv(.c) c_int, ?*const fn (?*const OSSL_CORE_HANDLE, ?*anyopaque) callconv(.c) c_int, ?*const fn ([*c]const u8, ?*anyopaque) callconv(.c) c_int, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_provider_register_child_cb(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_register_child_cb_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_register_child_cb_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_deregister_child_cb_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.c) void;
pub fn OSSL_FUNC_provider_deregister_child_cb(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_deregister_child_cb_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_deregister_child_cb_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_name_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.c) [*c]const u8;
pub fn OSSL_FUNC_provider_name(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_name_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_name_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_get0_provider_ctx_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_provider_get0_provider_ctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_get0_provider_ctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_get0_provider_ctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_get0_dispatch_fn = fn (?*const OSSL_CORE_HANDLE) callconv(.c) [*c]const OSSL_DISPATCH;
pub fn OSSL_FUNC_provider_get0_dispatch(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_get0_dispatch_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_get0_dispatch_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_up_ref_fn = fn (?*const OSSL_CORE_HANDLE, c_int) callconv(.c) c_int;
pub fn OSSL_FUNC_provider_up_ref(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_up_ref_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_up_ref_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_free_fn = fn (?*const OSSL_CORE_HANDLE, c_int) callconv(.c) c_int;
pub fn OSSL_FUNC_provider_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_teardown_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_provider_teardown(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_teardown_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_teardown_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_gettable_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_provider_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_get_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_provider_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_query_operation_fn = fn (?*anyopaque, c_int, [*c]c_int) callconv(.c) [*c]const OSSL_ALGORITHM;
pub fn OSSL_FUNC_provider_query_operation(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_query_operation_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_query_operation_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_unquery_operation_fn = fn (?*anyopaque, c_int, [*c]const OSSL_ALGORITHM) callconv(.c) void;
pub fn OSSL_FUNC_provider_unquery_operation(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_unquery_operation_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_unquery_operation_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_get_reason_strings_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_ITEM;
pub fn OSSL_FUNC_provider_get_reason_strings(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_get_reason_strings_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_get_reason_strings_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_get_capabilities_fn = fn (?*anyopaque, [*c]const u8, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_provider_get_capabilities(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_get_capabilities_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_get_capabilities_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_provider_self_test_fn = fn (?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_provider_self_test(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_provider_self_test_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_provider_self_test_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_newctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_digest_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_init_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_digest_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_digest_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_final_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_digest_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_squeeze_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_digest_squeeze(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_squeeze_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_squeeze_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_digest_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]u8, [*c]usize, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_digest_digest(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_digest_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_digest_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_freectx_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_digest_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_dupctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_digest_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_digest_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_digest_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_digest_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_gettable_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_digest_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_digest_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_digest_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_digest_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_digest_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_digest_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_newctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_cipher_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_encrypt_init_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]const u8, usize, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_cipher_encrypt_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_encrypt_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_encrypt_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_decrypt_init_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]const u8, usize, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_cipher_decrypt_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_decrypt_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_decrypt_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_update_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_cipher_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_final_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_cipher_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_cipher_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_cipher_cipher(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_cipher_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_cipher_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_freectx_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_cipher_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_dupctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_cipher_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_cipher_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_cipher_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_cipher_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_gettable_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_cipher_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_cipher_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_cipher_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_cipher_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_cipher_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_cipher_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_newctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_mac_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_dupctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_mac_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_freectx_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_mac_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_init_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_mac_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_mac_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_final_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_mac_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_gettable_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_mac_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_mac_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_mac_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_mac_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_mac_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_mac_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_mac_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_mac_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_mac_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_newctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_kdf_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kdf_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_dupctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_kdf_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kdf_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_freectx_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_kdf_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kdf_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_reset_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_kdf_reset(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kdf_reset_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_reset_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_derive_fn = fn (?*anyopaque, [*c]u8, usize, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_kdf_derive(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kdf_derive_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_derive_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_gettable_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_kdf_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kdf_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_kdf_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kdf_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_kdf_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kdf_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_kdf_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kdf_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_kdf_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kdf_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kdf_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_kdf_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kdf_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kdf_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_newctx_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_DISPATCH) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_rand_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_freectx_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_rand_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_instantiate_fn = fn (?*anyopaque, c_uint, c_int, [*c]const u8, usize, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_rand_instantiate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_instantiate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_instantiate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_uninstantiate_fn = fn (?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_rand_uninstantiate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_uninstantiate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_uninstantiate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_generate_fn = fn (?*anyopaque, [*c]u8, usize, c_uint, c_int, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_rand_generate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_generate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_generate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_reseed_fn = fn (?*anyopaque, c_int, [*c]const u8, usize, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_rand_reseed(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_reseed_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_reseed_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_nonce_fn = fn (?*anyopaque, [*c]u8, c_uint, usize, usize) callconv(.c) usize;
pub fn OSSL_FUNC_rand_nonce(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_nonce_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_nonce_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_enable_locking_fn = fn (?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_rand_enable_locking(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_enable_locking_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_enable_locking_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_lock_fn = fn (?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_rand_lock(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_lock_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_lock_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_unlock_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_rand_unlock(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_unlock_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_unlock_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_gettable_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_rand_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_rand_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_rand_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_rand_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_rand_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_rand_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_set_callbacks_fn = fn (?*anyopaque, ?*const OSSL_INOUT_CALLBACK, ?*const OSSL_CALLBACK, ?*const OSSL_INOUT_CALLBACK, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_rand_set_callbacks(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_set_callbacks_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_set_callbacks_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_verify_zeroization_fn = fn (?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_rand_verify_zeroization(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_verify_zeroization_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_verify_zeroization_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_get_seed_fn = fn (?*anyopaque, [*c][*c]u8, c_int, usize, usize, c_int, [*c]const u8, usize) callconv(.c) usize;
pub fn OSSL_FUNC_rand_get_seed(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_get_seed_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_get_seed_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_rand_clear_seed_fn = fn (?*anyopaque, [*c]u8, usize) callconv(.c) void;
pub fn OSSL_FUNC_rand_clear_seed(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_rand_clear_seed_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_rand_clear_seed_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_new_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_keymgmt_new(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_new_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_new_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_init_fn = fn (?*anyopaque, c_int, [*c]const OSSL_PARAM) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_keymgmt_gen_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_gen_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_set_template_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_keymgmt_gen_set_template(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_gen_set_template_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_set_template_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_set_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_keymgmt_gen_set_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_gen_set_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_set_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_settable_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_gen_settable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_gen_settable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_settable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_get_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_keymgmt_gen_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_gen_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_gettable_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_gen_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_gen_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_fn = fn (?*anyopaque, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_keymgmt_gen(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_gen_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gen_cleanup_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_keymgmt_gen_cleanup(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_gen_cleanup_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gen_cleanup_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_load_fn = fn (?*const anyopaque, usize) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_keymgmt_load(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_load_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_load_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_free_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_keymgmt_free(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_free_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_free_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_get_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_keymgmt_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_gettable_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_set_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_keymgmt_set_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_set_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_set_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_settable_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_settable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_settable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_settable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_query_operation_name_fn = fn (c_int) callconv(.c) [*c]const u8;
pub fn OSSL_FUNC_keymgmt_query_operation_name(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_query_operation_name_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_query_operation_name_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_has_fn = fn (?*const anyopaque, c_int) callconv(.c) c_int;
pub fn OSSL_FUNC_keymgmt_has(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_has_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_has_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_validate_fn = fn (?*const anyopaque, c_int, c_int) callconv(.c) c_int;
pub fn OSSL_FUNC_keymgmt_validate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_validate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_validate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_match_fn = fn (?*const anyopaque, ?*const anyopaque, c_int) callconv(.c) c_int;
pub fn OSSL_FUNC_keymgmt_match(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_match_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_match_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_import_fn = fn (?*anyopaque, c_int, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_keymgmt_import(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_import_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_import_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_import_types_fn = fn (c_int) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_import_types(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_import_types_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_import_types_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_export_fn = fn (?*anyopaque, c_int, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_keymgmt_export(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_export_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_export_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_export_types_fn = fn (c_int) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_export_types(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_export_types_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_export_types_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_dup_fn = fn (?*const anyopaque, c_int) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_keymgmt_dup(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_dup_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_dup_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_import_types_ex_fn = fn (?*anyopaque, c_int) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_import_types_ex(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_import_types_ex_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_import_types_ex_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keymgmt_export_types_ex_fn = fn (?*anyopaque, c_int) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keymgmt_export_types_ex(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keymgmt_export_types_ex_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keymgmt_export_types_ex_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_newctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_keyexch_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keyexch_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_keyexch_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keyexch_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_derive_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_keyexch_derive(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keyexch_derive_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_derive_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_set_peer_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_keyexch_set_peer(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keyexch_set_peer_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_set_peer_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_freectx_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_keyexch_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keyexch_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_dupctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_keyexch_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keyexch_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_keyexch_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keyexch_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keyexch_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keyexch_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_keyexch_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keyexch_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_keyexch_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_keyexch_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_keyexch_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_keyexch_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_newctx_fn = fn (?*anyopaque, [*c]const u8) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_signature_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_sign_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_sign_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_sign_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_sign_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_sign_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_sign(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_sign_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_sign_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_sign_message_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_sign_message_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_sign_message_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_sign_message_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_sign_message_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_sign_message_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_sign_message_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_sign_message_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_sign_message_final_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_sign_message_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_sign_message_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_sign_message_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_verify_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_verify_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_verify(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_verify_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_message_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_verify_message_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_verify_message_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_message_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_message_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_verify_message_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_verify_message_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_message_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_message_final_fn = fn (?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_verify_message_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_verify_message_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_message_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_recover_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_verify_recover_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_verify_recover_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_recover_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_verify_recover_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_verify_recover(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_verify_recover_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_verify_recover_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_sign_init_fn = fn (?*anyopaque, [*c]const u8, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_digest_sign_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_digest_sign_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_sign_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_sign_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_digest_sign_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_digest_sign_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_sign_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_sign_final_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_digest_sign_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_digest_sign_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_sign_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_sign_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_digest_sign(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_digest_sign_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_sign_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_verify_init_fn = fn (?*anyopaque, [*c]const u8, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_digest_verify_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_digest_verify_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_verify_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_verify_update_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_digest_verify_update(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_digest_verify_update_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_verify_update_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_verify_final_fn = fn (?*anyopaque, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_digest_verify_final(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_digest_verify_final_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_verify_final_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_digest_verify_fn = fn (?*anyopaque, [*c]const u8, usize, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_digest_verify(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_digest_verify_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_digest_verify_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_freectx_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_signature_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_dupctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_signature_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_signature_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_signature_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_get_ctx_md_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_get_ctx_md_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_get_ctx_md_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_get_ctx_md_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_gettable_ctx_md_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_signature_gettable_ctx_md_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_gettable_ctx_md_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_gettable_ctx_md_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_set_ctx_md_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_signature_set_ctx_md_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_set_ctx_md_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_set_ctx_md_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_settable_ctx_md_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_signature_settable_ctx_md_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_settable_ctx_md_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_settable_ctx_md_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_signature_query_key_types_fn = fn () callconv(.c) [*c][*c]const u8;
pub fn OSSL_FUNC_signature_query_key_types(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_signature_query_key_types_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_signature_query_key_types_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_newctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_asym_cipher_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_asym_cipher_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_encrypt_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_asym_cipher_encrypt_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_asym_cipher_encrypt_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_encrypt_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_encrypt_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_asym_cipher_encrypt(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_asym_cipher_encrypt_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_encrypt_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_decrypt_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_asym_cipher_decrypt_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_asym_cipher_decrypt_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_decrypt_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_decrypt_fn = fn (?*anyopaque, [*c]u8, [*c]usize, usize, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_asym_cipher_decrypt(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_asym_cipher_decrypt_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_decrypt_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_freectx_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_asym_cipher_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_asym_cipher_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_dupctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_asym_cipher_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_asym_cipher_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_asym_cipher_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_asym_cipher_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_asym_cipher_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_asym_cipher_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_asym_cipher_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_asym_cipher_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_asym_cipher_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_asym_cipher_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_asym_cipher_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_asym_cipher_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_newctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_kem_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_encapsulate_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_kem_encapsulate_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_encapsulate_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_encapsulate_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_auth_encapsulate_init_fn = fn (?*anyopaque, ?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_kem_auth_encapsulate_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_auth_encapsulate_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_auth_encapsulate_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_encapsulate_fn = fn (?*anyopaque, [*c]u8, [*c]usize, [*c]u8, [*c]usize) callconv(.c) c_int;
pub fn OSSL_FUNC_kem_encapsulate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_encapsulate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_encapsulate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_decapsulate_init_fn = fn (?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_kem_decapsulate_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_decapsulate_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_decapsulate_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_auth_decapsulate_init_fn = fn (?*anyopaque, ?*anyopaque, ?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_kem_auth_decapsulate_init(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_auth_decapsulate_init_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_auth_decapsulate_init_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_decapsulate_fn = fn (?*anyopaque, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.c) c_int;
pub fn OSSL_FUNC_kem_decapsulate(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_decapsulate_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_decapsulate_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_freectx_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_kem_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_dupctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_kem_dupctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_dupctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_dupctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_get_ctx_params_fn = fn (?*anyopaque, [*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_kem_get_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_get_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_get_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_gettable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_kem_gettable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_gettable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_gettable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_kem_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_kem_settable_ctx_params_fn = fn (?*anyopaque, ?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_kem_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_kem_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_kem_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_newctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_encoder_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_encoder_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_freectx_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_encoder_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_encoder_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_encoder_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_encoder_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_gettable_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_encoder_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_encoder_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_encoder_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_encoder_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_settable_ctx_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_encoder_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_encoder_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_does_selection_fn = fn (?*anyopaque, c_int) callconv(.c) c_int;
pub fn OSSL_FUNC_encoder_does_selection(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_encoder_does_selection_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_does_selection_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_encode_fn = fn (?*anyopaque, ?*OSSL_CORE_BIO, ?*const anyopaque, [*c]const OSSL_PARAM, c_int, ?*const OSSL_PASSPHRASE_CALLBACK, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_encoder_encode(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_encoder_encode_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_encode_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_import_object_fn = fn (?*anyopaque, c_int, [*c]const OSSL_PARAM) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_encoder_import_object(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_encoder_import_object_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_import_object_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_encoder_free_object_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_encoder_free_object(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_encoder_free_object_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_encoder_free_object_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_newctx_fn = fn (?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_decoder_newctx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_decoder_newctx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_newctx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_freectx_fn = fn (?*anyopaque) callconv(.c) void;
pub fn OSSL_FUNC_decoder_freectx(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_decoder_freectx_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_freectx_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_get_params_fn = fn ([*c]OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_decoder_get_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_decoder_get_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_get_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_gettable_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_decoder_gettable_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_decoder_gettable_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_gettable_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_decoder_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_decoder_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_settable_ctx_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_decoder_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_decoder_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_does_selection_fn = fn (?*anyopaque, c_int) callconv(.c) c_int;
pub fn OSSL_FUNC_decoder_does_selection(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_decoder_does_selection_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_does_selection_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_decode_fn = fn (?*anyopaque, ?*OSSL_CORE_BIO, c_int, ?*const OSSL_CALLBACK, ?*anyopaque, ?*const OSSL_PASSPHRASE_CALLBACK, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_decoder_decode(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_decoder_decode_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_decode_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_decoder_export_object_fn = fn (?*anyopaque, ?*const anyopaque, usize, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_decoder_export_object(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_decoder_export_object_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_decoder_export_object_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_open_fn = fn (?*anyopaque, [*c]const u8) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_store_open(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_store_open_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_open_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_attach_fn = fn (?*anyopaque, ?*OSSL_CORE_BIO) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_store_attach(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_store_attach_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_attach_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_settable_ctx_params_fn = fn (?*anyopaque) callconv(.c) [*c]const OSSL_PARAM;
pub fn OSSL_FUNC_store_settable_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_store_settable_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_settable_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_set_ctx_params_fn = fn (?*anyopaque, [*c]const OSSL_PARAM) callconv(.c) c_int;
pub fn OSSL_FUNC_store_set_ctx_params(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_store_set_ctx_params_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_set_ctx_params_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_load_fn = fn (?*anyopaque, ?*const OSSL_CALLBACK, ?*anyopaque, ?*const OSSL_PASSPHRASE_CALLBACK, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_store_load(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_store_load_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_load_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_eof_fn = fn (?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_store_eof(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_store_eof_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_eof_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_close_fn = fn (?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_store_close(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_store_close_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_close_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_export_object_fn = fn (?*anyopaque, ?*const anyopaque, usize, ?*const OSSL_CALLBACK, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_store_export_object(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_store_export_object_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_export_object_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_delete_fn = fn (?*anyopaque, [*c]const u8, [*c]const OSSL_PARAM, ?*const OSSL_PASSPHRASE_CALLBACK, ?*anyopaque) callconv(.c) c_int;
pub fn OSSL_FUNC_store_delete(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_store_delete_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_delete_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const OSSL_FUNC_store_open_ex_fn = fn (?*anyopaque, [*c]const u8, [*c]const OSSL_PARAM, ?*const OSSL_PASSPHRASE_CALLBACK, ?*anyopaque) callconv(.c) ?*anyopaque;
pub fn OSSL_FUNC_store_open_ex(arg_opf: [*c]const OSSL_DISPATCH) callconv(.c) ?*const OSSL_FUNC_store_open_ex_fn {
    var opf = arg_opf;
    _ = &opf;
    return @as(?*const OSSL_FUNC_store_open_ex_fn, @ptrCast(@alignCast(opf.*.function)));
}
pub const struct_stack_st_X509_ALGOR = opaque {};
pub const sk_X509_ALGOR_compfunc = ?*const fn ([*c]const [*c]const X509_ALGOR, [*c]const [*c]const X509_ALGOR) callconv(.c) c_int;
pub const sk_X509_ALGOR_freefunc = ?*const fn ([*c]X509_ALGOR) callconv(.c) void;
pub const sk_X509_ALGOR_copyfunc = ?*const fn ([*c]const X509_ALGOR) callconv(.c) [*c]X509_ALGOR;
pub fn ossl_check_X509_ALGOR_type(arg_ptr: [*c]X509_ALGOR) callconv(.c) [*c]X509_ALGOR {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_ALGOR_sk_type(arg_sk: ?*const struct_stack_st_X509_ALGOR) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_ALGOR_sk_type(arg_sk: ?*struct_stack_st_X509_ALGOR) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_ALGOR_compfunc_type(arg_cmp: sk_X509_ALGOR_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_ALGOR_copyfunc_type(arg_cpy: sk_X509_ALGOR_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_ALGOR_freefunc_type(arg_fr: sk_X509_ALGOR_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_ASN1_ENCODING_st = extern struct {
    enc: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    len: c_long = @import("std").mem.zeroes(c_long),
    modified: c_int = @import("std").mem.zeroes(c_int),
};
pub const ASN1_ENCODING = struct_ASN1_ENCODING_st;
pub const struct_stack_st_ASN1_STRING_TABLE = opaque {};
pub const sk_ASN1_STRING_TABLE_compfunc = ?*const fn ([*c]const [*c]const ASN1_STRING_TABLE, [*c]const [*c]const ASN1_STRING_TABLE) callconv(.c) c_int;
pub const sk_ASN1_STRING_TABLE_freefunc = ?*const fn ([*c]ASN1_STRING_TABLE) callconv(.c) void;
pub const sk_ASN1_STRING_TABLE_copyfunc = ?*const fn ([*c]const ASN1_STRING_TABLE) callconv(.c) [*c]ASN1_STRING_TABLE;
pub fn ossl_check_ASN1_STRING_TABLE_type(arg_ptr: [*c]ASN1_STRING_TABLE) callconv(.c) [*c]ASN1_STRING_TABLE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_STRING_TABLE_sk_type(arg_sk: ?*const struct_stack_st_ASN1_STRING_TABLE) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_STRING_TABLE_sk_type(arg_sk: ?*struct_stack_st_ASN1_STRING_TABLE) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_STRING_TABLE_compfunc_type(arg_cmp: sk_ASN1_STRING_TABLE_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_STRING_TABLE_copyfunc_type(arg_cpy: sk_ASN1_STRING_TABLE_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_STRING_TABLE_freefunc_type(arg_fr: sk_ASN1_STRING_TABLE_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_ASN1_TEMPLATE_st = opaque {};
pub const ASN1_TEMPLATE = struct_ASN1_TEMPLATE_st;
pub const struct_ASN1_TLC_st = opaque {};
pub const ASN1_TLC = struct_ASN1_TLC_st;
pub const d2i_of_void = fn ([*c]?*anyopaque, [*c][*c]const u8, c_long) callconv(.c) ?*anyopaque;
pub const i2d_of_void = fn (?*const anyopaque, [*c][*c]u8) callconv(.c) c_int;
pub const ASN1_ITEM_EXP = fn () callconv(.c) ?*const ASN1_ITEM;
pub const struct_stack_st_ASN1_TYPE = opaque {};
pub const sk_ASN1_TYPE_compfunc = ?*const fn ([*c]const [*c]const ASN1_TYPE, [*c]const [*c]const ASN1_TYPE) callconv(.c) c_int;
pub const sk_ASN1_TYPE_freefunc = ?*const fn ([*c]ASN1_TYPE) callconv(.c) void;
pub const sk_ASN1_TYPE_copyfunc = ?*const fn ([*c]const ASN1_TYPE) callconv(.c) [*c]ASN1_TYPE;
pub fn ossl_check_ASN1_TYPE_type(arg_ptr: [*c]ASN1_TYPE) callconv(.c) [*c]ASN1_TYPE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_TYPE_sk_type(arg_sk: ?*const struct_stack_st_ASN1_TYPE) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_TYPE_sk_type(arg_sk: ?*struct_stack_st_ASN1_TYPE) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_TYPE_compfunc_type(arg_cmp: sk_ASN1_TYPE_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_TYPE_copyfunc_type(arg_cpy: sk_ASN1_TYPE_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_TYPE_freefunc_type(arg_fr: sk_ASN1_TYPE_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const ASN1_SEQUENCE_ANY = struct_stack_st_ASN1_TYPE;
pub extern fn d2i_ASN1_SEQUENCE_ANY(a: [*c]?*ASN1_SEQUENCE_ANY, in: [*c][*c]const u8, len: c_long) ?*ASN1_SEQUENCE_ANY;
pub extern fn i2d_ASN1_SEQUENCE_ANY(a: ?*const ASN1_SEQUENCE_ANY, out: [*c][*c]u8) c_int;
pub extern fn ASN1_SEQUENCE_ANY_it() ?*const ASN1_ITEM;
pub extern fn d2i_ASN1_SET_ANY(a: [*c]?*ASN1_SEQUENCE_ANY, in: [*c][*c]const u8, len: c_long) ?*ASN1_SEQUENCE_ANY;
pub extern fn i2d_ASN1_SET_ANY(a: ?*const ASN1_SEQUENCE_ANY, out: [*c][*c]u8) c_int;
pub extern fn ASN1_SET_ANY_it() ?*const ASN1_ITEM;
pub const struct_BIT_STRING_BITNAME_st = extern struct {
    bitnum: c_int = @import("std").mem.zeroes(c_int),
    lname: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    sname: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const BIT_STRING_BITNAME = struct_BIT_STRING_BITNAME_st;
pub extern fn ASN1_TYPE_new() [*c]ASN1_TYPE;
pub extern fn ASN1_TYPE_free(a: [*c]ASN1_TYPE) void;
pub extern fn d2i_ASN1_TYPE(a: [*c][*c]ASN1_TYPE, in: [*c][*c]const u8, len: c_long) [*c]ASN1_TYPE;
pub extern fn i2d_ASN1_TYPE(a: [*c]const ASN1_TYPE, out: [*c][*c]u8) c_int;
pub extern fn ASN1_ANY_it() ?*const ASN1_ITEM;
pub extern fn ASN1_TYPE_get(a: [*c]const ASN1_TYPE) c_int;
pub extern fn ASN1_TYPE_set(a: [*c]ASN1_TYPE, @"type": c_int, value: ?*anyopaque) void;
pub extern fn ASN1_TYPE_set1(a: [*c]ASN1_TYPE, @"type": c_int, value: ?*const anyopaque) c_int;
pub extern fn ASN1_TYPE_cmp(a: [*c]const ASN1_TYPE, b: [*c]const ASN1_TYPE) c_int;
pub extern fn ASN1_TYPE_pack_sequence(it: ?*const ASN1_ITEM, s: ?*anyopaque, t: [*c][*c]ASN1_TYPE) [*c]ASN1_TYPE;
pub extern fn ASN1_TYPE_unpack_sequence(it: ?*const ASN1_ITEM, t: [*c]const ASN1_TYPE) ?*anyopaque;
pub const struct_stack_st_ASN1_OBJECT = opaque {};
pub const sk_ASN1_OBJECT_compfunc = ?*const fn ([*c]const ?*const ASN1_OBJECT, [*c]const ?*const ASN1_OBJECT) callconv(.c) c_int;
pub const sk_ASN1_OBJECT_freefunc = ?*const fn (?*ASN1_OBJECT) callconv(.c) void;
pub const sk_ASN1_OBJECT_copyfunc = ?*const fn (?*const ASN1_OBJECT) callconv(.c) ?*ASN1_OBJECT;
pub fn ossl_check_ASN1_OBJECT_type(arg_ptr: ?*ASN1_OBJECT) callconv(.c) ?*ASN1_OBJECT {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_OBJECT_sk_type(arg_sk: ?*const struct_stack_st_ASN1_OBJECT) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_OBJECT_sk_type(arg_sk: ?*struct_stack_st_ASN1_OBJECT) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_OBJECT_compfunc_type(arg_cmp: sk_ASN1_OBJECT_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_OBJECT_copyfunc_type(arg_cpy: sk_ASN1_OBJECT_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_OBJECT_freefunc_type(arg_fr: sk_ASN1_OBJECT_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn ASN1_OBJECT_new() ?*ASN1_OBJECT;
pub extern fn ASN1_OBJECT_free(a: ?*ASN1_OBJECT) void;
pub extern fn d2i_ASN1_OBJECT(a: [*c]?*ASN1_OBJECT, in: [*c][*c]const u8, len: c_long) ?*ASN1_OBJECT;
pub extern fn i2d_ASN1_OBJECT(a: ?*const ASN1_OBJECT, out: [*c][*c]u8) c_int;
pub extern fn ASN1_OBJECT_it() ?*const ASN1_ITEM;
pub extern fn ASN1_STRING_new() [*c]ASN1_STRING;
pub extern fn ASN1_STRING_free(a: [*c]ASN1_STRING) void;
pub extern fn ASN1_STRING_clear_free(a: [*c]ASN1_STRING) void;
pub extern fn ASN1_STRING_copy(dst: [*c]ASN1_STRING, str: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_STRING_dup(a: [*c]const ASN1_STRING) [*c]ASN1_STRING;
pub extern fn ASN1_STRING_type_new(@"type": c_int) [*c]ASN1_STRING;
pub extern fn ASN1_STRING_cmp(a: [*c]const ASN1_STRING, b: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_STRING_set(str: [*c]ASN1_STRING, data: ?*const anyopaque, len: c_int) c_int;
pub extern fn ASN1_STRING_set0(str: [*c]ASN1_STRING, data: ?*anyopaque, len: c_int) void;
pub extern fn ASN1_STRING_length(x: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_STRING_length_set(x: [*c]ASN1_STRING, n: c_int) void;
pub extern fn ASN1_STRING_type(x: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_STRING_data(x: [*c]ASN1_STRING) [*c]u8;
pub extern fn ASN1_STRING_get0_data(x: [*c]const ASN1_STRING) [*c]const u8;
pub extern fn ASN1_BIT_STRING_new() [*c]ASN1_BIT_STRING;
pub extern fn ASN1_BIT_STRING_free(a: [*c]ASN1_BIT_STRING) void;
pub extern fn d2i_ASN1_BIT_STRING(a: [*c][*c]ASN1_BIT_STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_BIT_STRING;
pub extern fn i2d_ASN1_BIT_STRING(a: [*c]const ASN1_BIT_STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_BIT_STRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_BIT_STRING_set(a: [*c]ASN1_BIT_STRING, d: [*c]u8, length: c_int) c_int;
pub extern fn ASN1_BIT_STRING_set_bit(a: [*c]ASN1_BIT_STRING, n: c_int, value: c_int) c_int;
pub extern fn ASN1_BIT_STRING_get_bit(a: [*c]const ASN1_BIT_STRING, n: c_int) c_int;
pub extern fn ASN1_BIT_STRING_check(a: [*c]const ASN1_BIT_STRING, flags: [*c]const u8, flags_len: c_int) c_int;
pub extern fn ASN1_BIT_STRING_name_print(out: ?*BIO, bs: [*c]ASN1_BIT_STRING, tbl: [*c]BIT_STRING_BITNAME, indent: c_int) c_int;
pub extern fn ASN1_BIT_STRING_num_asc(name: [*c]const u8, tbl: [*c]BIT_STRING_BITNAME) c_int;
pub extern fn ASN1_BIT_STRING_set_asc(bs: [*c]ASN1_BIT_STRING, name: [*c]const u8, value: c_int, tbl: [*c]BIT_STRING_BITNAME) c_int;
pub const struct_stack_st_ASN1_INTEGER = opaque {};
pub const sk_ASN1_INTEGER_compfunc = ?*const fn ([*c]const [*c]const ASN1_INTEGER, [*c]const [*c]const ASN1_INTEGER) callconv(.c) c_int;
pub const sk_ASN1_INTEGER_freefunc = ?*const fn ([*c]ASN1_INTEGER) callconv(.c) void;
pub const sk_ASN1_INTEGER_copyfunc = ?*const fn ([*c]const ASN1_INTEGER) callconv(.c) [*c]ASN1_INTEGER;
pub fn ossl_check_ASN1_INTEGER_type(arg_ptr: [*c]ASN1_INTEGER) callconv(.c) [*c]ASN1_INTEGER {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_INTEGER_sk_type(arg_sk: ?*const struct_stack_st_ASN1_INTEGER) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_INTEGER_sk_type(arg_sk: ?*struct_stack_st_ASN1_INTEGER) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_INTEGER_compfunc_type(arg_cmp: sk_ASN1_INTEGER_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_INTEGER_copyfunc_type(arg_cpy: sk_ASN1_INTEGER_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_INTEGER_freefunc_type(arg_fr: sk_ASN1_INTEGER_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn ASN1_INTEGER_new() [*c]ASN1_INTEGER;
pub extern fn ASN1_INTEGER_free(a: [*c]ASN1_INTEGER) void;
pub extern fn d2i_ASN1_INTEGER(a: [*c][*c]ASN1_INTEGER, in: [*c][*c]const u8, len: c_long) [*c]ASN1_INTEGER;
pub extern fn i2d_ASN1_INTEGER(a: [*c]const ASN1_INTEGER, out: [*c][*c]u8) c_int;
pub extern fn ASN1_INTEGER_it() ?*const ASN1_ITEM;
pub extern fn d2i_ASN1_UINTEGER(a: [*c][*c]ASN1_INTEGER, pp: [*c][*c]const u8, length: c_long) [*c]ASN1_INTEGER;
pub extern fn ASN1_INTEGER_dup(a: [*c]const ASN1_INTEGER) [*c]ASN1_INTEGER;
pub extern fn ASN1_INTEGER_cmp(x: [*c]const ASN1_INTEGER, y: [*c]const ASN1_INTEGER) c_int;
pub extern fn ASN1_ENUMERATED_new() [*c]ASN1_ENUMERATED;
pub extern fn ASN1_ENUMERATED_free(a: [*c]ASN1_ENUMERATED) void;
pub extern fn d2i_ASN1_ENUMERATED(a: [*c][*c]ASN1_ENUMERATED, in: [*c][*c]const u8, len: c_long) [*c]ASN1_ENUMERATED;
pub extern fn i2d_ASN1_ENUMERATED(a: [*c]const ASN1_ENUMERATED, out: [*c][*c]u8) c_int;
pub extern fn ASN1_ENUMERATED_it() ?*const ASN1_ITEM;
pub extern fn ASN1_UTCTIME_check(a: [*c]const ASN1_UTCTIME) c_int;
pub extern fn ASN1_UTCTIME_set(s: [*c]ASN1_UTCTIME, t: time_t) [*c]ASN1_UTCTIME;
pub extern fn ASN1_UTCTIME_adj(s: [*c]ASN1_UTCTIME, t: time_t, offset_day: c_int, offset_sec: c_long) [*c]ASN1_UTCTIME;
pub extern fn ASN1_UTCTIME_set_string(s: [*c]ASN1_UTCTIME, str: [*c]const u8) c_int;
pub extern fn ASN1_UTCTIME_cmp_time_t(s: [*c]const ASN1_UTCTIME, t: time_t) c_int;
pub extern fn ASN1_GENERALIZEDTIME_check(a: [*c]const ASN1_GENERALIZEDTIME) c_int;
pub extern fn ASN1_GENERALIZEDTIME_set(s: [*c]ASN1_GENERALIZEDTIME, t: time_t) [*c]ASN1_GENERALIZEDTIME;
pub extern fn ASN1_GENERALIZEDTIME_adj(s: [*c]ASN1_GENERALIZEDTIME, t: time_t, offset_day: c_int, offset_sec: c_long) [*c]ASN1_GENERALIZEDTIME;
pub extern fn ASN1_GENERALIZEDTIME_set_string(s: [*c]ASN1_GENERALIZEDTIME, str: [*c]const u8) c_int;
pub extern fn ASN1_TIME_diff(pday: [*c]c_int, psec: [*c]c_int, from: [*c]const ASN1_TIME, to: [*c]const ASN1_TIME) c_int;
pub extern fn ASN1_OCTET_STRING_new() [*c]ASN1_OCTET_STRING;
pub extern fn ASN1_OCTET_STRING_free(a: [*c]ASN1_OCTET_STRING) void;
pub extern fn d2i_ASN1_OCTET_STRING(a: [*c][*c]ASN1_OCTET_STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_OCTET_STRING;
pub extern fn i2d_ASN1_OCTET_STRING(a: [*c]const ASN1_OCTET_STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_OCTET_STRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_OCTET_STRING_dup(a: [*c]const ASN1_OCTET_STRING) [*c]ASN1_OCTET_STRING;
pub extern fn ASN1_OCTET_STRING_cmp(a: [*c]const ASN1_OCTET_STRING, b: [*c]const ASN1_OCTET_STRING) c_int;
pub extern fn ASN1_OCTET_STRING_set(str: [*c]ASN1_OCTET_STRING, data: [*c]const u8, len: c_int) c_int;
pub const struct_stack_st_ASN1_UTF8STRING = opaque {};
pub const sk_ASN1_UTF8STRING_compfunc = ?*const fn ([*c]const [*c]const ASN1_UTF8STRING, [*c]const [*c]const ASN1_UTF8STRING) callconv(.c) c_int;
pub const sk_ASN1_UTF8STRING_freefunc = ?*const fn ([*c]ASN1_UTF8STRING) callconv(.c) void;
pub const sk_ASN1_UTF8STRING_copyfunc = ?*const fn ([*c]const ASN1_UTF8STRING) callconv(.c) [*c]ASN1_UTF8STRING;
pub fn ossl_check_ASN1_UTF8STRING_type(arg_ptr: [*c]ASN1_UTF8STRING) callconv(.c) [*c]ASN1_UTF8STRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_UTF8STRING_sk_type(arg_sk: ?*const struct_stack_st_ASN1_UTF8STRING) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_UTF8STRING_sk_type(arg_sk: ?*struct_stack_st_ASN1_UTF8STRING) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_UTF8STRING_compfunc_type(arg_cmp: sk_ASN1_UTF8STRING_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_UTF8STRING_copyfunc_type(arg_cpy: sk_ASN1_UTF8STRING_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_UTF8STRING_freefunc_type(arg_fr: sk_ASN1_UTF8STRING_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn ASN1_VISIBLESTRING_new() [*c]ASN1_VISIBLESTRING;
pub extern fn ASN1_VISIBLESTRING_free(a: [*c]ASN1_VISIBLESTRING) void;
pub extern fn d2i_ASN1_VISIBLESTRING(a: [*c][*c]ASN1_VISIBLESTRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_VISIBLESTRING;
pub extern fn i2d_ASN1_VISIBLESTRING(a: [*c]const ASN1_VISIBLESTRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_VISIBLESTRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_UNIVERSALSTRING_new() [*c]ASN1_UNIVERSALSTRING;
pub extern fn ASN1_UNIVERSALSTRING_free(a: [*c]ASN1_UNIVERSALSTRING) void;
pub extern fn d2i_ASN1_UNIVERSALSTRING(a: [*c][*c]ASN1_UNIVERSALSTRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_UNIVERSALSTRING;
pub extern fn i2d_ASN1_UNIVERSALSTRING(a: [*c]const ASN1_UNIVERSALSTRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_UNIVERSALSTRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_UTF8STRING_new() [*c]ASN1_UTF8STRING;
pub extern fn ASN1_UTF8STRING_free(a: [*c]ASN1_UTF8STRING) void;
pub extern fn d2i_ASN1_UTF8STRING(a: [*c][*c]ASN1_UTF8STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_UTF8STRING;
pub extern fn i2d_ASN1_UTF8STRING(a: [*c]const ASN1_UTF8STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_UTF8STRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_NULL_new() [*c]ASN1_NULL;
pub extern fn ASN1_NULL_free(a: [*c]ASN1_NULL) void;
pub extern fn d2i_ASN1_NULL(a: [*c][*c]ASN1_NULL, in: [*c][*c]const u8, len: c_long) [*c]ASN1_NULL;
pub extern fn i2d_ASN1_NULL(a: [*c]const ASN1_NULL, out: [*c][*c]u8) c_int;
pub extern fn ASN1_NULL_it() ?*const ASN1_ITEM;
pub extern fn ASN1_BMPSTRING_new() [*c]ASN1_BMPSTRING;
pub extern fn ASN1_BMPSTRING_free(a: [*c]ASN1_BMPSTRING) void;
pub extern fn d2i_ASN1_BMPSTRING(a: [*c][*c]ASN1_BMPSTRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_BMPSTRING;
pub extern fn i2d_ASN1_BMPSTRING(a: [*c]const ASN1_BMPSTRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_BMPSTRING_it() ?*const ASN1_ITEM;
pub extern fn UTF8_getc(str: [*c]const u8, len: c_int, val: [*c]c_ulong) c_int;
pub extern fn UTF8_putc(str: [*c]u8, len: c_int, value: c_ulong) c_int;
pub const struct_stack_st_ASN1_GENERALSTRING = opaque {};
pub const sk_ASN1_GENERALSTRING_compfunc = ?*const fn ([*c]const [*c]const ASN1_GENERALSTRING, [*c]const [*c]const ASN1_GENERALSTRING) callconv(.c) c_int;
pub const sk_ASN1_GENERALSTRING_freefunc = ?*const fn ([*c]ASN1_GENERALSTRING) callconv(.c) void;
pub const sk_ASN1_GENERALSTRING_copyfunc = ?*const fn ([*c]const ASN1_GENERALSTRING) callconv(.c) [*c]ASN1_GENERALSTRING;
pub fn ossl_check_ASN1_GENERALSTRING_type(arg_ptr: [*c]ASN1_GENERALSTRING) callconv(.c) [*c]ASN1_GENERALSTRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_GENERALSTRING_sk_type(arg_sk: ?*const struct_stack_st_ASN1_GENERALSTRING) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_GENERALSTRING_sk_type(arg_sk: ?*struct_stack_st_ASN1_GENERALSTRING) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_GENERALSTRING_compfunc_type(arg_cmp: sk_ASN1_GENERALSTRING_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_GENERALSTRING_copyfunc_type(arg_cpy: sk_ASN1_GENERALSTRING_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_GENERALSTRING_freefunc_type(arg_fr: sk_ASN1_GENERALSTRING_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn ASN1_PRINTABLE_new() [*c]ASN1_STRING;
pub extern fn ASN1_PRINTABLE_free(a: [*c]ASN1_STRING) void;
pub extern fn d2i_ASN1_PRINTABLE(a: [*c][*c]ASN1_STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_STRING;
pub extern fn i2d_ASN1_PRINTABLE(a: [*c]const ASN1_STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_PRINTABLE_it() ?*const ASN1_ITEM;
pub extern fn DIRECTORYSTRING_new() [*c]ASN1_STRING;
pub extern fn DIRECTORYSTRING_free(a: [*c]ASN1_STRING) void;
pub extern fn d2i_DIRECTORYSTRING(a: [*c][*c]ASN1_STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_STRING;
pub extern fn i2d_DIRECTORYSTRING(a: [*c]const ASN1_STRING, out: [*c][*c]u8) c_int;
pub extern fn DIRECTORYSTRING_it() ?*const ASN1_ITEM;
pub extern fn DISPLAYTEXT_new() [*c]ASN1_STRING;
pub extern fn DISPLAYTEXT_free(a: [*c]ASN1_STRING) void;
pub extern fn d2i_DISPLAYTEXT(a: [*c][*c]ASN1_STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_STRING;
pub extern fn i2d_DISPLAYTEXT(a: [*c]const ASN1_STRING, out: [*c][*c]u8) c_int;
pub extern fn DISPLAYTEXT_it() ?*const ASN1_ITEM;
pub extern fn ASN1_PRINTABLESTRING_new() [*c]ASN1_PRINTABLESTRING;
pub extern fn ASN1_PRINTABLESTRING_free(a: [*c]ASN1_PRINTABLESTRING) void;
pub extern fn d2i_ASN1_PRINTABLESTRING(a: [*c][*c]ASN1_PRINTABLESTRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_PRINTABLESTRING;
pub extern fn i2d_ASN1_PRINTABLESTRING(a: [*c]const ASN1_PRINTABLESTRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_PRINTABLESTRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_T61STRING_new() [*c]ASN1_T61STRING;
pub extern fn ASN1_T61STRING_free(a: [*c]ASN1_T61STRING) void;
pub extern fn d2i_ASN1_T61STRING(a: [*c][*c]ASN1_T61STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_T61STRING;
pub extern fn i2d_ASN1_T61STRING(a: [*c]const ASN1_T61STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_T61STRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_IA5STRING_new() [*c]ASN1_IA5STRING;
pub extern fn ASN1_IA5STRING_free(a: [*c]ASN1_IA5STRING) void;
pub extern fn d2i_ASN1_IA5STRING(a: [*c][*c]ASN1_IA5STRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_IA5STRING;
pub extern fn i2d_ASN1_IA5STRING(a: [*c]const ASN1_IA5STRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_IA5STRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_GENERALSTRING_new() [*c]ASN1_GENERALSTRING;
pub extern fn ASN1_GENERALSTRING_free(a: [*c]ASN1_GENERALSTRING) void;
pub extern fn d2i_ASN1_GENERALSTRING(a: [*c][*c]ASN1_GENERALSTRING, in: [*c][*c]const u8, len: c_long) [*c]ASN1_GENERALSTRING;
pub extern fn i2d_ASN1_GENERALSTRING(a: [*c]const ASN1_GENERALSTRING, out: [*c][*c]u8) c_int;
pub extern fn ASN1_GENERALSTRING_it() ?*const ASN1_ITEM;
pub extern fn ASN1_UTCTIME_new() [*c]ASN1_UTCTIME;
pub extern fn ASN1_UTCTIME_free(a: [*c]ASN1_UTCTIME) void;
pub extern fn d2i_ASN1_UTCTIME(a: [*c][*c]ASN1_UTCTIME, in: [*c][*c]const u8, len: c_long) [*c]ASN1_UTCTIME;
pub extern fn i2d_ASN1_UTCTIME(a: [*c]const ASN1_UTCTIME, out: [*c][*c]u8) c_int;
pub extern fn ASN1_UTCTIME_it() ?*const ASN1_ITEM;
pub extern fn ASN1_GENERALIZEDTIME_new() [*c]ASN1_GENERALIZEDTIME;
pub extern fn ASN1_GENERALIZEDTIME_free(a: [*c]ASN1_GENERALIZEDTIME) void;
pub extern fn d2i_ASN1_GENERALIZEDTIME(a: [*c][*c]ASN1_GENERALIZEDTIME, in: [*c][*c]const u8, len: c_long) [*c]ASN1_GENERALIZEDTIME;
pub extern fn i2d_ASN1_GENERALIZEDTIME(a: [*c]const ASN1_GENERALIZEDTIME, out: [*c][*c]u8) c_int;
pub extern fn ASN1_GENERALIZEDTIME_it() ?*const ASN1_ITEM;
pub extern fn ASN1_TIME_new() [*c]ASN1_TIME;
pub extern fn ASN1_TIME_free(a: [*c]ASN1_TIME) void;
pub extern fn d2i_ASN1_TIME(a: [*c][*c]ASN1_TIME, in: [*c][*c]const u8, len: c_long) [*c]ASN1_TIME;
pub extern fn i2d_ASN1_TIME(a: [*c]const ASN1_TIME, out: [*c][*c]u8) c_int;
pub extern fn ASN1_TIME_it() ?*const ASN1_ITEM;
pub extern fn ASN1_TIME_dup(a: [*c]const ASN1_TIME) [*c]ASN1_TIME;
pub extern fn ASN1_UTCTIME_dup(a: [*c]const ASN1_UTCTIME) [*c]ASN1_UTCTIME;
pub extern fn ASN1_GENERALIZEDTIME_dup(a: [*c]const ASN1_GENERALIZEDTIME) [*c]ASN1_GENERALIZEDTIME;
pub extern fn ASN1_OCTET_STRING_NDEF_it() ?*const ASN1_ITEM;
pub extern fn ASN1_TIME_set(s: [*c]ASN1_TIME, t: time_t) [*c]ASN1_TIME;
pub extern fn ASN1_TIME_adj(s: [*c]ASN1_TIME, t: time_t, offset_day: c_int, offset_sec: c_long) [*c]ASN1_TIME;
pub extern fn ASN1_TIME_check(t: [*c]const ASN1_TIME) c_int;
pub extern fn ASN1_TIME_to_generalizedtime(t: [*c]const ASN1_TIME, out: [*c][*c]ASN1_GENERALIZEDTIME) [*c]ASN1_GENERALIZEDTIME;
pub extern fn ASN1_TIME_set_string(s: [*c]ASN1_TIME, str: [*c]const u8) c_int;
pub extern fn ASN1_TIME_set_string_X509(s: [*c]ASN1_TIME, str: [*c]const u8) c_int;
pub extern fn ASN1_TIME_to_tm(s: [*c]const ASN1_TIME, tm: [*c]struct_tm) c_int;
pub extern fn ASN1_TIME_normalize(s: [*c]ASN1_TIME) c_int;
pub extern fn ASN1_TIME_cmp_time_t(s: [*c]const ASN1_TIME, t: time_t) c_int;
pub extern fn ASN1_TIME_compare(a: [*c]const ASN1_TIME, b: [*c]const ASN1_TIME) c_int;
pub extern fn i2a_ASN1_INTEGER(bp: ?*BIO, a: [*c]const ASN1_INTEGER) c_int;
pub extern fn a2i_ASN1_INTEGER(bp: ?*BIO, bs: [*c]ASN1_INTEGER, buf: [*c]u8, size: c_int) c_int;
pub extern fn i2a_ASN1_ENUMERATED(bp: ?*BIO, a: [*c]const ASN1_ENUMERATED) c_int;
pub extern fn a2i_ASN1_ENUMERATED(bp: ?*BIO, bs: [*c]ASN1_ENUMERATED, buf: [*c]u8, size: c_int) c_int;
pub extern fn i2a_ASN1_OBJECT(bp: ?*BIO, a: ?*const ASN1_OBJECT) c_int;
pub extern fn a2i_ASN1_STRING(bp: ?*BIO, bs: [*c]ASN1_STRING, buf: [*c]u8, size: c_int) c_int;
pub extern fn i2a_ASN1_STRING(bp: ?*BIO, a: [*c]const ASN1_STRING, @"type": c_int) c_int;
pub extern fn i2t_ASN1_OBJECT(buf: [*c]u8, buf_len: c_int, a: ?*const ASN1_OBJECT) c_int;
pub extern fn a2d_ASN1_OBJECT(out: [*c]u8, olen: c_int, buf: [*c]const u8, num: c_int) c_int;
pub extern fn ASN1_OBJECT_create(nid: c_int, data: [*c]u8, len: c_int, sn: [*c]const u8, ln: [*c]const u8) ?*ASN1_OBJECT;
pub extern fn ASN1_INTEGER_get_int64(pr: [*c]i64, a: [*c]const ASN1_INTEGER) c_int;
pub extern fn ASN1_INTEGER_set_int64(a: [*c]ASN1_INTEGER, r: i64) c_int;
pub extern fn ASN1_INTEGER_get_uint64(pr: [*c]u64, a: [*c]const ASN1_INTEGER) c_int;
pub extern fn ASN1_INTEGER_set_uint64(a: [*c]ASN1_INTEGER, r: u64) c_int;
pub extern fn ASN1_INTEGER_set(a: [*c]ASN1_INTEGER, v: c_long) c_int;
pub extern fn ASN1_INTEGER_get(a: [*c]const ASN1_INTEGER) c_long;
pub extern fn BN_to_ASN1_INTEGER(bn: ?*const BIGNUM, ai: [*c]ASN1_INTEGER) [*c]ASN1_INTEGER;
pub extern fn ASN1_INTEGER_to_BN(ai: [*c]const ASN1_INTEGER, bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn ASN1_ENUMERATED_get_int64(pr: [*c]i64, a: [*c]const ASN1_ENUMERATED) c_int;
pub extern fn ASN1_ENUMERATED_set_int64(a: [*c]ASN1_ENUMERATED, r: i64) c_int;
pub extern fn ASN1_ENUMERATED_set(a: [*c]ASN1_ENUMERATED, v: c_long) c_int;
pub extern fn ASN1_ENUMERATED_get(a: [*c]const ASN1_ENUMERATED) c_long;
pub extern fn BN_to_ASN1_ENUMERATED(bn: ?*const BIGNUM, ai: [*c]ASN1_ENUMERATED) [*c]ASN1_ENUMERATED;
pub extern fn ASN1_ENUMERATED_to_BN(ai: [*c]const ASN1_ENUMERATED, bn: ?*BIGNUM) ?*BIGNUM;
pub extern fn ASN1_PRINTABLE_type(s: [*c]const u8, max: c_int) c_int;
pub extern fn ASN1_tag2bit(tag: c_int) c_ulong;
pub extern fn ASN1_get_object(pp: [*c][*c]const u8, plength: [*c]c_long, ptag: [*c]c_int, pclass: [*c]c_int, omax: c_long) c_int;
pub extern fn ASN1_check_infinite_end(p: [*c][*c]u8, len: c_long) c_int;
pub extern fn ASN1_const_check_infinite_end(p: [*c][*c]const u8, len: c_long) c_int;
pub extern fn ASN1_put_object(pp: [*c][*c]u8, constructed: c_int, length: c_int, tag: c_int, xclass: c_int) void;
pub extern fn ASN1_put_eoc(pp: [*c][*c]u8) c_int;
pub extern fn ASN1_object_size(constructed: c_int, length: c_int, tag: c_int) c_int;
pub extern fn ASN1_dup(i2d: ?*const i2d_of_void, d2i: ?*const d2i_of_void, x: ?*const anyopaque) ?*anyopaque;
pub extern fn ASN1_item_dup(it: ?*const ASN1_ITEM, x: ?*const anyopaque) ?*anyopaque;
pub extern fn ASN1_item_sign_ex(it: ?*const ASN1_ITEM, algor1: [*c]X509_ALGOR, algor2: [*c]X509_ALGOR, signature: [*c]ASN1_BIT_STRING, data: ?*const anyopaque, id: [*c]const ASN1_OCTET_STRING, pkey: ?*EVP_PKEY, md: ?*const EVP_MD, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn ASN1_item_verify_ex(it: ?*const ASN1_ITEM, alg: [*c]const X509_ALGOR, signature: [*c]const ASN1_BIT_STRING, data: ?*const anyopaque, id: [*c]const ASN1_OCTET_STRING, pkey: ?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn ASN1_d2i_fp(xnew: ?*const fn () callconv(.c) ?*anyopaque, d2i: ?*const d2i_of_void, in: [*c]FILE, x: [*c]?*anyopaque) ?*anyopaque;
pub extern fn ASN1_item_d2i_fp_ex(it: ?*const ASN1_ITEM, in: [*c]FILE, x: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*anyopaque;
pub extern fn ASN1_item_d2i_fp(it: ?*const ASN1_ITEM, in: [*c]FILE, x: ?*anyopaque) ?*anyopaque;
pub extern fn ASN1_i2d_fp(i2d: ?*const i2d_of_void, out: [*c]FILE, x: ?*const anyopaque) c_int;
pub extern fn ASN1_item_i2d_fp(it: ?*const ASN1_ITEM, out: [*c]FILE, x: ?*const anyopaque) c_int;
pub extern fn ASN1_STRING_print_ex_fp(fp: [*c]FILE, str: [*c]const ASN1_STRING, flags: c_ulong) c_int;
pub extern fn ASN1_STRING_to_UTF8(out: [*c][*c]u8, in: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_d2i_bio(xnew: ?*const fn () callconv(.c) ?*anyopaque, d2i: ?*const d2i_of_void, in: ?*BIO, x: [*c]?*anyopaque) ?*anyopaque;
pub extern fn ASN1_item_d2i_bio_ex(it: ?*const ASN1_ITEM, in: ?*BIO, pval: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*anyopaque;
pub extern fn ASN1_item_d2i_bio(it: ?*const ASN1_ITEM, in: ?*BIO, pval: ?*anyopaque) ?*anyopaque;
pub extern fn ASN1_i2d_bio(i2d: ?*const i2d_of_void, out: ?*BIO, x: ?*const anyopaque) c_int;
pub extern fn ASN1_item_i2d_bio(it: ?*const ASN1_ITEM, out: ?*BIO, x: ?*const anyopaque) c_int;
pub extern fn ASN1_item_i2d_mem_bio(it: ?*const ASN1_ITEM, val: ?*const ASN1_VALUE) ?*BIO;
pub extern fn ASN1_UTCTIME_print(fp: ?*BIO, a: [*c]const ASN1_UTCTIME) c_int;
pub extern fn ASN1_GENERALIZEDTIME_print(fp: ?*BIO, a: [*c]const ASN1_GENERALIZEDTIME) c_int;
pub extern fn ASN1_TIME_print(bp: ?*BIO, tm: [*c]const ASN1_TIME) c_int;
pub extern fn ASN1_TIME_print_ex(bp: ?*BIO, tm: [*c]const ASN1_TIME, flags: c_ulong) c_int;
pub extern fn ASN1_STRING_print(bp: ?*BIO, v: [*c]const ASN1_STRING) c_int;
pub extern fn ASN1_STRING_print_ex(out: ?*BIO, str: [*c]const ASN1_STRING, flags: c_ulong) c_int;
pub extern fn ASN1_buf_print(bp: ?*BIO, buf: [*c]const u8, buflen: usize, off: c_int) c_int;
pub extern fn ASN1_bn_print(bp: ?*BIO, number: [*c]const u8, num: ?*const BIGNUM, buf: [*c]u8, off: c_int) c_int;
pub extern fn ASN1_parse(bp: ?*BIO, pp: [*c]const u8, len: c_long, indent: c_int) c_int;
pub extern fn ASN1_parse_dump(bp: ?*BIO, pp: [*c]const u8, len: c_long, indent: c_int, dump: c_int) c_int;
pub extern fn ASN1_tag2str(tag: c_int) [*c]const u8;
pub extern fn ASN1_UNIVERSALSTRING_to_string(s: [*c]ASN1_UNIVERSALSTRING) c_int;
pub extern fn ASN1_TYPE_set_octetstring(a: [*c]ASN1_TYPE, data: [*c]u8, len: c_int) c_int;
pub extern fn ASN1_TYPE_get_octetstring(a: [*c]const ASN1_TYPE, data: [*c]u8, max_len: c_int) c_int;
pub extern fn ASN1_TYPE_set_int_octetstring(a: [*c]ASN1_TYPE, num: c_long, data: [*c]u8, len: c_int) c_int;
pub extern fn ASN1_TYPE_get_int_octetstring(a: [*c]const ASN1_TYPE, num: [*c]c_long, data: [*c]u8, max_len: c_int) c_int;
pub extern fn ASN1_item_unpack(oct: [*c]const ASN1_STRING, it: ?*const ASN1_ITEM) ?*anyopaque;
pub extern fn ASN1_item_unpack_ex(oct: [*c]const ASN1_STRING, it: ?*const ASN1_ITEM, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*anyopaque;
pub extern fn ASN1_item_pack(obj: ?*anyopaque, it: ?*const ASN1_ITEM, oct: [*c][*c]ASN1_OCTET_STRING) [*c]ASN1_STRING;
pub extern fn ASN1_STRING_set_default_mask(mask: c_ulong) void;
pub extern fn ASN1_STRING_set_default_mask_asc(p: [*c]const u8) c_int;
pub extern fn ASN1_STRING_get_default_mask() c_ulong;
pub extern fn ASN1_mbstring_copy(out: [*c][*c]ASN1_STRING, in: [*c]const u8, len: c_int, inform: c_int, mask: c_ulong) c_int;
pub extern fn ASN1_mbstring_ncopy(out: [*c][*c]ASN1_STRING, in: [*c]const u8, len: c_int, inform: c_int, mask: c_ulong, minsize: c_long, maxsize: c_long) c_int;
pub extern fn ASN1_STRING_set_by_NID(out: [*c][*c]ASN1_STRING, in: [*c]const u8, inlen: c_int, inform: c_int, nid: c_int) [*c]ASN1_STRING;
pub extern fn ASN1_STRING_TABLE_get(nid: c_int) [*c]ASN1_STRING_TABLE;
pub extern fn ASN1_STRING_TABLE_add(c_int, c_long, c_long, c_ulong, c_ulong) c_int;
pub extern fn ASN1_STRING_TABLE_cleanup() void;
pub extern fn ASN1_item_new(it: ?*const ASN1_ITEM) ?*ASN1_VALUE;
pub extern fn ASN1_item_new_ex(it: ?*const ASN1_ITEM, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*ASN1_VALUE;
pub extern fn ASN1_item_free(val: ?*ASN1_VALUE, it: ?*const ASN1_ITEM) void;
pub extern fn ASN1_item_d2i_ex(val: [*c]?*ASN1_VALUE, in: [*c][*c]const u8, len: c_long, it: ?*const ASN1_ITEM, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*ASN1_VALUE;
pub extern fn ASN1_item_d2i(val: [*c]?*ASN1_VALUE, in: [*c][*c]const u8, len: c_long, it: ?*const ASN1_ITEM) ?*ASN1_VALUE;
pub extern fn ASN1_item_i2d(val: ?*const ASN1_VALUE, out: [*c][*c]u8, it: ?*const ASN1_ITEM) c_int;
pub extern fn ASN1_item_ndef_i2d(val: ?*const ASN1_VALUE, out: [*c][*c]u8, it: ?*const ASN1_ITEM) c_int;
pub extern fn ASN1_add_oid_module() void;
pub extern fn ASN1_add_stable_module() void;
pub extern fn ASN1_generate_nconf(str: [*c]const u8, nconf: [*c]CONF) [*c]ASN1_TYPE;
pub extern fn ASN1_generate_v3(str: [*c]const u8, cnf: [*c]X509V3_CTX) [*c]ASN1_TYPE;
pub extern fn ASN1_str2mask(str: [*c]const u8, pmask: [*c]c_ulong) c_int;
pub extern fn ASN1_item_print(out: ?*BIO, ifld: ?*const ASN1_VALUE, indent: c_int, it: ?*const ASN1_ITEM, pctx: ?*const ASN1_PCTX) c_int;
pub extern fn ASN1_PCTX_new() ?*ASN1_PCTX;
pub extern fn ASN1_PCTX_free(p: ?*ASN1_PCTX) void;
pub extern fn ASN1_PCTX_get_flags(p: ?*const ASN1_PCTX) c_ulong;
pub extern fn ASN1_PCTX_set_flags(p: ?*ASN1_PCTX, flags: c_ulong) void;
pub extern fn ASN1_PCTX_get_nm_flags(p: ?*const ASN1_PCTX) c_ulong;
pub extern fn ASN1_PCTX_set_nm_flags(p: ?*ASN1_PCTX, flags: c_ulong) void;
pub extern fn ASN1_PCTX_get_cert_flags(p: ?*const ASN1_PCTX) c_ulong;
pub extern fn ASN1_PCTX_set_cert_flags(p: ?*ASN1_PCTX, flags: c_ulong) void;
pub extern fn ASN1_PCTX_get_oid_flags(p: ?*const ASN1_PCTX) c_ulong;
pub extern fn ASN1_PCTX_set_oid_flags(p: ?*ASN1_PCTX, flags: c_ulong) void;
pub extern fn ASN1_PCTX_get_str_flags(p: ?*const ASN1_PCTX) c_ulong;
pub extern fn ASN1_PCTX_set_str_flags(p: ?*ASN1_PCTX, flags: c_ulong) void;
pub extern fn ASN1_SCTX_new(scan_cb: ?*const fn (?*ASN1_SCTX) callconv(.c) c_int) ?*ASN1_SCTX;
pub extern fn ASN1_SCTX_free(p: ?*ASN1_SCTX) void;
pub extern fn ASN1_SCTX_get_item(p: ?*ASN1_SCTX) ?*const ASN1_ITEM;
pub extern fn ASN1_SCTX_get_template(p: ?*ASN1_SCTX) ?*const ASN1_TEMPLATE;
pub extern fn ASN1_SCTX_get_flags(p: ?*ASN1_SCTX) c_ulong;
pub extern fn ASN1_SCTX_set_app_data(p: ?*ASN1_SCTX, data: ?*anyopaque) void;
pub extern fn ASN1_SCTX_get_app_data(p: ?*ASN1_SCTX) ?*anyopaque;
pub extern fn BIO_f_asn1() ?*const BIO_METHOD;
pub extern fn BIO_new_NDEF(out: ?*BIO, val: ?*ASN1_VALUE, it: ?*const ASN1_ITEM) ?*BIO;
pub extern fn i2d_ASN1_bio_stream(out: ?*BIO, val: ?*ASN1_VALUE, in: ?*BIO, flags: c_int, it: ?*const ASN1_ITEM) c_int;
pub extern fn PEM_write_bio_ASN1_stream(out: ?*BIO, val: ?*ASN1_VALUE, in: ?*BIO, flags: c_int, hdr: [*c]const u8, it: ?*const ASN1_ITEM) c_int;
pub extern fn SMIME_write_ASN1(bio: ?*BIO, val: ?*ASN1_VALUE, data: ?*BIO, flags: c_int, ctype_nid: c_int, econt_nid: c_int, mdalgs: ?*struct_stack_st_X509_ALGOR, it: ?*const ASN1_ITEM) c_int;
pub extern fn SMIME_write_ASN1_ex(bio: ?*BIO, val: ?*ASN1_VALUE, data: ?*BIO, flags: c_int, ctype_nid: c_int, econt_nid: c_int, mdalgs: ?*struct_stack_st_X509_ALGOR, it: ?*const ASN1_ITEM, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn SMIME_read_ASN1(bio: ?*BIO, bcont: [*c]?*BIO, it: ?*const ASN1_ITEM) ?*ASN1_VALUE;
pub extern fn SMIME_read_ASN1_ex(bio: ?*BIO, flags: c_int, bcont: [*c]?*BIO, it: ?*const ASN1_ITEM, x: [*c]?*ASN1_VALUE, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*ASN1_VALUE;
pub extern fn SMIME_crlf_copy(in: ?*BIO, out: ?*BIO, flags: c_int) c_int;
pub extern fn SMIME_text(in: ?*BIO, out: ?*BIO) c_int;
pub extern fn ASN1_ITEM_lookup(name: [*c]const u8) ?*const ASN1_ITEM;
pub extern fn ASN1_ITEM_get(i: usize) ?*const ASN1_ITEM;
pub const struct_obj_name_st = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    alias: c_int = @import("std").mem.zeroes(c_int),
    name: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    data: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const OBJ_NAME = struct_obj_name_st;
pub extern fn OBJ_NAME_init() c_int;
pub extern fn OBJ_NAME_new_index(hash_func: ?*const fn ([*c]const u8) callconv(.c) c_ulong, cmp_func: ?*const fn ([*c]const u8, [*c]const u8) callconv(.c) c_int, free_func: ?*const fn ([*c]const u8, c_int, [*c]const u8) callconv(.c) void) c_int;
pub extern fn OBJ_NAME_get(name: [*c]const u8, @"type": c_int) [*c]const u8;
pub extern fn OBJ_NAME_add(name: [*c]const u8, @"type": c_int, data: [*c]const u8) c_int;
pub extern fn OBJ_NAME_remove(name: [*c]const u8, @"type": c_int) c_int;
pub extern fn OBJ_NAME_cleanup(@"type": c_int) void;
pub extern fn OBJ_NAME_do_all(@"type": c_int, @"fn": ?*const fn ([*c]const OBJ_NAME, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn OBJ_NAME_do_all_sorted(@"type": c_int, @"fn": ?*const fn ([*c]const OBJ_NAME, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn OBJ_dup(a: ?*const ASN1_OBJECT) ?*ASN1_OBJECT;
pub extern fn OBJ_nid2obj(n: c_int) ?*ASN1_OBJECT;
pub extern fn OBJ_nid2ln(n: c_int) [*c]const u8;
pub extern fn OBJ_nid2sn(n: c_int) [*c]const u8;
pub extern fn OBJ_obj2nid(o: ?*const ASN1_OBJECT) c_int;
pub extern fn OBJ_txt2obj(s: [*c]const u8, no_name: c_int) ?*ASN1_OBJECT;
pub extern fn OBJ_obj2txt(buf: [*c]u8, buf_len: c_int, a: ?*const ASN1_OBJECT, no_name: c_int) c_int;
pub extern fn OBJ_txt2nid(s: [*c]const u8) c_int;
pub extern fn OBJ_ln2nid(s: [*c]const u8) c_int;
pub extern fn OBJ_sn2nid(s: [*c]const u8) c_int;
pub extern fn OBJ_cmp(a: ?*const ASN1_OBJECT, b: ?*const ASN1_OBJECT) c_int;
pub extern fn OBJ_bsearch_(key: ?*const anyopaque, base: ?*const anyopaque, num: c_int, size: c_int, cmp: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.c) c_int) ?*const anyopaque;
pub extern fn OBJ_bsearch_ex_(key: ?*const anyopaque, base: ?*const anyopaque, num: c_int, size: c_int, cmp: ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.c) c_int, flags: c_int) ?*const anyopaque;
pub extern fn OBJ_new_nid(num: c_int) c_int;
pub extern fn OBJ_add_object(obj: ?*const ASN1_OBJECT) c_int;
pub extern fn OBJ_create(oid: [*c]const u8, sn: [*c]const u8, ln: [*c]const u8) c_int;
pub extern fn OBJ_create_objects(in: ?*BIO) c_int;
pub extern fn OBJ_length(obj: ?*const ASN1_OBJECT) usize;
pub extern fn OBJ_get0_data(obj: ?*const ASN1_OBJECT) [*c]const u8;
pub extern fn OBJ_find_sigid_algs(signid: c_int, pdig_nid: [*c]c_int, ppkey_nid: [*c]c_int) c_int;
pub extern fn OBJ_find_sigid_by_algs(psignid: [*c]c_int, dig_nid: c_int, pkey_nid: c_int) c_int;
pub extern fn OBJ_add_sigid(signid: c_int, dig_id: c_int, pkey_id: c_int) c_int;
pub extern fn OBJ_sigid_free() void;
pub extern fn EVP_set_default_properties(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn EVP_default_properties_is_fips_enabled(libctx: ?*OSSL_LIB_CTX) c_int;
pub extern fn EVP_default_properties_enable_fips(libctx: ?*OSSL_LIB_CTX, enable: c_int) c_int;
pub extern fn EVP_MD_meth_new(md_type: c_int, pkey_type: c_int) ?*EVP_MD;
pub extern fn EVP_MD_meth_dup(md: ?*const EVP_MD) ?*EVP_MD;
pub extern fn EVP_MD_meth_free(md: ?*EVP_MD) void;
pub extern fn EVP_MD_meth_set_input_blocksize(md: ?*EVP_MD, blocksize: c_int) c_int;
pub extern fn EVP_MD_meth_set_result_size(md: ?*EVP_MD, resultsize: c_int) c_int;
pub extern fn EVP_MD_meth_set_app_datasize(md: ?*EVP_MD, datasize: c_int) c_int;
pub extern fn EVP_MD_meth_set_flags(md: ?*EVP_MD, flags: c_ulong) c_int;
pub extern fn EVP_MD_meth_set_init(md: ?*EVP_MD, init: ?*const fn (?*EVP_MD_CTX) callconv(.c) c_int) c_int;
pub extern fn EVP_MD_meth_set_update(md: ?*EVP_MD, update: ?*const fn (?*EVP_MD_CTX, ?*const anyopaque, usize) callconv(.c) c_int) c_int;
pub extern fn EVP_MD_meth_set_final(md: ?*EVP_MD, final: ?*const fn (?*EVP_MD_CTX, [*c]u8) callconv(.c) c_int) c_int;
pub extern fn EVP_MD_meth_set_copy(md: ?*EVP_MD, copy: ?*const fn (?*EVP_MD_CTX, ?*const EVP_MD_CTX) callconv(.c) c_int) c_int;
pub extern fn EVP_MD_meth_set_cleanup(md: ?*EVP_MD, cleanup: ?*const fn (?*EVP_MD_CTX) callconv(.c) c_int) c_int;
pub extern fn EVP_MD_meth_set_ctrl(md: ?*EVP_MD, ctrl: ?*const fn (?*EVP_MD_CTX, c_int, c_int, ?*anyopaque) callconv(.c) c_int) c_int;
pub extern fn EVP_MD_meth_get_input_blocksize(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_meth_get_result_size(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_meth_get_app_datasize(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_meth_get_flags(md: ?*const EVP_MD) c_ulong;
pub extern fn EVP_MD_meth_get_init(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX) callconv(.c) c_int;
pub extern fn EVP_MD_meth_get_update(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX, ?*const anyopaque, usize) callconv(.c) c_int;
pub extern fn EVP_MD_meth_get_final(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX, [*c]u8) callconv(.c) c_int;
pub extern fn EVP_MD_meth_get_copy(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX, ?*const EVP_MD_CTX) callconv(.c) c_int;
pub extern fn EVP_MD_meth_get_cleanup(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX) callconv(.c) c_int;
pub extern fn EVP_MD_meth_get_ctrl(md: ?*const EVP_MD) ?*const fn (?*EVP_MD_CTX, c_int, c_int, ?*anyopaque) callconv(.c) c_int;
pub extern fn EVP_CIPHER_meth_new(cipher_type: c_int, block_size: c_int, key_len: c_int) ?*EVP_CIPHER;
pub extern fn EVP_CIPHER_meth_dup(cipher: ?*const EVP_CIPHER) ?*EVP_CIPHER;
pub extern fn EVP_CIPHER_meth_free(cipher: ?*EVP_CIPHER) void;
pub extern fn EVP_CIPHER_meth_set_iv_length(cipher: ?*EVP_CIPHER, iv_len: c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_flags(cipher: ?*EVP_CIPHER, flags: c_ulong) c_int;
pub extern fn EVP_CIPHER_meth_set_impl_ctx_size(cipher: ?*EVP_CIPHER, ctx_size: c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_init(cipher: ?*EVP_CIPHER, init: ?*const fn (?*EVP_CIPHER_CTX, [*c]const u8, [*c]const u8, c_int) callconv(.c) c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_do_cipher(cipher: ?*EVP_CIPHER, do_cipher: ?*const fn (?*EVP_CIPHER_CTX, [*c]u8, [*c]const u8, usize) callconv(.c) c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_cleanup(cipher: ?*EVP_CIPHER, cleanup: ?*const fn (?*EVP_CIPHER_CTX) callconv(.c) c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_set_asn1_params(cipher: ?*EVP_CIPHER, set_asn1_parameters: ?*const fn (?*EVP_CIPHER_CTX, [*c]ASN1_TYPE) callconv(.c) c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_get_asn1_params(cipher: ?*EVP_CIPHER, get_asn1_parameters: ?*const fn (?*EVP_CIPHER_CTX, [*c]ASN1_TYPE) callconv(.c) c_int) c_int;
pub extern fn EVP_CIPHER_meth_set_ctrl(cipher: ?*EVP_CIPHER, ctrl: ?*const fn (?*EVP_CIPHER_CTX, c_int, c_int, ?*anyopaque) callconv(.c) c_int) c_int;
pub extern fn EVP_CIPHER_meth_get_init(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX, [*c]const u8, [*c]const u8, c_int) callconv(.c) c_int;
pub extern fn EVP_CIPHER_meth_get_do_cipher(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX, [*c]u8, [*c]const u8, usize) callconv(.c) c_int;
pub extern fn EVP_CIPHER_meth_get_cleanup(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX) callconv(.c) c_int;
pub extern fn EVP_CIPHER_meth_get_set_asn1_params(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX, [*c]ASN1_TYPE) callconv(.c) c_int;
pub extern fn EVP_CIPHER_meth_get_get_asn1_params(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX, [*c]ASN1_TYPE) callconv(.c) c_int;
pub extern fn EVP_CIPHER_meth_get_ctrl(cipher: ?*const EVP_CIPHER) ?*const fn (?*EVP_CIPHER_CTX, c_int, c_int, ?*anyopaque) callconv(.c) c_int;
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM = extern struct {
    out: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    inp: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    len: usize = @import("std").mem.zeroes(usize),
    interleave: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const struct_evp_cipher_info_st = extern struct {
    cipher: ?*const EVP_CIPHER = @import("std").mem.zeroes(?*const EVP_CIPHER),
    iv: [16]u8 = @import("std").mem.zeroes([16]u8),
};
pub const EVP_CIPHER_INFO = struct_evp_cipher_info_st;
pub const EVP_PBE_KEYGEN = fn (?*EVP_CIPHER_CTX, [*c]const u8, c_int, [*c]ASN1_TYPE, ?*const EVP_CIPHER, ?*const EVP_MD, c_int) callconv(.c) c_int;
pub const EVP_PBE_KEYGEN_EX = fn (?*EVP_CIPHER_CTX, [*c]const u8, c_int, [*c]ASN1_TYPE, ?*const EVP_CIPHER, ?*const EVP_MD, c_int, ?*OSSL_LIB_CTX, [*c]const u8) callconv(.c) c_int;
pub extern fn EVP_MD_get_type(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_get0_name(md: ?*const EVP_MD) [*c]const u8;
pub extern fn EVP_MD_get0_description(md: ?*const EVP_MD) [*c]const u8;
pub extern fn EVP_MD_is_a(md: ?*const EVP_MD, name: [*c]const u8) c_int;
pub extern fn EVP_MD_names_do_all(md: ?*const EVP_MD, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) c_int;
pub extern fn EVP_MD_get0_provider(md: ?*const EVP_MD) ?*const OSSL_PROVIDER;
pub extern fn EVP_MD_get_pkey_type(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_get_size(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_get_block_size(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_get_flags(md: ?*const EVP_MD) c_ulong;
pub extern fn EVP_MD_xof(md: ?*const EVP_MD) c_int;
pub extern fn EVP_MD_CTX_get0_md(ctx: ?*const EVP_MD_CTX) ?*const EVP_MD;
pub extern fn EVP_MD_CTX_get1_md(ctx: ?*EVP_MD_CTX) ?*EVP_MD;
pub extern fn EVP_MD_CTX_md(ctx: ?*const EVP_MD_CTX) ?*const EVP_MD;
pub extern fn EVP_MD_CTX_update_fn(ctx: ?*EVP_MD_CTX) ?*const fn (?*EVP_MD_CTX, ?*const anyopaque, usize) callconv(.c) c_int;
pub extern fn EVP_MD_CTX_set_update_fn(ctx: ?*EVP_MD_CTX, update: ?*const fn (?*EVP_MD_CTX, ?*const anyopaque, usize) callconv(.c) c_int) void;
pub extern fn EVP_MD_CTX_get_size_ex(ctx: ?*const EVP_MD_CTX) c_int;
pub extern fn EVP_MD_CTX_get_pkey_ctx(ctx: ?*const EVP_MD_CTX) ?*EVP_PKEY_CTX;
pub extern fn EVP_MD_CTX_set_pkey_ctx(ctx: ?*EVP_MD_CTX, pctx: ?*EVP_PKEY_CTX) void;
pub extern fn EVP_MD_CTX_get0_md_data(ctx: ?*const EVP_MD_CTX) ?*anyopaque;
pub extern fn EVP_CIPHER_get_nid(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_get0_name(cipher: ?*const EVP_CIPHER) [*c]const u8;
pub extern fn EVP_CIPHER_get0_description(cipher: ?*const EVP_CIPHER) [*c]const u8;
pub extern fn EVP_CIPHER_is_a(cipher: ?*const EVP_CIPHER, name: [*c]const u8) c_int;
pub extern fn EVP_CIPHER_names_do_all(cipher: ?*const EVP_CIPHER, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) c_int;
pub extern fn EVP_CIPHER_get0_provider(cipher: ?*const EVP_CIPHER) ?*const OSSL_PROVIDER;
pub extern fn EVP_CIPHER_get_block_size(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_impl_ctx_size(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_get_key_length(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_get_iv_length(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_get_flags(cipher: ?*const EVP_CIPHER) c_ulong;
pub extern fn EVP_CIPHER_get_mode(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_get_type(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_CIPHER;
pub extern fn EVP_CIPHER_up_ref(cipher: ?*EVP_CIPHER) c_int;
pub extern fn EVP_CIPHER_free(cipher: ?*EVP_CIPHER) void;
pub extern fn EVP_CIPHER_CTX_get0_cipher(ctx: ?*const EVP_CIPHER_CTX) ?*const EVP_CIPHER;
pub extern fn EVP_CIPHER_CTX_get1_cipher(ctx: ?*EVP_CIPHER_CTX) ?*EVP_CIPHER;
pub extern fn EVP_CIPHER_CTX_is_encrypting(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_nid(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_block_size(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_key_length(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_iv_length(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_tag_length(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_cipher(ctx: ?*const EVP_CIPHER_CTX) ?*const EVP_CIPHER;
pub extern fn EVP_CIPHER_CTX_iv(ctx: ?*const EVP_CIPHER_CTX) [*c]const u8;
pub extern fn EVP_CIPHER_CTX_original_iv(ctx: ?*const EVP_CIPHER_CTX) [*c]const u8;
pub extern fn EVP_CIPHER_CTX_iv_noconst(ctx: ?*EVP_CIPHER_CTX) [*c]u8;
pub extern fn EVP_CIPHER_CTX_get_updated_iv(ctx: ?*EVP_CIPHER_CTX, buf: ?*anyopaque, len: usize) c_int;
pub extern fn EVP_CIPHER_CTX_get_original_iv(ctx: ?*EVP_CIPHER_CTX, buf: ?*anyopaque, len: usize) c_int;
pub extern fn EVP_CIPHER_CTX_buf_noconst(ctx: ?*EVP_CIPHER_CTX) [*c]u8;
pub extern fn EVP_CIPHER_CTX_get_num(ctx: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_set_num(ctx: ?*EVP_CIPHER_CTX, num: c_int) c_int;
pub extern fn EVP_CIPHER_CTX_dup(in: ?*const EVP_CIPHER_CTX) ?*EVP_CIPHER_CTX;
pub extern fn EVP_CIPHER_CTX_copy(out: ?*EVP_CIPHER_CTX, in: ?*const EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_get_app_data(ctx: ?*const EVP_CIPHER_CTX) ?*anyopaque;
pub extern fn EVP_CIPHER_CTX_set_app_data(ctx: ?*EVP_CIPHER_CTX, data: ?*anyopaque) void;
pub extern fn EVP_CIPHER_CTX_get_cipher_data(ctx: ?*const EVP_CIPHER_CTX) ?*anyopaque;
pub extern fn EVP_CIPHER_CTX_set_cipher_data(ctx: ?*EVP_CIPHER_CTX, cipher_data: ?*anyopaque) ?*anyopaque;
pub extern fn EVP_Cipher(c: ?*EVP_CIPHER_CTX, out: [*c]u8, in: [*c]const u8, inl: c_uint) c_int;
pub extern fn EVP_MD_get_params(digest: ?*const EVP_MD, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_MD_CTX_set_params(ctx: ?*EVP_MD_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_MD_CTX_get_params(ctx: ?*EVP_MD_CTX, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_MD_gettable_params(digest: ?*const EVP_MD) [*c]const OSSL_PARAM;
pub extern fn EVP_MD_settable_ctx_params(md: ?*const EVP_MD) [*c]const OSSL_PARAM;
pub extern fn EVP_MD_gettable_ctx_params(md: ?*const EVP_MD) [*c]const OSSL_PARAM;
pub extern fn EVP_MD_CTX_settable_params(ctx: ?*EVP_MD_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_MD_CTX_gettable_params(ctx: ?*EVP_MD_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_MD_CTX_ctrl(ctx: ?*EVP_MD_CTX, cmd: c_int, p1: c_int, p2: ?*anyopaque) c_int;
pub extern fn EVP_MD_CTX_new() ?*EVP_MD_CTX;
pub extern fn EVP_MD_CTX_reset(ctx: ?*EVP_MD_CTX) c_int;
pub extern fn EVP_MD_CTX_free(ctx: ?*EVP_MD_CTX) void;
pub extern fn EVP_MD_CTX_dup(in: ?*const EVP_MD_CTX) ?*EVP_MD_CTX;
pub extern fn EVP_MD_CTX_copy_ex(out: ?*EVP_MD_CTX, in: ?*const EVP_MD_CTX) c_int;
pub extern fn EVP_MD_CTX_set_flags(ctx: ?*EVP_MD_CTX, flags: c_int) void;
pub extern fn EVP_MD_CTX_clear_flags(ctx: ?*EVP_MD_CTX, flags: c_int) void;
pub extern fn EVP_MD_CTX_test_flags(ctx: ?*const EVP_MD_CTX, flags: c_int) c_int;
pub extern fn EVP_DigestInit_ex2(ctx: ?*EVP_MD_CTX, @"type": ?*const EVP_MD, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_DigestInit_ex(ctx: ?*EVP_MD_CTX, @"type": ?*const EVP_MD, impl: ?*ENGINE) c_int;
pub extern fn EVP_DigestUpdate(ctx: ?*EVP_MD_CTX, d: ?*const anyopaque, cnt: usize) c_int;
pub extern fn EVP_DigestFinal_ex(ctx: ?*EVP_MD_CTX, md: [*c]u8, s: [*c]c_uint) c_int;
pub extern fn EVP_Digest(data: ?*const anyopaque, count: usize, md: [*c]u8, size: [*c]c_uint, @"type": ?*const EVP_MD, impl: ?*ENGINE) c_int;
pub extern fn EVP_Q_digest(libctx: ?*OSSL_LIB_CTX, name: [*c]const u8, propq: [*c]const u8, data: ?*const anyopaque, datalen: usize, md: [*c]u8, mdlen: [*c]usize) c_int;
pub extern fn EVP_MD_CTX_copy(out: ?*EVP_MD_CTX, in: ?*const EVP_MD_CTX) c_int;
pub extern fn EVP_DigestInit(ctx: ?*EVP_MD_CTX, @"type": ?*const EVP_MD) c_int;
pub extern fn EVP_DigestFinal(ctx: ?*EVP_MD_CTX, md: [*c]u8, s: [*c]c_uint) c_int;
pub extern fn EVP_DigestFinalXOF(ctx: ?*EVP_MD_CTX, out: [*c]u8, outlen: usize) c_int;
pub extern fn EVP_DigestSqueeze(ctx: ?*EVP_MD_CTX, out: [*c]u8, outlen: usize) c_int;
pub extern fn EVP_MD_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_MD;
pub extern fn EVP_MD_up_ref(md: ?*EVP_MD) c_int;
pub extern fn EVP_MD_free(md: ?*EVP_MD) void;
pub extern fn EVP_read_pw_string(buf: [*c]u8, length: c_int, prompt: [*c]const u8, verify: c_int) c_int;
pub extern fn EVP_read_pw_string_min(buf: [*c]u8, minlen: c_int, maxlen: c_int, prompt: [*c]const u8, verify: c_int) c_int;
pub extern fn EVP_set_pw_prompt(prompt: [*c]const u8) void;
pub extern fn EVP_get_pw_prompt() [*c]u8;
pub extern fn EVP_BytesToKey(@"type": ?*const EVP_CIPHER, md: ?*const EVP_MD, salt: [*c]const u8, data: [*c]const u8, datal: c_int, count: c_int, key: [*c]u8, iv: [*c]u8) c_int;
pub extern fn EVP_CIPHER_CTX_set_flags(ctx: ?*EVP_CIPHER_CTX, flags: c_int) void;
pub extern fn EVP_CIPHER_CTX_clear_flags(ctx: ?*EVP_CIPHER_CTX, flags: c_int) void;
pub extern fn EVP_CIPHER_CTX_test_flags(ctx: ?*const EVP_CIPHER_CTX, flags: c_int) c_int;
pub extern fn EVP_EncryptInit(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8) c_int;
pub extern fn EVP_EncryptInit_ex(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, impl: ?*ENGINE, key: [*c]const u8, iv: [*c]const u8) c_int;
pub extern fn EVP_EncryptInit_ex2(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_EncryptUpdate(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int, in: [*c]const u8, inl: c_int) c_int;
pub extern fn EVP_EncryptFinal_ex(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_EncryptFinal(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_DecryptInit(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8) c_int;
pub extern fn EVP_DecryptInit_ex(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, impl: ?*ENGINE, key: [*c]const u8, iv: [*c]const u8) c_int;
pub extern fn EVP_DecryptInit_ex2(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_DecryptUpdate(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int, in: [*c]const u8, inl: c_int) c_int;
pub extern fn EVP_DecryptFinal(ctx: ?*EVP_CIPHER_CTX, outm: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_DecryptFinal_ex(ctx: ?*EVP_CIPHER_CTX, outm: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_CipherInit(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8, enc: c_int) c_int;
pub extern fn EVP_CipherInit_ex(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, impl: ?*ENGINE, key: [*c]const u8, iv: [*c]const u8, enc: c_int) c_int;
pub extern fn EVP_CipherInit_ex2(ctx: ?*EVP_CIPHER_CTX, cipher: ?*const EVP_CIPHER, key: [*c]const u8, iv: [*c]const u8, enc: c_int, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_CipherUpdate(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int, in: [*c]const u8, inl: c_int) c_int;
pub extern fn EVP_CipherFinal(ctx: ?*EVP_CIPHER_CTX, outm: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_CipherFinal_ex(ctx: ?*EVP_CIPHER_CTX, outm: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_SignFinal(ctx: ?*EVP_MD_CTX, md: [*c]u8, s: [*c]c_uint, pkey: ?*EVP_PKEY) c_int;
pub extern fn EVP_SignFinal_ex(ctx: ?*EVP_MD_CTX, md: [*c]u8, s: [*c]c_uint, pkey: ?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn EVP_DigestSign(ctx: ?*EVP_MD_CTX, sigret: [*c]u8, siglen: [*c]usize, tbs: [*c]const u8, tbslen: usize) c_int;
pub extern fn EVP_VerifyFinal(ctx: ?*EVP_MD_CTX, sigbuf: [*c]const u8, siglen: c_uint, pkey: ?*EVP_PKEY) c_int;
pub extern fn EVP_VerifyFinal_ex(ctx: ?*EVP_MD_CTX, sigbuf: [*c]const u8, siglen: c_uint, pkey: ?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn EVP_DigestVerify(ctx: ?*EVP_MD_CTX, sigret: [*c]const u8, siglen: usize, tbs: [*c]const u8, tbslen: usize) c_int;
pub extern fn EVP_DigestSignInit_ex(ctx: ?*EVP_MD_CTX, pctx: [*c]?*EVP_PKEY_CTX, mdname: [*c]const u8, libctx: ?*OSSL_LIB_CTX, props: [*c]const u8, pkey: ?*EVP_PKEY, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_DigestSignInit(ctx: ?*EVP_MD_CTX, pctx: [*c]?*EVP_PKEY_CTX, @"type": ?*const EVP_MD, e: ?*ENGINE, pkey: ?*EVP_PKEY) c_int;
pub extern fn EVP_DigestSignUpdate(ctx: ?*EVP_MD_CTX, data: ?*const anyopaque, dsize: usize) c_int;
pub extern fn EVP_DigestSignFinal(ctx: ?*EVP_MD_CTX, sigret: [*c]u8, siglen: [*c]usize) c_int;
pub extern fn EVP_DigestVerifyInit_ex(ctx: ?*EVP_MD_CTX, pctx: [*c]?*EVP_PKEY_CTX, mdname: [*c]const u8, libctx: ?*OSSL_LIB_CTX, props: [*c]const u8, pkey: ?*EVP_PKEY, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_DigestVerifyInit(ctx: ?*EVP_MD_CTX, pctx: [*c]?*EVP_PKEY_CTX, @"type": ?*const EVP_MD, e: ?*ENGINE, pkey: ?*EVP_PKEY) c_int;
pub extern fn EVP_DigestVerifyUpdate(ctx: ?*EVP_MD_CTX, data: ?*const anyopaque, dsize: usize) c_int;
pub extern fn EVP_DigestVerifyFinal(ctx: ?*EVP_MD_CTX, sig: [*c]const u8, siglen: usize) c_int;
pub extern fn EVP_OpenInit(ctx: ?*EVP_CIPHER_CTX, @"type": ?*const EVP_CIPHER, ek: [*c]const u8, ekl: c_int, iv: [*c]const u8, priv: ?*EVP_PKEY) c_int;
pub extern fn EVP_OpenFinal(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_SealInit(ctx: ?*EVP_CIPHER_CTX, @"type": ?*const EVP_CIPHER, ek: [*c][*c]u8, ekl: [*c]c_int, iv: [*c]u8, pubk: [*c]?*EVP_PKEY, npubk: c_int) c_int;
pub extern fn EVP_SealFinal(ctx: ?*EVP_CIPHER_CTX, out: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_ENCODE_CTX_new() ?*EVP_ENCODE_CTX;
pub extern fn EVP_ENCODE_CTX_free(ctx: ?*EVP_ENCODE_CTX) void;
pub extern fn EVP_ENCODE_CTX_copy(dctx: ?*EVP_ENCODE_CTX, sctx: ?*const EVP_ENCODE_CTX) c_int;
pub extern fn EVP_ENCODE_CTX_num(ctx: ?*EVP_ENCODE_CTX) c_int;
pub extern fn EVP_EncodeInit(ctx: ?*EVP_ENCODE_CTX) void;
pub extern fn EVP_EncodeUpdate(ctx: ?*EVP_ENCODE_CTX, out: [*c]u8, outl: [*c]c_int, in: [*c]const u8, inl: c_int) c_int;
pub extern fn EVP_EncodeFinal(ctx: ?*EVP_ENCODE_CTX, out: [*c]u8, outl: [*c]c_int) void;
pub extern fn EVP_EncodeBlock(t: [*c]u8, f: [*c]const u8, n: c_int) c_int;
pub extern fn EVP_DecodeInit(ctx: ?*EVP_ENCODE_CTX) void;
pub extern fn EVP_DecodeUpdate(ctx: ?*EVP_ENCODE_CTX, out: [*c]u8, outl: [*c]c_int, in: [*c]const u8, inl: c_int) c_int;
pub extern fn EVP_DecodeFinal(ctx: ?*EVP_ENCODE_CTX, out: [*c]u8, outl: [*c]c_int) c_int;
pub extern fn EVP_DecodeBlock(t: [*c]u8, f: [*c]const u8, n: c_int) c_int;
pub extern fn EVP_CIPHER_CTX_new() ?*EVP_CIPHER_CTX;
pub extern fn EVP_CIPHER_CTX_reset(c: ?*EVP_CIPHER_CTX) c_int;
pub extern fn EVP_CIPHER_CTX_free(c: ?*EVP_CIPHER_CTX) void;
pub extern fn EVP_CIPHER_CTX_set_key_length(x: ?*EVP_CIPHER_CTX, keylen: c_int) c_int;
pub extern fn EVP_CIPHER_CTX_set_padding(c: ?*EVP_CIPHER_CTX, pad: c_int) c_int;
pub extern fn EVP_CIPHER_CTX_ctrl(ctx: ?*EVP_CIPHER_CTX, @"type": c_int, arg: c_int, ptr: ?*anyopaque) c_int;
pub extern fn EVP_CIPHER_CTX_rand_key(ctx: ?*EVP_CIPHER_CTX, key: [*c]u8) c_int;
pub extern fn EVP_CIPHER_get_params(cipher: ?*EVP_CIPHER, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_CIPHER_CTX_set_params(ctx: ?*EVP_CIPHER_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_CIPHER_CTX_get_params(ctx: ?*EVP_CIPHER_CTX, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_CIPHER_gettable_params(cipher: ?*const EVP_CIPHER) [*c]const OSSL_PARAM;
pub extern fn EVP_CIPHER_settable_ctx_params(cipher: ?*const EVP_CIPHER) [*c]const OSSL_PARAM;
pub extern fn EVP_CIPHER_gettable_ctx_params(cipher: ?*const EVP_CIPHER) [*c]const OSSL_PARAM;
pub extern fn EVP_CIPHER_CTX_settable_params(ctx: ?*EVP_CIPHER_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_CIPHER_CTX_gettable_params(ctx: ?*EVP_CIPHER_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_CIPHER_CTX_set_algor_params(ctx: ?*EVP_CIPHER_CTX, alg: [*c]const X509_ALGOR) c_int;
pub extern fn EVP_CIPHER_CTX_get_algor_params(ctx: ?*EVP_CIPHER_CTX, alg: [*c]X509_ALGOR) c_int;
pub extern fn EVP_CIPHER_CTX_get_algor(ctx: ?*EVP_CIPHER_CTX, alg: [*c][*c]X509_ALGOR) c_int;
pub extern fn BIO_f_md() ?*const BIO_METHOD;
pub extern fn BIO_f_base64() ?*const BIO_METHOD;
pub extern fn BIO_f_cipher() ?*const BIO_METHOD;
pub extern fn BIO_f_reliable() ?*const BIO_METHOD;
pub extern fn BIO_set_cipher(b: ?*BIO, c: ?*const EVP_CIPHER, k: [*c]const u8, i: [*c]const u8, enc: c_int) c_int;
pub extern fn EVP_md_null() ?*const EVP_MD;
pub extern fn EVP_md4() ?*const EVP_MD;
pub extern fn EVP_md5() ?*const EVP_MD;
pub extern fn EVP_md5_sha1() ?*const EVP_MD;
pub extern fn EVP_blake2b512() ?*const EVP_MD;
pub extern fn EVP_blake2s256() ?*const EVP_MD;
pub extern fn EVP_sha1() ?*const EVP_MD;
pub extern fn EVP_sha224() ?*const EVP_MD;
pub extern fn EVP_sha256() ?*const EVP_MD;
pub extern fn EVP_sha384() ?*const EVP_MD;
pub extern fn EVP_sha512() ?*const EVP_MD;
pub extern fn EVP_sha512_224() ?*const EVP_MD;
pub extern fn EVP_sha512_256() ?*const EVP_MD;
pub extern fn EVP_sha3_224() ?*const EVP_MD;
pub extern fn EVP_sha3_256() ?*const EVP_MD;
pub extern fn EVP_sha3_384() ?*const EVP_MD;
pub extern fn EVP_sha3_512() ?*const EVP_MD;
pub extern fn EVP_shake128() ?*const EVP_MD;
pub extern fn EVP_shake256() ?*const EVP_MD;
pub extern fn EVP_mdc2() ?*const EVP_MD;
pub extern fn EVP_ripemd160() ?*const EVP_MD;
pub extern fn EVP_whirlpool() ?*const EVP_MD;
pub extern fn EVP_sm3() ?*const EVP_MD;
pub extern fn EVP_enc_null() ?*const EVP_CIPHER;
pub extern fn EVP_des_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_des_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_des_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_des_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_des_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_des_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_desx_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_des_ede3_wrap() ?*const EVP_CIPHER;
pub extern fn EVP_rc4() ?*const EVP_CIPHER;
pub extern fn EVP_rc4_40() ?*const EVP_CIPHER;
pub extern fn EVP_rc4_hmac_md5() ?*const EVP_CIPHER;
pub extern fn EVP_idea_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_idea_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_idea_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_idea_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_40_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_64_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_rc2_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_bf_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_bf_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_bf_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_bf_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_cast5_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_cast5_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_cast5_cfb64() ?*const EVP_CIPHER;
pub extern fn EVP_cast5_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_xts() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_wrap() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_wrap_pad() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_ocb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_wrap() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_wrap_pad() ?*const EVP_CIPHER;
pub extern fn EVP_aes_192_ocb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_xts() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_wrap() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_wrap_pad() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_ocb() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cbc_hmac_sha1() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cbc_hmac_sha1() ?*const EVP_CIPHER;
pub extern fn EVP_aes_128_cbc_hmac_sha256() ?*const EVP_CIPHER;
pub extern fn EVP_aes_256_cbc_hmac_sha256() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aria_128_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aria_192_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_gcm() ?*const EVP_CIPHER;
pub extern fn EVP_aria_256_ccm() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_128_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_192_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_cfb1() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_cfb8() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_camellia_256_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_chacha20() ?*const EVP_CIPHER;
pub extern fn EVP_chacha20_poly1305() ?*const EVP_CIPHER;
pub extern fn EVP_seed_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_seed_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_seed_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_seed_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_sm4_ecb() ?*const EVP_CIPHER;
pub extern fn EVP_sm4_cbc() ?*const EVP_CIPHER;
pub extern fn EVP_sm4_cfb128() ?*const EVP_CIPHER;
pub extern fn EVP_sm4_ofb() ?*const EVP_CIPHER;
pub extern fn EVP_sm4_ctr() ?*const EVP_CIPHER;
pub extern fn EVP_add_cipher(cipher: ?*const EVP_CIPHER) c_int;
pub extern fn EVP_add_digest(digest: ?*const EVP_MD) c_int;
pub extern fn EVP_get_cipherbyname(name: [*c]const u8) ?*const EVP_CIPHER;
pub extern fn EVP_get_digestbyname(name: [*c]const u8) ?*const EVP_MD;
pub extern fn EVP_CIPHER_do_all(@"fn": ?*const fn (?*const EVP_CIPHER, [*c]const u8, [*c]const u8, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn EVP_CIPHER_do_all_sorted(@"fn": ?*const fn (?*const EVP_CIPHER, [*c]const u8, [*c]const u8, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn EVP_CIPHER_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_CIPHER, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn EVP_MD_do_all(@"fn": ?*const fn (?*const EVP_MD, [*c]const u8, [*c]const u8, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn EVP_MD_do_all_sorted(@"fn": ?*const fn (?*const EVP_MD, [*c]const u8, [*c]const u8, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn EVP_MD_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_MD, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn EVP_MAC_fetch(libctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_MAC;
pub extern fn EVP_MAC_up_ref(mac: ?*EVP_MAC) c_int;
pub extern fn EVP_MAC_free(mac: ?*EVP_MAC) void;
pub extern fn EVP_MAC_get0_name(mac: ?*const EVP_MAC) [*c]const u8;
pub extern fn EVP_MAC_get0_description(mac: ?*const EVP_MAC) [*c]const u8;
pub extern fn EVP_MAC_is_a(mac: ?*const EVP_MAC, name: [*c]const u8) c_int;
pub extern fn EVP_MAC_get0_provider(mac: ?*const EVP_MAC) ?*const OSSL_PROVIDER;
pub extern fn EVP_MAC_get_params(mac: ?*EVP_MAC, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_MAC_CTX_new(mac: ?*EVP_MAC) ?*EVP_MAC_CTX;
pub extern fn EVP_MAC_CTX_free(ctx: ?*EVP_MAC_CTX) void;
pub extern fn EVP_MAC_CTX_dup(src: ?*const EVP_MAC_CTX) ?*EVP_MAC_CTX;
pub extern fn EVP_MAC_CTX_get0_mac(ctx: ?*EVP_MAC_CTX) ?*EVP_MAC;
pub extern fn EVP_MAC_CTX_get_params(ctx: ?*EVP_MAC_CTX, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_MAC_CTX_set_params(ctx: ?*EVP_MAC_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_MAC_CTX_get_mac_size(ctx: ?*EVP_MAC_CTX) usize;
pub extern fn EVP_MAC_CTX_get_block_size(ctx: ?*EVP_MAC_CTX) usize;
pub extern fn EVP_Q_mac(libctx: ?*OSSL_LIB_CTX, name: [*c]const u8, propq: [*c]const u8, subalg: [*c]const u8, params: [*c]const OSSL_PARAM, key: ?*const anyopaque, keylen: usize, data: [*c]const u8, datalen: usize, out: [*c]u8, outsize: usize, outlen: [*c]usize) [*c]u8;
pub extern fn EVP_MAC_init(ctx: ?*EVP_MAC_CTX, key: [*c]const u8, keylen: usize, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_MAC_update(ctx: ?*EVP_MAC_CTX, data: [*c]const u8, datalen: usize) c_int;
pub extern fn EVP_MAC_final(ctx: ?*EVP_MAC_CTX, out: [*c]u8, outl: [*c]usize, outsize: usize) c_int;
pub extern fn EVP_MAC_finalXOF(ctx: ?*EVP_MAC_CTX, out: [*c]u8, outsize: usize) c_int;
pub extern fn EVP_MAC_gettable_params(mac: ?*const EVP_MAC) [*c]const OSSL_PARAM;
pub extern fn EVP_MAC_gettable_ctx_params(mac: ?*const EVP_MAC) [*c]const OSSL_PARAM;
pub extern fn EVP_MAC_settable_ctx_params(mac: ?*const EVP_MAC) [*c]const OSSL_PARAM;
pub extern fn EVP_MAC_CTX_gettable_params(ctx: ?*EVP_MAC_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_MAC_CTX_settable_params(ctx: ?*EVP_MAC_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_MAC_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_MAC, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn EVP_MAC_names_do_all(mac: ?*const EVP_MAC, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) c_int;
pub extern fn EVP_RAND_fetch(libctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_RAND;
pub extern fn EVP_RAND_up_ref(rand: ?*EVP_RAND) c_int;
pub extern fn EVP_RAND_free(rand: ?*EVP_RAND) void;
pub extern fn EVP_RAND_get0_name(rand: ?*const EVP_RAND) [*c]const u8;
pub extern fn EVP_RAND_get0_description(md: ?*const EVP_RAND) [*c]const u8;
pub extern fn EVP_RAND_is_a(rand: ?*const EVP_RAND, name: [*c]const u8) c_int;
pub extern fn EVP_RAND_get0_provider(rand: ?*const EVP_RAND) ?*const OSSL_PROVIDER;
pub extern fn EVP_RAND_get_params(rand: ?*EVP_RAND, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_RAND_CTX_new(rand: ?*EVP_RAND, parent: ?*EVP_RAND_CTX) ?*EVP_RAND_CTX;
pub extern fn EVP_RAND_CTX_up_ref(ctx: ?*EVP_RAND_CTX) c_int;
pub extern fn EVP_RAND_CTX_free(ctx: ?*EVP_RAND_CTX) void;
pub extern fn EVP_RAND_CTX_get0_rand(ctx: ?*EVP_RAND_CTX) ?*EVP_RAND;
pub extern fn EVP_RAND_CTX_get_params(ctx: ?*EVP_RAND_CTX, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_RAND_CTX_set_params(ctx: ?*EVP_RAND_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_RAND_gettable_params(rand: ?*const EVP_RAND) [*c]const OSSL_PARAM;
pub extern fn EVP_RAND_gettable_ctx_params(rand: ?*const EVP_RAND) [*c]const OSSL_PARAM;
pub extern fn EVP_RAND_settable_ctx_params(rand: ?*const EVP_RAND) [*c]const OSSL_PARAM;
pub extern fn EVP_RAND_CTX_gettable_params(ctx: ?*EVP_RAND_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_RAND_CTX_settable_params(ctx: ?*EVP_RAND_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_RAND_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_RAND, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn EVP_RAND_names_do_all(rand: ?*const EVP_RAND, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) c_int;
pub extern fn EVP_RAND_instantiate(ctx: ?*EVP_RAND_CTX, strength: c_uint, prediction_resistance: c_int, pstr: [*c]const u8, pstr_len: usize, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_RAND_uninstantiate(ctx: ?*EVP_RAND_CTX) c_int;
pub extern fn EVP_RAND_generate(ctx: ?*EVP_RAND_CTX, out: [*c]u8, outlen: usize, strength: c_uint, prediction_resistance: c_int, addin: [*c]const u8, addin_len: usize) c_int;
pub extern fn EVP_RAND_reseed(ctx: ?*EVP_RAND_CTX, prediction_resistance: c_int, ent: [*c]const u8, ent_len: usize, addin: [*c]const u8, addin_len: usize) c_int;
pub extern fn EVP_RAND_nonce(ctx: ?*EVP_RAND_CTX, out: [*c]u8, outlen: usize) c_int;
pub extern fn EVP_RAND_enable_locking(ctx: ?*EVP_RAND_CTX) c_int;
pub extern fn EVP_RAND_verify_zeroization(ctx: ?*EVP_RAND_CTX) c_int;
pub extern fn EVP_RAND_get_strength(ctx: ?*EVP_RAND_CTX) c_uint;
pub extern fn EVP_RAND_get_state(ctx: ?*EVP_RAND_CTX) c_int;
pub extern fn EVP_PKEY_decrypt_old(dec_key: [*c]u8, enc_key: [*c]const u8, enc_key_len: c_int, private_key: ?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_encrypt_old(enc_key: [*c]u8, key: [*c]const u8, key_len: c_int, pub_key: ?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_is_a(pkey: ?*const EVP_PKEY, name: [*c]const u8) c_int;
pub extern fn EVP_PKEY_type_names_do_all(pkey: ?*const EVP_PKEY, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_type(@"type": c_int) c_int;
pub extern fn EVP_PKEY_get_id(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_base_id(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_bits(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_security_bits(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_size(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_can_sign(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_set_type(pkey: ?*EVP_PKEY, @"type": c_int) c_int;
pub extern fn EVP_PKEY_set_type_str(pkey: ?*EVP_PKEY, str: [*c]const u8, len: c_int) c_int;
pub extern fn EVP_PKEY_set_type_by_keymgmt(pkey: ?*EVP_PKEY, keymgmt: ?*EVP_KEYMGMT) c_int;
pub extern fn EVP_PKEY_set1_engine(pkey: ?*EVP_PKEY, e: ?*ENGINE) c_int;
pub extern fn EVP_PKEY_get0_engine(pkey: ?*const EVP_PKEY) ?*ENGINE;
pub extern fn EVP_PKEY_assign(pkey: ?*EVP_PKEY, @"type": c_int, key: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_get0(pkey: ?*const EVP_PKEY) ?*anyopaque;
pub extern fn EVP_PKEY_get0_hmac(pkey: ?*const EVP_PKEY, len: [*c]usize) [*c]const u8;
pub extern fn EVP_PKEY_get0_poly1305(pkey: ?*const EVP_PKEY, len: [*c]usize) [*c]const u8;
pub extern fn EVP_PKEY_get0_siphash(pkey: ?*const EVP_PKEY, len: [*c]usize) [*c]const u8;
pub extern fn EVP_PKEY_set1_RSA(pkey: ?*EVP_PKEY, key: ?*struct_rsa_st) c_int;
pub extern fn EVP_PKEY_get0_RSA(pkey: ?*const EVP_PKEY) ?*const struct_rsa_st;
pub extern fn EVP_PKEY_get1_RSA(pkey: ?*EVP_PKEY) ?*struct_rsa_st;
pub extern fn EVP_PKEY_set1_DSA(pkey: ?*EVP_PKEY, key: ?*struct_dsa_st) c_int;
pub extern fn EVP_PKEY_get0_DSA(pkey: ?*const EVP_PKEY) ?*const struct_dsa_st;
pub extern fn EVP_PKEY_get1_DSA(pkey: ?*EVP_PKEY) ?*struct_dsa_st;
pub extern fn EVP_PKEY_set1_DH(pkey: ?*EVP_PKEY, key: ?*struct_dh_st) c_int;
pub extern fn EVP_PKEY_get0_DH(pkey: ?*const EVP_PKEY) ?*const struct_dh_st;
pub extern fn EVP_PKEY_get1_DH(pkey: ?*EVP_PKEY) ?*struct_dh_st;
pub extern fn EVP_PKEY_set1_EC_KEY(pkey: ?*EVP_PKEY, key: ?*struct_ec_key_st) c_int;
pub extern fn EVP_PKEY_get0_EC_KEY(pkey: ?*const EVP_PKEY) ?*const struct_ec_key_st;
pub extern fn EVP_PKEY_get1_EC_KEY(pkey: ?*EVP_PKEY) ?*struct_ec_key_st;
pub extern fn EVP_PKEY_new() ?*EVP_PKEY;
pub extern fn EVP_PKEY_up_ref(pkey: ?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_dup(pkey: ?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn EVP_PKEY_free(pkey: ?*EVP_PKEY) void;
pub extern fn EVP_PKEY_get0_description(pkey: ?*const EVP_PKEY) [*c]const u8;
pub extern fn EVP_PKEY_get0_provider(key: ?*const EVP_PKEY) ?*const OSSL_PROVIDER;
pub extern fn d2i_PublicKey(@"type": c_int, a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn i2d_PublicKey(a: ?*const EVP_PKEY, pp: [*c][*c]u8) c_int;
pub extern fn d2i_PrivateKey_ex(@"type": c_int, a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_PrivateKey(@"type": c_int, a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn d2i_AutoPrivateKey_ex(a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_AutoPrivateKey(a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn i2d_PrivateKey(a: ?*const EVP_PKEY, pp: [*c][*c]u8) c_int;
pub extern fn i2d_KeyParams(a: ?*const EVP_PKEY, pp: [*c][*c]u8) c_int;
pub extern fn d2i_KeyParams(@"type": c_int, a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn i2d_KeyParams_bio(bp: ?*BIO, pkey: ?*const EVP_PKEY) c_int;
pub extern fn d2i_KeyParams_bio(@"type": c_int, a: [*c]?*EVP_PKEY, in: ?*BIO) ?*EVP_PKEY;
pub extern fn EVP_PKEY_copy_parameters(to: ?*EVP_PKEY, from: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_missing_parameters(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_save_parameters(pkey: ?*EVP_PKEY, mode: c_int) c_int;
pub extern fn EVP_PKEY_parameters_eq(a: ?*const EVP_PKEY, b: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_eq(a: ?*const EVP_PKEY, b: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_cmp_parameters(a: ?*const EVP_PKEY, b: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_cmp(a: ?*const EVP_PKEY, b: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_print_public(out: ?*BIO, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_print_private(out: ?*BIO, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_print_params(out: ?*BIO, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_print_public_fp(fp: [*c]FILE, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_print_private_fp(fp: [*c]FILE, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_print_params_fp(fp: [*c]FILE, pkey: ?*const EVP_PKEY, indent: c_int, pctx: ?*ASN1_PCTX) c_int;
pub extern fn EVP_PKEY_get_default_digest_nid(pkey: ?*EVP_PKEY, pnid: [*c]c_int) c_int;
pub extern fn EVP_PKEY_get_default_digest_name(pkey: ?*EVP_PKEY, mdname: [*c]u8, mdname_sz: usize) c_int;
pub extern fn EVP_PKEY_digestsign_supports_digest(pkey: ?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, name: [*c]const u8, propq: [*c]const u8) c_int;
pub extern fn EVP_PKEY_set1_encoded_public_key(pkey: ?*EVP_PKEY, @"pub": [*c]const u8, publen: usize) c_int;
pub extern fn EVP_PKEY_get1_encoded_public_key(pkey: ?*EVP_PKEY, ppub: [*c][*c]u8) usize;
pub extern fn EVP_CIPHER_param_to_asn1(c: ?*EVP_CIPHER_CTX, @"type": [*c]ASN1_TYPE) c_int;
pub extern fn EVP_CIPHER_asn1_to_param(c: ?*EVP_CIPHER_CTX, @"type": [*c]ASN1_TYPE) c_int;
pub extern fn EVP_CIPHER_set_asn1_iv(c: ?*EVP_CIPHER_CTX, @"type": [*c]ASN1_TYPE) c_int;
pub extern fn EVP_CIPHER_get_asn1_iv(c: ?*EVP_CIPHER_CTX, @"type": [*c]ASN1_TYPE) c_int;
pub extern fn PKCS5_PBE_keyivgen(ctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, cipher: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int) c_int;
pub extern fn PKCS5_PBE_keyivgen_ex(cctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, cipher: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PKCS5_PBKDF2_HMAC_SHA1(pass: [*c]const u8, passlen: c_int, salt: [*c]const u8, saltlen: c_int, iter: c_int, keylen: c_int, out: [*c]u8) c_int;
pub extern fn PKCS5_PBKDF2_HMAC(pass: [*c]const u8, passlen: c_int, salt: [*c]const u8, saltlen: c_int, iter: c_int, digest: ?*const EVP_MD, keylen: c_int, out: [*c]u8) c_int;
pub extern fn PKCS5_v2_PBE_keyivgen(ctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, cipher: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int) c_int;
pub extern fn PKCS5_v2_PBE_keyivgen_ex(ctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, cipher: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn EVP_PBE_scrypt(pass: [*c]const u8, passlen: usize, salt: [*c]const u8, saltlen: usize, N: u64, r: u64, p: u64, maxmem: u64, key: [*c]u8, keylen: usize) c_int;
pub extern fn EVP_PBE_scrypt_ex(pass: [*c]const u8, passlen: usize, salt: [*c]const u8, saltlen: usize, N: u64, r: u64, p: u64, maxmem: u64, key: [*c]u8, keylen: usize, ctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PKCS5_v2_scrypt_keyivgen(ctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, c: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int) c_int;
pub extern fn PKCS5_v2_scrypt_keyivgen_ex(ctx: ?*EVP_CIPHER_CTX, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, c: ?*const EVP_CIPHER, md: ?*const EVP_MD, en_de: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PKCS5_PBE_add() void;
pub extern fn EVP_PBE_CipherInit(pbe_obj: ?*ASN1_OBJECT, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, ctx: ?*EVP_CIPHER_CTX, en_de: c_int) c_int;
pub extern fn EVP_PBE_CipherInit_ex(pbe_obj: ?*ASN1_OBJECT, pass: [*c]const u8, passlen: c_int, param: [*c]ASN1_TYPE, ctx: ?*EVP_CIPHER_CTX, en_de: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn EVP_PBE_alg_add_type(pbe_type: c_int, pbe_nid: c_int, cipher_nid: c_int, md_nid: c_int, keygen: ?*const EVP_PBE_KEYGEN) c_int;
pub extern fn EVP_PBE_alg_add(nid: c_int, cipher: ?*const EVP_CIPHER, md: ?*const EVP_MD, keygen: ?*const EVP_PBE_KEYGEN) c_int;
pub extern fn EVP_PBE_find(@"type": c_int, pbe_nid: c_int, pcnid: [*c]c_int, pmnid: [*c]c_int, pkeygen: [*c]?*const EVP_PBE_KEYGEN) c_int;
pub extern fn EVP_PBE_find_ex(@"type": c_int, pbe_nid: c_int, pcnid: [*c]c_int, pmnid: [*c]c_int, pkeygen: [*c]?*const EVP_PBE_KEYGEN, pkeygen_ex: [*c]?*const EVP_PBE_KEYGEN_EX) c_int;
pub extern fn EVP_PBE_cleanup() void;
pub extern fn EVP_PBE_get(ptype: [*c]c_int, ppbe_nid: [*c]c_int, num: usize) c_int;
pub extern fn EVP_PKEY_asn1_get_count() c_int;
pub extern fn EVP_PKEY_asn1_get0(idx: c_int) ?*const EVP_PKEY_ASN1_METHOD;
pub extern fn EVP_PKEY_asn1_find(pe: [*c]?*ENGINE, @"type": c_int) ?*const EVP_PKEY_ASN1_METHOD;
pub extern fn EVP_PKEY_asn1_find_str(pe: [*c]?*ENGINE, str: [*c]const u8, len: c_int) ?*const EVP_PKEY_ASN1_METHOD;
pub extern fn EVP_PKEY_asn1_add0(ameth: ?*const EVP_PKEY_ASN1_METHOD) c_int;
pub extern fn EVP_PKEY_asn1_add_alias(to: c_int, from: c_int) c_int;
pub extern fn EVP_PKEY_asn1_get0_info(ppkey_id: [*c]c_int, pkey_base_id: [*c]c_int, ppkey_flags: [*c]c_int, pinfo: [*c][*c]const u8, ppem_str: [*c][*c]const u8, ameth: ?*const EVP_PKEY_ASN1_METHOD) c_int;
pub extern fn EVP_PKEY_get0_asn1(pkey: ?*const EVP_PKEY) ?*const EVP_PKEY_ASN1_METHOD;
pub extern fn EVP_PKEY_asn1_new(id: c_int, flags: c_int, pem_str: [*c]const u8, info: [*c]const u8) ?*EVP_PKEY_ASN1_METHOD;
pub extern fn EVP_PKEY_asn1_copy(dst: ?*EVP_PKEY_ASN1_METHOD, src: ?*const EVP_PKEY_ASN1_METHOD) void;
pub extern fn EVP_PKEY_asn1_free(ameth: ?*EVP_PKEY_ASN1_METHOD) void;
pub extern fn EVP_PKEY_asn1_set_public(ameth: ?*EVP_PKEY_ASN1_METHOD, pub_decode: ?*const fn (?*EVP_PKEY, ?*const X509_PUBKEY) callconv(.c) c_int, pub_encode: ?*const fn (?*X509_PUBKEY, ?*const EVP_PKEY) callconv(.c) c_int, pub_cmp: ?*const fn (?*const EVP_PKEY, ?*const EVP_PKEY) callconv(.c) c_int, pub_print: ?*const fn (?*BIO, ?*const EVP_PKEY, c_int, ?*ASN1_PCTX) callconv(.c) c_int, pkey_size: ?*const fn (?*const EVP_PKEY) callconv(.c) c_int, pkey_bits: ?*const fn (?*const EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_private(ameth: ?*EVP_PKEY_ASN1_METHOD, priv_decode: ?*const fn (?*EVP_PKEY, ?*const PKCS8_PRIV_KEY_INFO) callconv(.c) c_int, priv_encode: ?*const fn (?*PKCS8_PRIV_KEY_INFO, ?*const EVP_PKEY) callconv(.c) c_int, priv_print: ?*const fn (?*BIO, ?*const EVP_PKEY, c_int, ?*ASN1_PCTX) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_param(ameth: ?*EVP_PKEY_ASN1_METHOD, param_decode: ?*const fn (?*EVP_PKEY, [*c][*c]const u8, c_int) callconv(.c) c_int, param_encode: ?*const fn (?*const EVP_PKEY, [*c][*c]u8) callconv(.c) c_int, param_missing: ?*const fn (?*const EVP_PKEY) callconv(.c) c_int, param_copy: ?*const fn (?*EVP_PKEY, ?*const EVP_PKEY) callconv(.c) c_int, param_cmp: ?*const fn (?*const EVP_PKEY, ?*const EVP_PKEY) callconv(.c) c_int, param_print: ?*const fn (?*BIO, ?*const EVP_PKEY, c_int, ?*ASN1_PCTX) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_free(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_free: ?*const fn (?*EVP_PKEY) callconv(.c) void) void;
pub extern fn EVP_PKEY_asn1_set_ctrl(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_ctrl: ?*const fn (?*EVP_PKEY, c_int, c_long, ?*anyopaque) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_item(ameth: ?*EVP_PKEY_ASN1_METHOD, item_verify: ?*const fn (?*EVP_MD_CTX, ?*const ASN1_ITEM, ?*const anyopaque, [*c]const X509_ALGOR, [*c]const ASN1_BIT_STRING, ?*EVP_PKEY) callconv(.c) c_int, item_sign: ?*const fn (?*EVP_MD_CTX, ?*const ASN1_ITEM, ?*const anyopaque, [*c]X509_ALGOR, [*c]X509_ALGOR, [*c]ASN1_BIT_STRING) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_siginf(ameth: ?*EVP_PKEY_ASN1_METHOD, siginf_set: ?*const fn (?*X509_SIG_INFO, [*c]const X509_ALGOR, [*c]const ASN1_STRING) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_check(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_check: ?*const fn (?*const EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_public_check(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_pub_check: ?*const fn (?*const EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_param_check(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_param_check: ?*const fn (?*const EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_set_priv_key(ameth: ?*EVP_PKEY_ASN1_METHOD, set_priv_key: ?*const fn (?*EVP_PKEY, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_set_pub_key(ameth: ?*EVP_PKEY_ASN1_METHOD, set_pub_key: ?*const fn (?*EVP_PKEY, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_get_priv_key(ameth: ?*EVP_PKEY_ASN1_METHOD, get_priv_key: ?*const fn (?*const EVP_PKEY, [*c]u8, [*c]usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_get_pub_key(ameth: ?*EVP_PKEY_ASN1_METHOD, get_pub_key: ?*const fn (?*const EVP_PKEY, [*c]u8, [*c]usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_asn1_set_security_bits(ameth: ?*EVP_PKEY_ASN1_METHOD, pkey_security_bits: ?*const fn (?*const EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_CTX_get_signature_md(ctx: ?*EVP_PKEY_CTX, md: [*c]?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_signature_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set1_id(ctx: ?*EVP_PKEY_CTX, id: ?*const anyopaque, len: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get1_id(ctx: ?*EVP_PKEY_CTX, id: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_CTX_get1_id_len(ctx: ?*EVP_PKEY_CTX, id_len: [*c]usize) c_int;
pub extern fn EVP_PKEY_CTX_set_kem_op(ctx: ?*EVP_PKEY_CTX, op: [*c]const u8) c_int;
pub extern fn EVP_PKEY_get0_type_name(key: ?*const EVP_PKEY) [*c]const u8;
pub extern fn EVP_PKEY_CTX_set_mac_key(ctx: ?*EVP_PKEY_CTX, key: [*c]const u8, keylen: c_int) c_int;
pub extern fn EVP_PKEY_meth_find(@"type": c_int) ?*const EVP_PKEY_METHOD;
pub extern fn EVP_PKEY_meth_new(id: c_int, flags: c_int) ?*EVP_PKEY_METHOD;
pub extern fn EVP_PKEY_meth_get0_info(ppkey_id: [*c]c_int, pflags: [*c]c_int, meth: ?*const EVP_PKEY_METHOD) void;
pub extern fn EVP_PKEY_meth_copy(dst: ?*EVP_PKEY_METHOD, src: ?*const EVP_PKEY_METHOD) void;
pub extern fn EVP_PKEY_meth_free(pmeth: ?*EVP_PKEY_METHOD) void;
pub extern fn EVP_PKEY_meth_add0(pmeth: ?*const EVP_PKEY_METHOD) c_int;
pub extern fn EVP_PKEY_meth_remove(pmeth: ?*const EVP_PKEY_METHOD) c_int;
pub extern fn EVP_PKEY_meth_get_count() usize;
pub extern fn EVP_PKEY_meth_get0(idx: usize) ?*const EVP_PKEY_METHOD;
pub extern fn EVP_KEYMGMT_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_KEYMGMT;
pub extern fn EVP_KEYMGMT_up_ref(keymgmt: ?*EVP_KEYMGMT) c_int;
pub extern fn EVP_KEYMGMT_free(keymgmt: ?*EVP_KEYMGMT) void;
pub extern fn EVP_KEYMGMT_get0_provider(keymgmt: ?*const EVP_KEYMGMT) ?*const OSSL_PROVIDER;
pub extern fn EVP_KEYMGMT_get0_name(keymgmt: ?*const EVP_KEYMGMT) [*c]const u8;
pub extern fn EVP_KEYMGMT_get0_description(keymgmt: ?*const EVP_KEYMGMT) [*c]const u8;
pub extern fn EVP_KEYMGMT_is_a(keymgmt: ?*const EVP_KEYMGMT, name: [*c]const u8) c_int;
pub extern fn EVP_KEYMGMT_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_KEYMGMT, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn EVP_KEYMGMT_names_do_all(keymgmt: ?*const EVP_KEYMGMT, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) c_int;
pub extern fn EVP_KEYMGMT_gettable_params(keymgmt: ?*const EVP_KEYMGMT) [*c]const OSSL_PARAM;
pub extern fn EVP_KEYMGMT_settable_params(keymgmt: ?*const EVP_KEYMGMT) [*c]const OSSL_PARAM;
pub extern fn EVP_KEYMGMT_gen_settable_params(keymgmt: ?*const EVP_KEYMGMT) [*c]const OSSL_PARAM;
pub extern fn EVP_KEYMGMT_gen_gettable_params(keymgmt: ?*const EVP_KEYMGMT) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_CTX_new(pkey: ?*EVP_PKEY, e: ?*ENGINE) ?*EVP_PKEY_CTX;
pub extern fn EVP_PKEY_CTX_new_id(id: c_int, e: ?*ENGINE) ?*EVP_PKEY_CTX;
pub extern fn EVP_PKEY_CTX_new_from_name(libctx: ?*OSSL_LIB_CTX, name: [*c]const u8, propquery: [*c]const u8) ?*EVP_PKEY_CTX;
pub extern fn EVP_PKEY_CTX_new_from_pkey(libctx: ?*OSSL_LIB_CTX, pkey: ?*EVP_PKEY, propquery: [*c]const u8) ?*EVP_PKEY_CTX;
pub extern fn EVP_PKEY_CTX_dup(ctx: ?*const EVP_PKEY_CTX) ?*EVP_PKEY_CTX;
pub extern fn EVP_PKEY_CTX_free(ctx: ?*EVP_PKEY_CTX) void;
pub extern fn EVP_PKEY_CTX_is_a(ctx: ?*EVP_PKEY_CTX, keytype: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_get_params(ctx: ?*EVP_PKEY_CTX, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_CTX_gettable_params(ctx: ?*const EVP_PKEY_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_CTX_set_params(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_CTX_settable_params(ctx: ?*const EVP_PKEY_CTX) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_CTX_set_algor_params(ctx: ?*EVP_PKEY_CTX, alg: [*c]const X509_ALGOR) c_int;
pub extern fn EVP_PKEY_CTX_get_algor_params(ctx: ?*EVP_PKEY_CTX, alg: [*c]X509_ALGOR) c_int;
pub extern fn EVP_PKEY_CTX_get_algor(ctx: ?*EVP_PKEY_CTX, alg: [*c][*c]X509_ALGOR) c_int;
pub extern fn EVP_PKEY_CTX_ctrl(ctx: ?*EVP_PKEY_CTX, keytype: c_int, optype: c_int, cmd: c_int, p1: c_int, p2: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_CTX_ctrl_str(ctx: ?*EVP_PKEY_CTX, @"type": [*c]const u8, value: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_ctrl_uint64(ctx: ?*EVP_PKEY_CTX, keytype: c_int, optype: c_int, cmd: c_int, value: u64) c_int;
pub extern fn EVP_PKEY_CTX_str2ctrl(ctx: ?*EVP_PKEY_CTX, cmd: c_int, str: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_hex2ctrl(ctx: ?*EVP_PKEY_CTX, cmd: c_int, hex: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_md(ctx: ?*EVP_PKEY_CTX, optype: c_int, cmd: c_int, md: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_get_operation(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_CTX_set0_keygen_info(ctx: ?*EVP_PKEY_CTX, dat: [*c]c_int, datlen: c_int) void;
pub extern fn EVP_PKEY_new_mac_key(@"type": c_int, e: ?*ENGINE, key: [*c]const u8, keylen: c_int) ?*EVP_PKEY;
pub extern fn EVP_PKEY_new_raw_private_key_ex(libctx: ?*OSSL_LIB_CTX, keytype: [*c]const u8, propq: [*c]const u8, priv: [*c]const u8, len: usize) ?*EVP_PKEY;
pub extern fn EVP_PKEY_new_raw_private_key(@"type": c_int, e: ?*ENGINE, priv: [*c]const u8, len: usize) ?*EVP_PKEY;
pub extern fn EVP_PKEY_new_raw_public_key_ex(libctx: ?*OSSL_LIB_CTX, keytype: [*c]const u8, propq: [*c]const u8, @"pub": [*c]const u8, len: usize) ?*EVP_PKEY;
pub extern fn EVP_PKEY_new_raw_public_key(@"type": c_int, e: ?*ENGINE, @"pub": [*c]const u8, len: usize) ?*EVP_PKEY;
pub extern fn EVP_PKEY_get_raw_private_key(pkey: ?*const EVP_PKEY, priv: [*c]u8, len: [*c]usize) c_int;
pub extern fn EVP_PKEY_get_raw_public_key(pkey: ?*const EVP_PKEY, @"pub": [*c]u8, len: [*c]usize) c_int;
pub extern fn EVP_PKEY_new_CMAC_key(e: ?*ENGINE, priv: [*c]const u8, len: usize, cipher: ?*const EVP_CIPHER) ?*EVP_PKEY;
pub extern fn EVP_PKEY_CTX_set_data(ctx: ?*EVP_PKEY_CTX, data: ?*anyopaque) void;
pub extern fn EVP_PKEY_CTX_get_data(ctx: ?*const EVP_PKEY_CTX) ?*anyopaque;
pub extern fn EVP_PKEY_CTX_get0_pkey(ctx: ?*EVP_PKEY_CTX) ?*EVP_PKEY;
pub extern fn EVP_PKEY_CTX_get0_peerkey(ctx: ?*EVP_PKEY_CTX) ?*EVP_PKEY;
pub extern fn EVP_PKEY_CTX_set_app_data(ctx: ?*EVP_PKEY_CTX, data: ?*anyopaque) void;
pub extern fn EVP_PKEY_CTX_get_app_data(ctx: ?*EVP_PKEY_CTX) ?*anyopaque;
pub extern fn EVP_PKEY_CTX_set_signature(pctx: ?*EVP_PKEY_CTX, sig: [*c]const u8, siglen: usize) c_int;
pub extern fn EVP_SIGNATURE_free(signature: ?*EVP_SIGNATURE) void;
pub extern fn EVP_SIGNATURE_up_ref(signature: ?*EVP_SIGNATURE) c_int;
pub extern fn EVP_SIGNATURE_get0_provider(signature: ?*const EVP_SIGNATURE) ?*OSSL_PROVIDER;
pub extern fn EVP_SIGNATURE_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_SIGNATURE;
pub extern fn EVP_SIGNATURE_is_a(signature: ?*const EVP_SIGNATURE, name: [*c]const u8) c_int;
pub extern fn EVP_SIGNATURE_get0_name(signature: ?*const EVP_SIGNATURE) [*c]const u8;
pub extern fn EVP_SIGNATURE_get0_description(signature: ?*const EVP_SIGNATURE) [*c]const u8;
pub extern fn EVP_SIGNATURE_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_SIGNATURE, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) void;
pub extern fn EVP_SIGNATURE_names_do_all(signature: ?*const EVP_SIGNATURE, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) c_int;
pub extern fn EVP_SIGNATURE_gettable_ctx_params(sig: ?*const EVP_SIGNATURE) [*c]const OSSL_PARAM;
pub extern fn EVP_SIGNATURE_settable_ctx_params(sig: ?*const EVP_SIGNATURE) [*c]const OSSL_PARAM;
pub extern fn EVP_ASYM_CIPHER_free(cipher: ?*EVP_ASYM_CIPHER) void;
pub extern fn EVP_ASYM_CIPHER_up_ref(cipher: ?*EVP_ASYM_CIPHER) c_int;
pub extern fn EVP_ASYM_CIPHER_get0_provider(cipher: ?*const EVP_ASYM_CIPHER) ?*OSSL_PROVIDER;
pub extern fn EVP_ASYM_CIPHER_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_ASYM_CIPHER;
pub extern fn EVP_ASYM_CIPHER_is_a(cipher: ?*const EVP_ASYM_CIPHER, name: [*c]const u8) c_int;
pub extern fn EVP_ASYM_CIPHER_get0_name(cipher: ?*const EVP_ASYM_CIPHER) [*c]const u8;
pub extern fn EVP_ASYM_CIPHER_get0_description(cipher: ?*const EVP_ASYM_CIPHER) [*c]const u8;
pub extern fn EVP_ASYM_CIPHER_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_ASYM_CIPHER, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn EVP_ASYM_CIPHER_names_do_all(cipher: ?*const EVP_ASYM_CIPHER, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) c_int;
pub extern fn EVP_ASYM_CIPHER_gettable_ctx_params(ciph: ?*const EVP_ASYM_CIPHER) [*c]const OSSL_PARAM;
pub extern fn EVP_ASYM_CIPHER_settable_ctx_params(ciph: ?*const EVP_ASYM_CIPHER) [*c]const OSSL_PARAM;
pub extern fn EVP_KEM_free(wrap: ?*EVP_KEM) void;
pub extern fn EVP_KEM_up_ref(wrap: ?*EVP_KEM) c_int;
pub extern fn EVP_KEM_get0_provider(wrap: ?*const EVP_KEM) ?*OSSL_PROVIDER;
pub extern fn EVP_KEM_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_KEM;
pub extern fn EVP_KEM_is_a(wrap: ?*const EVP_KEM, name: [*c]const u8) c_int;
pub extern fn EVP_KEM_get0_name(wrap: ?*const EVP_KEM) [*c]const u8;
pub extern fn EVP_KEM_get0_description(wrap: ?*const EVP_KEM) [*c]const u8;
pub extern fn EVP_KEM_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_KEM, ?*anyopaque) callconv(.c) void, arg: ?*anyopaque) void;
pub extern fn EVP_KEM_names_do_all(wrap: ?*const EVP_KEM, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) c_int;
pub extern fn EVP_KEM_gettable_ctx_params(kem: ?*const EVP_KEM) [*c]const OSSL_PARAM;
pub extern fn EVP_KEM_settable_ctx_params(kem: ?*const EVP_KEM) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_sign_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_sign_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_sign_init_ex2(ctx: ?*EVP_PKEY_CTX, algo: ?*EVP_SIGNATURE, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_sign(ctx: ?*EVP_PKEY_CTX, sig: [*c]u8, siglen: [*c]usize, tbs: [*c]const u8, tbslen: usize) c_int;
pub extern fn EVP_PKEY_sign_message_init(ctx: ?*EVP_PKEY_CTX, algo: ?*EVP_SIGNATURE, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_sign_message_update(ctx: ?*EVP_PKEY_CTX, in: [*c]const u8, inlen: usize) c_int;
pub extern fn EVP_PKEY_sign_message_final(ctx: ?*EVP_PKEY_CTX, sig: [*c]u8, siglen: [*c]usize) c_int;
pub extern fn EVP_PKEY_verify_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_verify_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_verify_init_ex2(ctx: ?*EVP_PKEY_CTX, algo: ?*EVP_SIGNATURE, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_verify(ctx: ?*EVP_PKEY_CTX, sig: [*c]const u8, siglen: usize, tbs: [*c]const u8, tbslen: usize) c_int;
pub extern fn EVP_PKEY_verify_message_init(ctx: ?*EVP_PKEY_CTX, algo: ?*EVP_SIGNATURE, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_verify_message_update(ctx: ?*EVP_PKEY_CTX, in: [*c]const u8, inlen: usize) c_int;
pub extern fn EVP_PKEY_verify_message_final(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_verify_recover_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_verify_recover_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_verify_recover_init_ex2(ctx: ?*EVP_PKEY_CTX, algo: ?*EVP_SIGNATURE, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_verify_recover(ctx: ?*EVP_PKEY_CTX, rout: [*c]u8, routlen: [*c]usize, sig: [*c]const u8, siglen: usize) c_int;
pub extern fn EVP_PKEY_encrypt_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_encrypt_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_encrypt(ctx: ?*EVP_PKEY_CTX, out: [*c]u8, outlen: [*c]usize, in: [*c]const u8, inlen: usize) c_int;
pub extern fn EVP_PKEY_decrypt_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_decrypt_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_decrypt(ctx: ?*EVP_PKEY_CTX, out: [*c]u8, outlen: [*c]usize, in: [*c]const u8, inlen: usize) c_int;
pub extern fn EVP_PKEY_derive_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_derive_init_ex(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_derive_set_peer_ex(ctx: ?*EVP_PKEY_CTX, peer: ?*EVP_PKEY, validate_peer: c_int) c_int;
pub extern fn EVP_PKEY_derive_set_peer(ctx: ?*EVP_PKEY_CTX, peer: ?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_derive(ctx: ?*EVP_PKEY_CTX, key: [*c]u8, keylen: [*c]usize) c_int;
pub extern fn EVP_PKEY_encapsulate_init(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_auth_encapsulate_init(ctx: ?*EVP_PKEY_CTX, authpriv: ?*EVP_PKEY, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_encapsulate(ctx: ?*EVP_PKEY_CTX, wrappedkey: [*c]u8, wrappedkeylen: [*c]usize, genkey: [*c]u8, genkeylen: [*c]usize) c_int;
pub extern fn EVP_PKEY_decapsulate_init(ctx: ?*EVP_PKEY_CTX, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_auth_decapsulate_init(ctx: ?*EVP_PKEY_CTX, authpub: ?*EVP_PKEY, params: [*c]const OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_decapsulate(ctx: ?*EVP_PKEY_CTX, unwrapped: [*c]u8, unwrappedlen: [*c]usize, wrapped: [*c]const u8, wrappedlen: usize) c_int;
pub const EVP_PKEY_gen_cb = fn (?*EVP_PKEY_CTX) callconv(.c) c_int;
pub extern fn EVP_PKEY_fromdata_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_fromdata(ctx: ?*EVP_PKEY_CTX, ppkey: [*c]?*EVP_PKEY, selection: c_int, param: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_fromdata_settable(ctx: ?*EVP_PKEY_CTX, selection: c_int) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_todata(pkey: ?*const EVP_PKEY, selection: c_int, params: [*c][*c]OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_export(pkey: ?*const EVP_PKEY, selection: c_int, export_cb: ?*const OSSL_CALLBACK, export_cbarg: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_gettable_params(pkey: ?*const EVP_PKEY) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_get_params(pkey: ?*const EVP_PKEY, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_get_int_param(pkey: ?*const EVP_PKEY, key_name: [*c]const u8, out: [*c]c_int) c_int;
pub extern fn EVP_PKEY_get_size_t_param(pkey: ?*const EVP_PKEY, key_name: [*c]const u8, out: [*c]usize) c_int;
pub extern fn EVP_PKEY_get_bn_param(pkey: ?*const EVP_PKEY, key_name: [*c]const u8, bn: [*c]?*BIGNUM) c_int;
pub extern fn EVP_PKEY_get_utf8_string_param(pkey: ?*const EVP_PKEY, key_name: [*c]const u8, str: [*c]u8, max_buf_sz: usize, out_sz: [*c]usize) c_int;
pub extern fn EVP_PKEY_get_octet_string_param(pkey: ?*const EVP_PKEY, key_name: [*c]const u8, buf: [*c]u8, max_buf_sz: usize, out_sz: [*c]usize) c_int;
pub extern fn EVP_PKEY_settable_params(pkey: ?*const EVP_PKEY) [*c]const OSSL_PARAM;
pub extern fn EVP_PKEY_set_params(pkey: ?*EVP_PKEY, params: [*c]OSSL_PARAM) c_int;
pub extern fn EVP_PKEY_set_int_param(pkey: ?*EVP_PKEY, key_name: [*c]const u8, in: c_int) c_int;
pub extern fn EVP_PKEY_set_size_t_param(pkey: ?*EVP_PKEY, key_name: [*c]const u8, in: usize) c_int;
pub extern fn EVP_PKEY_set_bn_param(pkey: ?*EVP_PKEY, key_name: [*c]const u8, bn: ?*const BIGNUM) c_int;
pub extern fn EVP_PKEY_set_utf8_string_param(pkey: ?*EVP_PKEY, key_name: [*c]const u8, str: [*c]const u8) c_int;
pub extern fn EVP_PKEY_set_octet_string_param(pkey: ?*EVP_PKEY, key_name: [*c]const u8, buf: [*c]const u8, bsize: usize) c_int;
pub extern fn EVP_PKEY_get_ec_point_conv_form(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_field_type(pkey: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_Q_keygen(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, @"type": [*c]const u8, ...) ?*EVP_PKEY;
pub extern fn EVP_PKEY_paramgen_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_paramgen(ctx: ?*EVP_PKEY_CTX, ppkey: [*c]?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_keygen_init(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_keygen(ctx: ?*EVP_PKEY_CTX, ppkey: [*c]?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_generate(ctx: ?*EVP_PKEY_CTX, ppkey: [*c]?*EVP_PKEY) c_int;
pub extern fn EVP_PKEY_check(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_public_check(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_public_check_quick(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_param_check(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_param_check_quick(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_private_check(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_pairwise_check(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_set_ex_data(key: ?*EVP_PKEY, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn EVP_PKEY_get_ex_data(key: ?*const EVP_PKEY, idx: c_int) ?*anyopaque;
pub extern fn EVP_PKEY_CTX_set_cb(ctx: ?*EVP_PKEY_CTX, cb: ?*const EVP_PKEY_gen_cb) void;
pub extern fn EVP_PKEY_CTX_get_cb(ctx: ?*EVP_PKEY_CTX) ?*const EVP_PKEY_gen_cb;
pub extern fn EVP_PKEY_CTX_get_keygen_info(ctx: ?*EVP_PKEY_CTX, idx: c_int) c_int;
pub extern fn EVP_PKEY_meth_set_init(pmeth: ?*EVP_PKEY_METHOD, init: ?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_copy(pmeth: ?*EVP_PKEY_METHOD, copy: ?*const fn (?*EVP_PKEY_CTX, ?*const EVP_PKEY_CTX) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_cleanup(pmeth: ?*EVP_PKEY_METHOD, cleanup: ?*const fn (?*EVP_PKEY_CTX) callconv(.c) void) void;
pub extern fn EVP_PKEY_meth_set_paramgen(pmeth: ?*EVP_PKEY_METHOD, paramgen_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, paramgen: ?*const fn (?*EVP_PKEY_CTX, ?*EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_keygen(pmeth: ?*EVP_PKEY_METHOD, keygen_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, keygen: ?*const fn (?*EVP_PKEY_CTX, ?*EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_sign(pmeth: ?*EVP_PKEY_METHOD, sign_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, sign: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_verify(pmeth: ?*EVP_PKEY_METHOD, verify_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, verify: ?*const fn (?*EVP_PKEY_CTX, [*c]const u8, usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_verify_recover(pmeth: ?*EVP_PKEY_METHOD, verify_recover_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, verify_recover: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_signctx(pmeth: ?*EVP_PKEY_METHOD, signctx_init: ?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.c) c_int, signctx: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, ?*EVP_MD_CTX) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_verifyctx(pmeth: ?*EVP_PKEY_METHOD, verifyctx_init: ?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.c) c_int, verifyctx: ?*const fn (?*EVP_PKEY_CTX, [*c]const u8, c_int, ?*EVP_MD_CTX) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_encrypt(pmeth: ?*EVP_PKEY_METHOD, encrypt_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, encryptfn: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_decrypt(pmeth: ?*EVP_PKEY_METHOD, decrypt_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, decrypt: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_derive(pmeth: ?*EVP_PKEY_METHOD, derive_init: ?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, derive: ?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_ctrl(pmeth: ?*EVP_PKEY_METHOD, ctrl: ?*const fn (?*EVP_PKEY_CTX, c_int, c_int, ?*anyopaque) callconv(.c) c_int, ctrl_str: ?*const fn (?*EVP_PKEY_CTX, [*c]const u8, [*c]const u8) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_digestsign(pmeth: ?*EVP_PKEY_METHOD, digestsign: ?*const fn (?*EVP_MD_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_digestverify(pmeth: ?*EVP_PKEY_METHOD, digestverify: ?*const fn (?*EVP_MD_CTX, [*c]const u8, usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_check(pmeth: ?*EVP_PKEY_METHOD, check: ?*const fn (?*EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_public_check(pmeth: ?*EVP_PKEY_METHOD, check: ?*const fn (?*EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_param_check(pmeth: ?*EVP_PKEY_METHOD, check: ?*const fn (?*EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_set_digest_custom(pmeth: ?*EVP_PKEY_METHOD, digest_custom: ?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_init(pmeth: ?*const EVP_PKEY_METHOD, pinit: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_copy(pmeth: ?*const EVP_PKEY_METHOD, pcopy: [*c]?*const fn (?*EVP_PKEY_CTX, ?*const EVP_PKEY_CTX) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_cleanup(pmeth: ?*const EVP_PKEY_METHOD, pcleanup: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.c) void) void;
pub extern fn EVP_PKEY_meth_get_paramgen(pmeth: ?*const EVP_PKEY_METHOD, pparamgen_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, pparamgen: [*c]?*const fn (?*EVP_PKEY_CTX, ?*EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_keygen(pmeth: ?*const EVP_PKEY_METHOD, pkeygen_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, pkeygen: [*c]?*const fn (?*EVP_PKEY_CTX, ?*EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_sign(pmeth: ?*const EVP_PKEY_METHOD, psign_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, psign: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_verify(pmeth: ?*const EVP_PKEY_METHOD, pverify_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, pverify: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]const u8, usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_verify_recover(pmeth: ?*const EVP_PKEY_METHOD, pverify_recover_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, pverify_recover: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_signctx(pmeth: ?*const EVP_PKEY_METHOD, psignctx_init: [*c]?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.c) c_int, psignctx: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, ?*EVP_MD_CTX) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_verifyctx(pmeth: ?*const EVP_PKEY_METHOD, pverifyctx_init: [*c]?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.c) c_int, pverifyctx: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]const u8, c_int, ?*EVP_MD_CTX) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_encrypt(pmeth: ?*const EVP_PKEY_METHOD, pencrypt_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, pencryptfn: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_decrypt(pmeth: ?*const EVP_PKEY_METHOD, pdecrypt_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, pdecrypt: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_derive(pmeth: ?*const EVP_PKEY_METHOD, pderive_init: [*c]?*const fn (?*EVP_PKEY_CTX) callconv(.c) c_int, pderive: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]u8, [*c]usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_ctrl(pmeth: ?*const EVP_PKEY_METHOD, pctrl: [*c]?*const fn (?*EVP_PKEY_CTX, c_int, c_int, ?*anyopaque) callconv(.c) c_int, pctrl_str: [*c]?*const fn (?*EVP_PKEY_CTX, [*c]const u8, [*c]const u8) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_digestsign(pmeth: ?*const EVP_PKEY_METHOD, digestsign: [*c]?*const fn (?*EVP_MD_CTX, [*c]u8, [*c]usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_digestverify(pmeth: ?*const EVP_PKEY_METHOD, digestverify: [*c]?*const fn (?*EVP_MD_CTX, [*c]const u8, usize, [*c]const u8, usize) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_check(pmeth: ?*const EVP_PKEY_METHOD, pcheck: [*c]?*const fn (?*EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_public_check(pmeth: ?*const EVP_PKEY_METHOD, pcheck: [*c]?*const fn (?*EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_param_check(pmeth: ?*const EVP_PKEY_METHOD, pcheck: [*c]?*const fn (?*EVP_PKEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_meth_get_digest_custom(pmeth: ?*const EVP_PKEY_METHOD, pdigest_custom: [*c]?*const fn (?*EVP_PKEY_CTX, ?*EVP_MD_CTX) callconv(.c) c_int) void;
pub extern fn EVP_KEYEXCH_free(exchange: ?*EVP_KEYEXCH) void;
pub extern fn EVP_KEYEXCH_up_ref(exchange: ?*EVP_KEYEXCH) c_int;
pub extern fn EVP_KEYEXCH_fetch(ctx: ?*OSSL_LIB_CTX, algorithm: [*c]const u8, properties: [*c]const u8) ?*EVP_KEYEXCH;
pub extern fn EVP_KEYEXCH_get0_provider(exchange: ?*const EVP_KEYEXCH) ?*OSSL_PROVIDER;
pub extern fn EVP_KEYEXCH_is_a(keyexch: ?*const EVP_KEYEXCH, name: [*c]const u8) c_int;
pub extern fn EVP_KEYEXCH_get0_name(keyexch: ?*const EVP_KEYEXCH) [*c]const u8;
pub extern fn EVP_KEYEXCH_get0_description(keyexch: ?*const EVP_KEYEXCH) [*c]const u8;
pub extern fn EVP_KEYEXCH_do_all_provided(libctx: ?*OSSL_LIB_CTX, @"fn": ?*const fn (?*EVP_KEYEXCH, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) void;
pub extern fn EVP_KEYEXCH_names_do_all(keyexch: ?*const EVP_KEYEXCH, @"fn": ?*const fn ([*c]const u8, ?*anyopaque) callconv(.c) void, data: ?*anyopaque) c_int;
pub extern fn EVP_KEYEXCH_gettable_ctx_params(keyexch: ?*const EVP_KEYEXCH) [*c]const OSSL_PARAM;
pub extern fn EVP_KEYEXCH_settable_ctx_params(keyexch: ?*const EVP_KEYEXCH) [*c]const OSSL_PARAM;
pub extern fn EVP_add_alg_module() void;
pub extern fn EVP_PKEY_CTX_set_group_name(ctx: ?*EVP_PKEY_CTX, name: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_get_group_name(ctx: ?*EVP_PKEY_CTX, name: [*c]u8, namelen: usize) c_int;
pub extern fn EVP_PKEY_get_group_name(pkey: ?*const EVP_PKEY, name: [*c]u8, name_sz: usize, gname_len: [*c]usize) c_int;
pub extern fn EVP_PKEY_CTX_get0_libctx(ctx: ?*EVP_PKEY_CTX) ?*OSSL_LIB_CTX;
pub extern fn EVP_PKEY_CTX_get0_propq(ctx: ?*const EVP_PKEY_CTX) [*c]const u8;
pub extern fn EVP_PKEY_CTX_get0_provider(ctx: ?*const EVP_PKEY_CTX) ?*const OSSL_PROVIDER;
pub extern fn EVP_PKEY_CTX_set_ec_paramgen_curve_nid(ctx: ?*EVP_PKEY_CTX, nid: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_ec_param_enc(ctx: ?*EVP_PKEY_CTX, param_enc: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_ecdh_cofactor_mode(ctx: ?*EVP_PKEY_CTX, cofactor_mode: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_ecdh_cofactor_mode(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_CTX_set_ecdh_kdf_type(ctx: ?*EVP_PKEY_CTX, kdf: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_ecdh_kdf_type(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_CTX_set_ecdh_kdf_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_get_ecdh_kdf_md(ctx: ?*EVP_PKEY_CTX, md: [*c]?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_ecdh_kdf_outlen(ctx: ?*EVP_PKEY_CTX, len: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_ecdh_kdf_outlen(ctx: ?*EVP_PKEY_CTX, len: [*c]c_int) c_int;
pub extern fn EVP_PKEY_CTX_set0_ecdh_kdf_ukm(ctx: ?*EVP_PKEY_CTX, ukm: [*c]u8, len: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get0_ecdh_kdf_ukm(ctx: ?*EVP_PKEY_CTX, ukm: [*c][*c]u8) c_int;
pub const POINT_CONVERSION_COMPRESSED: c_int = 2;
pub const POINT_CONVERSION_UNCOMPRESSED: c_int = 4;
pub const POINT_CONVERSION_HYBRID: c_int = 6;
pub const point_conversion_form_t = c_uint;
pub extern fn OSSL_EC_curve_nid2name(nid: c_int) [*c]const u8;
pub const struct_ec_method_st = opaque {};
pub const EC_METHOD = struct_ec_method_st;
pub const struct_ec_group_st = opaque {};
pub const EC_GROUP = struct_ec_group_st;
pub const struct_ec_point_st = opaque {};
pub const EC_POINT = struct_ec_point_st;
pub const struct_ecpk_parameters_st = opaque {};
pub const ECPKPARAMETERS = struct_ecpk_parameters_st;
pub const struct_ec_parameters_st = opaque {};
pub const ECPARAMETERS = struct_ec_parameters_st;
pub extern fn EC_GFp_simple_method() ?*const EC_METHOD;
pub extern fn EC_GFp_mont_method() ?*const EC_METHOD;
pub extern fn EC_GFp_nist_method() ?*const EC_METHOD;
pub extern fn EC_GFp_nistp224_method() ?*const EC_METHOD;
pub extern fn EC_GFp_nistp256_method() ?*const EC_METHOD;
pub extern fn EC_GFp_nistp521_method() ?*const EC_METHOD;
pub extern fn EC_GF2m_simple_method() ?*const EC_METHOD;
pub extern fn EC_GROUP_new(meth: ?*const EC_METHOD) ?*EC_GROUP;
pub extern fn EC_GROUP_clear_free(group: ?*EC_GROUP) void;
pub extern fn EC_GROUP_method_of(group: ?*const EC_GROUP) ?*const EC_METHOD;
pub extern fn EC_METHOD_get_field_type(meth: ?*const EC_METHOD) c_int;
pub extern fn EC_GROUP_free(group: ?*EC_GROUP) void;
pub extern fn EC_GROUP_copy(dst: ?*EC_GROUP, src: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_dup(src: ?*const EC_GROUP) ?*EC_GROUP;
pub extern fn EC_GROUP_set_generator(group: ?*EC_GROUP, generator: ?*const EC_POINT, order: ?*const BIGNUM, cofactor: ?*const BIGNUM) c_int;
pub extern fn EC_GROUP_get0_generator(group: ?*const EC_GROUP) ?*const EC_POINT;
pub extern fn EC_GROUP_get_mont_data(group: ?*const EC_GROUP) ?*BN_MONT_CTX;
pub extern fn EC_GROUP_get_order(group: ?*const EC_GROUP, order: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get0_order(group: ?*const EC_GROUP) ?*const BIGNUM;
pub extern fn EC_GROUP_order_bits(group: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_get_cofactor(group: ?*const EC_GROUP, cofactor: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get0_cofactor(group: ?*const EC_GROUP) ?*const BIGNUM;
pub extern fn EC_GROUP_set_curve_name(group: ?*EC_GROUP, nid: c_int) void;
pub extern fn EC_GROUP_get_curve_name(group: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_get0_field(group: ?*const EC_GROUP) ?*const BIGNUM;
pub extern fn EC_GROUP_get_field_type(group: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_set_asn1_flag(group: ?*EC_GROUP, flag: c_int) void;
pub extern fn EC_GROUP_get_asn1_flag(group: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_set_point_conversion_form(group: ?*EC_GROUP, form: point_conversion_form_t) void;
pub extern fn EC_GROUP_get_point_conversion_form(?*const EC_GROUP) point_conversion_form_t;
pub extern fn EC_GROUP_get0_seed(x: ?*const EC_GROUP) [*c]u8;
pub extern fn EC_GROUP_get_seed_len(?*const EC_GROUP) usize;
pub extern fn EC_GROUP_set_seed(?*EC_GROUP, [*c]const u8, len: usize) usize;
pub extern fn EC_GROUP_set_curve(group: ?*EC_GROUP, p: ?*const BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get_curve(group: ?*const EC_GROUP, p: ?*BIGNUM, a: ?*BIGNUM, b: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_set_curve_GFp(group: ?*EC_GROUP, p: ?*const BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get_curve_GFp(group: ?*const EC_GROUP, p: ?*BIGNUM, a: ?*BIGNUM, b: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_set_curve_GF2m(group: ?*EC_GROUP, p: ?*const BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get_curve_GF2m(group: ?*const EC_GROUP, p: ?*BIGNUM, a: ?*BIGNUM, b: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_get_degree(group: ?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_check(group: ?*const EC_GROUP, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_check_discriminant(group: ?*const EC_GROUP, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_cmp(a: ?*const EC_GROUP, b: ?*const EC_GROUP, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_new_curve_GFp(p: ?*const BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) ?*EC_GROUP;
pub extern fn EC_GROUP_new_curve_GF2m(p: ?*const BIGNUM, a: ?*const BIGNUM, b: ?*const BIGNUM, ctx: ?*BN_CTX) ?*EC_GROUP;
pub extern fn EC_GROUP_new_from_params(params: [*c]const OSSL_PARAM, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EC_GROUP;
pub extern fn EC_GROUP_to_params(group: ?*const EC_GROUP, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, bnctx: ?*BN_CTX) [*c]OSSL_PARAM;
pub extern fn EC_GROUP_new_by_curve_name_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, nid: c_int) ?*EC_GROUP;
pub extern fn EC_GROUP_new_by_curve_name(nid: c_int) ?*EC_GROUP;
pub extern fn EC_GROUP_new_from_ecparameters(params: ?*const ECPARAMETERS) ?*EC_GROUP;
pub extern fn EC_GROUP_get_ecparameters(group: ?*const EC_GROUP, params: ?*ECPARAMETERS) ?*ECPARAMETERS;
pub extern fn EC_GROUP_new_from_ecpkparameters(params: ?*const ECPKPARAMETERS) ?*EC_GROUP;
pub extern fn EC_GROUP_get_ecpkparameters(group: ?*const EC_GROUP, params: ?*ECPKPARAMETERS) ?*ECPKPARAMETERS;
pub const EC_builtin_curve = extern struct {
    nid: c_int = @import("std").mem.zeroes(c_int),
    comment: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub extern fn EC_get_builtin_curves(r: [*c]EC_builtin_curve, nitems: usize) usize;
pub extern fn EC_curve_nid2nist(nid: c_int) [*c]const u8;
pub extern fn EC_curve_nist2nid(name: [*c]const u8) c_int;
pub extern fn EC_GROUP_check_named_curve(group: ?*const EC_GROUP, nist_only: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_new(group: ?*const EC_GROUP) ?*EC_POINT;
pub extern fn EC_POINT_free(point: ?*EC_POINT) void;
pub extern fn EC_POINT_clear_free(point: ?*EC_POINT) void;
pub extern fn EC_POINT_copy(dst: ?*EC_POINT, src: ?*const EC_POINT) c_int;
pub extern fn EC_POINT_dup(src: ?*const EC_POINT, group: ?*const EC_GROUP) ?*EC_POINT;
pub extern fn EC_POINT_set_to_infinity(group: ?*const EC_GROUP, point: ?*EC_POINT) c_int;
pub extern fn EC_POINT_method_of(point: ?*const EC_POINT) ?*const EC_METHOD;
pub extern fn EC_POINT_set_Jprojective_coordinates_GFp(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y: ?*const BIGNUM, z: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_get_Jprojective_coordinates_GFp(group: ?*const EC_GROUP, p: ?*const EC_POINT, x: ?*BIGNUM, y: ?*BIGNUM, z: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_affine_coordinates(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_get_affine_coordinates(group: ?*const EC_GROUP, p: ?*const EC_POINT, x: ?*BIGNUM, y: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_affine_coordinates_GFp(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_get_affine_coordinates_GFp(group: ?*const EC_GROUP, p: ?*const EC_POINT, x: ?*BIGNUM, y: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_compressed_coordinates(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y_bit: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_compressed_coordinates_GFp(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y_bit: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_affine_coordinates_GF2m(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_get_affine_coordinates_GF2m(group: ?*const EC_GROUP, p: ?*const EC_POINT, x: ?*BIGNUM, y: ?*BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_set_compressed_coordinates_GF2m(group: ?*const EC_GROUP, p: ?*EC_POINT, x: ?*const BIGNUM, y_bit: c_int, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_point2oct(group: ?*const EC_GROUP, p: ?*const EC_POINT, form: point_conversion_form_t, buf: [*c]u8, len: usize, ctx: ?*BN_CTX) usize;
pub extern fn EC_POINT_oct2point(group: ?*const EC_GROUP, p: ?*EC_POINT, buf: [*c]const u8, len: usize, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_point2buf(group: ?*const EC_GROUP, point: ?*const EC_POINT, form: point_conversion_form_t, pbuf: [*c][*c]u8, ctx: ?*BN_CTX) usize;
pub extern fn EC_POINT_point2bn(?*const EC_GROUP, ?*const EC_POINT, form: point_conversion_form_t, ?*BIGNUM, ?*BN_CTX) ?*BIGNUM;
pub extern fn EC_POINT_bn2point(?*const EC_GROUP, ?*const BIGNUM, ?*EC_POINT, ?*BN_CTX) ?*EC_POINT;
pub extern fn EC_POINT_point2hex(?*const EC_GROUP, ?*const EC_POINT, form: point_conversion_form_t, ?*BN_CTX) [*c]u8;
pub extern fn EC_POINT_hex2point(?*const EC_GROUP, [*c]const u8, ?*EC_POINT, ?*BN_CTX) ?*EC_POINT;
pub extern fn EC_POINT_add(group: ?*const EC_GROUP, r: ?*EC_POINT, a: ?*const EC_POINT, b: ?*const EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_dbl(group: ?*const EC_GROUP, r: ?*EC_POINT, a: ?*const EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_invert(group: ?*const EC_GROUP, a: ?*EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_is_at_infinity(group: ?*const EC_GROUP, p: ?*const EC_POINT) c_int;
pub extern fn EC_POINT_is_on_curve(group: ?*const EC_GROUP, point: ?*const EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_cmp(group: ?*const EC_GROUP, a: ?*const EC_POINT, b: ?*const EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_make_affine(group: ?*const EC_GROUP, point: ?*EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINTs_make_affine(group: ?*const EC_GROUP, num: usize, points: [*c]?*EC_POINT, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINTs_mul(group: ?*const EC_GROUP, r: ?*EC_POINT, n: ?*const BIGNUM, num: usize, p: [*c]?*const EC_POINT, m: [*c]?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_POINT_mul(group: ?*const EC_GROUP, r: ?*EC_POINT, n: ?*const BIGNUM, q: ?*const EC_POINT, m: ?*const BIGNUM, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_precompute_mult(group: ?*EC_GROUP, ctx: ?*BN_CTX) c_int;
pub extern fn EC_GROUP_have_precompute_mult(group: ?*const EC_GROUP) c_int;
pub extern fn ECPKPARAMETERS_it() ?*const ASN1_ITEM;
pub extern fn ECPKPARAMETERS_new() ?*ECPKPARAMETERS;
pub extern fn ECPKPARAMETERS_free(a: ?*ECPKPARAMETERS) void;
pub extern fn ECPARAMETERS_it() ?*const ASN1_ITEM;
pub extern fn ECPARAMETERS_new() ?*ECPARAMETERS;
pub extern fn ECPARAMETERS_free(a: ?*ECPARAMETERS) void;
pub extern fn EC_GROUP_get_basis_type(?*const EC_GROUP) c_int;
pub extern fn EC_GROUP_get_trinomial_basis(?*const EC_GROUP, k: [*c]c_uint) c_int;
pub extern fn EC_GROUP_get_pentanomial_basis(?*const EC_GROUP, k1: [*c]c_uint, k2: [*c]c_uint, k3: [*c]c_uint) c_int;
pub extern fn d2i_ECPKParameters([*c]?*EC_GROUP, in: [*c][*c]const u8, len: c_long) ?*EC_GROUP;
pub extern fn i2d_ECPKParameters(?*const EC_GROUP, out: [*c][*c]u8) c_int;
pub extern fn ECPKParameters_print(bp: ?*BIO, x: ?*const EC_GROUP, off: c_int) c_int;
pub extern fn ECPKParameters_print_fp(fp: [*c]FILE, x: ?*const EC_GROUP, off: c_int) c_int;
pub extern fn EC_KEY_new_ex(ctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EC_KEY;
pub extern fn EC_KEY_new() ?*EC_KEY;
pub extern fn EC_KEY_get_flags(key: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_set_flags(key: ?*EC_KEY, flags: c_int) void;
pub extern fn EC_KEY_clear_flags(key: ?*EC_KEY, flags: c_int) void;
pub extern fn EC_KEY_decoded_from_explicit_params(key: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_new_by_curve_name_ex(ctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, nid: c_int) ?*EC_KEY;
pub extern fn EC_KEY_new_by_curve_name(nid: c_int) ?*EC_KEY;
pub extern fn EC_KEY_free(key: ?*EC_KEY) void;
pub extern fn EC_KEY_copy(dst: ?*EC_KEY, src: ?*const EC_KEY) ?*EC_KEY;
pub extern fn EC_KEY_dup(src: ?*const EC_KEY) ?*EC_KEY;
pub extern fn EC_KEY_up_ref(key: ?*EC_KEY) c_int;
pub extern fn EC_KEY_get0_engine(eckey: ?*const EC_KEY) ?*ENGINE;
pub extern fn EC_KEY_get0_group(key: ?*const EC_KEY) ?*const EC_GROUP;
pub extern fn EC_KEY_set_group(key: ?*EC_KEY, group: ?*const EC_GROUP) c_int;
pub extern fn EC_KEY_get0_private_key(key: ?*const EC_KEY) ?*const BIGNUM;
pub extern fn EC_KEY_set_private_key(key: ?*EC_KEY, prv: ?*const BIGNUM) c_int;
pub extern fn EC_KEY_get0_public_key(key: ?*const EC_KEY) ?*const EC_POINT;
pub extern fn EC_KEY_set_public_key(key: ?*EC_KEY, @"pub": ?*const EC_POINT) c_int;
pub extern fn EC_KEY_get_enc_flags(key: ?*const EC_KEY) c_uint;
pub extern fn EC_KEY_set_enc_flags(eckey: ?*EC_KEY, flags: c_uint) void;
pub extern fn EC_KEY_get_conv_form(key: ?*const EC_KEY) point_conversion_form_t;
pub extern fn EC_KEY_set_conv_form(eckey: ?*EC_KEY, cform: point_conversion_form_t) void;
pub extern fn EC_KEY_set_ex_data(key: ?*EC_KEY, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn EC_KEY_get_ex_data(key: ?*const EC_KEY, idx: c_int) ?*anyopaque;
pub extern fn EC_KEY_set_asn1_flag(eckey: ?*EC_KEY, asn1_flag: c_int) void;
pub extern fn EC_KEY_precompute_mult(key: ?*EC_KEY, ctx: ?*BN_CTX) c_int;
pub extern fn EC_KEY_generate_key(key: ?*EC_KEY) c_int;
pub extern fn EC_KEY_check_key(key: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_can_sign(eckey: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_set_public_key_affine_coordinates(key: ?*EC_KEY, x: ?*BIGNUM, y: ?*BIGNUM) c_int;
pub extern fn EC_KEY_key2buf(key: ?*const EC_KEY, form: point_conversion_form_t, pbuf: [*c][*c]u8, ctx: ?*BN_CTX) usize;
pub extern fn EC_KEY_oct2key(key: ?*EC_KEY, buf: [*c]const u8, len: usize, ctx: ?*BN_CTX) c_int;
pub extern fn EC_KEY_oct2priv(key: ?*EC_KEY, buf: [*c]const u8, len: usize) c_int;
pub extern fn EC_KEY_priv2oct(key: ?*const EC_KEY, buf: [*c]u8, len: usize) usize;
pub extern fn EC_KEY_priv2buf(eckey: ?*const EC_KEY, pbuf: [*c][*c]u8) usize;
pub extern fn d2i_ECPrivateKey(key: [*c]?*EC_KEY, in: [*c][*c]const u8, len: c_long) ?*EC_KEY;
pub extern fn i2d_ECPrivateKey(key: ?*const EC_KEY, out: [*c][*c]u8) c_int;
pub extern fn d2i_ECParameters(key: [*c]?*EC_KEY, in: [*c][*c]const u8, len: c_long) ?*EC_KEY;
pub extern fn i2d_ECParameters(key: ?*const EC_KEY, out: [*c][*c]u8) c_int;
pub extern fn o2i_ECPublicKey(key: [*c]?*EC_KEY, in: [*c][*c]const u8, len: c_long) ?*EC_KEY;
pub extern fn i2o_ECPublicKey(key: ?*const EC_KEY, out: [*c][*c]u8) c_int;
pub extern fn ECParameters_print(bp: ?*BIO, key: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_print(bp: ?*BIO, key: ?*const EC_KEY, off: c_int) c_int;
pub extern fn ECParameters_print_fp(fp: [*c]FILE, key: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_print_fp(fp: [*c]FILE, key: ?*const EC_KEY, off: c_int) c_int;
pub extern fn EC_KEY_OpenSSL() ?*const EC_KEY_METHOD;
pub extern fn EC_KEY_get_default_method() ?*const EC_KEY_METHOD;
pub extern fn EC_KEY_set_default_method(meth: ?*const EC_KEY_METHOD) void;
pub extern fn EC_KEY_get_method(key: ?*const EC_KEY) ?*const EC_KEY_METHOD;
pub extern fn EC_KEY_set_method(key: ?*EC_KEY, meth: ?*const EC_KEY_METHOD) c_int;
pub extern fn EC_KEY_new_method(engine: ?*ENGINE) ?*EC_KEY;
pub extern fn ECDH_KDF_X9_62(out: [*c]u8, outlen: usize, Z: [*c]const u8, Zlen: usize, sinfo: [*c]const u8, sinfolen: usize, md: ?*const EVP_MD) c_int;
pub extern fn ECDH_compute_key(out: ?*anyopaque, outlen: usize, pub_key: ?*const EC_POINT, ecdh: ?*const EC_KEY, KDF: ?*const fn (?*const anyopaque, usize, ?*anyopaque, [*c]usize) callconv(.c) ?*anyopaque) c_int;
pub const struct_ECDSA_SIG_st = opaque {};
pub const ECDSA_SIG = struct_ECDSA_SIG_st;
pub extern fn ECDSA_SIG_new() ?*ECDSA_SIG;
pub extern fn ECDSA_SIG_free(sig: ?*ECDSA_SIG) void;
pub extern fn d2i_ECDSA_SIG(a: [*c]?*ECDSA_SIG, in: [*c][*c]const u8, len: c_long) ?*ECDSA_SIG;
pub extern fn i2d_ECDSA_SIG(a: ?*const ECDSA_SIG, out: [*c][*c]u8) c_int;
pub extern fn ECDSA_SIG_get0(sig: ?*const ECDSA_SIG, pr: [*c]?*const BIGNUM, ps: [*c]?*const BIGNUM) void;
pub extern fn ECDSA_SIG_get0_r(sig: ?*const ECDSA_SIG) ?*const BIGNUM;
pub extern fn ECDSA_SIG_get0_s(sig: ?*const ECDSA_SIG) ?*const BIGNUM;
pub extern fn ECDSA_SIG_set0(sig: ?*ECDSA_SIG, r: ?*BIGNUM, s: ?*BIGNUM) c_int;
pub extern fn ECDSA_do_sign(dgst: [*c]const u8, dgst_len: c_int, eckey: ?*EC_KEY) ?*ECDSA_SIG;
pub extern fn ECDSA_do_sign_ex(dgst: [*c]const u8, dgstlen: c_int, kinv: ?*const BIGNUM, rp: ?*const BIGNUM, eckey: ?*EC_KEY) ?*ECDSA_SIG;
pub extern fn ECDSA_do_verify(dgst: [*c]const u8, dgst_len: c_int, sig: ?*const ECDSA_SIG, eckey: ?*EC_KEY) c_int;
pub extern fn ECDSA_sign_setup(eckey: ?*EC_KEY, ctx: ?*BN_CTX, kinv: [*c]?*BIGNUM, rp: [*c]?*BIGNUM) c_int;
pub extern fn ECDSA_sign(@"type": c_int, dgst: [*c]const u8, dgstlen: c_int, sig: [*c]u8, siglen: [*c]c_uint, eckey: ?*EC_KEY) c_int;
pub extern fn ECDSA_sign_ex(@"type": c_int, dgst: [*c]const u8, dgstlen: c_int, sig: [*c]u8, siglen: [*c]c_uint, kinv: ?*const BIGNUM, rp: ?*const BIGNUM, eckey: ?*EC_KEY) c_int;
pub extern fn ECDSA_verify(@"type": c_int, dgst: [*c]const u8, dgstlen: c_int, sig: [*c]const u8, siglen: c_int, eckey: ?*EC_KEY) c_int;
pub extern fn ECDSA_size(eckey: ?*const EC_KEY) c_int;
pub extern fn EC_KEY_METHOD_new(meth: ?*const EC_KEY_METHOD) ?*EC_KEY_METHOD;
pub extern fn EC_KEY_METHOD_free(meth: ?*EC_KEY_METHOD) void;
pub extern fn EC_KEY_METHOD_set_init(meth: ?*EC_KEY_METHOD, init: ?*const fn (?*EC_KEY) callconv(.c) c_int, finish: ?*const fn (?*EC_KEY) callconv(.c) void, copy: ?*const fn (?*EC_KEY, ?*const EC_KEY) callconv(.c) c_int, set_group: ?*const fn (?*EC_KEY, ?*const EC_GROUP) callconv(.c) c_int, set_private: ?*const fn (?*EC_KEY, ?*const BIGNUM) callconv(.c) c_int, set_public: ?*const fn (?*EC_KEY, ?*const EC_POINT) callconv(.c) c_int) void;
pub extern fn EC_KEY_METHOD_set_keygen(meth: ?*EC_KEY_METHOD, keygen: ?*const fn (?*EC_KEY) callconv(.c) c_int) void;
pub extern fn EC_KEY_METHOD_set_compute_key(meth: ?*EC_KEY_METHOD, ckey: ?*const fn ([*c][*c]u8, [*c]usize, ?*const EC_POINT, ?*const EC_KEY) callconv(.c) c_int) void;
pub extern fn EC_KEY_METHOD_set_sign(meth: ?*EC_KEY_METHOD, sign: ?*const fn (c_int, [*c]const u8, c_int, [*c]u8, [*c]c_uint, ?*const BIGNUM, ?*const BIGNUM, ?*EC_KEY) callconv(.c) c_int, sign_setup: ?*const fn (?*EC_KEY, ?*BN_CTX, [*c]?*BIGNUM, [*c]?*BIGNUM) callconv(.c) c_int, sign_sig: ?*const fn ([*c]const u8, c_int, ?*const BIGNUM, ?*const BIGNUM, ?*EC_KEY) callconv(.c) ?*ECDSA_SIG) void;
pub extern fn EC_KEY_METHOD_set_verify(meth: ?*EC_KEY_METHOD, verify: ?*const fn (c_int, [*c]const u8, c_int, [*c]const u8, c_int, ?*EC_KEY) callconv(.c) c_int, verify_sig: ?*const fn ([*c]const u8, c_int, ?*const ECDSA_SIG, ?*EC_KEY) callconv(.c) c_int) void;
pub extern fn EC_KEY_METHOD_get_init(meth: ?*const EC_KEY_METHOD, pinit: [*c]?*const fn (?*EC_KEY) callconv(.c) c_int, pfinish: [*c]?*const fn (?*EC_KEY) callconv(.c) void, pcopy: [*c]?*const fn (?*EC_KEY, ?*const EC_KEY) callconv(.c) c_int, pset_group: [*c]?*const fn (?*EC_KEY, ?*const EC_GROUP) callconv(.c) c_int, pset_private: [*c]?*const fn (?*EC_KEY, ?*const BIGNUM) callconv(.c) c_int, pset_public: [*c]?*const fn (?*EC_KEY, ?*const EC_POINT) callconv(.c) c_int) void;
pub extern fn EC_KEY_METHOD_get_keygen(meth: ?*const EC_KEY_METHOD, pkeygen: [*c]?*const fn (?*EC_KEY) callconv(.c) c_int) void;
pub extern fn EC_KEY_METHOD_get_compute_key(meth: ?*const EC_KEY_METHOD, pck: [*c]?*const fn ([*c][*c]u8, [*c]usize, ?*const EC_POINT, ?*const EC_KEY) callconv(.c) c_int) void;
pub extern fn EC_KEY_METHOD_get_sign(meth: ?*const EC_KEY_METHOD, psign: [*c]?*const fn (c_int, [*c]const u8, c_int, [*c]u8, [*c]c_uint, ?*const BIGNUM, ?*const BIGNUM, ?*EC_KEY) callconv(.c) c_int, psign_setup: [*c]?*const fn (?*EC_KEY, ?*BN_CTX, [*c]?*BIGNUM, [*c]?*BIGNUM) callconv(.c) c_int, psign_sig: [*c]?*const fn ([*c]const u8, c_int, ?*const BIGNUM, ?*const BIGNUM, ?*EC_KEY) callconv(.c) ?*ECDSA_SIG) void;
pub extern fn EC_KEY_METHOD_get_verify(meth: ?*const EC_KEY_METHOD, pverify: [*c]?*const fn (c_int, [*c]const u8, c_int, [*c]const u8, c_int, ?*EC_KEY) callconv(.c) c_int, pverify_sig: [*c]?*const fn ([*c]const u8, c_int, ?*const ECDSA_SIG, ?*EC_KEY) callconv(.c) c_int) void;
pub extern fn EVP_PKEY_CTX_set_rsa_padding(ctx: ?*EVP_PKEY_CTX, pad_mode: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_padding(ctx: ?*EVP_PKEY_CTX, pad_mode: [*c]c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx: ?*EVP_PKEY_CTX, saltlen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_pss_saltlen(ctx: ?*EVP_PKEY_CTX, saltlen: [*c]c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_keygen_bits(ctx: ?*EVP_PKEY_CTX, bits: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set1_rsa_keygen_pubexp(ctx: ?*EVP_PKEY_CTX, pubexp: ?*BIGNUM) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_keygen_primes(ctx: ?*EVP_PKEY_CTX, primes: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_keygen_saltlen(ctx: ?*EVP_PKEY_CTX, saltlen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx: ?*EVP_PKEY_CTX, pubexp: ?*BIGNUM) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_mgf1_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_mgf1_md_name(ctx: ?*EVP_PKEY_CTX, mdname: [*c]const u8, mdprops: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_mgf1_md(ctx: ?*EVP_PKEY_CTX, md: [*c]?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_mgf1_md_name(ctx: ?*EVP_PKEY_CTX, name: [*c]u8, namelen: usize) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_keygen_mgf1_md_name(ctx: ?*EVP_PKEY_CTX, mdname: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_keygen_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_pss_keygen_md_name(ctx: ?*EVP_PKEY_CTX, mdname: [*c]const u8, mdprops: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_oaep_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_rsa_oaep_md_name(ctx: ?*EVP_PKEY_CTX, mdname: [*c]const u8, mdprops: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_oaep_md(ctx: ?*EVP_PKEY_CTX, md: [*c]?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_get_rsa_oaep_md_name(ctx: ?*EVP_PKEY_CTX, name: [*c]u8, namelen: usize) c_int;
pub extern fn EVP_PKEY_CTX_set0_rsa_oaep_label(ctx: ?*EVP_PKEY_CTX, label: ?*anyopaque, llen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get0_rsa_oaep_label(ctx: ?*EVP_PKEY_CTX, label: [*c][*c]u8) c_int;
pub extern fn RSA_new() ?*RSA;
pub extern fn RSA_new_method(engine: ?*ENGINE) ?*RSA;
pub extern fn RSA_bits(rsa: ?*const RSA) c_int;
pub extern fn RSA_size(rsa: ?*const RSA) c_int;
pub extern fn RSA_security_bits(rsa: ?*const RSA) c_int;
pub extern fn RSA_set0_key(r: ?*RSA, n: ?*BIGNUM, e: ?*BIGNUM, d: ?*BIGNUM) c_int;
pub extern fn RSA_set0_factors(r: ?*RSA, p: ?*BIGNUM, q: ?*BIGNUM) c_int;
pub extern fn RSA_set0_crt_params(r: ?*RSA, dmp1: ?*BIGNUM, dmq1: ?*BIGNUM, iqmp: ?*BIGNUM) c_int;
pub extern fn RSA_set0_multi_prime_params(r: ?*RSA, primes: [*c]?*BIGNUM, exps: [*c]?*BIGNUM, coeffs: [*c]?*BIGNUM, pnum: c_int) c_int;
pub extern fn RSA_get0_key(r: ?*const RSA, n: [*c]?*const BIGNUM, e: [*c]?*const BIGNUM, d: [*c]?*const BIGNUM) void;
pub extern fn RSA_get0_factors(r: ?*const RSA, p: [*c]?*const BIGNUM, q: [*c]?*const BIGNUM) void;
pub extern fn RSA_get_multi_prime_extra_count(r: ?*const RSA) c_int;
pub extern fn RSA_get0_multi_prime_factors(r: ?*const RSA, primes: [*c]?*const BIGNUM) c_int;
pub extern fn RSA_get0_crt_params(r: ?*const RSA, dmp1: [*c]?*const BIGNUM, dmq1: [*c]?*const BIGNUM, iqmp: [*c]?*const BIGNUM) void;
pub extern fn RSA_get0_multi_prime_crt_params(r: ?*const RSA, exps: [*c]?*const BIGNUM, coeffs: [*c]?*const BIGNUM) c_int;
pub extern fn RSA_get0_n(d: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_e(d: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_d(d: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_p(d: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_q(d: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_dmp1(r: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_dmq1(r: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_iqmp(r: ?*const RSA) ?*const BIGNUM;
pub extern fn RSA_get0_pss_params(r: ?*const RSA) [*c]const RSA_PSS_PARAMS;
pub extern fn RSA_clear_flags(r: ?*RSA, flags: c_int) void;
pub extern fn RSA_test_flags(r: ?*const RSA, flags: c_int) c_int;
pub extern fn RSA_set_flags(r: ?*RSA, flags: c_int) void;
pub extern fn RSA_get_version(r: ?*RSA) c_int;
pub extern fn RSA_get0_engine(r: ?*const RSA) ?*ENGINE;
pub extern fn RSA_generate_key(bits: c_int, e: c_ulong, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.c) void, cb_arg: ?*anyopaque) ?*RSA;
pub extern fn RSA_generate_key_ex(rsa: ?*RSA, bits: c_int, e: ?*BIGNUM, cb: ?*BN_GENCB) c_int;
pub extern fn RSA_generate_multi_prime_key(rsa: ?*RSA, bits: c_int, primes: c_int, e: ?*BIGNUM, cb: ?*BN_GENCB) c_int;
pub extern fn RSA_X931_derive_ex(rsa: ?*RSA, p1: ?*BIGNUM, p2: ?*BIGNUM, q1: ?*BIGNUM, q2: ?*BIGNUM, Xp1: ?*const BIGNUM, Xp2: ?*const BIGNUM, Xp: ?*const BIGNUM, Xq1: ?*const BIGNUM, Xq2: ?*const BIGNUM, Xq: ?*const BIGNUM, e: ?*const BIGNUM, cb: ?*BN_GENCB) c_int;
pub extern fn RSA_X931_generate_key_ex(rsa: ?*RSA, bits: c_int, e: ?*const BIGNUM, cb: ?*BN_GENCB) c_int;
pub extern fn RSA_check_key(?*const RSA) c_int;
pub extern fn RSA_check_key_ex(?*const RSA, cb: ?*BN_GENCB) c_int;
pub extern fn RSA_public_encrypt(flen: c_int, from: [*c]const u8, to: [*c]u8, rsa: ?*RSA, padding: c_int) c_int;
pub extern fn RSA_private_encrypt(flen: c_int, from: [*c]const u8, to: [*c]u8, rsa: ?*RSA, padding: c_int) c_int;
pub extern fn RSA_public_decrypt(flen: c_int, from: [*c]const u8, to: [*c]u8, rsa: ?*RSA, padding: c_int) c_int;
pub extern fn RSA_private_decrypt(flen: c_int, from: [*c]const u8, to: [*c]u8, rsa: ?*RSA, padding: c_int) c_int;
pub extern fn RSA_free(r: ?*RSA) void;
pub extern fn RSA_up_ref(r: ?*RSA) c_int;
pub extern fn RSA_flags(r: ?*const RSA) c_int;
pub extern fn RSA_set_default_method(meth: ?*const RSA_METHOD) void;
pub extern fn RSA_get_default_method() ?*const RSA_METHOD;
pub extern fn RSA_null_method() ?*const RSA_METHOD;
pub extern fn RSA_get_method(rsa: ?*const RSA) ?*const RSA_METHOD;
pub extern fn RSA_set_method(rsa: ?*RSA, meth: ?*const RSA_METHOD) c_int;
pub extern fn RSA_PKCS1_OpenSSL() ?*const RSA_METHOD;
pub extern fn d2i_RSAPublicKey(a: [*c]?*RSA, in: [*c][*c]const u8, len: c_long) ?*RSA;
pub extern fn i2d_RSAPublicKey(a: ?*const RSA, out: [*c][*c]u8) c_int;
pub extern fn RSAPublicKey_it() ?*const ASN1_ITEM;
pub extern fn d2i_RSAPrivateKey(a: [*c]?*RSA, in: [*c][*c]const u8, len: c_long) ?*RSA;
pub extern fn i2d_RSAPrivateKey(a: ?*const RSA, out: [*c][*c]u8) c_int;
pub extern fn RSAPrivateKey_it() ?*const ASN1_ITEM;
pub extern fn RSA_pkey_ctx_ctrl(ctx: ?*EVP_PKEY_CTX, optype: c_int, cmd: c_int, p1: c_int, p2: ?*anyopaque) c_int;
pub extern fn RSA_PSS_PARAMS_new() [*c]RSA_PSS_PARAMS;
pub extern fn RSA_PSS_PARAMS_free(a: [*c]RSA_PSS_PARAMS) void;
pub extern fn d2i_RSA_PSS_PARAMS(a: [*c][*c]RSA_PSS_PARAMS, in: [*c][*c]const u8, len: c_long) [*c]RSA_PSS_PARAMS;
pub extern fn i2d_RSA_PSS_PARAMS(a: [*c]const RSA_PSS_PARAMS, out: [*c][*c]u8) c_int;
pub extern fn RSA_PSS_PARAMS_it() ?*const ASN1_ITEM;
pub extern fn RSA_PSS_PARAMS_dup(a: [*c]const RSA_PSS_PARAMS) [*c]RSA_PSS_PARAMS;
pub const struct_rsa_oaep_params_st = extern struct {
    hashFunc: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    maskGenFunc: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    pSourceFunc: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    maskHash: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
};
pub const RSA_OAEP_PARAMS = struct_rsa_oaep_params_st;
pub extern fn RSA_OAEP_PARAMS_new() [*c]RSA_OAEP_PARAMS;
pub extern fn RSA_OAEP_PARAMS_free(a: [*c]RSA_OAEP_PARAMS) void;
pub extern fn d2i_RSA_OAEP_PARAMS(a: [*c][*c]RSA_OAEP_PARAMS, in: [*c][*c]const u8, len: c_long) [*c]RSA_OAEP_PARAMS;
pub extern fn i2d_RSA_OAEP_PARAMS(a: [*c]const RSA_OAEP_PARAMS, out: [*c][*c]u8) c_int;
pub extern fn RSA_OAEP_PARAMS_it() ?*const ASN1_ITEM;
pub extern fn RSA_print_fp(fp: [*c]FILE, r: ?*const RSA, offset: c_int) c_int;
pub extern fn RSA_print(bp: ?*BIO, r: ?*const RSA, offset: c_int) c_int;
pub extern fn RSA_sign(@"type": c_int, m: [*c]const u8, m_length: c_uint, sigret: [*c]u8, siglen: [*c]c_uint, rsa: ?*RSA) c_int;
pub extern fn RSA_verify(@"type": c_int, m: [*c]const u8, m_length: c_uint, sigbuf: [*c]const u8, siglen: c_uint, rsa: ?*RSA) c_int;
pub extern fn RSA_sign_ASN1_OCTET_STRING(@"type": c_int, m: [*c]const u8, m_length: c_uint, sigret: [*c]u8, siglen: [*c]c_uint, rsa: ?*RSA) c_int;
pub extern fn RSA_verify_ASN1_OCTET_STRING(@"type": c_int, m: [*c]const u8, m_length: c_uint, sigbuf: [*c]u8, siglen: c_uint, rsa: ?*RSA) c_int;
pub extern fn RSA_blinding_on(rsa: ?*RSA, ctx: ?*BN_CTX) c_int;
pub extern fn RSA_blinding_off(rsa: ?*RSA) void;
pub extern fn RSA_setup_blinding(rsa: ?*RSA, ctx: ?*BN_CTX) ?*BN_BLINDING;
pub extern fn RSA_padding_add_PKCS1_type_1(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int) c_int;
pub extern fn RSA_padding_check_PKCS1_type_1(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, rsa_len: c_int) c_int;
pub extern fn RSA_padding_add_PKCS1_type_2(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int) c_int;
pub extern fn RSA_padding_check_PKCS1_type_2(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, rsa_len: c_int) c_int;
pub extern fn PKCS1_MGF1(mask: [*c]u8, len: c_long, seed: [*c]const u8, seedlen: c_long, dgst: ?*const EVP_MD) c_int;
pub extern fn RSA_padding_add_PKCS1_OAEP(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, p: [*c]const u8, pl: c_int) c_int;
pub extern fn RSA_padding_check_PKCS1_OAEP(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, rsa_len: c_int, p: [*c]const u8, pl: c_int) c_int;
pub extern fn RSA_padding_add_PKCS1_OAEP_mgf1(to: [*c]u8, tlen: c_int, from: [*c]const u8, flen: c_int, param: [*c]const u8, plen: c_int, md: ?*const EVP_MD, mgf1md: ?*const EVP_MD) c_int;
pub extern fn RSA_padding_check_PKCS1_OAEP_mgf1(to: [*c]u8, tlen: c_int, from: [*c]const u8, flen: c_int, num: c_int, param: [*c]const u8, plen: c_int, md: ?*const EVP_MD, mgf1md: ?*const EVP_MD) c_int;
pub extern fn RSA_padding_add_none(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int) c_int;
pub extern fn RSA_padding_check_none(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, rsa_len: c_int) c_int;
pub extern fn RSA_padding_add_X931(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int) c_int;
pub extern fn RSA_padding_check_X931(to: [*c]u8, tlen: c_int, f: [*c]const u8, fl: c_int, rsa_len: c_int) c_int;
pub extern fn RSA_X931_hash_id(nid: c_int) c_int;
pub extern fn RSA_verify_PKCS1_PSS(rsa: ?*RSA, mHash: [*c]const u8, Hash: ?*const EVP_MD, EM: [*c]const u8, sLen: c_int) c_int;
pub extern fn RSA_padding_add_PKCS1_PSS(rsa: ?*RSA, EM: [*c]u8, mHash: [*c]const u8, Hash: ?*const EVP_MD, sLen: c_int) c_int;
pub extern fn RSA_verify_PKCS1_PSS_mgf1(rsa: ?*RSA, mHash: [*c]const u8, Hash: ?*const EVP_MD, mgf1Hash: ?*const EVP_MD, EM: [*c]const u8, sLen: c_int) c_int;
pub extern fn RSA_padding_add_PKCS1_PSS_mgf1(rsa: ?*RSA, EM: [*c]u8, mHash: [*c]const u8, Hash: ?*const EVP_MD, mgf1Hash: ?*const EVP_MD, sLen: c_int) c_int;
pub extern fn RSA_set_ex_data(r: ?*RSA, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn RSA_get_ex_data(r: ?*const RSA, idx: c_int) ?*anyopaque;
pub extern fn RSAPublicKey_dup(a: ?*const RSA) ?*RSA;
pub extern fn RSAPrivateKey_dup(a: ?*const RSA) ?*RSA;
pub extern fn RSA_meth_new(name: [*c]const u8, flags: c_int) ?*RSA_METHOD;
pub extern fn RSA_meth_free(meth: ?*RSA_METHOD) void;
pub extern fn RSA_meth_dup(meth: ?*const RSA_METHOD) ?*RSA_METHOD;
pub extern fn RSA_meth_get0_name(meth: ?*const RSA_METHOD) [*c]const u8;
pub extern fn RSA_meth_set1_name(meth: ?*RSA_METHOD, name: [*c]const u8) c_int;
pub extern fn RSA_meth_get_flags(meth: ?*const RSA_METHOD) c_int;
pub extern fn RSA_meth_set_flags(meth: ?*RSA_METHOD, flags: c_int) c_int;
pub extern fn RSA_meth_get0_app_data(meth: ?*const RSA_METHOD) ?*anyopaque;
pub extern fn RSA_meth_set0_app_data(meth: ?*RSA_METHOD, app_data: ?*anyopaque) c_int;
pub extern fn RSA_meth_get_pub_enc(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.c) c_int;
pub extern fn RSA_meth_set_pub_enc(rsa: ?*RSA_METHOD, pub_enc: ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.c) c_int) c_int;
pub extern fn RSA_meth_get_pub_dec(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.c) c_int;
pub extern fn RSA_meth_set_pub_dec(rsa: ?*RSA_METHOD, pub_dec: ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.c) c_int) c_int;
pub extern fn RSA_meth_get_priv_enc(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.c) c_int;
pub extern fn RSA_meth_set_priv_enc(rsa: ?*RSA_METHOD, priv_enc: ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.c) c_int) c_int;
pub extern fn RSA_meth_get_priv_dec(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.c) c_int;
pub extern fn RSA_meth_set_priv_dec(rsa: ?*RSA_METHOD, priv_dec: ?*const fn (c_int, [*c]const u8, [*c]u8, ?*RSA, c_int) callconv(.c) c_int) c_int;
pub extern fn RSA_meth_get_mod_exp(meth: ?*const RSA_METHOD) ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*RSA, ?*BN_CTX) callconv(.c) c_int;
pub extern fn RSA_meth_set_mod_exp(rsa: ?*RSA_METHOD, mod_exp: ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*RSA, ?*BN_CTX) callconv(.c) c_int) c_int;
pub extern fn RSA_meth_get_bn_mod_exp(meth: ?*const RSA_METHOD) ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.c) c_int;
pub extern fn RSA_meth_set_bn_mod_exp(rsa: ?*RSA_METHOD, bn_mod_exp: ?*const fn (?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.c) c_int) c_int;
pub extern fn RSA_meth_get_init(meth: ?*const RSA_METHOD) ?*const fn (?*RSA) callconv(.c) c_int;
pub extern fn RSA_meth_set_init(rsa: ?*RSA_METHOD, init: ?*const fn (?*RSA) callconv(.c) c_int) c_int;
pub extern fn RSA_meth_get_finish(meth: ?*const RSA_METHOD) ?*const fn (?*RSA) callconv(.c) c_int;
pub extern fn RSA_meth_set_finish(rsa: ?*RSA_METHOD, finish: ?*const fn (?*RSA) callconv(.c) c_int) c_int;
pub extern fn RSA_meth_get_sign(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, c_uint, [*c]u8, [*c]c_uint, ?*const RSA) callconv(.c) c_int;
pub extern fn RSA_meth_set_sign(rsa: ?*RSA_METHOD, sign: ?*const fn (c_int, [*c]const u8, c_uint, [*c]u8, [*c]c_uint, ?*const RSA) callconv(.c) c_int) c_int;
pub extern fn RSA_meth_get_verify(meth: ?*const RSA_METHOD) ?*const fn (c_int, [*c]const u8, c_uint, [*c]const u8, c_uint, ?*const RSA) callconv(.c) c_int;
pub extern fn RSA_meth_set_verify(rsa: ?*RSA_METHOD, verify: ?*const fn (c_int, [*c]const u8, c_uint, [*c]const u8, c_uint, ?*const RSA) callconv(.c) c_int) c_int;
pub extern fn RSA_meth_get_keygen(meth: ?*const RSA_METHOD) ?*const fn (?*RSA, c_int, ?*BIGNUM, ?*BN_GENCB) callconv(.c) c_int;
pub extern fn RSA_meth_set_keygen(rsa: ?*RSA_METHOD, keygen: ?*const fn (?*RSA, c_int, ?*BIGNUM, ?*BN_GENCB) callconv(.c) c_int) c_int;
pub extern fn RSA_meth_get_multi_prime_keygen(meth: ?*const RSA_METHOD) ?*const fn (?*RSA, c_int, c_int, ?*BIGNUM, ?*BN_GENCB) callconv(.c) c_int;
pub extern fn RSA_meth_set_multi_prime_keygen(meth: ?*RSA_METHOD, keygen: ?*const fn (?*RSA, c_int, c_int, ?*BIGNUM, ?*BN_GENCB) callconv(.c) c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_type(ctx: ?*EVP_PKEY_CTX, typ: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_gindex(ctx: ?*EVP_PKEY_CTX, gindex: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_seed(ctx: ?*EVP_PKEY_CTX, seed: [*c]const u8, seedlen: usize) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_prime_len(ctx: ?*EVP_PKEY_CTX, pbits: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_subprime_len(ctx: ?*EVP_PKEY_CTX, qlen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_paramgen_generator(ctx: ?*EVP_PKEY_CTX, gen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_nid(ctx: ?*EVP_PKEY_CTX, nid: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_rfc5114(ctx: ?*EVP_PKEY_CTX, gen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dhx_rfc5114(ctx: ?*EVP_PKEY_CTX, gen: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_pad(ctx: ?*EVP_PKEY_CTX, pad: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_kdf_type(ctx: ?*EVP_PKEY_CTX, kdf: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_dh_kdf_type(ctx: ?*EVP_PKEY_CTX) c_int;
pub extern fn EVP_PKEY_CTX_set0_dh_kdf_oid(ctx: ?*EVP_PKEY_CTX, oid: ?*ASN1_OBJECT) c_int;
pub extern fn EVP_PKEY_CTX_get0_dh_kdf_oid(ctx: ?*EVP_PKEY_CTX, oid: [*c]?*ASN1_OBJECT) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_kdf_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_get_dh_kdf_md(ctx: ?*EVP_PKEY_CTX, md: [*c]?*const EVP_MD) c_int;
pub extern fn EVP_PKEY_CTX_set_dh_kdf_outlen(ctx: ?*EVP_PKEY_CTX, len: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get_dh_kdf_outlen(ctx: ?*EVP_PKEY_CTX, len: [*c]c_int) c_int;
pub extern fn EVP_PKEY_CTX_set0_dh_kdf_ukm(ctx: ?*EVP_PKEY_CTX, ukm: [*c]u8, len: c_int) c_int;
pub extern fn EVP_PKEY_CTX_get0_dh_kdf_ukm(ctx: ?*EVP_PKEY_CTX, ukm: [*c][*c]u8) c_int;
pub extern fn DHparams_it() ?*const ASN1_ITEM;
pub extern fn DHparams_dup(a: ?*const DH) ?*DH;
pub extern fn DH_OpenSSL() ?*const DH_METHOD;
pub extern fn DH_set_default_method(meth: ?*const DH_METHOD) void;
pub extern fn DH_get_default_method() ?*const DH_METHOD;
pub extern fn DH_set_method(dh: ?*DH, meth: ?*const DH_METHOD) c_int;
pub extern fn DH_new_method(engine: ?*ENGINE) ?*DH;
pub extern fn DH_new() ?*DH;
pub extern fn DH_free(dh: ?*DH) void;
pub extern fn DH_up_ref(dh: ?*DH) c_int;
pub extern fn DH_bits(dh: ?*const DH) c_int;
pub extern fn DH_size(dh: ?*const DH) c_int;
pub extern fn DH_security_bits(dh: ?*const DH) c_int;
pub extern fn DH_set_ex_data(d: ?*DH, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn DH_get_ex_data(d: ?*const DH, idx: c_int) ?*anyopaque;
pub extern fn DH_generate_parameters_ex(dh: ?*DH, prime_len: c_int, generator: c_int, cb: ?*BN_GENCB) c_int;
pub extern fn DH_check_params_ex(dh: ?*const DH) c_int;
pub extern fn DH_check_ex(dh: ?*const DH) c_int;
pub extern fn DH_check_pub_key_ex(dh: ?*const DH, pub_key: ?*const BIGNUM) c_int;
pub extern fn DH_check_params(dh: ?*const DH, ret: [*c]c_int) c_int;
pub extern fn DH_check(dh: ?*const DH, codes: [*c]c_int) c_int;
pub extern fn DH_check_pub_key(dh: ?*const DH, pub_key: ?*const BIGNUM, codes: [*c]c_int) c_int;
pub extern fn DH_generate_key(dh: ?*DH) c_int;
pub extern fn DH_compute_key(key: [*c]u8, pub_key: ?*const BIGNUM, dh: ?*DH) c_int;
pub extern fn DH_compute_key_padded(key: [*c]u8, pub_key: ?*const BIGNUM, dh: ?*DH) c_int;
pub extern fn d2i_DHparams(a: [*c]?*DH, in: [*c][*c]const u8, len: c_long) ?*DH;
pub extern fn i2d_DHparams(a: ?*const DH, out: [*c][*c]u8) c_int;
pub extern fn d2i_DHxparams(a: [*c]?*DH, in: [*c][*c]const u8, len: c_long) ?*DH;
pub extern fn i2d_DHxparams(a: ?*const DH, out: [*c][*c]u8) c_int;
pub extern fn DHparams_print_fp(fp: [*c]FILE, x: ?*const DH) c_int;
pub extern fn DHparams_print(bp: ?*BIO, x: ?*const DH) c_int;
pub extern fn DH_get_1024_160() ?*DH;
pub extern fn DH_get_2048_224() ?*DH;
pub extern fn DH_get_2048_256() ?*DH;
pub extern fn DH_new_by_nid(nid: c_int) ?*DH;
pub extern fn DH_get_nid(dh: ?*const DH) c_int;
pub extern fn DH_KDF_X9_42(out: [*c]u8, outlen: usize, Z: [*c]const u8, Zlen: usize, key_oid: ?*ASN1_OBJECT, ukm: [*c]const u8, ukmlen: usize, md: ?*const EVP_MD) c_int;
pub extern fn DH_get0_pqg(dh: ?*const DH, p: [*c]?*const BIGNUM, q: [*c]?*const BIGNUM, g: [*c]?*const BIGNUM) void;
pub extern fn DH_set0_pqg(dh: ?*DH, p: ?*BIGNUM, q: ?*BIGNUM, g: ?*BIGNUM) c_int;
pub extern fn DH_get0_key(dh: ?*const DH, pub_key: [*c]?*const BIGNUM, priv_key: [*c]?*const BIGNUM) void;
pub extern fn DH_set0_key(dh: ?*DH, pub_key: ?*BIGNUM, priv_key: ?*BIGNUM) c_int;
pub extern fn DH_get0_p(dh: ?*const DH) ?*const BIGNUM;
pub extern fn DH_get0_q(dh: ?*const DH) ?*const BIGNUM;
pub extern fn DH_get0_g(dh: ?*const DH) ?*const BIGNUM;
pub extern fn DH_get0_priv_key(dh: ?*const DH) ?*const BIGNUM;
pub extern fn DH_get0_pub_key(dh: ?*const DH) ?*const BIGNUM;
pub extern fn DH_clear_flags(dh: ?*DH, flags: c_int) void;
pub extern fn DH_test_flags(dh: ?*const DH, flags: c_int) c_int;
pub extern fn DH_set_flags(dh: ?*DH, flags: c_int) void;
pub extern fn DH_get0_engine(d: ?*DH) ?*ENGINE;
pub extern fn DH_get_length(dh: ?*const DH) c_long;
pub extern fn DH_set_length(dh: ?*DH, length: c_long) c_int;
pub extern fn DH_meth_new(name: [*c]const u8, flags: c_int) ?*DH_METHOD;
pub extern fn DH_meth_free(dhm: ?*DH_METHOD) void;
pub extern fn DH_meth_dup(dhm: ?*const DH_METHOD) ?*DH_METHOD;
pub extern fn DH_meth_get0_name(dhm: ?*const DH_METHOD) [*c]const u8;
pub extern fn DH_meth_set1_name(dhm: ?*DH_METHOD, name: [*c]const u8) c_int;
pub extern fn DH_meth_get_flags(dhm: ?*const DH_METHOD) c_int;
pub extern fn DH_meth_set_flags(dhm: ?*DH_METHOD, flags: c_int) c_int;
pub extern fn DH_meth_get0_app_data(dhm: ?*const DH_METHOD) ?*anyopaque;
pub extern fn DH_meth_set0_app_data(dhm: ?*DH_METHOD, app_data: ?*anyopaque) c_int;
pub extern fn DH_meth_get_generate_key(dhm: ?*const DH_METHOD) ?*const fn (?*DH) callconv(.c) c_int;
pub extern fn DH_meth_set_generate_key(dhm: ?*DH_METHOD, generate_key: ?*const fn (?*DH) callconv(.c) c_int) c_int;
pub extern fn DH_meth_get_compute_key(dhm: ?*const DH_METHOD) ?*const fn ([*c]u8, ?*const BIGNUM, ?*DH) callconv(.c) c_int;
pub extern fn DH_meth_set_compute_key(dhm: ?*DH_METHOD, compute_key: ?*const fn ([*c]u8, ?*const BIGNUM, ?*DH) callconv(.c) c_int) c_int;
pub extern fn DH_meth_get_bn_mod_exp(dhm: ?*const DH_METHOD) ?*const fn (?*const DH, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.c) c_int;
pub extern fn DH_meth_set_bn_mod_exp(dhm: ?*DH_METHOD, bn_mod_exp: ?*const fn (?*const DH, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.c) c_int) c_int;
pub extern fn DH_meth_get_init(dhm: ?*const DH_METHOD) ?*const fn (?*DH) callconv(.c) c_int;
pub extern fn DH_meth_set_init(dhm: ?*DH_METHOD, init: ?*const fn (?*DH) callconv(.c) c_int) c_int;
pub extern fn DH_meth_get_finish(dhm: ?*const DH_METHOD) ?*const fn (?*DH) callconv(.c) c_int;
pub extern fn DH_meth_set_finish(dhm: ?*DH_METHOD, finish: ?*const fn (?*DH) callconv(.c) c_int) c_int;
pub extern fn DH_meth_get_generate_params(dhm: ?*const DH_METHOD) ?*const fn (?*DH, c_int, c_int, ?*BN_GENCB) callconv(.c) c_int;
pub extern fn DH_meth_set_generate_params(dhm: ?*DH_METHOD, generate_params: ?*const fn (?*DH, c_int, c_int, ?*BN_GENCB) callconv(.c) c_int) c_int;
pub extern fn DH_generate_parameters(prime_len: c_int, generator: c_int, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.c) void, cb_arg: ?*anyopaque) ?*DH;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_bits(ctx: ?*EVP_PKEY_CTX, nbits: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_q_bits(ctx: ?*EVP_PKEY_CTX, qbits: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_md_props(ctx: ?*EVP_PKEY_CTX, md_name: [*c]const u8, md_properties: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_gindex(ctx: ?*EVP_PKEY_CTX, gindex: c_int) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_type(ctx: ?*EVP_PKEY_CTX, name: [*c]const u8) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_seed(ctx: ?*EVP_PKEY_CTX, seed: [*c]const u8, seedlen: usize) c_int;
pub extern fn EVP_PKEY_CTX_set_dsa_paramgen_md(ctx: ?*EVP_PKEY_CTX, md: ?*const EVP_MD) c_int;
pub const struct_DSA_SIG_st = opaque {};
pub const DSA_SIG = struct_DSA_SIG_st;
pub extern fn DSA_SIG_new() ?*DSA_SIG;
pub extern fn DSA_SIG_free(a: ?*DSA_SIG) void;
pub extern fn d2i_DSA_SIG(a: [*c]?*DSA_SIG, in: [*c][*c]const u8, len: c_long) ?*DSA_SIG;
pub extern fn i2d_DSA_SIG(a: ?*const DSA_SIG, out: [*c][*c]u8) c_int;
pub extern fn DSA_SIG_get0(sig: ?*const DSA_SIG, pr: [*c]?*const BIGNUM, ps: [*c]?*const BIGNUM) void;
pub extern fn DSA_SIG_set0(sig: ?*DSA_SIG, r: ?*BIGNUM, s: ?*BIGNUM) c_int;
pub extern fn DSAparams_dup(a: ?*const DSA) ?*DSA;
pub extern fn DSA_do_sign(dgst: [*c]const u8, dlen: c_int, dsa: ?*DSA) ?*DSA_SIG;
pub extern fn DSA_do_verify(dgst: [*c]const u8, dgst_len: c_int, sig: ?*DSA_SIG, dsa: ?*DSA) c_int;
pub extern fn DSA_OpenSSL() ?*const DSA_METHOD;
pub extern fn DSA_set_default_method(?*const DSA_METHOD) void;
pub extern fn DSA_get_default_method() ?*const DSA_METHOD;
pub extern fn DSA_set_method(dsa: ?*DSA, ?*const DSA_METHOD) c_int;
pub extern fn DSA_get_method(d: ?*DSA) ?*const DSA_METHOD;
pub extern fn DSA_new() ?*DSA;
pub extern fn DSA_new_method(engine: ?*ENGINE) ?*DSA;
pub extern fn DSA_free(r: ?*DSA) void;
pub extern fn DSA_up_ref(r: ?*DSA) c_int;
pub extern fn DSA_size(?*const DSA) c_int;
pub extern fn DSA_bits(d: ?*const DSA) c_int;
pub extern fn DSA_security_bits(d: ?*const DSA) c_int;
pub extern fn DSA_sign_setup(dsa: ?*DSA, ctx_in: ?*BN_CTX, kinvp: [*c]?*BIGNUM, rp: [*c]?*BIGNUM) c_int;
pub extern fn DSA_sign(@"type": c_int, dgst: [*c]const u8, dlen: c_int, sig: [*c]u8, siglen: [*c]c_uint, dsa: ?*DSA) c_int;
pub extern fn DSA_verify(@"type": c_int, dgst: [*c]const u8, dgst_len: c_int, sigbuf: [*c]const u8, siglen: c_int, dsa: ?*DSA) c_int;
pub extern fn DSA_set_ex_data(d: ?*DSA, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn DSA_get_ex_data(d: ?*const DSA, idx: c_int) ?*anyopaque;
pub extern fn d2i_DSAPublicKey(a: [*c]?*DSA, in: [*c][*c]const u8, len: c_long) ?*DSA;
pub extern fn i2d_DSAPublicKey(a: ?*const DSA, out: [*c][*c]u8) c_int;
pub extern fn d2i_DSAPrivateKey(a: [*c]?*DSA, in: [*c][*c]const u8, len: c_long) ?*DSA;
pub extern fn i2d_DSAPrivateKey(a: ?*const DSA, out: [*c][*c]u8) c_int;
pub extern fn d2i_DSAparams(a: [*c]?*DSA, in: [*c][*c]const u8, len: c_long) ?*DSA;
pub extern fn i2d_DSAparams(a: ?*const DSA, out: [*c][*c]u8) c_int;
pub extern fn DSA_generate_parameters(bits: c_int, seed: [*c]u8, seed_len: c_int, counter_ret: [*c]c_int, h_ret: [*c]c_ulong, callback: ?*const fn (c_int, c_int, ?*anyopaque) callconv(.c) void, cb_arg: ?*anyopaque) ?*DSA;
pub extern fn DSA_generate_parameters_ex(dsa: ?*DSA, bits: c_int, seed: [*c]const u8, seed_len: c_int, counter_ret: [*c]c_int, h_ret: [*c]c_ulong, cb: ?*BN_GENCB) c_int;
pub extern fn DSA_generate_key(a: ?*DSA) c_int;
pub extern fn DSAparams_print(bp: ?*BIO, x: ?*const DSA) c_int;
pub extern fn DSA_print(bp: ?*BIO, x: ?*const DSA, off: c_int) c_int;
pub extern fn DSAparams_print_fp(fp: [*c]FILE, x: ?*const DSA) c_int;
pub extern fn DSA_print_fp(bp: [*c]FILE, x: ?*const DSA, off: c_int) c_int;
pub extern fn DSA_dup_DH(r: ?*const DSA) ?*DH;
pub extern fn DSA_get0_pqg(d: ?*const DSA, p: [*c]?*const BIGNUM, q: [*c]?*const BIGNUM, g: [*c]?*const BIGNUM) void;
pub extern fn DSA_set0_pqg(d: ?*DSA, p: ?*BIGNUM, q: ?*BIGNUM, g: ?*BIGNUM) c_int;
pub extern fn DSA_get0_key(d: ?*const DSA, pub_key: [*c]?*const BIGNUM, priv_key: [*c]?*const BIGNUM) void;
pub extern fn DSA_set0_key(d: ?*DSA, pub_key: ?*BIGNUM, priv_key: ?*BIGNUM) c_int;
pub extern fn DSA_get0_p(d: ?*const DSA) ?*const BIGNUM;
pub extern fn DSA_get0_q(d: ?*const DSA) ?*const BIGNUM;
pub extern fn DSA_get0_g(d: ?*const DSA) ?*const BIGNUM;
pub extern fn DSA_get0_pub_key(d: ?*const DSA) ?*const BIGNUM;
pub extern fn DSA_get0_priv_key(d: ?*const DSA) ?*const BIGNUM;
pub extern fn DSA_clear_flags(d: ?*DSA, flags: c_int) void;
pub extern fn DSA_test_flags(d: ?*const DSA, flags: c_int) c_int;
pub extern fn DSA_set_flags(d: ?*DSA, flags: c_int) void;
pub extern fn DSA_get0_engine(d: ?*DSA) ?*ENGINE;
pub extern fn DSA_meth_new(name: [*c]const u8, flags: c_int) ?*DSA_METHOD;
pub extern fn DSA_meth_free(dsam: ?*DSA_METHOD) void;
pub extern fn DSA_meth_dup(dsam: ?*const DSA_METHOD) ?*DSA_METHOD;
pub extern fn DSA_meth_get0_name(dsam: ?*const DSA_METHOD) [*c]const u8;
pub extern fn DSA_meth_set1_name(dsam: ?*DSA_METHOD, name: [*c]const u8) c_int;
pub extern fn DSA_meth_get_flags(dsam: ?*const DSA_METHOD) c_int;
pub extern fn DSA_meth_set_flags(dsam: ?*DSA_METHOD, flags: c_int) c_int;
pub extern fn DSA_meth_get0_app_data(dsam: ?*const DSA_METHOD) ?*anyopaque;
pub extern fn DSA_meth_set0_app_data(dsam: ?*DSA_METHOD, app_data: ?*anyopaque) c_int;
pub extern fn DSA_meth_get_sign(dsam: ?*const DSA_METHOD) ?*const fn ([*c]const u8, c_int, ?*DSA) callconv(.c) ?*DSA_SIG;
pub extern fn DSA_meth_set_sign(dsam: ?*DSA_METHOD, sign: ?*const fn ([*c]const u8, c_int, ?*DSA) callconv(.c) ?*DSA_SIG) c_int;
pub extern fn DSA_meth_get_sign_setup(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA, ?*BN_CTX, [*c]?*BIGNUM, [*c]?*BIGNUM) callconv(.c) c_int;
pub extern fn DSA_meth_set_sign_setup(dsam: ?*DSA_METHOD, sign_setup: ?*const fn (?*DSA, ?*BN_CTX, [*c]?*BIGNUM, [*c]?*BIGNUM) callconv(.c) c_int) c_int;
pub extern fn DSA_meth_get_verify(dsam: ?*const DSA_METHOD) ?*const fn ([*c]const u8, c_int, ?*DSA_SIG, ?*DSA) callconv(.c) c_int;
pub extern fn DSA_meth_set_verify(dsam: ?*DSA_METHOD, verify: ?*const fn ([*c]const u8, c_int, ?*DSA_SIG, ?*DSA) callconv(.c) c_int) c_int;
pub extern fn DSA_meth_get_mod_exp(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.c) c_int;
pub extern fn DSA_meth_set_mod_exp(dsam: ?*DSA_METHOD, mod_exp: ?*const fn (?*DSA, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.c) c_int) c_int;
pub extern fn DSA_meth_get_bn_mod_exp(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.c) c_int;
pub extern fn DSA_meth_set_bn_mod_exp(dsam: ?*DSA_METHOD, bn_mod_exp: ?*const fn (?*DSA, ?*BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*const BIGNUM, ?*BN_CTX, ?*BN_MONT_CTX) callconv(.c) c_int) c_int;
pub extern fn DSA_meth_get_init(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA) callconv(.c) c_int;
pub extern fn DSA_meth_set_init(dsam: ?*DSA_METHOD, init: ?*const fn (?*DSA) callconv(.c) c_int) c_int;
pub extern fn DSA_meth_get_finish(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA) callconv(.c) c_int;
pub extern fn DSA_meth_set_finish(dsam: ?*DSA_METHOD, finish: ?*const fn (?*DSA) callconv(.c) c_int) c_int;
pub extern fn DSA_meth_get_paramgen(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA, c_int, [*c]const u8, c_int, [*c]c_int, [*c]c_ulong, ?*BN_GENCB) callconv(.c) c_int;
pub extern fn DSA_meth_set_paramgen(dsam: ?*DSA_METHOD, paramgen: ?*const fn (?*DSA, c_int, [*c]const u8, c_int, [*c]c_int, [*c]c_ulong, ?*BN_GENCB) callconv(.c) c_int) c_int;
pub extern fn DSA_meth_get_keygen(dsam: ?*const DSA_METHOD) ?*const fn (?*DSA) callconv(.c) c_int;
pub extern fn DSA_meth_set_keygen(dsam: ?*DSA_METHOD, keygen: ?*const fn (?*DSA) callconv(.c) c_int) c_int;
pub const struct_SHAstate_st = extern struct {
    h0: c_uint = @import("std").mem.zeroes(c_uint),
    h1: c_uint = @import("std").mem.zeroes(c_uint),
    h2: c_uint = @import("std").mem.zeroes(c_uint),
    h3: c_uint = @import("std").mem.zeroes(c_uint),
    h4: c_uint = @import("std").mem.zeroes(c_uint),
    Nl: c_uint = @import("std").mem.zeroes(c_uint),
    Nh: c_uint = @import("std").mem.zeroes(c_uint),
    data: [16]c_uint = @import("std").mem.zeroes([16]c_uint),
    num: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const SHA_CTX = struct_SHAstate_st;
pub extern fn SHA1_Init(c: [*c]SHA_CTX) c_int;
pub extern fn SHA1_Update(c: [*c]SHA_CTX, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SHA1_Final(md: [*c]u8, c: [*c]SHA_CTX) c_int;
pub extern fn SHA1_Transform(c: [*c]SHA_CTX, data: [*c]const u8) void;
pub extern fn SHA1(d: [*c]const u8, n: usize, md: [*c]u8) [*c]u8;
pub const struct_SHA256state_st = extern struct {
    h: [8]c_uint = @import("std").mem.zeroes([8]c_uint),
    Nl: c_uint = @import("std").mem.zeroes(c_uint),
    Nh: c_uint = @import("std").mem.zeroes(c_uint),
    data: [16]c_uint = @import("std").mem.zeroes([16]c_uint),
    num: c_uint = @import("std").mem.zeroes(c_uint),
    md_len: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const SHA256_CTX = struct_SHA256state_st;
pub extern fn SHA224_Init(c: [*c]SHA256_CTX) c_int;
pub extern fn SHA224_Update(c: [*c]SHA256_CTX, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SHA224_Final(md: [*c]u8, c: [*c]SHA256_CTX) c_int;
pub extern fn SHA256_Init(c: [*c]SHA256_CTX) c_int;
pub extern fn SHA256_Update(c: [*c]SHA256_CTX, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SHA256_Final(md: [*c]u8, c: [*c]SHA256_CTX) c_int;
pub extern fn SHA256_Transform(c: [*c]SHA256_CTX, data: [*c]const u8) void;
pub extern fn SHA224(d: [*c]const u8, n: usize, md: [*c]u8) [*c]u8;
pub extern fn SHA256(d: [*c]const u8, n: usize, md: [*c]u8) [*c]u8;
const union_unnamed_98 = extern union {
    d: [16]c_ulonglong,
    p: [128]u8,
};
pub const struct_SHA512state_st = extern struct {
    h: [8]c_ulonglong = @import("std").mem.zeroes([8]c_ulonglong),
    Nl: c_ulonglong = @import("std").mem.zeroes(c_ulonglong),
    Nh: c_ulonglong = @import("std").mem.zeroes(c_ulonglong),
    u: union_unnamed_98 = @import("std").mem.zeroes(union_unnamed_98),
    num: c_uint = @import("std").mem.zeroes(c_uint),
    md_len: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const SHA512_CTX = struct_SHA512state_st;
pub extern fn SHA384_Init(c: [*c]SHA512_CTX) c_int;
pub extern fn SHA384_Update(c: [*c]SHA512_CTX, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SHA384_Final(md: [*c]u8, c: [*c]SHA512_CTX) c_int;
pub extern fn SHA512_Init(c: [*c]SHA512_CTX) c_int;
pub extern fn SHA512_Update(c: [*c]SHA512_CTX, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SHA512_Final(md: [*c]u8, c: [*c]SHA512_CTX) c_int;
pub extern fn SHA512_Transform(c: [*c]SHA512_CTX, data: [*c]const u8) void;
pub extern fn SHA384(d: [*c]const u8, n: usize, md: [*c]u8) [*c]u8;
pub extern fn SHA512(d: [*c]const u8, n: usize, md: [*c]u8) [*c]u8;
pub const struct_stack_st_X509_NAME = opaque {};
pub const sk_X509_NAME_compfunc = ?*const fn ([*c]const ?*const X509_NAME, [*c]const ?*const X509_NAME) callconv(.c) c_int;
pub const sk_X509_NAME_freefunc = ?*const fn (?*X509_NAME) callconv(.c) void;
pub const sk_X509_NAME_copyfunc = ?*const fn (?*const X509_NAME) callconv(.c) ?*X509_NAME;
pub fn ossl_check_X509_NAME_type(arg_ptr: ?*X509_NAME) callconv(.c) ?*X509_NAME {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_NAME_sk_type(arg_sk: ?*const struct_stack_st_X509_NAME) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_NAME_sk_type(arg_sk: ?*struct_stack_st_X509_NAME) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_NAME_compfunc_type(arg_cmp: sk_X509_NAME_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_NAME_copyfunc_type(arg_cpy: sk_X509_NAME_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_NAME_freefunc_type(arg_fr: sk_X509_NAME_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_X509 = opaque {};
pub const sk_X509_compfunc = ?*const fn ([*c]const ?*const X509, [*c]const ?*const X509) callconv(.c) c_int;
pub const sk_X509_freefunc = ?*const fn (?*X509) callconv(.c) void;
pub const sk_X509_copyfunc = ?*const fn (?*const X509) callconv(.c) ?*X509;
pub fn ossl_check_X509_type(arg_ptr: ?*X509) callconv(.c) ?*X509 {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_sk_type(arg_sk: ?*const struct_stack_st_X509) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_sk_type(arg_sk: ?*struct_stack_st_X509) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_compfunc_type(arg_cmp: sk_X509_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_copyfunc_type(arg_cpy: sk_X509_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_freefunc_type(arg_fr: sk_X509_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_X509_REVOKED = opaque {};
pub const sk_X509_REVOKED_compfunc = ?*const fn ([*c]const ?*const X509_REVOKED, [*c]const ?*const X509_REVOKED) callconv(.c) c_int;
pub const sk_X509_REVOKED_freefunc = ?*const fn (?*X509_REVOKED) callconv(.c) void;
pub const sk_X509_REVOKED_copyfunc = ?*const fn (?*const X509_REVOKED) callconv(.c) ?*X509_REVOKED;
pub fn ossl_check_X509_REVOKED_type(arg_ptr: ?*X509_REVOKED) callconv(.c) ?*X509_REVOKED {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_REVOKED_sk_type(arg_sk: ?*const struct_stack_st_X509_REVOKED) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_REVOKED_sk_type(arg_sk: ?*struct_stack_st_X509_REVOKED) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_REVOKED_compfunc_type(arg_cmp: sk_X509_REVOKED_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_REVOKED_copyfunc_type(arg_cpy: sk_X509_REVOKED_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_REVOKED_freefunc_type(arg_fr: sk_X509_REVOKED_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_X509_CRL = opaque {};
pub const sk_X509_CRL_compfunc = ?*const fn ([*c]const ?*const X509_CRL, [*c]const ?*const X509_CRL) callconv(.c) c_int;
pub const sk_X509_CRL_freefunc = ?*const fn (?*X509_CRL) callconv(.c) void;
pub const sk_X509_CRL_copyfunc = ?*const fn (?*const X509_CRL) callconv(.c) ?*X509_CRL;
pub fn ossl_check_X509_CRL_type(arg_ptr: ?*X509_CRL) callconv(.c) ?*X509_CRL {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_CRL_sk_type(arg_sk: ?*const struct_stack_st_X509_CRL) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_CRL_sk_type(arg_sk: ?*struct_stack_st_X509_CRL) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_CRL_compfunc_type(arg_cmp: sk_X509_CRL_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_CRL_copyfunc_type(arg_cpy: sk_X509_CRL_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_CRL_freefunc_type(arg_fr: sk_X509_CRL_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const X509_ALGORS = struct_stack_st_X509_ALGOR;
pub const struct_X509_val_st = extern struct {
    notBefore: [*c]ASN1_TIME = @import("std").mem.zeroes([*c]ASN1_TIME),
    notAfter: [*c]ASN1_TIME = @import("std").mem.zeroes([*c]ASN1_TIME),
};
pub const X509_VAL = struct_X509_val_st;
pub const struct_X509_sig_st = opaque {};
pub const X509_SIG = struct_X509_sig_st;
pub const struct_X509_name_entry_st = opaque {};
pub const X509_NAME_ENTRY = struct_X509_name_entry_st;
pub const sk_X509_NAME_ENTRY_compfunc = ?*const fn ([*c]const ?*const X509_NAME_ENTRY, [*c]const ?*const X509_NAME_ENTRY) callconv(.c) c_int;
pub const sk_X509_NAME_ENTRY_freefunc = ?*const fn (?*X509_NAME_ENTRY) callconv(.c) void;
pub const sk_X509_NAME_ENTRY_copyfunc = ?*const fn (?*const X509_NAME_ENTRY) callconv(.c) ?*X509_NAME_ENTRY;
pub fn ossl_check_X509_NAME_ENTRY_type(arg_ptr: ?*X509_NAME_ENTRY) callconv(.c) ?*X509_NAME_ENTRY {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_NAME_ENTRY_sk_type(arg_sk: ?*const struct_stack_st_X509_NAME_ENTRY) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_NAME_ENTRY_sk_type(arg_sk: ?*struct_stack_st_X509_NAME_ENTRY) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_NAME_ENTRY_compfunc_type(arg_cmp: sk_X509_NAME_ENTRY_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_NAME_ENTRY_copyfunc_type(arg_cpy: sk_X509_NAME_ENTRY_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_NAME_ENTRY_freefunc_type(arg_fr: sk_X509_NAME_ENTRY_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_X509_extension_st = opaque {};
pub const X509_EXTENSION = struct_X509_extension_st;
pub const struct_stack_st_X509_EXTENSION = opaque {};
pub const sk_X509_EXTENSION_compfunc = ?*const fn ([*c]const ?*const X509_EXTENSION, [*c]const ?*const X509_EXTENSION) callconv(.c) c_int;
pub const sk_X509_EXTENSION_freefunc = ?*const fn (?*X509_EXTENSION) callconv(.c) void;
pub const sk_X509_EXTENSION_copyfunc = ?*const fn (?*const X509_EXTENSION) callconv(.c) ?*X509_EXTENSION;
pub fn ossl_check_X509_EXTENSION_type(arg_ptr: ?*X509_EXTENSION) callconv(.c) ?*X509_EXTENSION {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_EXTENSION_sk_type(arg_sk: ?*const struct_stack_st_X509_EXTENSION) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_EXTENSION_sk_type(arg_sk: ?*struct_stack_st_X509_EXTENSION) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_EXTENSION_compfunc_type(arg_cmp: sk_X509_EXTENSION_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_EXTENSION_copyfunc_type(arg_cpy: sk_X509_EXTENSION_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_EXTENSION_freefunc_type(arg_fr: sk_X509_EXTENSION_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const X509_EXTENSIONS = struct_stack_st_X509_EXTENSION;
pub const struct_x509_attributes_st = opaque {};
pub const X509_ATTRIBUTE = struct_x509_attributes_st;
pub const struct_stack_st_X509_ATTRIBUTE = opaque {};
pub const sk_X509_ATTRIBUTE_compfunc = ?*const fn ([*c]const ?*const X509_ATTRIBUTE, [*c]const ?*const X509_ATTRIBUTE) callconv(.c) c_int;
pub const sk_X509_ATTRIBUTE_freefunc = ?*const fn (?*X509_ATTRIBUTE) callconv(.c) void;
pub const sk_X509_ATTRIBUTE_copyfunc = ?*const fn (?*const X509_ATTRIBUTE) callconv(.c) ?*X509_ATTRIBUTE;
pub fn ossl_check_X509_ATTRIBUTE_type(arg_ptr: ?*X509_ATTRIBUTE) callconv(.c) ?*X509_ATTRIBUTE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_ATTRIBUTE_sk_type(arg_sk: ?*const struct_stack_st_X509_ATTRIBUTE) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_ATTRIBUTE_sk_type(arg_sk: ?*struct_stack_st_X509_ATTRIBUTE) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_ATTRIBUTE_compfunc_type(arg_cmp: sk_X509_ATTRIBUTE_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_ATTRIBUTE_copyfunc_type(arg_cpy: sk_X509_ATTRIBUTE_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_ATTRIBUTE_freefunc_type(arg_fr: sk_X509_ATTRIBUTE_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_X509_req_info_st = opaque {};
pub const X509_REQ_INFO = struct_X509_req_info_st;
pub const struct_x509_cert_aux_st = opaque {};
pub const X509_CERT_AUX = struct_x509_cert_aux_st;
pub const struct_x509_cinf_st = opaque {};
pub const X509_CINF = struct_x509_cinf_st;
pub const struct_X509_crl_info_st = opaque {};
pub const X509_CRL_INFO = struct_X509_crl_info_st;
pub const struct_private_key_st = extern struct {
    version: c_int = @import("std").mem.zeroes(c_int),
    enc_algor: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    enc_pkey: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    dec_pkey: ?*EVP_PKEY = @import("std").mem.zeroes(?*EVP_PKEY),
    key_length: c_int = @import("std").mem.zeroes(c_int),
    key_data: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    key_free: c_int = @import("std").mem.zeroes(c_int),
    cipher: EVP_CIPHER_INFO = @import("std").mem.zeroes(EVP_CIPHER_INFO),
};
pub const X509_PKEY = struct_private_key_st;
pub const struct_X509_info_st = extern struct {
    x509: ?*X509 = @import("std").mem.zeroes(?*X509),
    crl: ?*X509_CRL = @import("std").mem.zeroes(?*X509_CRL),
    x_pkey: [*c]X509_PKEY = @import("std").mem.zeroes([*c]X509_PKEY),
    enc_cipher: EVP_CIPHER_INFO = @import("std").mem.zeroes(EVP_CIPHER_INFO),
    enc_len: c_int = @import("std").mem.zeroes(c_int),
    enc_data: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const X509_INFO = struct_X509_info_st;
pub const struct_stack_st_X509_INFO = opaque {};
pub const sk_X509_INFO_compfunc = ?*const fn ([*c]const [*c]const X509_INFO, [*c]const [*c]const X509_INFO) callconv(.c) c_int;
pub const sk_X509_INFO_freefunc = ?*const fn ([*c]X509_INFO) callconv(.c) void;
pub const sk_X509_INFO_copyfunc = ?*const fn ([*c]const X509_INFO) callconv(.c) [*c]X509_INFO;
pub fn ossl_check_X509_INFO_type(arg_ptr: [*c]X509_INFO) callconv(.c) [*c]X509_INFO {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_INFO_sk_type(arg_sk: ?*const struct_stack_st_X509_INFO) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_INFO_sk_type(arg_sk: ?*struct_stack_st_X509_INFO) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_INFO_compfunc_type(arg_cmp: sk_X509_INFO_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_INFO_copyfunc_type(arg_cpy: sk_X509_INFO_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_INFO_freefunc_type(arg_fr: sk_X509_INFO_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_Netscape_spkac_st = extern struct {
    pubkey: ?*X509_PUBKEY = @import("std").mem.zeroes(?*X509_PUBKEY),
    challenge: [*c]ASN1_IA5STRING = @import("std").mem.zeroes([*c]ASN1_IA5STRING),
};
pub const NETSCAPE_SPKAC = struct_Netscape_spkac_st;
pub const struct_Netscape_spki_st = extern struct {
    spkac: [*c]NETSCAPE_SPKAC = @import("std").mem.zeroes([*c]NETSCAPE_SPKAC),
    sig_algor: X509_ALGOR = @import("std").mem.zeroes(X509_ALGOR),
    signature: [*c]ASN1_BIT_STRING = @import("std").mem.zeroes([*c]ASN1_BIT_STRING),
};
pub const NETSCAPE_SPKI = struct_Netscape_spki_st;
pub const struct_Netscape_certificate_sequence = extern struct {
    type: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    certs: ?*struct_stack_st_X509 = @import("std").mem.zeroes(?*struct_stack_st_X509),
};
pub const NETSCAPE_CERT_SEQUENCE = struct_Netscape_certificate_sequence;
pub const struct_PBEPARAM_st = extern struct {
    salt: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    iter: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const PBEPARAM = struct_PBEPARAM_st;
pub const struct_PBE2PARAM_st = extern struct {
    keyfunc: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    encryption: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
};
pub const PBE2PARAM = struct_PBE2PARAM_st;
pub const struct_PBKDF2PARAM_st = extern struct {
    salt: [*c]ASN1_TYPE = @import("std").mem.zeroes([*c]ASN1_TYPE),
    iter: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    keylength: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    prf: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
};
pub const PBKDF2PARAM = struct_PBKDF2PARAM_st;
pub const PBMAC1PARAM = extern struct {
    keyDerivationFunc: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    messageAuthScheme: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
};
pub const struct_SCRYPT_PARAMS_st = extern struct {
    salt: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    costParameter: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    blockSize: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    parallelizationParameter: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    keyLength: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const SCRYPT_PARAMS = struct_SCRYPT_PARAMS_st;
pub const struct_lhash_node_st = opaque {};
pub const OPENSSL_LH_NODE = struct_lhash_node_st;
pub const OPENSSL_LH_COMPFUNC = ?*const fn (?*const anyopaque, ?*const anyopaque) callconv(.c) c_int;
pub const OPENSSL_LH_COMPFUNCTHUNK = ?*const fn (?*const anyopaque, ?*const anyopaque, OPENSSL_LH_COMPFUNC) callconv(.c) c_int;
pub const OPENSSL_LH_HASHFUNC = ?*const fn (?*const anyopaque) callconv(.c) c_ulong;
pub const OPENSSL_LH_HASHFUNCTHUNK = ?*const fn (?*const anyopaque, OPENSSL_LH_HASHFUNC) callconv(.c) c_ulong;
pub const OPENSSL_LH_DOALL_FUNC = ?*const fn (?*anyopaque) callconv(.c) void;
pub const OPENSSL_LH_DOALL_FUNC_THUNK = ?*const fn (?*anyopaque, OPENSSL_LH_DOALL_FUNC) callconv(.c) void;
pub const OPENSSL_LH_DOALL_FUNCARG = ?*const fn (?*anyopaque, ?*anyopaque) callconv(.c) void;
pub const OPENSSL_LH_DOALL_FUNCARG_THUNK = ?*const fn (?*anyopaque, ?*anyopaque, OPENSSL_LH_DOALL_FUNCARG) callconv(.c) void;
pub const struct_lhash_st = opaque {};
pub const OPENSSL_LHASH = struct_lhash_st;
pub extern fn OPENSSL_LH_error(lh: ?*OPENSSL_LHASH) c_int;
pub extern fn OPENSSL_LH_new(h: OPENSSL_LH_HASHFUNC, c: OPENSSL_LH_COMPFUNC) ?*OPENSSL_LHASH;
pub extern fn OPENSSL_LH_set_thunks(lh: ?*OPENSSL_LHASH, hw: OPENSSL_LH_HASHFUNCTHUNK, cw: OPENSSL_LH_COMPFUNCTHUNK, daw: OPENSSL_LH_DOALL_FUNC_THUNK, daaw: OPENSSL_LH_DOALL_FUNCARG_THUNK) ?*OPENSSL_LHASH;
pub extern fn OPENSSL_LH_free(lh: ?*OPENSSL_LHASH) void;
pub extern fn OPENSSL_LH_flush(lh: ?*OPENSSL_LHASH) void;
pub extern fn OPENSSL_LH_insert(lh: ?*OPENSSL_LHASH, data: ?*anyopaque) ?*anyopaque;
pub extern fn OPENSSL_LH_delete(lh: ?*OPENSSL_LHASH, data: ?*const anyopaque) ?*anyopaque;
pub extern fn OPENSSL_LH_retrieve(lh: ?*OPENSSL_LHASH, data: ?*const anyopaque) ?*anyopaque;
pub extern fn OPENSSL_LH_doall(lh: ?*OPENSSL_LHASH, func: OPENSSL_LH_DOALL_FUNC) void;
pub extern fn OPENSSL_LH_doall_arg(lh: ?*OPENSSL_LHASH, func: OPENSSL_LH_DOALL_FUNCARG, arg: ?*anyopaque) void;
pub extern fn OPENSSL_LH_doall_arg_thunk(lh: ?*OPENSSL_LHASH, daaw: OPENSSL_LH_DOALL_FUNCARG_THUNK, @"fn": OPENSSL_LH_DOALL_FUNCARG, arg: ?*anyopaque) void;
pub extern fn OPENSSL_LH_strhash(c: [*c]const u8) c_ulong;
pub extern fn OPENSSL_LH_num_items(lh: ?*const OPENSSL_LHASH) c_ulong;
pub extern fn OPENSSL_LH_get_down_load(lh: ?*const OPENSSL_LHASH) c_ulong;
pub extern fn OPENSSL_LH_set_down_load(lh: ?*OPENSSL_LHASH, down_load: c_ulong) void;
pub extern fn OPENSSL_LH_stats(lh: ?*const OPENSSL_LHASH, fp: [*c]FILE) void;
pub extern fn OPENSSL_LH_node_stats(lh: ?*const OPENSSL_LHASH, fp: [*c]FILE) void;
pub extern fn OPENSSL_LH_node_usage_stats(lh: ?*const OPENSSL_LHASH, fp: [*c]FILE) void;
pub extern fn OPENSSL_LH_stats_bio(lh: ?*const OPENSSL_LHASH, out: ?*BIO) void;
pub extern fn OPENSSL_LH_node_stats_bio(lh: ?*const OPENSSL_LHASH, out: ?*BIO) void;
pub extern fn OPENSSL_LH_node_usage_stats_bio(lh: ?*const OPENSSL_LHASH, out: ?*BIO) void;
pub const union_lh_OPENSSL_STRING_dummy_99 = extern union {
    d1: ?*anyopaque,
    d2: c_ulong,
    d3: c_int,
};
pub const struct_lhash_st_OPENSSL_STRING = extern struct {
    dummy: union_lh_OPENSSL_STRING_dummy_99 = @import("std").mem.zeroes(union_lh_OPENSSL_STRING_dummy_99),
};
pub const lh_OPENSSL_STRING_compfunc = ?*const fn ([*c]const OPENSSL_STRING, [*c]const OPENSSL_STRING) callconv(.c) c_int;
pub const lh_OPENSSL_STRING_hashfunc = ?*const fn ([*c]const OPENSSL_STRING) callconv(.c) c_ulong;
pub const lh_OPENSSL_STRING_doallfunc = ?*const fn ([*c]OPENSSL_STRING) callconv(.c) void;
pub fn lh_OPENSSL_STRING_hash_thunk(arg_data: ?*const anyopaque, arg_hfn: OPENSSL_LH_HASHFUNC) callconv(.c) c_ulong {
    var data = arg_data;
    _ = &data;
    var hfn = arg_hfn;
    _ = &hfn;
    var hfn_conv: ?*const fn ([*c]const OPENSSL_STRING) callconv(.c) c_ulong = @as(?*const fn ([*c]const OPENSSL_STRING) callconv(.c) c_ulong, @ptrCast(@alignCast(hfn)));
    _ = &hfn_conv;
    return hfn_conv.?(@as([*c]const OPENSSL_STRING, @ptrCast(@alignCast(data))));
}
pub fn lh_OPENSSL_STRING_comp_thunk(arg_da: ?*const anyopaque, arg_db: ?*const anyopaque, arg_cfn: OPENSSL_LH_COMPFUNC) callconv(.c) c_int {
    var da = arg_da;
    _ = &da;
    var db = arg_db;
    _ = &db;
    var cfn = arg_cfn;
    _ = &cfn;
    var cfn_conv: ?*const fn ([*c]const OPENSSL_STRING, [*c]const OPENSSL_STRING) callconv(.c) c_int = @as(?*const fn ([*c]const OPENSSL_STRING, [*c]const OPENSSL_STRING) callconv(.c) c_int, @ptrCast(@alignCast(cfn)));
    _ = &cfn_conv;
    return cfn_conv.?(@as([*c]const OPENSSL_STRING, @ptrCast(@alignCast(da))), @as([*c]const OPENSSL_STRING, @ptrCast(@alignCast(db))));
}
pub fn lh_OPENSSL_STRING_doall_thunk(arg_node: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNC) callconv(.c) void {
    var node = arg_node;
    _ = &node;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]OPENSSL_STRING) callconv(.c) void = @as(?*const fn ([*c]OPENSSL_STRING) callconv(.c) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]OPENSSL_STRING, @ptrCast(@alignCast(node))));
}
pub fn lh_OPENSSL_STRING_doall_arg_thunk(arg_node: ?*anyopaque, arg_arg: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNCARG) callconv(.c) void {
    var node = arg_node;
    _ = &node;
    var arg = arg_arg;
    _ = &arg;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]OPENSSL_STRING, ?*anyopaque) callconv(.c) void = @as(?*const fn ([*c]OPENSSL_STRING, ?*anyopaque) callconv(.c) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]OPENSSL_STRING, @ptrCast(@alignCast(node))), arg);
}
pub fn ossl_check_OPENSSL_STRING_lh_plain_type(arg_ptr: [*c]OPENSSL_STRING) callconv(.c) [*c]OPENSSL_STRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_STRING_lh_plain_type(arg_ptr: [*c]const OPENSSL_STRING) callconv(.c) [*c]const OPENSSL_STRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_STRING_lh_type(arg_lh: [*c]const struct_lhash_st_OPENSSL_STRING) callconv(.c) ?*const OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*const OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_OPENSSL_STRING_lh_type(arg_lh: [*c]struct_lhash_st_OPENSSL_STRING) callconv(.c) ?*OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_OPENSSL_STRING_lh_compfunc_type(arg_cmp: lh_OPENSSL_STRING_compfunc) callconv(.c) OPENSSL_LH_COMPFUNC {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_LH_COMPFUNC, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OPENSSL_STRING_lh_hashfunc_type(arg_hfn: lh_OPENSSL_STRING_hashfunc) callconv(.c) OPENSSL_LH_HASHFUNC {
    var hfn = arg_hfn;
    _ = &hfn;
    return @as(OPENSSL_LH_HASHFUNC, @ptrCast(@alignCast(hfn)));
}
pub fn ossl_check_OPENSSL_STRING_lh_doallfunc_type(arg_dfn: lh_OPENSSL_STRING_doallfunc) callconv(.c) OPENSSL_LH_DOALL_FUNC {
    var dfn = arg_dfn;
    _ = &dfn;
    return @as(OPENSSL_LH_DOALL_FUNC, @ptrCast(@alignCast(dfn)));
}
pub const union_lh_OPENSSL_CSTRING_dummy_100 = extern union {
    d1: ?*anyopaque,
    d2: c_ulong,
    d3: c_int,
};
pub const struct_lhash_st_OPENSSL_CSTRING = extern struct {
    dummy: union_lh_OPENSSL_CSTRING_dummy_100 = @import("std").mem.zeroes(union_lh_OPENSSL_CSTRING_dummy_100),
};
pub const lh_OPENSSL_CSTRING_compfunc = ?*const fn ([*c]const OPENSSL_CSTRING, [*c]const OPENSSL_CSTRING) callconv(.c) c_int;
pub const lh_OPENSSL_CSTRING_hashfunc = ?*const fn ([*c]const OPENSSL_CSTRING) callconv(.c) c_ulong;
pub const lh_OPENSSL_CSTRING_doallfunc = ?*const fn ([*c]OPENSSL_CSTRING) callconv(.c) void;
pub fn lh_OPENSSL_CSTRING_hash_thunk(arg_data: ?*const anyopaque, arg_hfn: OPENSSL_LH_HASHFUNC) callconv(.c) c_ulong {
    var data = arg_data;
    _ = &data;
    var hfn = arg_hfn;
    _ = &hfn;
    var hfn_conv: ?*const fn ([*c]const OPENSSL_CSTRING) callconv(.c) c_ulong = @as(?*const fn ([*c]const OPENSSL_CSTRING) callconv(.c) c_ulong, @ptrCast(@alignCast(hfn)));
    _ = &hfn_conv;
    return hfn_conv.?(@as([*c]const OPENSSL_CSTRING, @ptrCast(@alignCast(data))));
}
pub fn lh_OPENSSL_CSTRING_comp_thunk(arg_da: ?*const anyopaque, arg_db: ?*const anyopaque, arg_cfn: OPENSSL_LH_COMPFUNC) callconv(.c) c_int {
    var da = arg_da;
    _ = &da;
    var db = arg_db;
    _ = &db;
    var cfn = arg_cfn;
    _ = &cfn;
    var cfn_conv: ?*const fn ([*c]const OPENSSL_CSTRING, [*c]const OPENSSL_CSTRING) callconv(.c) c_int = @as(?*const fn ([*c]const OPENSSL_CSTRING, [*c]const OPENSSL_CSTRING) callconv(.c) c_int, @ptrCast(@alignCast(cfn)));
    _ = &cfn_conv;
    return cfn_conv.?(@as([*c]const OPENSSL_CSTRING, @ptrCast(@alignCast(da))), @as([*c]const OPENSSL_CSTRING, @ptrCast(@alignCast(db))));
}
pub fn lh_OPENSSL_CSTRING_doall_thunk(arg_node: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNC) callconv(.c) void {
    var node = arg_node;
    _ = &node;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]OPENSSL_CSTRING) callconv(.c) void = @as(?*const fn ([*c]OPENSSL_CSTRING) callconv(.c) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]OPENSSL_CSTRING, @ptrCast(@alignCast(node))));
}
pub fn lh_OPENSSL_CSTRING_doall_arg_thunk(arg_node: ?*anyopaque, arg_arg: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNCARG) callconv(.c) void {
    var node = arg_node;
    _ = &node;
    var arg = arg_arg;
    _ = &arg;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]OPENSSL_CSTRING, ?*anyopaque) callconv(.c) void = @as(?*const fn ([*c]OPENSSL_CSTRING, ?*anyopaque) callconv(.c) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]OPENSSL_CSTRING, @ptrCast(@alignCast(node))), arg);
}
pub fn ossl_check_OPENSSL_CSTRING_lh_plain_type(arg_ptr: [*c]OPENSSL_CSTRING) callconv(.c) [*c]OPENSSL_CSTRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_CSTRING_lh_plain_type(arg_ptr: [*c]const OPENSSL_CSTRING) callconv(.c) [*c]const OPENSSL_CSTRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OPENSSL_CSTRING_lh_type(arg_lh: [*c]const struct_lhash_st_OPENSSL_CSTRING) callconv(.c) ?*const OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*const OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_OPENSSL_CSTRING_lh_type(arg_lh: [*c]struct_lhash_st_OPENSSL_CSTRING) callconv(.c) ?*OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_OPENSSL_CSTRING_lh_compfunc_type(arg_cmp: lh_OPENSSL_CSTRING_compfunc) callconv(.c) OPENSSL_LH_COMPFUNC {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_LH_COMPFUNC, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OPENSSL_CSTRING_lh_hashfunc_type(arg_hfn: lh_OPENSSL_CSTRING_hashfunc) callconv(.c) OPENSSL_LH_HASHFUNC {
    var hfn = arg_hfn;
    _ = &hfn;
    return @as(OPENSSL_LH_HASHFUNC, @ptrCast(@alignCast(hfn)));
}
pub fn ossl_check_OPENSSL_CSTRING_lh_doallfunc_type(arg_dfn: lh_OPENSSL_CSTRING_doallfunc) callconv(.c) OPENSSL_LH_DOALL_FUNC {
    var dfn = arg_dfn;
    _ = &dfn;
    return @as(OPENSSL_LH_DOALL_FUNC, @ptrCast(@alignCast(dfn)));
}
pub const X509_LU_NONE: c_int = 0;
pub const X509_LU_X509: c_int = 1;
pub const X509_LU_CRL: c_int = 2;
pub const X509_LOOKUP_TYPE = c_uint;
pub const struct_stack_st_X509_LOOKUP = opaque {};
pub const sk_X509_LOOKUP_compfunc = ?*const fn ([*c]const ?*const X509_LOOKUP, [*c]const ?*const X509_LOOKUP) callconv(.c) c_int;
pub const sk_X509_LOOKUP_freefunc = ?*const fn (?*X509_LOOKUP) callconv(.c) void;
pub const sk_X509_LOOKUP_copyfunc = ?*const fn (?*const X509_LOOKUP) callconv(.c) ?*X509_LOOKUP;
pub fn ossl_check_X509_LOOKUP_type(arg_ptr: ?*X509_LOOKUP) callconv(.c) ?*X509_LOOKUP {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_LOOKUP_sk_type(arg_sk: ?*const struct_stack_st_X509_LOOKUP) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_LOOKUP_sk_type(arg_sk: ?*struct_stack_st_X509_LOOKUP) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_LOOKUP_compfunc_type(arg_cmp: sk_X509_LOOKUP_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_LOOKUP_copyfunc_type(arg_cpy: sk_X509_LOOKUP_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_LOOKUP_freefunc_type(arg_fr: sk_X509_LOOKUP_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_X509_OBJECT = opaque {};
pub const sk_X509_OBJECT_compfunc = ?*const fn ([*c]const ?*const X509_OBJECT, [*c]const ?*const X509_OBJECT) callconv(.c) c_int;
pub const sk_X509_OBJECT_freefunc = ?*const fn (?*X509_OBJECT) callconv(.c) void;
pub const sk_X509_OBJECT_copyfunc = ?*const fn (?*const X509_OBJECT) callconv(.c) ?*X509_OBJECT;
pub fn ossl_check_X509_OBJECT_type(arg_ptr: ?*X509_OBJECT) callconv(.c) ?*X509_OBJECT {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_OBJECT_sk_type(arg_sk: ?*const struct_stack_st_X509_OBJECT) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_OBJECT_sk_type(arg_sk: ?*struct_stack_st_X509_OBJECT) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_OBJECT_compfunc_type(arg_cmp: sk_X509_OBJECT_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_OBJECT_copyfunc_type(arg_cpy: sk_X509_OBJECT_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_OBJECT_freefunc_type(arg_fr: sk_X509_OBJECT_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_X509_VERIFY_PARAM = opaque {};
pub const sk_X509_VERIFY_PARAM_compfunc = ?*const fn ([*c]const ?*const X509_VERIFY_PARAM, [*c]const ?*const X509_VERIFY_PARAM) callconv(.c) c_int;
pub const sk_X509_VERIFY_PARAM_freefunc = ?*const fn (?*X509_VERIFY_PARAM) callconv(.c) void;
pub const sk_X509_VERIFY_PARAM_copyfunc = ?*const fn (?*const X509_VERIFY_PARAM) callconv(.c) ?*X509_VERIFY_PARAM;
pub fn ossl_check_X509_VERIFY_PARAM_type(arg_ptr: ?*X509_VERIFY_PARAM) callconv(.c) ?*X509_VERIFY_PARAM {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_VERIFY_PARAM_sk_type(arg_sk: ?*const struct_stack_st_X509_VERIFY_PARAM) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_VERIFY_PARAM_sk_type(arg_sk: ?*struct_stack_st_X509_VERIFY_PARAM) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_VERIFY_PARAM_compfunc_type(arg_cmp: sk_X509_VERIFY_PARAM_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_VERIFY_PARAM_copyfunc_type(arg_cpy: sk_X509_VERIFY_PARAM_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_VERIFY_PARAM_freefunc_type(arg_fr: sk_X509_VERIFY_PARAM_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_x509_trust_st = extern struct {
    trust: c_int = @import("std").mem.zeroes(c_int),
    flags: c_int = @import("std").mem.zeroes(c_int),
    check_trust: ?*const fn ([*c]struct_x509_trust_st, ?*X509, c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]struct_x509_trust_st, ?*X509, c_int) callconv(.c) c_int),
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    arg1: c_int = @import("std").mem.zeroes(c_int),
    arg2: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const X509_TRUST = struct_x509_trust_st;
pub const struct_stack_st_X509_TRUST = opaque {};
pub const sk_X509_TRUST_compfunc = ?*const fn ([*c]const [*c]const X509_TRUST, [*c]const [*c]const X509_TRUST) callconv(.c) c_int;
pub const sk_X509_TRUST_freefunc = ?*const fn ([*c]X509_TRUST) callconv(.c) void;
pub const sk_X509_TRUST_copyfunc = ?*const fn ([*c]const X509_TRUST) callconv(.c) [*c]X509_TRUST;
pub fn ossl_check_X509_TRUST_type(arg_ptr: [*c]X509_TRUST) callconv(.c) [*c]X509_TRUST {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_TRUST_sk_type(arg_sk: ?*const struct_stack_st_X509_TRUST) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_TRUST_sk_type(arg_sk: ?*struct_stack_st_X509_TRUST) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_TRUST_compfunc_type(arg_cmp: sk_X509_TRUST_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_TRUST_copyfunc_type(arg_cpy: sk_X509_TRUST_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_TRUST_freefunc_type(arg_fr: sk_X509_TRUST_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn X509_TRUST_set(t: [*c]c_int, trust: c_int) c_int;
pub extern fn X509_TRUST_get_count() c_int;
pub extern fn X509_TRUST_get0(idx: c_int) [*c]X509_TRUST;
pub extern fn X509_TRUST_get_by_id(id: c_int) c_int;
pub extern fn X509_TRUST_add(id: c_int, flags: c_int, ck: ?*const fn ([*c]X509_TRUST, ?*X509, c_int) callconv(.c) c_int, name: [*c]const u8, arg1: c_int, arg2: ?*anyopaque) c_int;
pub extern fn X509_TRUST_cleanup() void;
pub extern fn X509_TRUST_get_flags(xp: [*c]const X509_TRUST) c_int;
pub extern fn X509_TRUST_get0_name(xp: [*c]const X509_TRUST) [*c]u8;
pub extern fn X509_TRUST_get_trust(xp: [*c]const X509_TRUST) c_int;
pub extern fn X509_trusted(x: ?*const X509) c_int;
pub extern fn X509_add1_trust_object(x: ?*X509, obj: ?*const ASN1_OBJECT) c_int;
pub extern fn X509_add1_reject_object(x: ?*X509, obj: ?*const ASN1_OBJECT) c_int;
pub extern fn X509_trust_clear(x: ?*X509) void;
pub extern fn X509_reject_clear(x: ?*X509) void;
pub extern fn X509_get0_trust_objects(x: ?*X509) ?*struct_stack_st_ASN1_OBJECT;
pub extern fn X509_get0_reject_objects(x: ?*X509) ?*struct_stack_st_ASN1_OBJECT;
pub extern fn X509_TRUST_set_default(trust: ?*const fn (c_int, ?*X509, c_int) callconv(.c) c_int) ?*const fn (c_int, ?*X509, c_int) callconv(.c) c_int;
pub extern fn X509_check_trust(x: ?*X509, id: c_int, flags: c_int) c_int;
pub extern fn X509_verify_cert(ctx: ?*X509_STORE_CTX) c_int;
pub extern fn X509_STORE_CTX_verify(ctx: ?*X509_STORE_CTX) c_int;
pub extern fn X509_build_chain(target: ?*X509, certs: ?*struct_stack_st_X509, store: ?*X509_STORE, with_self_signed: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*struct_stack_st_X509;
pub extern fn X509_STORE_set_depth(store: ?*X509_STORE, depth: c_int) c_int;
pub const X509_STORE_CTX_verify_cb = ?*const fn (c_int, ?*X509_STORE_CTX) callconv(.c) c_int;
pub extern fn X509_STORE_CTX_print_verify_cb(ok: c_int, ctx: ?*X509_STORE_CTX) c_int;
pub const X509_STORE_CTX_verify_fn = ?*const fn (?*X509_STORE_CTX) callconv(.c) c_int;
pub const X509_STORE_CTX_get_issuer_fn = ?*const fn ([*c]?*X509, ?*X509_STORE_CTX, ?*X509) callconv(.c) c_int;
pub const X509_STORE_CTX_check_issued_fn = ?*const fn (?*X509_STORE_CTX, ?*X509, ?*X509) callconv(.c) c_int;
pub const X509_STORE_CTX_check_revocation_fn = ?*const fn (?*X509_STORE_CTX) callconv(.c) c_int;
pub const X509_STORE_CTX_get_crl_fn = ?*const fn (?*X509_STORE_CTX, [*c]?*X509_CRL, ?*X509) callconv(.c) c_int;
pub const X509_STORE_CTX_check_crl_fn = ?*const fn (?*X509_STORE_CTX, ?*X509_CRL) callconv(.c) c_int;
pub const X509_STORE_CTX_cert_crl_fn = ?*const fn (?*X509_STORE_CTX, ?*X509_CRL, ?*X509) callconv(.c) c_int;
pub const X509_STORE_CTX_check_policy_fn = ?*const fn (?*X509_STORE_CTX) callconv(.c) c_int;
pub const X509_STORE_CTX_lookup_certs_fn = ?*const fn (?*X509_STORE_CTX, ?*const X509_NAME) callconv(.c) ?*struct_stack_st_X509;
pub const X509_STORE_CTX_lookup_crls_fn = ?*const fn (?*const X509_STORE_CTX, ?*const X509_NAME) callconv(.c) ?*struct_stack_st_X509_CRL;
pub const X509_STORE_CTX_cleanup_fn = ?*const fn (?*X509_STORE_CTX) callconv(.c) c_int;
pub extern fn X509_STORE_CTX_set_depth(ctx: ?*X509_STORE_CTX, depth: c_int) void;
pub extern fn X509_OBJECT_idx_by_subject(h: ?*struct_stack_st_X509_OBJECT, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME) c_int;
pub extern fn X509_OBJECT_retrieve_by_subject(h: ?*struct_stack_st_X509_OBJECT, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME) ?*X509_OBJECT;
pub extern fn X509_OBJECT_retrieve_match(h: ?*struct_stack_st_X509_OBJECT, x: ?*X509_OBJECT) ?*X509_OBJECT;
pub extern fn X509_OBJECT_up_ref_count(a: ?*X509_OBJECT) c_int;
pub extern fn X509_OBJECT_new() ?*X509_OBJECT;
pub extern fn X509_OBJECT_free(a: ?*X509_OBJECT) void;
pub extern fn X509_OBJECT_get_type(a: ?*const X509_OBJECT) X509_LOOKUP_TYPE;
pub extern fn X509_OBJECT_get0_X509(a: ?*const X509_OBJECT) ?*X509;
pub extern fn X509_OBJECT_set1_X509(a: ?*X509_OBJECT, obj: ?*X509) c_int;
pub extern fn X509_OBJECT_get0_X509_CRL(a: ?*const X509_OBJECT) ?*X509_CRL;
pub extern fn X509_OBJECT_set1_X509_CRL(a: ?*X509_OBJECT, obj: ?*X509_CRL) c_int;
pub extern fn X509_STORE_new() ?*X509_STORE;
pub extern fn X509_STORE_free(xs: ?*X509_STORE) void;
pub extern fn X509_STORE_lock(xs: ?*X509_STORE) c_int;
pub extern fn X509_STORE_unlock(xs: ?*X509_STORE) c_int;
pub extern fn X509_STORE_up_ref(xs: ?*X509_STORE) c_int;
pub extern fn X509_STORE_get0_objects(xs: ?*const X509_STORE) ?*struct_stack_st_X509_OBJECT;
pub extern fn X509_STORE_get1_objects(xs: ?*X509_STORE) ?*struct_stack_st_X509_OBJECT;
pub extern fn X509_STORE_get1_all_certs(xs: ?*X509_STORE) ?*struct_stack_st_X509;
pub extern fn X509_STORE_CTX_get1_certs(xs: ?*X509_STORE_CTX, nm: ?*const X509_NAME) ?*struct_stack_st_X509;
pub extern fn X509_STORE_CTX_get1_crls(st: ?*const X509_STORE_CTX, nm: ?*const X509_NAME) ?*struct_stack_st_X509_CRL;
pub extern fn X509_STORE_set_flags(xs: ?*X509_STORE, flags: c_ulong) c_int;
pub extern fn X509_STORE_set_purpose(xs: ?*X509_STORE, purpose: c_int) c_int;
pub extern fn X509_STORE_set_trust(xs: ?*X509_STORE, trust: c_int) c_int;
pub extern fn X509_STORE_set1_param(xs: ?*X509_STORE, pm: ?*const X509_VERIFY_PARAM) c_int;
pub extern fn X509_STORE_get0_param(xs: ?*const X509_STORE) ?*X509_VERIFY_PARAM;
pub extern fn X509_STORE_set_verify(xs: ?*X509_STORE, verify: X509_STORE_CTX_verify_fn) void;
pub extern fn X509_STORE_CTX_set_verify(ctx: ?*X509_STORE_CTX, verify: X509_STORE_CTX_verify_fn) void;
pub extern fn X509_STORE_get_verify(xs: ?*const X509_STORE) X509_STORE_CTX_verify_fn;
pub extern fn X509_STORE_set_verify_cb(xs: ?*X509_STORE, verify_cb: X509_STORE_CTX_verify_cb) void;
pub extern fn X509_STORE_get_verify_cb(xs: ?*const X509_STORE) X509_STORE_CTX_verify_cb;
pub extern fn X509_STORE_set_get_issuer(xs: ?*X509_STORE, get_issuer: X509_STORE_CTX_get_issuer_fn) void;
pub extern fn X509_STORE_get_get_issuer(xs: ?*const X509_STORE) X509_STORE_CTX_get_issuer_fn;
pub extern fn X509_STORE_set_check_issued(xs: ?*X509_STORE, check_issued: X509_STORE_CTX_check_issued_fn) void;
pub extern fn X509_STORE_get_check_issued(s: ?*const X509_STORE) X509_STORE_CTX_check_issued_fn;
pub extern fn X509_STORE_set_check_revocation(xs: ?*X509_STORE, check_revocation: X509_STORE_CTX_check_revocation_fn) void;
pub extern fn X509_STORE_get_check_revocation(xs: ?*const X509_STORE) X509_STORE_CTX_check_revocation_fn;
pub extern fn X509_STORE_set_get_crl(xs: ?*X509_STORE, get_crl: X509_STORE_CTX_get_crl_fn) void;
pub extern fn X509_STORE_get_get_crl(xs: ?*const X509_STORE) X509_STORE_CTX_get_crl_fn;
pub extern fn X509_STORE_set_check_crl(xs: ?*X509_STORE, check_crl: X509_STORE_CTX_check_crl_fn) void;
pub extern fn X509_STORE_get_check_crl(xs: ?*const X509_STORE) X509_STORE_CTX_check_crl_fn;
pub extern fn X509_STORE_set_cert_crl(xs: ?*X509_STORE, cert_crl: X509_STORE_CTX_cert_crl_fn) void;
pub extern fn X509_STORE_get_cert_crl(xs: ?*const X509_STORE) X509_STORE_CTX_cert_crl_fn;
pub extern fn X509_STORE_set_check_policy(xs: ?*X509_STORE, check_policy: X509_STORE_CTX_check_policy_fn) void;
pub extern fn X509_STORE_get_check_policy(s: ?*const X509_STORE) X509_STORE_CTX_check_policy_fn;
pub extern fn X509_STORE_set_lookup_certs(xs: ?*X509_STORE, lookup_certs: X509_STORE_CTX_lookup_certs_fn) void;
pub extern fn X509_STORE_get_lookup_certs(s: ?*const X509_STORE) X509_STORE_CTX_lookup_certs_fn;
pub extern fn X509_STORE_set_lookup_crls(xs: ?*X509_STORE, lookup_crls: X509_STORE_CTX_lookup_crls_fn) void;
pub extern fn X509_STORE_get_lookup_crls(xs: ?*const X509_STORE) X509_STORE_CTX_lookup_crls_fn;
pub extern fn X509_STORE_set_cleanup(xs: ?*X509_STORE, cleanup: X509_STORE_CTX_cleanup_fn) void;
pub extern fn X509_STORE_get_cleanup(xs: ?*const X509_STORE) X509_STORE_CTX_cleanup_fn;
pub extern fn X509_STORE_set_ex_data(xs: ?*X509_STORE, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn X509_STORE_get_ex_data(xs: ?*const X509_STORE, idx: c_int) ?*anyopaque;
pub extern fn X509_STORE_CTX_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*X509_STORE_CTX;
pub extern fn X509_STORE_CTX_new() ?*X509_STORE_CTX;
pub extern fn X509_STORE_CTX_get1_issuer(issuer: [*c]?*X509, ctx: ?*X509_STORE_CTX, x: ?*X509) c_int;
pub extern fn X509_STORE_CTX_free(ctx: ?*X509_STORE_CTX) void;
pub extern fn X509_STORE_CTX_init(ctx: ?*X509_STORE_CTX, trust_store: ?*X509_STORE, target: ?*X509, untrusted: ?*struct_stack_st_X509) c_int;
pub extern fn X509_STORE_CTX_init_rpk(ctx: ?*X509_STORE_CTX, trust_store: ?*X509_STORE, rpk: ?*EVP_PKEY) c_int;
pub extern fn X509_STORE_CTX_set0_trusted_stack(ctx: ?*X509_STORE_CTX, sk: ?*struct_stack_st_X509) void;
pub extern fn X509_STORE_CTX_cleanup(ctx: ?*X509_STORE_CTX) void;
pub extern fn X509_STORE_CTX_get0_store(ctx: ?*const X509_STORE_CTX) ?*X509_STORE;
pub extern fn X509_STORE_CTX_get0_cert(ctx: ?*const X509_STORE_CTX) ?*X509;
pub extern fn X509_STORE_CTX_get0_rpk(ctx: ?*const X509_STORE_CTX) ?*EVP_PKEY;
pub extern fn X509_STORE_CTX_get0_untrusted(ctx: ?*const X509_STORE_CTX) ?*struct_stack_st_X509;
pub extern fn X509_STORE_CTX_set0_untrusted(ctx: ?*X509_STORE_CTX, sk: ?*struct_stack_st_X509) void;
pub extern fn X509_STORE_CTX_set_verify_cb(ctx: ?*X509_STORE_CTX, verify: X509_STORE_CTX_verify_cb) void;
pub extern fn X509_STORE_CTX_get_verify_cb(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_verify_cb;
pub extern fn X509_STORE_CTX_get_verify(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_verify_fn;
pub extern fn X509_STORE_CTX_get_get_issuer(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_get_issuer_fn;
pub extern fn X509_STORE_CTX_get_check_issued(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_check_issued_fn;
pub extern fn X509_STORE_CTX_get_check_revocation(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_check_revocation_fn;
pub extern fn X509_STORE_CTX_set_get_crl(ctx: ?*X509_STORE_CTX, get_crl: X509_STORE_CTX_get_crl_fn) void;
pub extern fn X509_STORE_CTX_get_get_crl(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_get_crl_fn;
pub extern fn X509_STORE_CTX_get_check_crl(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_check_crl_fn;
pub extern fn X509_STORE_CTX_get_cert_crl(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_cert_crl_fn;
pub extern fn X509_STORE_CTX_get_check_policy(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_check_policy_fn;
pub extern fn X509_STORE_CTX_get_lookup_certs(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_lookup_certs_fn;
pub extern fn X509_STORE_CTX_get_lookup_crls(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_lookup_crls_fn;
pub extern fn X509_STORE_CTX_get_cleanup(ctx: ?*const X509_STORE_CTX) X509_STORE_CTX_cleanup_fn;
pub extern fn X509_STORE_add_lookup(xs: ?*X509_STORE, m: ?*X509_LOOKUP_METHOD) ?*X509_LOOKUP;
pub extern fn X509_LOOKUP_hash_dir() ?*X509_LOOKUP_METHOD;
pub extern fn X509_LOOKUP_file() ?*X509_LOOKUP_METHOD;
pub extern fn X509_LOOKUP_store() ?*X509_LOOKUP_METHOD;
pub const X509_LOOKUP_ctrl_fn = ?*const fn (?*X509_LOOKUP, c_int, [*c]const u8, c_long, [*c][*c]u8) callconv(.c) c_int;
pub const X509_LOOKUP_ctrl_ex_fn = ?*const fn (?*X509_LOOKUP, c_int, [*c]const u8, c_long, [*c][*c]u8, ?*OSSL_LIB_CTX, [*c]const u8) callconv(.c) c_int;
pub const X509_LOOKUP_get_by_subject_fn = ?*const fn (?*X509_LOOKUP, X509_LOOKUP_TYPE, ?*const X509_NAME, ?*X509_OBJECT) callconv(.c) c_int;
pub const X509_LOOKUP_get_by_subject_ex_fn = ?*const fn (?*X509_LOOKUP, X509_LOOKUP_TYPE, ?*const X509_NAME, ?*X509_OBJECT, ?*OSSL_LIB_CTX, [*c]const u8) callconv(.c) c_int;
pub const X509_LOOKUP_get_by_issuer_serial_fn = ?*const fn (?*X509_LOOKUP, X509_LOOKUP_TYPE, ?*const X509_NAME, [*c]const ASN1_INTEGER, ?*X509_OBJECT) callconv(.c) c_int;
pub const X509_LOOKUP_get_by_fingerprint_fn = ?*const fn (?*X509_LOOKUP, X509_LOOKUP_TYPE, [*c]const u8, c_int, ?*X509_OBJECT) callconv(.c) c_int;
pub const X509_LOOKUP_get_by_alias_fn = ?*const fn (?*X509_LOOKUP, X509_LOOKUP_TYPE, [*c]const u8, c_int, ?*X509_OBJECT) callconv(.c) c_int;
pub extern fn X509_LOOKUP_meth_new(name: [*c]const u8) ?*X509_LOOKUP_METHOD;
pub extern fn X509_LOOKUP_meth_free(method: ?*X509_LOOKUP_METHOD) void;
pub extern fn X509_LOOKUP_meth_set_new_item(method: ?*X509_LOOKUP_METHOD, new_item: ?*const fn (?*X509_LOOKUP) callconv(.c) c_int) c_int;
pub extern fn X509_LOOKUP_meth_get_new_item(method: ?*const X509_LOOKUP_METHOD) ?*const fn (?*X509_LOOKUP) callconv(.c) c_int;
pub extern fn X509_LOOKUP_meth_set_free(method: ?*X509_LOOKUP_METHOD, free_fn: ?*const fn (?*X509_LOOKUP) callconv(.c) void) c_int;
pub extern fn X509_LOOKUP_meth_get_free(method: ?*const X509_LOOKUP_METHOD) ?*const fn (?*X509_LOOKUP) callconv(.c) void;
pub extern fn X509_LOOKUP_meth_set_init(method: ?*X509_LOOKUP_METHOD, init: ?*const fn (?*X509_LOOKUP) callconv(.c) c_int) c_int;
pub extern fn X509_LOOKUP_meth_get_init(method: ?*const X509_LOOKUP_METHOD) ?*const fn (?*X509_LOOKUP) callconv(.c) c_int;
pub extern fn X509_LOOKUP_meth_set_shutdown(method: ?*X509_LOOKUP_METHOD, shutdown: ?*const fn (?*X509_LOOKUP) callconv(.c) c_int) c_int;
pub extern fn X509_LOOKUP_meth_get_shutdown(method: ?*const X509_LOOKUP_METHOD) ?*const fn (?*X509_LOOKUP) callconv(.c) c_int;
pub extern fn X509_LOOKUP_meth_set_ctrl(method: ?*X509_LOOKUP_METHOD, ctrl_fn: X509_LOOKUP_ctrl_fn) c_int;
pub extern fn X509_LOOKUP_meth_get_ctrl(method: ?*const X509_LOOKUP_METHOD) X509_LOOKUP_ctrl_fn;
pub extern fn X509_LOOKUP_meth_set_get_by_subject(method: ?*X509_LOOKUP_METHOD, @"fn": X509_LOOKUP_get_by_subject_fn) c_int;
pub extern fn X509_LOOKUP_meth_get_get_by_subject(method: ?*const X509_LOOKUP_METHOD) X509_LOOKUP_get_by_subject_fn;
pub extern fn X509_LOOKUP_meth_set_get_by_issuer_serial(method: ?*X509_LOOKUP_METHOD, @"fn": X509_LOOKUP_get_by_issuer_serial_fn) c_int;
pub extern fn X509_LOOKUP_meth_get_get_by_issuer_serial(method: ?*const X509_LOOKUP_METHOD) X509_LOOKUP_get_by_issuer_serial_fn;
pub extern fn X509_LOOKUP_meth_set_get_by_fingerprint(method: ?*X509_LOOKUP_METHOD, @"fn": X509_LOOKUP_get_by_fingerprint_fn) c_int;
pub extern fn X509_LOOKUP_meth_get_get_by_fingerprint(method: ?*const X509_LOOKUP_METHOD) X509_LOOKUP_get_by_fingerprint_fn;
pub extern fn X509_LOOKUP_meth_set_get_by_alias(method: ?*X509_LOOKUP_METHOD, @"fn": X509_LOOKUP_get_by_alias_fn) c_int;
pub extern fn X509_LOOKUP_meth_get_get_by_alias(method: ?*const X509_LOOKUP_METHOD) X509_LOOKUP_get_by_alias_fn;
pub extern fn X509_STORE_add_cert(xs: ?*X509_STORE, x: ?*X509) c_int;
pub extern fn X509_STORE_add_crl(xs: ?*X509_STORE, x: ?*X509_CRL) c_int;
pub extern fn X509_STORE_CTX_get_by_subject(vs: ?*const X509_STORE_CTX, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME, ret: ?*X509_OBJECT) c_int;
pub extern fn X509_STORE_CTX_get_obj_by_subject(vs: ?*X509_STORE_CTX, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME) ?*X509_OBJECT;
pub extern fn X509_LOOKUP_ctrl(ctx: ?*X509_LOOKUP, cmd: c_int, argc: [*c]const u8, argl: c_long, ret: [*c][*c]u8) c_int;
pub extern fn X509_LOOKUP_ctrl_ex(ctx: ?*X509_LOOKUP, cmd: c_int, argc: [*c]const u8, argl: c_long, ret: [*c][*c]u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_load_cert_file(ctx: ?*X509_LOOKUP, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn X509_load_cert_file_ex(ctx: ?*X509_LOOKUP, file: [*c]const u8, @"type": c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_load_crl_file(ctx: ?*X509_LOOKUP, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn X509_load_cert_crl_file(ctx: ?*X509_LOOKUP, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn X509_load_cert_crl_file_ex(ctx: ?*X509_LOOKUP, file: [*c]const u8, @"type": c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_LOOKUP_new(method: ?*X509_LOOKUP_METHOD) ?*X509_LOOKUP;
pub extern fn X509_LOOKUP_free(ctx: ?*X509_LOOKUP) void;
pub extern fn X509_LOOKUP_init(ctx: ?*X509_LOOKUP) c_int;
pub extern fn X509_LOOKUP_by_subject(ctx: ?*X509_LOOKUP, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME, ret: ?*X509_OBJECT) c_int;
pub extern fn X509_LOOKUP_by_subject_ex(ctx: ?*X509_LOOKUP, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME, ret: ?*X509_OBJECT, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_LOOKUP_by_issuer_serial(ctx: ?*X509_LOOKUP, @"type": X509_LOOKUP_TYPE, name: ?*const X509_NAME, serial: [*c]const ASN1_INTEGER, ret: ?*X509_OBJECT) c_int;
pub extern fn X509_LOOKUP_by_fingerprint(ctx: ?*X509_LOOKUP, @"type": X509_LOOKUP_TYPE, bytes: [*c]const u8, len: c_int, ret: ?*X509_OBJECT) c_int;
pub extern fn X509_LOOKUP_by_alias(ctx: ?*X509_LOOKUP, @"type": X509_LOOKUP_TYPE, str: [*c]const u8, len: c_int, ret: ?*X509_OBJECT) c_int;
pub extern fn X509_LOOKUP_set_method_data(ctx: ?*X509_LOOKUP, data: ?*anyopaque) c_int;
pub extern fn X509_LOOKUP_get_method_data(ctx: ?*const X509_LOOKUP) ?*anyopaque;
pub extern fn X509_LOOKUP_get_store(ctx: ?*const X509_LOOKUP) ?*X509_STORE;
pub extern fn X509_LOOKUP_shutdown(ctx: ?*X509_LOOKUP) c_int;
pub extern fn X509_STORE_load_file(xs: ?*X509_STORE, file: [*c]const u8) c_int;
pub extern fn X509_STORE_load_path(xs: ?*X509_STORE, path: [*c]const u8) c_int;
pub extern fn X509_STORE_load_store(xs: ?*X509_STORE, store: [*c]const u8) c_int;
pub extern fn X509_STORE_load_locations(s: ?*X509_STORE, file: [*c]const u8, dir: [*c]const u8) c_int;
pub extern fn X509_STORE_set_default_paths(xs: ?*X509_STORE) c_int;
pub extern fn X509_STORE_load_file_ex(xs: ?*X509_STORE, file: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_STORE_load_store_ex(xs: ?*X509_STORE, store: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_STORE_load_locations_ex(xs: ?*X509_STORE, file: [*c]const u8, dir: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_STORE_set_default_paths_ex(xs: ?*X509_STORE, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_STORE_CTX_set_ex_data(ctx: ?*X509_STORE_CTX, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn X509_STORE_CTX_get_ex_data(ctx: ?*const X509_STORE_CTX, idx: c_int) ?*anyopaque;
pub extern fn X509_STORE_CTX_get_error(ctx: ?*const X509_STORE_CTX) c_int;
pub extern fn X509_STORE_CTX_set_error(ctx: ?*X509_STORE_CTX, s: c_int) void;
pub extern fn X509_STORE_CTX_get_error_depth(ctx: ?*const X509_STORE_CTX) c_int;
pub extern fn X509_STORE_CTX_set_error_depth(ctx: ?*X509_STORE_CTX, depth: c_int) void;
pub extern fn X509_STORE_CTX_get_current_cert(ctx: ?*const X509_STORE_CTX) ?*X509;
pub extern fn X509_STORE_CTX_set_current_cert(ctx: ?*X509_STORE_CTX, x: ?*X509) void;
pub extern fn X509_STORE_CTX_get0_current_issuer(ctx: ?*const X509_STORE_CTX) ?*X509;
pub extern fn X509_STORE_CTX_get0_current_crl(ctx: ?*const X509_STORE_CTX) ?*X509_CRL;
pub extern fn X509_STORE_CTX_get0_parent_ctx(ctx: ?*const X509_STORE_CTX) ?*X509_STORE_CTX;
pub extern fn X509_STORE_CTX_get0_chain(ctx: ?*const X509_STORE_CTX) ?*struct_stack_st_X509;
pub extern fn X509_STORE_CTX_get1_chain(ctx: ?*const X509_STORE_CTX) ?*struct_stack_st_X509;
pub extern fn X509_STORE_CTX_set_cert(ctx: ?*X509_STORE_CTX, target: ?*X509) void;
pub extern fn X509_STORE_CTX_set0_rpk(ctx: ?*X509_STORE_CTX, target: ?*EVP_PKEY) void;
pub extern fn X509_STORE_CTX_set0_verified_chain(c: ?*X509_STORE_CTX, sk: ?*struct_stack_st_X509) void;
pub extern fn X509_STORE_CTX_set0_crls(ctx: ?*X509_STORE_CTX, sk: ?*struct_stack_st_X509_CRL) void;
pub extern fn X509_STORE_CTX_set_purpose(ctx: ?*X509_STORE_CTX, purpose: c_int) c_int;
pub extern fn X509_STORE_CTX_set_trust(ctx: ?*X509_STORE_CTX, trust: c_int) c_int;
pub extern fn X509_STORE_CTX_purpose_inherit(ctx: ?*X509_STORE_CTX, def_purpose: c_int, purpose: c_int, trust: c_int) c_int;
pub extern fn X509_STORE_CTX_set_flags(ctx: ?*X509_STORE_CTX, flags: c_ulong) void;
pub extern fn X509_STORE_CTX_set_time(ctx: ?*X509_STORE_CTX, flags: c_ulong, t: time_t) void;
pub extern fn X509_STORE_CTX_set_current_reasons(ctx: ?*X509_STORE_CTX, current_reasons: c_uint) void;
pub extern fn X509_STORE_CTX_get0_policy_tree(ctx: ?*const X509_STORE_CTX) ?*X509_POLICY_TREE;
pub extern fn X509_STORE_CTX_get_explicit_policy(ctx: ?*const X509_STORE_CTX) c_int;
pub extern fn X509_STORE_CTX_get_num_untrusted(ctx: ?*const X509_STORE_CTX) c_int;
pub extern fn X509_STORE_CTX_get0_param(ctx: ?*const X509_STORE_CTX) ?*X509_VERIFY_PARAM;
pub extern fn X509_STORE_CTX_set0_param(ctx: ?*X509_STORE_CTX, param: ?*X509_VERIFY_PARAM) void;
pub extern fn X509_STORE_CTX_set_default(ctx: ?*X509_STORE_CTX, name: [*c]const u8) c_int;
pub extern fn X509_STORE_CTX_set0_dane(ctx: ?*X509_STORE_CTX, dane: ?*SSL_DANE) void;
pub extern fn X509_VERIFY_PARAM_new() ?*X509_VERIFY_PARAM;
pub extern fn X509_VERIFY_PARAM_free(param: ?*X509_VERIFY_PARAM) void;
pub extern fn X509_VERIFY_PARAM_inherit(to: ?*X509_VERIFY_PARAM, from: ?*const X509_VERIFY_PARAM) c_int;
pub extern fn X509_VERIFY_PARAM_set1(to: ?*X509_VERIFY_PARAM, from: ?*const X509_VERIFY_PARAM) c_int;
pub extern fn X509_VERIFY_PARAM_set1_name(param: ?*X509_VERIFY_PARAM, name: [*c]const u8) c_int;
pub extern fn X509_VERIFY_PARAM_set_flags(param: ?*X509_VERIFY_PARAM, flags: c_ulong) c_int;
pub extern fn X509_VERIFY_PARAM_clear_flags(param: ?*X509_VERIFY_PARAM, flags: c_ulong) c_int;
pub extern fn X509_VERIFY_PARAM_get_flags(param: ?*const X509_VERIFY_PARAM) c_ulong;
pub extern fn X509_VERIFY_PARAM_set_purpose(param: ?*X509_VERIFY_PARAM, purpose: c_int) c_int;
pub extern fn X509_VERIFY_PARAM_set_trust(param: ?*X509_VERIFY_PARAM, trust: c_int) c_int;
pub extern fn X509_VERIFY_PARAM_set_depth(param: ?*X509_VERIFY_PARAM, depth: c_int) void;
pub extern fn X509_VERIFY_PARAM_set_auth_level(param: ?*X509_VERIFY_PARAM, auth_level: c_int) void;
pub extern fn X509_VERIFY_PARAM_get_time(param: ?*const X509_VERIFY_PARAM) time_t;
pub extern fn X509_VERIFY_PARAM_set_time(param: ?*X509_VERIFY_PARAM, t: time_t) void;
pub extern fn X509_VERIFY_PARAM_add0_policy(param: ?*X509_VERIFY_PARAM, policy: ?*ASN1_OBJECT) c_int;
pub extern fn X509_VERIFY_PARAM_set1_policies(param: ?*X509_VERIFY_PARAM, policies: ?*struct_stack_st_ASN1_OBJECT) c_int;
pub extern fn X509_VERIFY_PARAM_set_inh_flags(param: ?*X509_VERIFY_PARAM, flags: u32) c_int;
pub extern fn X509_VERIFY_PARAM_get_inh_flags(param: ?*const X509_VERIFY_PARAM) u32;
pub extern fn X509_VERIFY_PARAM_get0_host(param: ?*X509_VERIFY_PARAM, idx: c_int) [*c]u8;
pub extern fn X509_VERIFY_PARAM_set1_host(param: ?*X509_VERIFY_PARAM, name: [*c]const u8, namelen: usize) c_int;
pub extern fn X509_VERIFY_PARAM_add1_host(param: ?*X509_VERIFY_PARAM, name: [*c]const u8, namelen: usize) c_int;
pub extern fn X509_VERIFY_PARAM_set_hostflags(param: ?*X509_VERIFY_PARAM, flags: c_uint) void;
pub extern fn X509_VERIFY_PARAM_get_hostflags(param: ?*const X509_VERIFY_PARAM) c_uint;
pub extern fn X509_VERIFY_PARAM_get0_peername(param: ?*const X509_VERIFY_PARAM) [*c]u8;
pub extern fn X509_VERIFY_PARAM_move_peername(?*X509_VERIFY_PARAM, ?*X509_VERIFY_PARAM) void;
pub extern fn X509_VERIFY_PARAM_get0_email(param: ?*X509_VERIFY_PARAM) [*c]u8;
pub extern fn X509_VERIFY_PARAM_set1_email(param: ?*X509_VERIFY_PARAM, email: [*c]const u8, emaillen: usize) c_int;
pub extern fn X509_VERIFY_PARAM_get1_ip_asc(param: ?*X509_VERIFY_PARAM) [*c]u8;
pub extern fn X509_VERIFY_PARAM_set1_ip(param: ?*X509_VERIFY_PARAM, ip: [*c]const u8, iplen: usize) c_int;
pub extern fn X509_VERIFY_PARAM_set1_ip_asc(param: ?*X509_VERIFY_PARAM, ipasc: [*c]const u8) c_int;
pub extern fn X509_VERIFY_PARAM_get_depth(param: ?*const X509_VERIFY_PARAM) c_int;
pub extern fn X509_VERIFY_PARAM_get_auth_level(param: ?*const X509_VERIFY_PARAM) c_int;
pub extern fn X509_VERIFY_PARAM_get0_name(param: ?*const X509_VERIFY_PARAM) [*c]const u8;
pub extern fn X509_VERIFY_PARAM_add0_table(param: ?*X509_VERIFY_PARAM) c_int;
pub extern fn X509_VERIFY_PARAM_get_count() c_int;
pub extern fn X509_VERIFY_PARAM_get0(id: c_int) ?*const X509_VERIFY_PARAM;
pub extern fn X509_VERIFY_PARAM_lookup(name: [*c]const u8) ?*const X509_VERIFY_PARAM;
pub extern fn X509_VERIFY_PARAM_table_cleanup() void;
pub extern fn X509_policy_check(ptree: [*c]?*X509_POLICY_TREE, pexplicit_policy: [*c]c_int, certs: ?*struct_stack_st_X509, policy_oids: ?*struct_stack_st_ASN1_OBJECT, flags: c_uint) c_int;
pub extern fn X509_policy_tree_free(tree: ?*X509_POLICY_TREE) void;
pub extern fn X509_policy_tree_level_count(tree: ?*const X509_POLICY_TREE) c_int;
pub extern fn X509_policy_tree_get0_level(tree: ?*const X509_POLICY_TREE, i: c_int) ?*X509_POLICY_LEVEL;
pub const struct_stack_st_X509_POLICY_NODE = opaque {};
pub extern fn X509_policy_tree_get0_policies(tree: ?*const X509_POLICY_TREE) ?*struct_stack_st_X509_POLICY_NODE;
pub extern fn X509_policy_tree_get0_user_policies(tree: ?*const X509_POLICY_TREE) ?*struct_stack_st_X509_POLICY_NODE;
pub extern fn X509_policy_level_node_count(level: ?*X509_POLICY_LEVEL) c_int;
pub extern fn X509_policy_level_get0_node(level: ?*const X509_POLICY_LEVEL, i: c_int) ?*X509_POLICY_NODE;
pub extern fn X509_policy_node_get0_policy(node: ?*const X509_POLICY_NODE) ?*const ASN1_OBJECT;
pub const struct_stack_st_POLICYQUALINFO = opaque {};
pub extern fn X509_policy_node_get0_qualifiers(node: ?*const X509_POLICY_NODE) ?*struct_stack_st_POLICYQUALINFO;
pub extern fn X509_policy_node_get0_parent(node: ?*const X509_POLICY_NODE) ?*const X509_POLICY_NODE;
pub const struct_PKCS7_CTX_st = extern struct {
    libctx: ?*OSSL_LIB_CTX = @import("std").mem.zeroes(?*OSSL_LIB_CTX),
    propq: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const PKCS7_CTX = struct_PKCS7_CTX_st;
pub const struct_pkcs7_issuer_and_serial_st = extern struct {
    issuer: ?*X509_NAME = @import("std").mem.zeroes(?*X509_NAME),
    serial: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const PKCS7_ISSUER_AND_SERIAL = struct_pkcs7_issuer_and_serial_st;
pub const struct_pkcs7_signer_info_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    issuer_and_serial: [*c]PKCS7_ISSUER_AND_SERIAL = @import("std").mem.zeroes([*c]PKCS7_ISSUER_AND_SERIAL),
    digest_alg: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    auth_attr: ?*struct_stack_st_X509_ATTRIBUTE = @import("std").mem.zeroes(?*struct_stack_st_X509_ATTRIBUTE),
    digest_enc_alg: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    enc_digest: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    unauth_attr: ?*struct_stack_st_X509_ATTRIBUTE = @import("std").mem.zeroes(?*struct_stack_st_X509_ATTRIBUTE),
    pkey: ?*EVP_PKEY = @import("std").mem.zeroes(?*EVP_PKEY),
    ctx: [*c]const PKCS7_CTX = @import("std").mem.zeroes([*c]const PKCS7_CTX),
};
pub const PKCS7_SIGNER_INFO = struct_pkcs7_signer_info_st;
pub const struct_stack_st_PKCS7_SIGNER_INFO = opaque {};
pub const sk_PKCS7_SIGNER_INFO_compfunc = ?*const fn ([*c]const [*c]const PKCS7_SIGNER_INFO, [*c]const [*c]const PKCS7_SIGNER_INFO) callconv(.c) c_int;
pub const sk_PKCS7_SIGNER_INFO_freefunc = ?*const fn ([*c]PKCS7_SIGNER_INFO) callconv(.c) void;
pub const sk_PKCS7_SIGNER_INFO_copyfunc = ?*const fn ([*c]const PKCS7_SIGNER_INFO) callconv(.c) [*c]PKCS7_SIGNER_INFO;
pub fn ossl_check_PKCS7_SIGNER_INFO_type(arg_ptr: [*c]PKCS7_SIGNER_INFO) callconv(.c) [*c]PKCS7_SIGNER_INFO {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_PKCS7_SIGNER_INFO_sk_type(arg_sk: ?*const struct_stack_st_PKCS7_SIGNER_INFO) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_SIGNER_INFO_sk_type(arg_sk: ?*struct_stack_st_PKCS7_SIGNER_INFO) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_SIGNER_INFO_compfunc_type(arg_cmp: sk_PKCS7_SIGNER_INFO_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_PKCS7_SIGNER_INFO_copyfunc_type(arg_cpy: sk_PKCS7_SIGNER_INFO_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_PKCS7_SIGNER_INFO_freefunc_type(arg_fr: sk_PKCS7_SIGNER_INFO_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_pkcs7_recip_info_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    issuer_and_serial: [*c]PKCS7_ISSUER_AND_SERIAL = @import("std").mem.zeroes([*c]PKCS7_ISSUER_AND_SERIAL),
    key_enc_algor: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    enc_key: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    cert: ?*X509 = @import("std").mem.zeroes(?*X509),
    ctx: [*c]const PKCS7_CTX = @import("std").mem.zeroes([*c]const PKCS7_CTX),
};
pub const PKCS7_RECIP_INFO = struct_pkcs7_recip_info_st;
pub const struct_stack_st_PKCS7_RECIP_INFO = opaque {};
pub const sk_PKCS7_RECIP_INFO_compfunc = ?*const fn ([*c]const [*c]const PKCS7_RECIP_INFO, [*c]const [*c]const PKCS7_RECIP_INFO) callconv(.c) c_int;
pub const sk_PKCS7_RECIP_INFO_freefunc = ?*const fn ([*c]PKCS7_RECIP_INFO) callconv(.c) void;
pub const sk_PKCS7_RECIP_INFO_copyfunc = ?*const fn ([*c]const PKCS7_RECIP_INFO) callconv(.c) [*c]PKCS7_RECIP_INFO;
pub fn ossl_check_PKCS7_RECIP_INFO_type(arg_ptr: [*c]PKCS7_RECIP_INFO) callconv(.c) [*c]PKCS7_RECIP_INFO {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_PKCS7_RECIP_INFO_sk_type(arg_sk: ?*const struct_stack_st_PKCS7_RECIP_INFO) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_RECIP_INFO_sk_type(arg_sk: ?*struct_stack_st_PKCS7_RECIP_INFO) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_RECIP_INFO_compfunc_type(arg_cmp: sk_PKCS7_RECIP_INFO_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_PKCS7_RECIP_INFO_copyfunc_type(arg_cpy: sk_PKCS7_RECIP_INFO_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_PKCS7_RECIP_INFO_freefunc_type(arg_fr: sk_PKCS7_RECIP_INFO_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const PKCS7_SIGNED = struct_pkcs7_signed_st;
pub const struct_pkcs7_enc_content_st = extern struct {
    content_type: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    algorithm: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    enc_data: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    cipher: ?*const EVP_CIPHER = @import("std").mem.zeroes(?*const EVP_CIPHER),
    ctx: [*c]const PKCS7_CTX = @import("std").mem.zeroes([*c]const PKCS7_CTX),
};
pub const PKCS7_ENC_CONTENT = struct_pkcs7_enc_content_st;
pub const struct_pkcs7_enveloped_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    recipientinfo: ?*struct_stack_st_PKCS7_RECIP_INFO = @import("std").mem.zeroes(?*struct_stack_st_PKCS7_RECIP_INFO),
    enc_data: [*c]PKCS7_ENC_CONTENT = @import("std").mem.zeroes([*c]PKCS7_ENC_CONTENT),
};
pub const PKCS7_ENVELOPE = struct_pkcs7_enveloped_st;
pub const struct_pkcs7_signedandenveloped_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    md_algs: ?*struct_stack_st_X509_ALGOR = @import("std").mem.zeroes(?*struct_stack_st_X509_ALGOR),
    cert: ?*struct_stack_st_X509 = @import("std").mem.zeroes(?*struct_stack_st_X509),
    crl: ?*struct_stack_st_X509_CRL = @import("std").mem.zeroes(?*struct_stack_st_X509_CRL),
    signer_info: ?*struct_stack_st_PKCS7_SIGNER_INFO = @import("std").mem.zeroes(?*struct_stack_st_PKCS7_SIGNER_INFO),
    enc_data: [*c]PKCS7_ENC_CONTENT = @import("std").mem.zeroes([*c]PKCS7_ENC_CONTENT),
    recipientinfo: ?*struct_stack_st_PKCS7_RECIP_INFO = @import("std").mem.zeroes(?*struct_stack_st_PKCS7_RECIP_INFO),
};
pub const PKCS7_SIGN_ENVELOPE = struct_pkcs7_signedandenveloped_st;
pub const struct_pkcs7_digest_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    md: [*c]X509_ALGOR = @import("std").mem.zeroes([*c]X509_ALGOR),
    contents: [*c]struct_pkcs7_st = @import("std").mem.zeroes([*c]struct_pkcs7_st),
    digest: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
};
pub const PKCS7_DIGEST = struct_pkcs7_digest_st;
pub const struct_pkcs7_encrypted_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    enc_data: [*c]PKCS7_ENC_CONTENT = @import("std").mem.zeroes([*c]PKCS7_ENC_CONTENT),
};
pub const PKCS7_ENCRYPT = struct_pkcs7_encrypted_st;
const union_unnamed_101 = extern union {
    ptr: [*c]u8,
    data: [*c]ASN1_OCTET_STRING,
    sign: [*c]PKCS7_SIGNED,
    enveloped: [*c]PKCS7_ENVELOPE,
    signed_and_enveloped: [*c]PKCS7_SIGN_ENVELOPE,
    digest: [*c]PKCS7_DIGEST,
    encrypted: [*c]PKCS7_ENCRYPT,
    other: [*c]ASN1_TYPE,
};
pub const struct_pkcs7_st = extern struct {
    asn1: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    length: c_long = @import("std").mem.zeroes(c_long),
    state: c_int = @import("std").mem.zeroes(c_int),
    detached: c_int = @import("std").mem.zeroes(c_int),
    type: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    d: union_unnamed_101 = @import("std").mem.zeroes(union_unnamed_101),
    ctx: PKCS7_CTX = @import("std").mem.zeroes(PKCS7_CTX),
};
pub const struct_pkcs7_signed_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    md_algs: ?*struct_stack_st_X509_ALGOR = @import("std").mem.zeroes(?*struct_stack_st_X509_ALGOR),
    cert: ?*struct_stack_st_X509 = @import("std").mem.zeroes(?*struct_stack_st_X509),
    crl: ?*struct_stack_st_X509_CRL = @import("std").mem.zeroes(?*struct_stack_st_X509_CRL),
    signer_info: ?*struct_stack_st_PKCS7_SIGNER_INFO = @import("std").mem.zeroes(?*struct_stack_st_PKCS7_SIGNER_INFO),
    contents: [*c]struct_pkcs7_st = @import("std").mem.zeroes([*c]struct_pkcs7_st),
};
pub const PKCS7 = struct_pkcs7_st;
pub const struct_stack_st_PKCS7 = opaque {};
pub const sk_PKCS7_compfunc = ?*const fn ([*c]const [*c]const PKCS7, [*c]const [*c]const PKCS7) callconv(.c) c_int;
pub const sk_PKCS7_freefunc = ?*const fn ([*c]PKCS7) callconv(.c) void;
pub const sk_PKCS7_copyfunc = ?*const fn ([*c]const PKCS7) callconv(.c) [*c]PKCS7;
pub fn ossl_check_PKCS7_type(arg_ptr: [*c]PKCS7) callconv(.c) [*c]PKCS7 {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_PKCS7_sk_type(arg_sk: ?*const struct_stack_st_PKCS7) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_sk_type(arg_sk: ?*struct_stack_st_PKCS7) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PKCS7_compfunc_type(arg_cmp: sk_PKCS7_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_PKCS7_copyfunc_type(arg_cpy: sk_PKCS7_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_PKCS7_freefunc_type(arg_fr: sk_PKCS7_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn PKCS7_ISSUER_AND_SERIAL_new() [*c]PKCS7_ISSUER_AND_SERIAL;
pub extern fn PKCS7_ISSUER_AND_SERIAL_free(a: [*c]PKCS7_ISSUER_AND_SERIAL) void;
pub extern fn d2i_PKCS7_ISSUER_AND_SERIAL(a: [*c][*c]PKCS7_ISSUER_AND_SERIAL, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_ISSUER_AND_SERIAL;
pub extern fn i2d_PKCS7_ISSUER_AND_SERIAL(a: [*c]const PKCS7_ISSUER_AND_SERIAL, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_ISSUER_AND_SERIAL_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_ISSUER_AND_SERIAL_digest(data: [*c]PKCS7_ISSUER_AND_SERIAL, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn d2i_PKCS7_fp(fp: [*c]FILE, p7: [*c][*c]PKCS7) [*c]PKCS7;
pub extern fn i2d_PKCS7_fp(fp: [*c]FILE, p7: [*c]const PKCS7) c_int;
pub extern fn PKCS7_dup(a: [*c]const PKCS7) [*c]PKCS7;
pub extern fn d2i_PKCS7_bio(bp: ?*BIO, p7: [*c][*c]PKCS7) [*c]PKCS7;
pub extern fn i2d_PKCS7_bio(bp: ?*BIO, p7: [*c]const PKCS7) c_int;
pub extern fn i2d_PKCS7_bio_stream(out: ?*BIO, p7: [*c]PKCS7, in: ?*BIO, flags: c_int) c_int;
pub extern fn PEM_write_bio_PKCS7_stream(out: ?*BIO, p7: [*c]PKCS7, in: ?*BIO, flags: c_int) c_int;
pub extern fn PKCS7_SIGNER_INFO_new() [*c]PKCS7_SIGNER_INFO;
pub extern fn PKCS7_SIGNER_INFO_free(a: [*c]PKCS7_SIGNER_INFO) void;
pub extern fn d2i_PKCS7_SIGNER_INFO(a: [*c][*c]PKCS7_SIGNER_INFO, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_SIGNER_INFO;
pub extern fn i2d_PKCS7_SIGNER_INFO(a: [*c]const PKCS7_SIGNER_INFO, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_SIGNER_INFO_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_RECIP_INFO_new() [*c]PKCS7_RECIP_INFO;
pub extern fn PKCS7_RECIP_INFO_free(a: [*c]PKCS7_RECIP_INFO) void;
pub extern fn d2i_PKCS7_RECIP_INFO(a: [*c][*c]PKCS7_RECIP_INFO, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_RECIP_INFO;
pub extern fn i2d_PKCS7_RECIP_INFO(a: [*c]const PKCS7_RECIP_INFO, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_RECIP_INFO_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_SIGNED_new() [*c]PKCS7_SIGNED;
pub extern fn PKCS7_SIGNED_free(a: [*c]PKCS7_SIGNED) void;
pub extern fn d2i_PKCS7_SIGNED(a: [*c][*c]PKCS7_SIGNED, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_SIGNED;
pub extern fn i2d_PKCS7_SIGNED(a: [*c]const PKCS7_SIGNED, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_SIGNED_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_ENC_CONTENT_new() [*c]PKCS7_ENC_CONTENT;
pub extern fn PKCS7_ENC_CONTENT_free(a: [*c]PKCS7_ENC_CONTENT) void;
pub extern fn d2i_PKCS7_ENC_CONTENT(a: [*c][*c]PKCS7_ENC_CONTENT, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_ENC_CONTENT;
pub extern fn i2d_PKCS7_ENC_CONTENT(a: [*c]const PKCS7_ENC_CONTENT, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_ENC_CONTENT_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_ENVELOPE_new() [*c]PKCS7_ENVELOPE;
pub extern fn PKCS7_ENVELOPE_free(a: [*c]PKCS7_ENVELOPE) void;
pub extern fn d2i_PKCS7_ENVELOPE(a: [*c][*c]PKCS7_ENVELOPE, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_ENVELOPE;
pub extern fn i2d_PKCS7_ENVELOPE(a: [*c]const PKCS7_ENVELOPE, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_ENVELOPE_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_SIGN_ENVELOPE_new() [*c]PKCS7_SIGN_ENVELOPE;
pub extern fn PKCS7_SIGN_ENVELOPE_free(a: [*c]PKCS7_SIGN_ENVELOPE) void;
pub extern fn d2i_PKCS7_SIGN_ENVELOPE(a: [*c][*c]PKCS7_SIGN_ENVELOPE, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_SIGN_ENVELOPE;
pub extern fn i2d_PKCS7_SIGN_ENVELOPE(a: [*c]const PKCS7_SIGN_ENVELOPE, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_SIGN_ENVELOPE_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_DIGEST_new() [*c]PKCS7_DIGEST;
pub extern fn PKCS7_DIGEST_free(a: [*c]PKCS7_DIGEST) void;
pub extern fn d2i_PKCS7_DIGEST(a: [*c][*c]PKCS7_DIGEST, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_DIGEST;
pub extern fn i2d_PKCS7_DIGEST(a: [*c]const PKCS7_DIGEST, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_DIGEST_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_ENCRYPT_new() [*c]PKCS7_ENCRYPT;
pub extern fn PKCS7_ENCRYPT_free(a: [*c]PKCS7_ENCRYPT) void;
pub extern fn d2i_PKCS7_ENCRYPT(a: [*c][*c]PKCS7_ENCRYPT, in: [*c][*c]const u8, len: c_long) [*c]PKCS7_ENCRYPT;
pub extern fn i2d_PKCS7_ENCRYPT(a: [*c]const PKCS7_ENCRYPT, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_ENCRYPT_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_new() [*c]PKCS7;
pub extern fn PKCS7_free(a: [*c]PKCS7) void;
pub extern fn d2i_PKCS7(a: [*c][*c]PKCS7, in: [*c][*c]const u8, len: c_long) [*c]PKCS7;
pub extern fn i2d_PKCS7(a: [*c]const PKCS7, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) [*c]PKCS7;
pub extern fn PKCS7_ATTR_SIGN_it() ?*const ASN1_ITEM;
pub extern fn PKCS7_ATTR_VERIFY_it() ?*const ASN1_ITEM;
pub extern fn i2d_PKCS7_NDEF(a: [*c]const PKCS7, out: [*c][*c]u8) c_int;
pub extern fn PKCS7_print_ctx(out: ?*BIO, x: [*c]const PKCS7, indent: c_int, pctx: ?*const ASN1_PCTX) c_int;
pub extern fn PKCS7_ctrl(p7: [*c]PKCS7, cmd: c_int, larg: c_long, parg: [*c]u8) c_long;
pub extern fn PKCS7_type_is_other(p7: [*c]PKCS7) c_int;
pub extern fn PKCS7_set_type(p7: [*c]PKCS7, @"type": c_int) c_int;
pub extern fn PKCS7_set0_type_other(p7: [*c]PKCS7, @"type": c_int, other: [*c]ASN1_TYPE) c_int;
pub extern fn PKCS7_set_content(p7: [*c]PKCS7, p7_data: [*c]PKCS7) c_int;
pub extern fn PKCS7_SIGNER_INFO_set(p7i: [*c]PKCS7_SIGNER_INFO, x509: ?*X509, pkey: ?*EVP_PKEY, dgst: ?*const EVP_MD) c_int;
pub extern fn PKCS7_SIGNER_INFO_sign(si: [*c]PKCS7_SIGNER_INFO) c_int;
pub extern fn PKCS7_add_signer(p7: [*c]PKCS7, p7i: [*c]PKCS7_SIGNER_INFO) c_int;
pub extern fn PKCS7_add_certificate(p7: [*c]PKCS7, cert: ?*X509) c_int;
pub extern fn PKCS7_add_crl(p7: [*c]PKCS7, crl: ?*X509_CRL) c_int;
pub extern fn PKCS7_content_new(p7: [*c]PKCS7, nid: c_int) c_int;
pub extern fn PKCS7_dataVerify(cert_store: ?*X509_STORE, ctx: ?*X509_STORE_CTX, bio: ?*BIO, p7: [*c]PKCS7, si: [*c]PKCS7_SIGNER_INFO) c_int;
pub extern fn PKCS7_signatureVerify(bio: ?*BIO, p7: [*c]PKCS7, si: [*c]PKCS7_SIGNER_INFO, signer: ?*X509) c_int;
pub extern fn PKCS7_dataInit(p7: [*c]PKCS7, bio: ?*BIO) ?*BIO;
pub extern fn PKCS7_dataFinal(p7: [*c]PKCS7, bio: ?*BIO) c_int;
pub extern fn PKCS7_dataDecode(p7: [*c]PKCS7, pkey: ?*EVP_PKEY, in_bio: ?*BIO, pcert: ?*X509) ?*BIO;
pub extern fn PKCS7_add_signature(p7: [*c]PKCS7, x509: ?*X509, pkey: ?*EVP_PKEY, dgst: ?*const EVP_MD) [*c]PKCS7_SIGNER_INFO;
pub extern fn PKCS7_cert_from_signer_info(p7: [*c]PKCS7, si: [*c]PKCS7_SIGNER_INFO) ?*X509;
pub extern fn PKCS7_set_digest(p7: [*c]PKCS7, md: ?*const EVP_MD) c_int;
pub extern fn PKCS7_get_signer_info(p7: [*c]PKCS7) ?*struct_stack_st_PKCS7_SIGNER_INFO;
pub extern fn PKCS7_add_recipient(p7: [*c]PKCS7, x509: ?*X509) [*c]PKCS7_RECIP_INFO;
pub extern fn PKCS7_SIGNER_INFO_get0_algs(si: [*c]PKCS7_SIGNER_INFO, pk: [*c]?*EVP_PKEY, pdig: [*c][*c]X509_ALGOR, psig: [*c][*c]X509_ALGOR) void;
pub extern fn PKCS7_RECIP_INFO_get0_alg(ri: [*c]PKCS7_RECIP_INFO, penc: [*c][*c]X509_ALGOR) void;
pub extern fn PKCS7_add_recipient_info(p7: [*c]PKCS7, ri: [*c]PKCS7_RECIP_INFO) c_int;
pub extern fn PKCS7_RECIP_INFO_set(p7i: [*c]PKCS7_RECIP_INFO, x509: ?*X509) c_int;
pub extern fn PKCS7_set_cipher(p7: [*c]PKCS7, cipher: ?*const EVP_CIPHER) c_int;
pub extern fn PKCS7_stream(boundary: [*c][*c][*c]u8, p7: [*c]PKCS7) c_int;
pub extern fn PKCS7_get_issuer_and_serial(p7: [*c]PKCS7, idx: c_int) [*c]PKCS7_ISSUER_AND_SERIAL;
pub extern fn PKCS7_get_octet_string(p7: [*c]PKCS7) [*c]ASN1_OCTET_STRING;
pub extern fn PKCS7_digest_from_attributes(sk: ?*struct_stack_st_X509_ATTRIBUTE) [*c]ASN1_OCTET_STRING;
pub extern fn PKCS7_add_signed_attribute(p7si: [*c]PKCS7_SIGNER_INFO, nid: c_int, @"type": c_int, data: ?*anyopaque) c_int;
pub extern fn PKCS7_add_attribute(p7si: [*c]PKCS7_SIGNER_INFO, nid: c_int, atrtype: c_int, value: ?*anyopaque) c_int;
pub extern fn PKCS7_get_attribute(si: [*c]const PKCS7_SIGNER_INFO, nid: c_int) [*c]ASN1_TYPE;
pub extern fn PKCS7_get_signed_attribute(si: [*c]const PKCS7_SIGNER_INFO, nid: c_int) [*c]ASN1_TYPE;
pub extern fn PKCS7_set_signed_attributes(p7si: [*c]PKCS7_SIGNER_INFO, sk: ?*struct_stack_st_X509_ATTRIBUTE) c_int;
pub extern fn PKCS7_set_attributes(p7si: [*c]PKCS7_SIGNER_INFO, sk: ?*struct_stack_st_X509_ATTRIBUTE) c_int;
pub extern fn PKCS7_sign(signcert: ?*X509, pkey: ?*EVP_PKEY, certs: ?*struct_stack_st_X509, data: ?*BIO, flags: c_int) [*c]PKCS7;
pub extern fn PKCS7_sign_ex(signcert: ?*X509, pkey: ?*EVP_PKEY, certs: ?*struct_stack_st_X509, data: ?*BIO, flags: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) [*c]PKCS7;
pub extern fn PKCS7_sign_add_signer(p7: [*c]PKCS7, signcert: ?*X509, pkey: ?*EVP_PKEY, md: ?*const EVP_MD, flags: c_int) [*c]PKCS7_SIGNER_INFO;
pub extern fn PKCS7_final(p7: [*c]PKCS7, data: ?*BIO, flags: c_int) c_int;
pub extern fn PKCS7_verify(p7: [*c]PKCS7, certs: ?*struct_stack_st_X509, store: ?*X509_STORE, indata: ?*BIO, out: ?*BIO, flags: c_int) c_int;
pub extern fn PKCS7_get0_signers(p7: [*c]PKCS7, certs: ?*struct_stack_st_X509, flags: c_int) ?*struct_stack_st_X509;
pub extern fn PKCS7_encrypt(certs: ?*struct_stack_st_X509, in: ?*BIO, cipher: ?*const EVP_CIPHER, flags: c_int) [*c]PKCS7;
pub extern fn PKCS7_encrypt_ex(certs: ?*struct_stack_st_X509, in: ?*BIO, cipher: ?*const EVP_CIPHER, flags: c_int, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) [*c]PKCS7;
pub extern fn PKCS7_decrypt(p7: [*c]PKCS7, pkey: ?*EVP_PKEY, cert: ?*X509, data: ?*BIO, flags: c_int) c_int;
pub extern fn PKCS7_add_attrib_smimecap(si: [*c]PKCS7_SIGNER_INFO, cap: ?*struct_stack_st_X509_ALGOR) c_int;
pub extern fn PKCS7_get_smimecap(si: [*c]PKCS7_SIGNER_INFO) ?*struct_stack_st_X509_ALGOR;
pub extern fn PKCS7_simple_smimecap(sk: ?*struct_stack_st_X509_ALGOR, nid: c_int, arg: c_int) c_int;
pub extern fn PKCS7_add_attrib_content_type(si: [*c]PKCS7_SIGNER_INFO, coid: ?*ASN1_OBJECT) c_int;
pub extern fn PKCS7_add0_attrib_signing_time(si: [*c]PKCS7_SIGNER_INFO, t: [*c]ASN1_TIME) c_int;
pub extern fn PKCS7_add1_attrib_digest(si: [*c]PKCS7_SIGNER_INFO, md: [*c]const u8, mdlen: c_int) c_int;
pub extern fn SMIME_write_PKCS7(bio: ?*BIO, p7: [*c]PKCS7, data: ?*BIO, flags: c_int) c_int;
pub extern fn SMIME_read_PKCS7_ex(bio: ?*BIO, bcont: [*c]?*BIO, p7: [*c][*c]PKCS7) [*c]PKCS7;
pub extern fn SMIME_read_PKCS7(bio: ?*BIO, bcont: [*c]?*BIO) [*c]PKCS7;
pub extern fn BIO_new_PKCS7(out: ?*BIO, p7: [*c]PKCS7) ?*BIO;
pub extern fn X509_CRL_set_default_method(meth: ?*const X509_CRL_METHOD) void;
pub extern fn X509_CRL_METHOD_new(crl_init: ?*const fn (?*X509_CRL) callconv(.c) c_int, crl_free: ?*const fn (?*X509_CRL) callconv(.c) c_int, crl_lookup: ?*const fn (?*X509_CRL, [*c]?*X509_REVOKED, [*c]const ASN1_INTEGER, ?*const X509_NAME) callconv(.c) c_int, crl_verify: ?*const fn (?*X509_CRL, ?*EVP_PKEY) callconv(.c) c_int) ?*X509_CRL_METHOD;
pub extern fn X509_CRL_METHOD_free(m: ?*X509_CRL_METHOD) void;
pub extern fn X509_CRL_set_meth_data(crl: ?*X509_CRL, dat: ?*anyopaque) void;
pub extern fn X509_CRL_get_meth_data(crl: ?*X509_CRL) ?*anyopaque;
pub extern fn X509_verify_cert_error_string(n: c_long) [*c]const u8;
pub extern fn X509_verify(a: ?*X509, r: ?*EVP_PKEY) c_int;
pub extern fn X509_self_signed(cert: ?*X509, verify_signature: c_int) c_int;
pub extern fn X509_REQ_verify_ex(a: ?*X509_REQ, r: ?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn X509_REQ_verify(a: ?*X509_REQ, r: ?*EVP_PKEY) c_int;
pub extern fn X509_CRL_verify(a: ?*X509_CRL, r: ?*EVP_PKEY) c_int;
pub extern fn NETSCAPE_SPKI_verify(a: [*c]NETSCAPE_SPKI, r: ?*EVP_PKEY) c_int;
pub extern fn NETSCAPE_SPKI_b64_decode(str: [*c]const u8, len: c_int) [*c]NETSCAPE_SPKI;
pub extern fn NETSCAPE_SPKI_b64_encode(x: [*c]NETSCAPE_SPKI) [*c]u8;
pub extern fn NETSCAPE_SPKI_get_pubkey(x: [*c]NETSCAPE_SPKI) ?*EVP_PKEY;
pub extern fn NETSCAPE_SPKI_set_pubkey(x: [*c]NETSCAPE_SPKI, pkey: ?*EVP_PKEY) c_int;
pub extern fn NETSCAPE_SPKI_print(out: ?*BIO, spki: [*c]NETSCAPE_SPKI) c_int;
pub extern fn X509_signature_dump(bp: ?*BIO, sig: [*c]const ASN1_STRING, indent: c_int) c_int;
pub extern fn X509_signature_print(bp: ?*BIO, alg: [*c]const X509_ALGOR, sig: [*c]const ASN1_STRING) c_int;
pub extern fn X509_sign(x: ?*X509, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) c_int;
pub extern fn X509_sign_ctx(x: ?*X509, ctx: ?*EVP_MD_CTX) c_int;
pub extern fn X509_REQ_sign(x: ?*X509_REQ, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) c_int;
pub extern fn X509_REQ_sign_ctx(x: ?*X509_REQ, ctx: ?*EVP_MD_CTX) c_int;
pub extern fn X509_CRL_sign(x: ?*X509_CRL, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) c_int;
pub extern fn X509_CRL_sign_ctx(x: ?*X509_CRL, ctx: ?*EVP_MD_CTX) c_int;
pub extern fn NETSCAPE_SPKI_sign(x: [*c]NETSCAPE_SPKI, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) c_int;
pub extern fn X509_pubkey_digest(data: ?*const X509, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn X509_digest(data: ?*const X509, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn X509_digest_sig(cert: ?*const X509, md_used: [*c]?*EVP_MD, md_is_fallback: [*c]c_int) [*c]ASN1_OCTET_STRING;
pub extern fn X509_CRL_digest(data: ?*const X509_CRL, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn X509_REQ_digest(data: ?*const X509_REQ, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn X509_NAME_digest(data: ?*const X509_NAME, @"type": ?*const EVP_MD, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn X509_load_http(url: [*c]const u8, bio: ?*BIO, rbio: ?*BIO, timeout: c_int) ?*X509;
pub extern fn X509_CRL_load_http(url: [*c]const u8, bio: ?*BIO, rbio: ?*BIO, timeout: c_int) ?*X509_CRL;
pub const CONF_VALUE = extern struct {
    section: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    value: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const sk_CONF_VALUE_compfunc = ?*const fn ([*c]const [*c]const CONF_VALUE, [*c]const [*c]const CONF_VALUE) callconv(.c) c_int;
pub const sk_CONF_VALUE_freefunc = ?*const fn ([*c]CONF_VALUE) callconv(.c) void;
pub const sk_CONF_VALUE_copyfunc = ?*const fn ([*c]const CONF_VALUE) callconv(.c) [*c]CONF_VALUE;
pub fn ossl_check_CONF_VALUE_type(arg_ptr: [*c]CONF_VALUE) callconv(.c) [*c]CONF_VALUE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_CONF_VALUE_sk_type(arg_sk: ?*const struct_stack_st_CONF_VALUE) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_CONF_VALUE_sk_type(arg_sk: ?*struct_stack_st_CONF_VALUE) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_CONF_VALUE_compfunc_type(arg_cmp: sk_CONF_VALUE_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_CONF_VALUE_copyfunc_type(arg_cpy: sk_CONF_VALUE_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_CONF_VALUE_freefunc_type(arg_fr: sk_CONF_VALUE_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const lh_CONF_VALUE_compfunc = ?*const fn ([*c]const CONF_VALUE, [*c]const CONF_VALUE) callconv(.c) c_int;
pub const lh_CONF_VALUE_hashfunc = ?*const fn ([*c]const CONF_VALUE) callconv(.c) c_ulong;
pub const lh_CONF_VALUE_doallfunc = ?*const fn ([*c]CONF_VALUE) callconv(.c) void;
pub fn lh_CONF_VALUE_hash_thunk(arg_data: ?*const anyopaque, arg_hfn: OPENSSL_LH_HASHFUNC) callconv(.c) c_ulong {
    var data = arg_data;
    _ = &data;
    var hfn = arg_hfn;
    _ = &hfn;
    var hfn_conv: ?*const fn ([*c]const CONF_VALUE) callconv(.c) c_ulong = @as(?*const fn ([*c]const CONF_VALUE) callconv(.c) c_ulong, @ptrCast(@alignCast(hfn)));
    _ = &hfn_conv;
    return hfn_conv.?(@as([*c]const CONF_VALUE, @ptrCast(@alignCast(data))));
}
pub fn lh_CONF_VALUE_comp_thunk(arg_da: ?*const anyopaque, arg_db: ?*const anyopaque, arg_cfn: OPENSSL_LH_COMPFUNC) callconv(.c) c_int {
    var da = arg_da;
    _ = &da;
    var db = arg_db;
    _ = &db;
    var cfn = arg_cfn;
    _ = &cfn;
    var cfn_conv: ?*const fn ([*c]const CONF_VALUE, [*c]const CONF_VALUE) callconv(.c) c_int = @as(?*const fn ([*c]const CONF_VALUE, [*c]const CONF_VALUE) callconv(.c) c_int, @ptrCast(@alignCast(cfn)));
    _ = &cfn_conv;
    return cfn_conv.?(@as([*c]const CONF_VALUE, @ptrCast(@alignCast(da))), @as([*c]const CONF_VALUE, @ptrCast(@alignCast(db))));
}
pub fn lh_CONF_VALUE_doall_thunk(arg_node: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNC) callconv(.c) void {
    var node = arg_node;
    _ = &node;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]CONF_VALUE) callconv(.c) void = @as(?*const fn ([*c]CONF_VALUE) callconv(.c) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]CONF_VALUE, @ptrCast(@alignCast(node))));
}
pub fn lh_CONF_VALUE_doall_arg_thunk(arg_node: ?*anyopaque, arg_arg: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNCARG) callconv(.c) void {
    var node = arg_node;
    _ = &node;
    var arg = arg_arg;
    _ = &arg;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]CONF_VALUE, ?*anyopaque) callconv(.c) void = @as(?*const fn ([*c]CONF_VALUE, ?*anyopaque) callconv(.c) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]CONF_VALUE, @ptrCast(@alignCast(node))), arg);
}
pub fn ossl_check_CONF_VALUE_lh_plain_type(arg_ptr: [*c]CONF_VALUE) callconv(.c) [*c]CONF_VALUE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_CONF_VALUE_lh_plain_type(arg_ptr: [*c]const CONF_VALUE) callconv(.c) [*c]const CONF_VALUE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_CONF_VALUE_lh_type(arg_lh: [*c]const struct_lhash_st_CONF_VALUE) callconv(.c) ?*const OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*const OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_CONF_VALUE_lh_type(arg_lh: [*c]struct_lhash_st_CONF_VALUE) callconv(.c) ?*OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_CONF_VALUE_lh_compfunc_type(arg_cmp: lh_CONF_VALUE_compfunc) callconv(.c) OPENSSL_LH_COMPFUNC {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_LH_COMPFUNC, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_CONF_VALUE_lh_hashfunc_type(arg_hfn: lh_CONF_VALUE_hashfunc) callconv(.c) OPENSSL_LH_HASHFUNC {
    var hfn = arg_hfn;
    _ = &hfn;
    return @as(OPENSSL_LH_HASHFUNC, @ptrCast(@alignCast(hfn)));
}
pub fn ossl_check_CONF_VALUE_lh_doallfunc_type(arg_dfn: lh_CONF_VALUE_doallfunc) callconv(.c) OPENSSL_LH_DOALL_FUNC {
    var dfn = arg_dfn;
    _ = &dfn;
    return @as(OPENSSL_LH_DOALL_FUNC, @ptrCast(@alignCast(dfn)));
}
pub const struct_conf_imodule_st = opaque {};
pub const CONF_IMODULE = struct_conf_imodule_st;
pub const struct_conf_module_st = opaque {};
pub const CONF_MODULE = struct_conf_module_st;
pub const struct_stack_st_CONF_MODULE = opaque {};
pub const struct_stack_st_CONF_IMODULE = opaque {};
pub const conf_init_func = fn (?*CONF_IMODULE, [*c]const CONF) callconv(.c) c_int;
pub const conf_finish_func = fn (?*CONF_IMODULE) callconv(.c) void;
pub extern fn CONF_set_default_method(meth: [*c]CONF_METHOD) c_int;
pub extern fn CONF_set_nconf(conf: [*c]CONF, hash: [*c]struct_lhash_st_CONF_VALUE) void;
pub extern fn CONF_load(conf: [*c]struct_lhash_st_CONF_VALUE, file: [*c]const u8, eline: [*c]c_long) [*c]struct_lhash_st_CONF_VALUE;
pub extern fn CONF_load_fp(conf: [*c]struct_lhash_st_CONF_VALUE, fp: [*c]FILE, eline: [*c]c_long) [*c]struct_lhash_st_CONF_VALUE;
pub extern fn CONF_load_bio(conf: [*c]struct_lhash_st_CONF_VALUE, bp: ?*BIO, eline: [*c]c_long) [*c]struct_lhash_st_CONF_VALUE;
pub extern fn CONF_get_section(conf: [*c]struct_lhash_st_CONF_VALUE, section: [*c]const u8) ?*struct_stack_st_CONF_VALUE;
pub extern fn CONF_get_string(conf: [*c]struct_lhash_st_CONF_VALUE, group: [*c]const u8, name: [*c]const u8) [*c]u8;
pub extern fn CONF_get_number(conf: [*c]struct_lhash_st_CONF_VALUE, group: [*c]const u8, name: [*c]const u8) c_long;
pub extern fn CONF_free(conf: [*c]struct_lhash_st_CONF_VALUE) void;
pub extern fn CONF_dump_fp(conf: [*c]struct_lhash_st_CONF_VALUE, out: [*c]FILE) c_int;
pub extern fn CONF_dump_bio(conf: [*c]struct_lhash_st_CONF_VALUE, out: ?*BIO) c_int;
pub extern fn OPENSSL_config(config_name: [*c]const u8) void;
pub extern fn NCONF_new_ex(libctx: ?*OSSL_LIB_CTX, meth: [*c]CONF_METHOD) [*c]CONF;
pub extern fn NCONF_get0_libctx(conf: [*c]const CONF) ?*OSSL_LIB_CTX;
pub extern fn NCONF_new(meth: [*c]CONF_METHOD) [*c]CONF;
pub extern fn NCONF_default() [*c]CONF_METHOD;
pub extern fn NCONF_WIN32() [*c]CONF_METHOD;
pub extern fn NCONF_free(conf: [*c]CONF) void;
pub extern fn NCONF_free_data(conf: [*c]CONF) void;
pub extern fn NCONF_load(conf: [*c]CONF, file: [*c]const u8, eline: [*c]c_long) c_int;
pub extern fn NCONF_load_fp(conf: [*c]CONF, fp: [*c]FILE, eline: [*c]c_long) c_int;
pub extern fn NCONF_load_bio(conf: [*c]CONF, bp: ?*BIO, eline: [*c]c_long) c_int;
pub extern fn NCONF_get_section_names(conf: [*c]const CONF) ?*struct_stack_st_OPENSSL_CSTRING;
pub extern fn NCONF_get_section(conf: [*c]const CONF, section: [*c]const u8) ?*struct_stack_st_CONF_VALUE;
pub extern fn NCONF_get_string(conf: [*c]const CONF, group: [*c]const u8, name: [*c]const u8) [*c]u8;
pub extern fn NCONF_get_number_e(conf: [*c]const CONF, group: [*c]const u8, name: [*c]const u8, result: [*c]c_long) c_int;
pub extern fn NCONF_dump_fp(conf: [*c]const CONF, out: [*c]FILE) c_int;
pub extern fn NCONF_dump_bio(conf: [*c]const CONF, out: ?*BIO) c_int;
pub extern fn CONF_modules_load(cnf: [*c]const CONF, appname: [*c]const u8, flags: c_ulong) c_int;
pub extern fn CONF_modules_load_file_ex(libctx: ?*OSSL_LIB_CTX, filename: [*c]const u8, appname: [*c]const u8, flags: c_ulong) c_int;
pub extern fn CONF_modules_load_file(filename: [*c]const u8, appname: [*c]const u8, flags: c_ulong) c_int;
pub extern fn CONF_modules_unload(all: c_int) void;
pub extern fn CONF_modules_finish() void;
pub extern fn CONF_module_add(name: [*c]const u8, ifunc: ?*const conf_init_func, ffunc: ?*const conf_finish_func) c_int;
pub extern fn CONF_imodule_get_name(md: ?*const CONF_IMODULE) [*c]const u8;
pub extern fn CONF_imodule_get_value(md: ?*const CONF_IMODULE) [*c]const u8;
pub extern fn CONF_imodule_get_usr_data(md: ?*const CONF_IMODULE) ?*anyopaque;
pub extern fn CONF_imodule_set_usr_data(md: ?*CONF_IMODULE, usr_data: ?*anyopaque) void;
pub extern fn CONF_imodule_get_module(md: ?*const CONF_IMODULE) ?*CONF_MODULE;
pub extern fn CONF_imodule_get_flags(md: ?*const CONF_IMODULE) c_ulong;
pub extern fn CONF_imodule_set_flags(md: ?*CONF_IMODULE, flags: c_ulong) void;
pub extern fn CONF_module_get_usr_data(pmod: ?*CONF_MODULE) ?*anyopaque;
pub extern fn CONF_module_set_usr_data(pmod: ?*CONF_MODULE, usr_data: ?*anyopaque) void;
pub extern fn CONF_get1_default_config_file() [*c]u8;
pub extern fn CONF_parse_list(list: [*c]const u8, sep: c_int, nospc: c_int, list_cb: ?*const fn ([*c]const u8, c_int, ?*anyopaque) callconv(.c) c_int, arg: ?*anyopaque) c_int;
pub extern fn OPENSSL_load_builtin_modules() void;
pub extern fn OSSL_HTTP_REQ_CTX_new(wbio: ?*BIO, rbio: ?*BIO, buf_size: c_int) ?*OSSL_HTTP_REQ_CTX;
pub extern fn OSSL_HTTP_REQ_CTX_free(rctx: ?*OSSL_HTTP_REQ_CTX) void;
pub extern fn OSSL_HTTP_REQ_CTX_set_request_line(rctx: ?*OSSL_HTTP_REQ_CTX, method_POST: c_int, server: [*c]const u8, port: [*c]const u8, path: [*c]const u8) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_add1_header(rctx: ?*OSSL_HTTP_REQ_CTX, name: [*c]const u8, value: [*c]const u8) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_set_expected(rctx: ?*OSSL_HTTP_REQ_CTX, content_type: [*c]const u8, asn1: c_int, timeout: c_int, keep_alive: c_int) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_set1_req(rctx: ?*OSSL_HTTP_REQ_CTX, content_type: [*c]const u8, it: ?*const ASN1_ITEM, req: ?*const ASN1_VALUE) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_nbio(rctx: ?*OSSL_HTTP_REQ_CTX) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_nbio_d2i(rctx: ?*OSSL_HTTP_REQ_CTX, pval: [*c]?*ASN1_VALUE, it: ?*const ASN1_ITEM) c_int;
pub extern fn OSSL_HTTP_REQ_CTX_exchange(rctx: ?*OSSL_HTTP_REQ_CTX) ?*BIO;
pub extern fn OSSL_HTTP_REQ_CTX_get0_mem_bio(rctx: ?*const OSSL_HTTP_REQ_CTX) ?*BIO;
pub extern fn OSSL_HTTP_REQ_CTX_get_resp_len(rctx: ?*const OSSL_HTTP_REQ_CTX) usize;
pub extern fn OSSL_HTTP_REQ_CTX_set_max_response_length(rctx: ?*OSSL_HTTP_REQ_CTX, len: c_ulong) void;
pub extern fn OSSL_HTTP_is_alive(rctx: ?*const OSSL_HTTP_REQ_CTX) c_int;
pub const OSSL_HTTP_bio_cb_t = ?*const fn (?*BIO, ?*anyopaque, c_int, c_int) callconv(.c) ?*BIO;
pub extern fn OSSL_HTTP_open(server: [*c]const u8, port: [*c]const u8, proxy: [*c]const u8, no_proxy: [*c]const u8, use_ssl: c_int, bio: ?*BIO, rbio: ?*BIO, bio_update_fn: OSSL_HTTP_bio_cb_t, arg: ?*anyopaque, buf_size: c_int, overall_timeout: c_int) ?*OSSL_HTTP_REQ_CTX;
pub extern fn OSSL_HTTP_proxy_connect(bio: ?*BIO, server: [*c]const u8, port: [*c]const u8, proxyuser: [*c]const u8, proxypass: [*c]const u8, timeout: c_int, bio_err: ?*BIO, prog: [*c]const u8) c_int;
pub extern fn OSSL_HTTP_set1_request(rctx: ?*OSSL_HTTP_REQ_CTX, path: [*c]const u8, headers: ?*const struct_stack_st_CONF_VALUE, content_type: [*c]const u8, req: ?*BIO, expected_content_type: [*c]const u8, expect_asn1: c_int, max_resp_len: usize, timeout: c_int, keep_alive: c_int) c_int;
pub extern fn OSSL_HTTP_exchange(rctx: ?*OSSL_HTTP_REQ_CTX, redirection_url: [*c][*c]u8) ?*BIO;
pub extern fn OSSL_HTTP_get(url: [*c]const u8, proxy: [*c]const u8, no_proxy: [*c]const u8, bio: ?*BIO, rbio: ?*BIO, bio_update_fn: OSSL_HTTP_bio_cb_t, arg: ?*anyopaque, buf_size: c_int, headers: ?*const struct_stack_st_CONF_VALUE, expected_content_type: [*c]const u8, expect_asn1: c_int, max_resp_len: usize, timeout: c_int) ?*BIO;
pub extern fn OSSL_HTTP_transfer(prctx: [*c]?*OSSL_HTTP_REQ_CTX, server: [*c]const u8, port: [*c]const u8, path: [*c]const u8, use_ssl: c_int, proxy: [*c]const u8, no_proxy: [*c]const u8, bio: ?*BIO, rbio: ?*BIO, bio_update_fn: OSSL_HTTP_bio_cb_t, arg: ?*anyopaque, buf_size: c_int, headers: ?*const struct_stack_st_CONF_VALUE, content_type: [*c]const u8, req: ?*BIO, expected_content_type: [*c]const u8, expect_asn1: c_int, max_resp_len: usize, timeout: c_int, keep_alive: c_int) ?*BIO;
pub extern fn OSSL_HTTP_close(rctx: ?*OSSL_HTTP_REQ_CTX, ok: c_int) c_int;
pub extern fn OSSL_parse_url(url: [*c]const u8, pscheme: [*c][*c]u8, puser: [*c][*c]u8, phost: [*c][*c]u8, pport: [*c][*c]u8, pport_num: [*c]c_int, ppath: [*c][*c]u8, pquery: [*c][*c]u8, pfrag: [*c][*c]u8) c_int;
pub extern fn OSSL_HTTP_parse_url(url: [*c]const u8, pssl: [*c]c_int, puser: [*c][*c]u8, phost: [*c][*c]u8, pport: [*c][*c]u8, pport_num: [*c]c_int, ppath: [*c][*c]u8, pquery: [*c][*c]u8, pfrag: [*c][*c]u8) c_int;
pub extern fn OSSL_HTTP_adapt_proxy(proxy: [*c]const u8, no_proxy: [*c]const u8, server: [*c]const u8, use_ssl: c_int) [*c]const u8;
pub extern fn OSSL_HTTP_REQ_CTX_set_max_response_hdr_lines(rctx: ?*OSSL_HTTP_REQ_CTX, count: usize) void;
pub extern fn d2i_X509_fp(fp: [*c]FILE, x509: [*c]?*X509) ?*X509;
pub extern fn i2d_X509_fp(fp: [*c]FILE, x509: ?*const X509) c_int;
pub extern fn d2i_X509_CRL_fp(fp: [*c]FILE, crl: [*c]?*X509_CRL) ?*X509_CRL;
pub extern fn i2d_X509_CRL_fp(fp: [*c]FILE, crl: ?*const X509_CRL) c_int;
pub extern fn d2i_X509_REQ_fp(fp: [*c]FILE, req: [*c]?*X509_REQ) ?*X509_REQ;
pub extern fn i2d_X509_REQ_fp(fp: [*c]FILE, req: ?*const X509_REQ) c_int;
pub extern fn d2i_RSAPrivateKey_fp(fp: [*c]FILE, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSAPrivateKey_fp(fp: [*c]FILE, rsa: ?*const RSA) c_int;
pub extern fn d2i_RSAPublicKey_fp(fp: [*c]FILE, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSAPublicKey_fp(fp: [*c]FILE, rsa: ?*const RSA) c_int;
pub extern fn d2i_RSA_PUBKEY_fp(fp: [*c]FILE, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSA_PUBKEY_fp(fp: [*c]FILE, rsa: ?*const RSA) c_int;
pub extern fn d2i_DSA_PUBKEY_fp(fp: [*c]FILE, dsa: [*c]?*DSA) ?*DSA;
pub extern fn i2d_DSA_PUBKEY_fp(fp: [*c]FILE, dsa: ?*const DSA) c_int;
pub extern fn d2i_DSAPrivateKey_fp(fp: [*c]FILE, dsa: [*c]?*DSA) ?*DSA;
pub extern fn i2d_DSAPrivateKey_fp(fp: [*c]FILE, dsa: ?*const DSA) c_int;
pub extern fn d2i_EC_PUBKEY_fp(fp: [*c]FILE, eckey: [*c]?*EC_KEY) ?*EC_KEY;
pub extern fn i2d_EC_PUBKEY_fp(fp: [*c]FILE, eckey: ?*const EC_KEY) c_int;
pub extern fn d2i_ECPrivateKey_fp(fp: [*c]FILE, eckey: [*c]?*EC_KEY) ?*EC_KEY;
pub extern fn i2d_ECPrivateKey_fp(fp: [*c]FILE, eckey: ?*const EC_KEY) c_int;
pub extern fn d2i_PKCS8_fp(fp: [*c]FILE, p8: [*c]?*X509_SIG) ?*X509_SIG;
pub extern fn i2d_PKCS8_fp(fp: [*c]FILE, p8: ?*const X509_SIG) c_int;
pub extern fn d2i_X509_PUBKEY_fp(fp: [*c]FILE, xpk: [*c]?*X509_PUBKEY) ?*X509_PUBKEY;
pub extern fn i2d_X509_PUBKEY_fp(fp: [*c]FILE, xpk: ?*const X509_PUBKEY) c_int;
pub extern fn d2i_PKCS8_PRIV_KEY_INFO_fp(fp: [*c]FILE, p8inf: [*c]?*PKCS8_PRIV_KEY_INFO) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn i2d_PKCS8_PRIV_KEY_INFO_fp(fp: [*c]FILE, p8inf: ?*const PKCS8_PRIV_KEY_INFO) c_int;
pub extern fn i2d_PKCS8PrivateKeyInfo_fp(fp: [*c]FILE, key: ?*const EVP_PKEY) c_int;
pub extern fn i2d_PrivateKey_fp(fp: [*c]FILE, pkey: ?*const EVP_PKEY) c_int;
pub extern fn d2i_PrivateKey_ex_fp(fp: [*c]FILE, a: [*c]?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_PrivateKey_fp(fp: [*c]FILE, a: [*c]?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn i2d_PUBKEY_fp(fp: [*c]FILE, pkey: ?*const EVP_PKEY) c_int;
pub extern fn d2i_PUBKEY_ex_fp(fp: [*c]FILE, a: [*c]?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_PUBKEY_fp(fp: [*c]FILE, a: [*c]?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn d2i_X509_bio(bp: ?*BIO, x509: [*c]?*X509) ?*X509;
pub extern fn i2d_X509_bio(bp: ?*BIO, x509: ?*const X509) c_int;
pub extern fn d2i_X509_CRL_bio(bp: ?*BIO, crl: [*c]?*X509_CRL) ?*X509_CRL;
pub extern fn i2d_X509_CRL_bio(bp: ?*BIO, crl: ?*const X509_CRL) c_int;
pub extern fn d2i_X509_REQ_bio(bp: ?*BIO, req: [*c]?*X509_REQ) ?*X509_REQ;
pub extern fn i2d_X509_REQ_bio(bp: ?*BIO, req: ?*const X509_REQ) c_int;
pub extern fn d2i_RSAPrivateKey_bio(bp: ?*BIO, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSAPrivateKey_bio(bp: ?*BIO, rsa: ?*const RSA) c_int;
pub extern fn d2i_RSAPublicKey_bio(bp: ?*BIO, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSAPublicKey_bio(bp: ?*BIO, rsa: ?*const RSA) c_int;
pub extern fn d2i_RSA_PUBKEY_bio(bp: ?*BIO, rsa: [*c]?*RSA) ?*RSA;
pub extern fn i2d_RSA_PUBKEY_bio(bp: ?*BIO, rsa: ?*const RSA) c_int;
pub extern fn d2i_DSA_PUBKEY_bio(bp: ?*BIO, dsa: [*c]?*DSA) ?*DSA;
pub extern fn i2d_DSA_PUBKEY_bio(bp: ?*BIO, dsa: ?*const DSA) c_int;
pub extern fn d2i_DSAPrivateKey_bio(bp: ?*BIO, dsa: [*c]?*DSA) ?*DSA;
pub extern fn i2d_DSAPrivateKey_bio(bp: ?*BIO, dsa: ?*const DSA) c_int;
pub extern fn d2i_EC_PUBKEY_bio(bp: ?*BIO, eckey: [*c]?*EC_KEY) ?*EC_KEY;
pub extern fn i2d_EC_PUBKEY_bio(bp: ?*BIO, eckey: ?*const EC_KEY) c_int;
pub extern fn d2i_ECPrivateKey_bio(bp: ?*BIO, eckey: [*c]?*EC_KEY) ?*EC_KEY;
pub extern fn i2d_ECPrivateKey_bio(bp: ?*BIO, eckey: ?*const EC_KEY) c_int;
pub extern fn d2i_PKCS8_bio(bp: ?*BIO, p8: [*c]?*X509_SIG) ?*X509_SIG;
pub extern fn i2d_PKCS8_bio(bp: ?*BIO, p8: ?*const X509_SIG) c_int;
pub extern fn d2i_X509_PUBKEY_bio(bp: ?*BIO, xpk: [*c]?*X509_PUBKEY) ?*X509_PUBKEY;
pub extern fn i2d_X509_PUBKEY_bio(bp: ?*BIO, xpk: ?*const X509_PUBKEY) c_int;
pub extern fn d2i_PKCS8_PRIV_KEY_INFO_bio(bp: ?*BIO, p8inf: [*c]?*PKCS8_PRIV_KEY_INFO) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn i2d_PKCS8_PRIV_KEY_INFO_bio(bp: ?*BIO, p8inf: ?*const PKCS8_PRIV_KEY_INFO) c_int;
pub extern fn i2d_PKCS8PrivateKeyInfo_bio(bp: ?*BIO, key: ?*const EVP_PKEY) c_int;
pub extern fn i2d_PrivateKey_bio(bp: ?*BIO, pkey: ?*const EVP_PKEY) c_int;
pub extern fn d2i_PrivateKey_ex_bio(bp: ?*BIO, a: [*c]?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_PrivateKey_bio(bp: ?*BIO, a: [*c]?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn i2d_PUBKEY_bio(bp: ?*BIO, pkey: ?*const EVP_PKEY) c_int;
pub extern fn d2i_PUBKEY_ex_bio(bp: ?*BIO, a: [*c]?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_PUBKEY_bio(bp: ?*BIO, a: [*c]?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn X509_dup(a: ?*const X509) ?*X509;
pub extern fn X509_ALGOR_dup(a: [*c]const X509_ALGOR) [*c]X509_ALGOR;
pub extern fn X509_ATTRIBUTE_dup(a: ?*const X509_ATTRIBUTE) ?*X509_ATTRIBUTE;
pub extern fn X509_CRL_dup(a: ?*const X509_CRL) ?*X509_CRL;
pub extern fn X509_EXTENSION_dup(a: ?*const X509_EXTENSION) ?*X509_EXTENSION;
pub extern fn X509_PUBKEY_dup(a: ?*const X509_PUBKEY) ?*X509_PUBKEY;
pub extern fn X509_REQ_dup(a: ?*const X509_REQ) ?*X509_REQ;
pub extern fn X509_REVOKED_dup(a: ?*const X509_REVOKED) ?*X509_REVOKED;
pub extern fn X509_ALGOR_set0(alg: [*c]X509_ALGOR, aobj: ?*ASN1_OBJECT, ptype: c_int, pval: ?*anyopaque) c_int;
pub extern fn X509_ALGOR_get0(paobj: [*c]?*const ASN1_OBJECT, pptype: [*c]c_int, ppval: [*c]?*const anyopaque, algor: [*c]const X509_ALGOR) void;
pub extern fn X509_ALGOR_set_md(alg: [*c]X509_ALGOR, md: ?*const EVP_MD) void;
pub extern fn X509_ALGOR_cmp(a: [*c]const X509_ALGOR, b: [*c]const X509_ALGOR) c_int;
pub extern fn X509_ALGOR_copy(dest: [*c]X509_ALGOR, src: [*c]const X509_ALGOR) c_int;
pub extern fn X509_NAME_dup(a: ?*const X509_NAME) ?*X509_NAME;
pub extern fn X509_NAME_ENTRY_dup(a: ?*const X509_NAME_ENTRY) ?*X509_NAME_ENTRY;
pub extern fn X509_cmp_time(s: [*c]const ASN1_TIME, t: [*c]time_t) c_int;
pub extern fn X509_cmp_current_time(s: [*c]const ASN1_TIME) c_int;
pub extern fn X509_cmp_timeframe(vpm: ?*const X509_VERIFY_PARAM, start: [*c]const ASN1_TIME, end: [*c]const ASN1_TIME) c_int;
pub extern fn X509_time_adj(s: [*c]ASN1_TIME, adj: c_long, t: [*c]time_t) [*c]ASN1_TIME;
pub extern fn X509_time_adj_ex(s: [*c]ASN1_TIME, offset_day: c_int, offset_sec: c_long, t: [*c]time_t) [*c]ASN1_TIME;
pub extern fn X509_gmtime_adj(s: [*c]ASN1_TIME, adj: c_long) [*c]ASN1_TIME;
pub extern fn X509_get_default_cert_area() [*c]const u8;
pub extern fn X509_get_default_cert_dir() [*c]const u8;
pub extern fn X509_get_default_cert_file() [*c]const u8;
pub extern fn X509_get_default_cert_dir_env() [*c]const u8;
pub extern fn X509_get_default_cert_file_env() [*c]const u8;
pub extern fn X509_get_default_private_dir() [*c]const u8;
pub extern fn X509_to_X509_REQ(x: ?*X509, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) ?*X509_REQ;
pub extern fn X509_REQ_to_X509(r: ?*X509_REQ, days: c_int, pkey: ?*EVP_PKEY) ?*X509;
pub extern fn X509_ALGOR_new() [*c]X509_ALGOR;
pub extern fn X509_ALGOR_free(a: [*c]X509_ALGOR) void;
pub extern fn d2i_X509_ALGOR(a: [*c][*c]X509_ALGOR, in: [*c][*c]const u8, len: c_long) [*c]X509_ALGOR;
pub extern fn i2d_X509_ALGOR(a: [*c]const X509_ALGOR, out: [*c][*c]u8) c_int;
pub extern fn X509_ALGOR_it() ?*const ASN1_ITEM;
pub extern fn d2i_X509_ALGORS(a: [*c]?*X509_ALGORS, in: [*c][*c]const u8, len: c_long) ?*X509_ALGORS;
pub extern fn i2d_X509_ALGORS(a: ?*const X509_ALGORS, out: [*c][*c]u8) c_int;
pub extern fn X509_ALGORS_it() ?*const ASN1_ITEM;
pub extern fn X509_VAL_new() [*c]X509_VAL;
pub extern fn X509_VAL_free(a: [*c]X509_VAL) void;
pub extern fn d2i_X509_VAL(a: [*c][*c]X509_VAL, in: [*c][*c]const u8, len: c_long) [*c]X509_VAL;
pub extern fn i2d_X509_VAL(a: [*c]const X509_VAL, out: [*c][*c]u8) c_int;
pub extern fn X509_VAL_it() ?*const ASN1_ITEM;
pub extern fn X509_PUBKEY_new() ?*X509_PUBKEY;
pub extern fn X509_PUBKEY_free(a: ?*X509_PUBKEY) void;
pub extern fn d2i_X509_PUBKEY(a: [*c]?*X509_PUBKEY, in: [*c][*c]const u8, len: c_long) ?*X509_PUBKEY;
pub extern fn i2d_X509_PUBKEY(a: ?*const X509_PUBKEY, out: [*c][*c]u8) c_int;
pub extern fn X509_PUBKEY_it() ?*const ASN1_ITEM;
pub extern fn X509_PUBKEY_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*X509_PUBKEY;
pub extern fn X509_PUBKEY_set(x: [*c]?*X509_PUBKEY, pkey: ?*EVP_PKEY) c_int;
pub extern fn X509_PUBKEY_get0(key: ?*const X509_PUBKEY) ?*EVP_PKEY;
pub extern fn X509_PUBKEY_get(key: ?*const X509_PUBKEY) ?*EVP_PKEY;
pub extern fn X509_get_pubkey_parameters(pkey: ?*EVP_PKEY, chain: ?*struct_stack_st_X509) c_int;
pub extern fn X509_get_pathlen(x: ?*X509) c_long;
pub extern fn d2i_PUBKEY(a: [*c]?*EVP_PKEY, in: [*c][*c]const u8, len: c_long) ?*EVP_PKEY;
pub extern fn i2d_PUBKEY(a: ?*const EVP_PKEY, out: [*c][*c]u8) c_int;
pub extern fn d2i_PUBKEY_ex(a: [*c]?*EVP_PKEY, pp: [*c][*c]const u8, length: c_long, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn d2i_RSA_PUBKEY(a: [*c]?*RSA, in: [*c][*c]const u8, len: c_long) ?*RSA;
pub extern fn i2d_RSA_PUBKEY(a: ?*const RSA, out: [*c][*c]u8) c_int;
pub extern fn d2i_DSA_PUBKEY(a: [*c]?*DSA, in: [*c][*c]const u8, len: c_long) ?*DSA;
pub extern fn i2d_DSA_PUBKEY(a: ?*const DSA, out: [*c][*c]u8) c_int;
pub extern fn d2i_EC_PUBKEY(a: [*c]?*EC_KEY, in: [*c][*c]const u8, len: c_long) ?*EC_KEY;
pub extern fn i2d_EC_PUBKEY(a: ?*const EC_KEY, out: [*c][*c]u8) c_int;
pub extern fn X509_SIG_new() ?*X509_SIG;
pub extern fn X509_SIG_free(a: ?*X509_SIG) void;
pub extern fn d2i_X509_SIG(a: [*c]?*X509_SIG, in: [*c][*c]const u8, len: c_long) ?*X509_SIG;
pub extern fn i2d_X509_SIG(a: ?*const X509_SIG, out: [*c][*c]u8) c_int;
pub extern fn X509_SIG_it() ?*const ASN1_ITEM;
pub extern fn X509_SIG_get0(sig: ?*const X509_SIG, palg: [*c][*c]const X509_ALGOR, pdigest: [*c][*c]const ASN1_OCTET_STRING) void;
pub extern fn X509_SIG_getm(sig: ?*X509_SIG, palg: [*c][*c]X509_ALGOR, pdigest: [*c][*c]ASN1_OCTET_STRING) void;
pub extern fn X509_REQ_INFO_new() ?*X509_REQ_INFO;
pub extern fn X509_REQ_INFO_free(a: ?*X509_REQ_INFO) void;
pub extern fn d2i_X509_REQ_INFO(a: [*c]?*X509_REQ_INFO, in: [*c][*c]const u8, len: c_long) ?*X509_REQ_INFO;
pub extern fn i2d_X509_REQ_INFO(a: ?*const X509_REQ_INFO, out: [*c][*c]u8) c_int;
pub extern fn X509_REQ_INFO_it() ?*const ASN1_ITEM;
pub extern fn X509_REQ_new() ?*X509_REQ;
pub extern fn X509_REQ_free(a: ?*X509_REQ) void;
pub extern fn d2i_X509_REQ(a: [*c]?*X509_REQ, in: [*c][*c]const u8, len: c_long) ?*X509_REQ;
pub extern fn i2d_X509_REQ(a: ?*const X509_REQ, out: [*c][*c]u8) c_int;
pub extern fn X509_REQ_it() ?*const ASN1_ITEM;
pub extern fn X509_REQ_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*X509_REQ;
pub extern fn X509_ATTRIBUTE_new() ?*X509_ATTRIBUTE;
pub extern fn X509_ATTRIBUTE_free(a: ?*X509_ATTRIBUTE) void;
pub extern fn d2i_X509_ATTRIBUTE(a: [*c]?*X509_ATTRIBUTE, in: [*c][*c]const u8, len: c_long) ?*X509_ATTRIBUTE;
pub extern fn i2d_X509_ATTRIBUTE(a: ?*const X509_ATTRIBUTE, out: [*c][*c]u8) c_int;
pub extern fn X509_ATTRIBUTE_it() ?*const ASN1_ITEM;
pub extern fn X509_ATTRIBUTE_create(nid: c_int, atrtype: c_int, value: ?*anyopaque) ?*X509_ATTRIBUTE;
pub extern fn X509_EXTENSION_new() ?*X509_EXTENSION;
pub extern fn X509_EXTENSION_free(a: ?*X509_EXTENSION) void;
pub extern fn d2i_X509_EXTENSION(a: [*c]?*X509_EXTENSION, in: [*c][*c]const u8, len: c_long) ?*X509_EXTENSION;
pub extern fn i2d_X509_EXTENSION(a: ?*const X509_EXTENSION, out: [*c][*c]u8) c_int;
pub extern fn X509_EXTENSION_it() ?*const ASN1_ITEM;
pub extern fn d2i_X509_EXTENSIONS(a: [*c]?*X509_EXTENSIONS, in: [*c][*c]const u8, len: c_long) ?*X509_EXTENSIONS;
pub extern fn i2d_X509_EXTENSIONS(a: ?*const X509_EXTENSIONS, out: [*c][*c]u8) c_int;
pub extern fn X509_EXTENSIONS_it() ?*const ASN1_ITEM;
pub extern fn X509_NAME_ENTRY_new() ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_ENTRY_free(a: ?*X509_NAME_ENTRY) void;
pub extern fn d2i_X509_NAME_ENTRY(a: [*c]?*X509_NAME_ENTRY, in: [*c][*c]const u8, len: c_long) ?*X509_NAME_ENTRY;
pub extern fn i2d_X509_NAME_ENTRY(a: ?*const X509_NAME_ENTRY, out: [*c][*c]u8) c_int;
pub extern fn X509_NAME_ENTRY_it() ?*const ASN1_ITEM;
pub extern fn X509_NAME_new() ?*X509_NAME;
pub extern fn X509_NAME_free(a: ?*X509_NAME) void;
pub extern fn d2i_X509_NAME(a: [*c]?*X509_NAME, in: [*c][*c]const u8, len: c_long) ?*X509_NAME;
pub extern fn i2d_X509_NAME(a: ?*const X509_NAME, out: [*c][*c]u8) c_int;
pub extern fn X509_NAME_it() ?*const ASN1_ITEM;
pub extern fn X509_NAME_set(xn: [*c]?*X509_NAME, name: ?*const X509_NAME) c_int;
pub extern fn X509_CINF_new() ?*X509_CINF;
pub extern fn X509_CINF_free(a: ?*X509_CINF) void;
pub extern fn d2i_X509_CINF(a: [*c]?*X509_CINF, in: [*c][*c]const u8, len: c_long) ?*X509_CINF;
pub extern fn i2d_X509_CINF(a: ?*const X509_CINF, out: [*c][*c]u8) c_int;
pub extern fn X509_CINF_it() ?*const ASN1_ITEM;
pub extern fn X509_new() ?*X509;
pub extern fn X509_free(a: ?*X509) void;
pub extern fn d2i_X509(a: [*c]?*X509, in: [*c][*c]const u8, len: c_long) ?*X509;
pub extern fn i2d_X509(a: ?*const X509, out: [*c][*c]u8) c_int;
pub extern fn X509_it() ?*const ASN1_ITEM;
pub extern fn X509_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*X509;
pub extern fn X509_CERT_AUX_new() ?*X509_CERT_AUX;
pub extern fn X509_CERT_AUX_free(a: ?*X509_CERT_AUX) void;
pub extern fn d2i_X509_CERT_AUX(a: [*c]?*X509_CERT_AUX, in: [*c][*c]const u8, len: c_long) ?*X509_CERT_AUX;
pub extern fn i2d_X509_CERT_AUX(a: ?*const X509_CERT_AUX, out: [*c][*c]u8) c_int;
pub extern fn X509_CERT_AUX_it() ?*const ASN1_ITEM;
pub extern fn X509_set_ex_data(r: ?*X509, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn X509_get_ex_data(r: ?*const X509, idx: c_int) ?*anyopaque;
pub extern fn d2i_X509_AUX(a: [*c]?*X509, in: [*c][*c]const u8, len: c_long) ?*X509;
pub extern fn i2d_X509_AUX(a: ?*const X509, out: [*c][*c]u8) c_int;
pub extern fn i2d_re_X509_tbs(x: ?*X509, pp: [*c][*c]u8) c_int;
pub extern fn X509_SIG_INFO_get(siginf: ?*const X509_SIG_INFO, mdnid: [*c]c_int, pknid: [*c]c_int, secbits: [*c]c_int, flags: [*c]u32) c_int;
pub extern fn X509_SIG_INFO_set(siginf: ?*X509_SIG_INFO, mdnid: c_int, pknid: c_int, secbits: c_int, flags: u32) void;
pub extern fn X509_get_signature_info(x: ?*X509, mdnid: [*c]c_int, pknid: [*c]c_int, secbits: [*c]c_int, flags: [*c]u32) c_int;
pub extern fn X509_get0_signature(psig: [*c][*c]const ASN1_BIT_STRING, palg: [*c][*c]const X509_ALGOR, x: ?*const X509) void;
pub extern fn X509_get_signature_nid(x: ?*const X509) c_int;
pub extern fn X509_set0_distinguishing_id(x: ?*X509, d_id: [*c]ASN1_OCTET_STRING) void;
pub extern fn X509_get0_distinguishing_id(x: ?*X509) [*c]ASN1_OCTET_STRING;
pub extern fn X509_REQ_set0_distinguishing_id(x: ?*X509_REQ, d_id: [*c]ASN1_OCTET_STRING) void;
pub extern fn X509_REQ_get0_distinguishing_id(x: ?*X509_REQ) [*c]ASN1_OCTET_STRING;
pub extern fn X509_alias_set1(x: ?*X509, name: [*c]const u8, len: c_int) c_int;
pub extern fn X509_keyid_set1(x: ?*X509, id: [*c]const u8, len: c_int) c_int;
pub extern fn X509_alias_get0(x: ?*X509, len: [*c]c_int) [*c]u8;
pub extern fn X509_keyid_get0(x: ?*X509, len: [*c]c_int) [*c]u8;
pub extern fn X509_REVOKED_new() ?*X509_REVOKED;
pub extern fn X509_REVOKED_free(a: ?*X509_REVOKED) void;
pub extern fn d2i_X509_REVOKED(a: [*c]?*X509_REVOKED, in: [*c][*c]const u8, len: c_long) ?*X509_REVOKED;
pub extern fn i2d_X509_REVOKED(a: ?*const X509_REVOKED, out: [*c][*c]u8) c_int;
pub extern fn X509_REVOKED_it() ?*const ASN1_ITEM;
pub extern fn X509_CRL_INFO_new() ?*X509_CRL_INFO;
pub extern fn X509_CRL_INFO_free(a: ?*X509_CRL_INFO) void;
pub extern fn d2i_X509_CRL_INFO(a: [*c]?*X509_CRL_INFO, in: [*c][*c]const u8, len: c_long) ?*X509_CRL_INFO;
pub extern fn i2d_X509_CRL_INFO(a: ?*const X509_CRL_INFO, out: [*c][*c]u8) c_int;
pub extern fn X509_CRL_INFO_it() ?*const ASN1_ITEM;
pub extern fn X509_CRL_new() ?*X509_CRL;
pub extern fn X509_CRL_free(a: ?*X509_CRL) void;
pub extern fn d2i_X509_CRL(a: [*c]?*X509_CRL, in: [*c][*c]const u8, len: c_long) ?*X509_CRL;
pub extern fn i2d_X509_CRL(a: ?*const X509_CRL, out: [*c][*c]u8) c_int;
pub extern fn X509_CRL_it() ?*const ASN1_ITEM;
pub extern fn X509_CRL_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*X509_CRL;
pub extern fn X509_CRL_add0_revoked(crl: ?*X509_CRL, rev: ?*X509_REVOKED) c_int;
pub extern fn X509_CRL_get0_by_serial(crl: ?*X509_CRL, ret: [*c]?*X509_REVOKED, serial: [*c]const ASN1_INTEGER) c_int;
pub extern fn X509_CRL_get0_by_cert(crl: ?*X509_CRL, ret: [*c]?*X509_REVOKED, x: ?*X509) c_int;
pub extern fn X509_PKEY_new() [*c]X509_PKEY;
pub extern fn X509_PKEY_free(a: [*c]X509_PKEY) void;
pub extern fn NETSCAPE_SPKI_new() [*c]NETSCAPE_SPKI;
pub extern fn NETSCAPE_SPKI_free(a: [*c]NETSCAPE_SPKI) void;
pub extern fn d2i_NETSCAPE_SPKI(a: [*c][*c]NETSCAPE_SPKI, in: [*c][*c]const u8, len: c_long) [*c]NETSCAPE_SPKI;
pub extern fn i2d_NETSCAPE_SPKI(a: [*c]const NETSCAPE_SPKI, out: [*c][*c]u8) c_int;
pub extern fn NETSCAPE_SPKI_it() ?*const ASN1_ITEM;
pub extern fn NETSCAPE_SPKAC_new() [*c]NETSCAPE_SPKAC;
pub extern fn NETSCAPE_SPKAC_free(a: [*c]NETSCAPE_SPKAC) void;
pub extern fn d2i_NETSCAPE_SPKAC(a: [*c][*c]NETSCAPE_SPKAC, in: [*c][*c]const u8, len: c_long) [*c]NETSCAPE_SPKAC;
pub extern fn i2d_NETSCAPE_SPKAC(a: [*c]const NETSCAPE_SPKAC, out: [*c][*c]u8) c_int;
pub extern fn NETSCAPE_SPKAC_it() ?*const ASN1_ITEM;
pub extern fn NETSCAPE_CERT_SEQUENCE_new() [*c]NETSCAPE_CERT_SEQUENCE;
pub extern fn NETSCAPE_CERT_SEQUENCE_free(a: [*c]NETSCAPE_CERT_SEQUENCE) void;
pub extern fn d2i_NETSCAPE_CERT_SEQUENCE(a: [*c][*c]NETSCAPE_CERT_SEQUENCE, in: [*c][*c]const u8, len: c_long) [*c]NETSCAPE_CERT_SEQUENCE;
pub extern fn i2d_NETSCAPE_CERT_SEQUENCE(a: [*c]const NETSCAPE_CERT_SEQUENCE, out: [*c][*c]u8) c_int;
pub extern fn NETSCAPE_CERT_SEQUENCE_it() ?*const ASN1_ITEM;
pub extern fn X509_INFO_new() [*c]X509_INFO;
pub extern fn X509_INFO_free(a: [*c]X509_INFO) void;
pub extern fn X509_NAME_oneline(a: ?*const X509_NAME, buf: [*c]u8, size: c_int) [*c]u8;
pub extern fn ASN1_verify(i2d: ?*const i2d_of_void, algor1: [*c]X509_ALGOR, signature: [*c]ASN1_BIT_STRING, data: [*c]u8, pkey: ?*EVP_PKEY) c_int;
pub extern fn ASN1_digest(i2d: ?*const i2d_of_void, @"type": ?*const EVP_MD, data: [*c]u8, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn ASN1_sign(i2d: ?*const i2d_of_void, algor1: [*c]X509_ALGOR, algor2: [*c]X509_ALGOR, signature: [*c]ASN1_BIT_STRING, data: [*c]u8, pkey: ?*EVP_PKEY, @"type": ?*const EVP_MD) c_int;
pub extern fn ASN1_item_digest(it: ?*const ASN1_ITEM, @"type": ?*const EVP_MD, data: ?*anyopaque, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn ASN1_item_verify(it: ?*const ASN1_ITEM, alg: [*c]const X509_ALGOR, signature: [*c]const ASN1_BIT_STRING, data: ?*const anyopaque, pkey: ?*EVP_PKEY) c_int;
pub extern fn ASN1_item_verify_ctx(it: ?*const ASN1_ITEM, alg: [*c]const X509_ALGOR, signature: [*c]const ASN1_BIT_STRING, data: ?*const anyopaque, ctx: ?*EVP_MD_CTX) c_int;
pub extern fn ASN1_item_sign(it: ?*const ASN1_ITEM, algor1: [*c]X509_ALGOR, algor2: [*c]X509_ALGOR, signature: [*c]ASN1_BIT_STRING, data: ?*const anyopaque, pkey: ?*EVP_PKEY, md: ?*const EVP_MD) c_int;
pub extern fn ASN1_item_sign_ctx(it: ?*const ASN1_ITEM, algor1: [*c]X509_ALGOR, algor2: [*c]X509_ALGOR, signature: [*c]ASN1_BIT_STRING, data: ?*const anyopaque, ctx: ?*EVP_MD_CTX) c_int;
pub extern fn X509_get_version(x: ?*const X509) c_long;
pub extern fn X509_set_version(x: ?*X509, version: c_long) c_int;
pub extern fn X509_set_serialNumber(x: ?*X509, serial: [*c]ASN1_INTEGER) c_int;
pub extern fn X509_get_serialNumber(x: ?*X509) [*c]ASN1_INTEGER;
pub extern fn X509_get0_serialNumber(x: ?*const X509) [*c]const ASN1_INTEGER;
pub extern fn X509_set_issuer_name(x: ?*X509, name: ?*const X509_NAME) c_int;
pub extern fn X509_get_issuer_name(a: ?*const X509) ?*X509_NAME;
pub extern fn X509_set_subject_name(x: ?*X509, name: ?*const X509_NAME) c_int;
pub extern fn X509_get_subject_name(a: ?*const X509) ?*X509_NAME;
pub extern fn X509_get0_notBefore(x: ?*const X509) [*c]const ASN1_TIME;
pub extern fn X509_getm_notBefore(x: ?*const X509) [*c]ASN1_TIME;
pub extern fn X509_set1_notBefore(x: ?*X509, tm: [*c]const ASN1_TIME) c_int;
pub extern fn X509_get0_notAfter(x: ?*const X509) [*c]const ASN1_TIME;
pub extern fn X509_getm_notAfter(x: ?*const X509) [*c]ASN1_TIME;
pub extern fn X509_set1_notAfter(x: ?*X509, tm: [*c]const ASN1_TIME) c_int;
pub extern fn X509_set_pubkey(x: ?*X509, pkey: ?*EVP_PKEY) c_int;
pub extern fn X509_up_ref(x: ?*X509) c_int;
pub extern fn X509_get_signature_type(x: ?*const X509) c_int;
pub extern fn X509_get_X509_PUBKEY(x: ?*const X509) ?*X509_PUBKEY;
pub extern fn X509_get0_extensions(x: ?*const X509) ?*const struct_stack_st_X509_EXTENSION;
pub extern fn X509_get0_uids(x: ?*const X509, piuid: [*c][*c]const ASN1_BIT_STRING, psuid: [*c][*c]const ASN1_BIT_STRING) void;
pub extern fn X509_get0_tbs_sigalg(x: ?*const X509) [*c]const X509_ALGOR;
pub extern fn X509_get0_pubkey(x: ?*const X509) ?*EVP_PKEY;
pub extern fn X509_get_pubkey(x: ?*X509) ?*EVP_PKEY;
pub extern fn X509_get0_pubkey_bitstr(x: ?*const X509) [*c]ASN1_BIT_STRING;
pub extern fn X509_REQ_get_version(req: ?*const X509_REQ) c_long;
pub extern fn X509_REQ_set_version(x: ?*X509_REQ, version: c_long) c_int;
pub extern fn X509_REQ_get_subject_name(req: ?*const X509_REQ) ?*X509_NAME;
pub extern fn X509_REQ_set_subject_name(req: ?*X509_REQ, name: ?*const X509_NAME) c_int;
pub extern fn X509_REQ_get0_signature(req: ?*const X509_REQ, psig: [*c][*c]const ASN1_BIT_STRING, palg: [*c][*c]const X509_ALGOR) void;
pub extern fn X509_REQ_set0_signature(req: ?*X509_REQ, psig: [*c]ASN1_BIT_STRING) void;
pub extern fn X509_REQ_set1_signature_algo(req: ?*X509_REQ, palg: [*c]X509_ALGOR) c_int;
pub extern fn X509_REQ_get_signature_nid(req: ?*const X509_REQ) c_int;
pub extern fn i2d_re_X509_REQ_tbs(req: ?*X509_REQ, pp: [*c][*c]u8) c_int;
pub extern fn X509_REQ_set_pubkey(x: ?*X509_REQ, pkey: ?*EVP_PKEY) c_int;
pub extern fn X509_REQ_get_pubkey(req: ?*X509_REQ) ?*EVP_PKEY;
pub extern fn X509_REQ_get0_pubkey(req: ?*const X509_REQ) ?*EVP_PKEY;
pub extern fn X509_REQ_get_X509_PUBKEY(req: ?*X509_REQ) ?*X509_PUBKEY;
pub extern fn X509_REQ_extension_nid(nid: c_int) c_int;
pub extern fn X509_REQ_get_extension_nids() [*c]c_int;
pub extern fn X509_REQ_set_extension_nids(nids: [*c]c_int) void;
pub extern fn X509_REQ_get_extensions(req: ?*X509_REQ) ?*struct_stack_st_X509_EXTENSION;
pub extern fn X509_REQ_add_extensions_nid(req: ?*X509_REQ, exts: ?*const struct_stack_st_X509_EXTENSION, nid: c_int) c_int;
pub extern fn X509_REQ_add_extensions(req: ?*X509_REQ, ext: ?*const struct_stack_st_X509_EXTENSION) c_int;
pub extern fn X509_REQ_get_attr_count(req: ?*const X509_REQ) c_int;
pub extern fn X509_REQ_get_attr_by_NID(req: ?*const X509_REQ, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509_REQ_get_attr_by_OBJ(req: ?*const X509_REQ, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509_REQ_get_attr(req: ?*const X509_REQ, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509_REQ_delete_attr(req: ?*X509_REQ, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509_REQ_add1_attr(req: ?*X509_REQ, attr: ?*X509_ATTRIBUTE) c_int;
pub extern fn X509_REQ_add1_attr_by_OBJ(req: ?*X509_REQ, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_REQ_add1_attr_by_NID(req: ?*X509_REQ, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_REQ_add1_attr_by_txt(req: ?*X509_REQ, attrname: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_CRL_set_version(x: ?*X509_CRL, version: c_long) c_int;
pub extern fn X509_CRL_set_issuer_name(x: ?*X509_CRL, name: ?*const X509_NAME) c_int;
pub extern fn X509_CRL_set1_lastUpdate(x: ?*X509_CRL, tm: [*c]const ASN1_TIME) c_int;
pub extern fn X509_CRL_set1_nextUpdate(x: ?*X509_CRL, tm: [*c]const ASN1_TIME) c_int;
pub extern fn X509_CRL_sort(crl: ?*X509_CRL) c_int;
pub extern fn X509_CRL_up_ref(crl: ?*X509_CRL) c_int;
pub extern fn X509_CRL_get_version(crl: ?*const X509_CRL) c_long;
pub extern fn X509_CRL_get0_lastUpdate(crl: ?*const X509_CRL) [*c]const ASN1_TIME;
pub extern fn X509_CRL_get0_nextUpdate(crl: ?*const X509_CRL) [*c]const ASN1_TIME;
pub extern fn X509_CRL_get_lastUpdate(crl: ?*X509_CRL) [*c]ASN1_TIME;
pub extern fn X509_CRL_get_nextUpdate(crl: ?*X509_CRL) [*c]ASN1_TIME;
pub extern fn X509_CRL_get_issuer(crl: ?*const X509_CRL) ?*X509_NAME;
pub extern fn X509_CRL_get0_extensions(crl: ?*const X509_CRL) ?*const struct_stack_st_X509_EXTENSION;
pub extern fn X509_CRL_get_REVOKED(crl: ?*X509_CRL) ?*struct_stack_st_X509_REVOKED;
pub extern fn X509_CRL_get0_signature(crl: ?*const X509_CRL, psig: [*c][*c]const ASN1_BIT_STRING, palg: [*c][*c]const X509_ALGOR) void;
pub extern fn X509_CRL_get_signature_nid(crl: ?*const X509_CRL) c_int;
pub extern fn i2d_re_X509_CRL_tbs(req: ?*X509_CRL, pp: [*c][*c]u8) c_int;
pub extern fn X509_REVOKED_get0_serialNumber(x: ?*const X509_REVOKED) [*c]const ASN1_INTEGER;
pub extern fn X509_REVOKED_set_serialNumber(x: ?*X509_REVOKED, serial: [*c]ASN1_INTEGER) c_int;
pub extern fn X509_REVOKED_get0_revocationDate(x: ?*const X509_REVOKED) [*c]const ASN1_TIME;
pub extern fn X509_REVOKED_set_revocationDate(r: ?*X509_REVOKED, tm: [*c]ASN1_TIME) c_int;
pub extern fn X509_REVOKED_get0_extensions(r: ?*const X509_REVOKED) ?*const struct_stack_st_X509_EXTENSION;
pub extern fn X509_CRL_diff(base: ?*X509_CRL, newer: ?*X509_CRL, skey: ?*EVP_PKEY, md: ?*const EVP_MD, flags: c_uint) ?*X509_CRL;
pub extern fn X509_REQ_check_private_key(req: ?*const X509_REQ, pkey: ?*EVP_PKEY) c_int;
pub extern fn X509_check_private_key(cert: ?*const X509, pkey: ?*const EVP_PKEY) c_int;
pub extern fn X509_chain_check_suiteb(perror_depth: [*c]c_int, x: ?*X509, chain: ?*struct_stack_st_X509, flags: c_ulong) c_int;
pub extern fn X509_CRL_check_suiteb(crl: ?*X509_CRL, pk: ?*EVP_PKEY, flags: c_ulong) c_int;
pub extern fn OSSL_STACK_OF_X509_free(certs: ?*struct_stack_st_X509) void;
pub extern fn X509_chain_up_ref(chain: ?*struct_stack_st_X509) ?*struct_stack_st_X509;
pub extern fn X509_issuer_and_serial_cmp(a: ?*const X509, b: ?*const X509) c_int;
pub extern fn X509_issuer_and_serial_hash(a: ?*X509) c_ulong;
pub extern fn X509_issuer_name_cmp(a: ?*const X509, b: ?*const X509) c_int;
pub extern fn X509_issuer_name_hash(a: ?*X509) c_ulong;
pub extern fn X509_subject_name_cmp(a: ?*const X509, b: ?*const X509) c_int;
pub extern fn X509_subject_name_hash(x: ?*X509) c_ulong;
pub extern fn X509_issuer_name_hash_old(a: ?*X509) c_ulong;
pub extern fn X509_subject_name_hash_old(x: ?*X509) c_ulong;
pub extern fn X509_add_cert(sk: ?*struct_stack_st_X509, cert: ?*X509, flags: c_int) c_int;
pub extern fn X509_add_certs(sk: ?*struct_stack_st_X509, certs: ?*struct_stack_st_X509, flags: c_int) c_int;
pub extern fn X509_cmp(a: ?*const X509, b: ?*const X509) c_int;
pub extern fn X509_NAME_cmp(a: ?*const X509_NAME, b: ?*const X509_NAME) c_int;
pub extern fn X509_certificate_type(x: ?*const X509, pubkey: ?*const EVP_PKEY) c_int;
pub extern fn X509_NAME_hash_ex(x: ?*const X509_NAME, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, ok: [*c]c_int) c_ulong;
pub extern fn X509_NAME_hash_old(x: ?*const X509_NAME) c_ulong;
pub extern fn X509_CRL_cmp(a: ?*const X509_CRL, b: ?*const X509_CRL) c_int;
pub extern fn X509_CRL_match(a: ?*const X509_CRL, b: ?*const X509_CRL) c_int;
pub extern fn X509_aux_print(out: ?*BIO, x: ?*X509, indent: c_int) c_int;
pub extern fn X509_print_ex_fp(bp: [*c]FILE, x: ?*X509, nmflag: c_ulong, cflag: c_ulong) c_int;
pub extern fn X509_print_fp(bp: [*c]FILE, x: ?*X509) c_int;
pub extern fn X509_CRL_print_fp(bp: [*c]FILE, x: ?*X509_CRL) c_int;
pub extern fn X509_REQ_print_fp(bp: [*c]FILE, req: ?*X509_REQ) c_int;
pub extern fn X509_NAME_print_ex_fp(fp: [*c]FILE, nm: ?*const X509_NAME, indent: c_int, flags: c_ulong) c_int;
pub extern fn X509_NAME_print(bp: ?*BIO, name: ?*const X509_NAME, obase: c_int) c_int;
pub extern fn X509_NAME_print_ex(out: ?*BIO, nm: ?*const X509_NAME, indent: c_int, flags: c_ulong) c_int;
pub extern fn X509_print_ex(bp: ?*BIO, x: ?*X509, nmflag: c_ulong, cflag: c_ulong) c_int;
pub extern fn X509_print(bp: ?*BIO, x: ?*X509) c_int;
pub extern fn X509_ocspid_print(bp: ?*BIO, x: ?*X509) c_int;
pub extern fn X509_CRL_print_ex(out: ?*BIO, x: ?*X509_CRL, nmflag: c_ulong) c_int;
pub extern fn X509_CRL_print(bp: ?*BIO, x: ?*X509_CRL) c_int;
pub extern fn X509_REQ_print_ex(bp: ?*BIO, x: ?*X509_REQ, nmflag: c_ulong, cflag: c_ulong) c_int;
pub extern fn X509_REQ_print(bp: ?*BIO, req: ?*X509_REQ) c_int;
pub extern fn X509_NAME_entry_count(name: ?*const X509_NAME) c_int;
pub extern fn X509_NAME_get_text_by_NID(name: ?*const X509_NAME, nid: c_int, buf: [*c]u8, len: c_int) c_int;
pub extern fn X509_NAME_get_text_by_OBJ(name: ?*const X509_NAME, obj: ?*const ASN1_OBJECT, buf: [*c]u8, len: c_int) c_int;
pub extern fn X509_NAME_get_index_by_NID(name: ?*const X509_NAME, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509_NAME_get_index_by_OBJ(name: ?*const X509_NAME, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509_NAME_get_entry(name: ?*const X509_NAME, loc: c_int) ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_delete_entry(name: ?*X509_NAME, loc: c_int) ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_add_entry(name: ?*X509_NAME, ne: ?*const X509_NAME_ENTRY, loc: c_int, set: c_int) c_int;
pub extern fn X509_NAME_add_entry_by_OBJ(name: ?*X509_NAME, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int, loc: c_int, set: c_int) c_int;
pub extern fn X509_NAME_add_entry_by_NID(name: ?*X509_NAME, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int, loc: c_int, set: c_int) c_int;
pub extern fn X509_NAME_ENTRY_create_by_txt(ne: [*c]?*X509_NAME_ENTRY, field: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_ENTRY_create_by_NID(ne: [*c]?*X509_NAME_ENTRY, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_add_entry_by_txt(name: ?*X509_NAME, field: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int, loc: c_int, set: c_int) c_int;
pub extern fn X509_NAME_ENTRY_create_by_OBJ(ne: [*c]?*X509_NAME_ENTRY, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*X509_NAME_ENTRY;
pub extern fn X509_NAME_ENTRY_set_object(ne: ?*X509_NAME_ENTRY, obj: ?*const ASN1_OBJECT) c_int;
pub extern fn X509_NAME_ENTRY_set_data(ne: ?*X509_NAME_ENTRY, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_NAME_ENTRY_get_object(ne: ?*const X509_NAME_ENTRY) ?*ASN1_OBJECT;
pub extern fn X509_NAME_ENTRY_get_data(ne: ?*const X509_NAME_ENTRY) [*c]ASN1_STRING;
pub extern fn X509_NAME_ENTRY_set(ne: ?*const X509_NAME_ENTRY) c_int;
pub extern fn X509_NAME_get0_der(nm: ?*const X509_NAME, pder: [*c][*c]const u8, pderlen: [*c]usize) c_int;
pub extern fn X509v3_get_ext_count(x: ?*const struct_stack_st_X509_EXTENSION) c_int;
pub extern fn X509v3_get_ext_by_NID(x: ?*const struct_stack_st_X509_EXTENSION, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509v3_get_ext_by_OBJ(x: ?*const struct_stack_st_X509_EXTENSION, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509v3_get_ext_by_critical(x: ?*const struct_stack_st_X509_EXTENSION, crit: c_int, lastpos: c_int) c_int;
pub extern fn X509v3_get_ext(x: ?*const struct_stack_st_X509_EXTENSION, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509v3_delete_ext(x: ?*struct_stack_st_X509_EXTENSION, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509v3_add_ext(x: [*c]?*struct_stack_st_X509_EXTENSION, ex: ?*X509_EXTENSION, loc: c_int) ?*struct_stack_st_X509_EXTENSION;
pub extern fn X509v3_add_extensions(target: [*c]?*struct_stack_st_X509_EXTENSION, exts: ?*const struct_stack_st_X509_EXTENSION) ?*struct_stack_st_X509_EXTENSION;
pub extern fn X509_get_ext_count(x: ?*const X509) c_int;
pub extern fn X509_get_ext_by_NID(x: ?*const X509, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509_get_ext_by_OBJ(x: ?*const X509, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509_get_ext_by_critical(x: ?*const X509, crit: c_int, lastpos: c_int) c_int;
pub extern fn X509_get_ext(x: ?*const X509, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_delete_ext(x: ?*X509, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_add_ext(x: ?*X509, ex: ?*X509_EXTENSION, loc: c_int) c_int;
pub extern fn X509_get_ext_d2i(x: ?*const X509, nid: c_int, crit: [*c]c_int, idx: [*c]c_int) ?*anyopaque;
pub extern fn X509_add1_ext_i2d(x: ?*X509, nid: c_int, value: ?*anyopaque, crit: c_int, flags: c_ulong) c_int;
pub extern fn X509_CRL_get_ext_count(x: ?*const X509_CRL) c_int;
pub extern fn X509_CRL_get_ext_by_NID(x: ?*const X509_CRL, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509_CRL_get_ext_by_OBJ(x: ?*const X509_CRL, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509_CRL_get_ext_by_critical(x: ?*const X509_CRL, crit: c_int, lastpos: c_int) c_int;
pub extern fn X509_CRL_get_ext(x: ?*const X509_CRL, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_CRL_delete_ext(x: ?*X509_CRL, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_CRL_add_ext(x: ?*X509_CRL, ex: ?*X509_EXTENSION, loc: c_int) c_int;
pub extern fn X509_CRL_get_ext_d2i(x: ?*const X509_CRL, nid: c_int, crit: [*c]c_int, idx: [*c]c_int) ?*anyopaque;
pub extern fn X509_CRL_add1_ext_i2d(x: ?*X509_CRL, nid: c_int, value: ?*anyopaque, crit: c_int, flags: c_ulong) c_int;
pub extern fn X509_REVOKED_get_ext_count(x: ?*const X509_REVOKED) c_int;
pub extern fn X509_REVOKED_get_ext_by_NID(x: ?*const X509_REVOKED, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509_REVOKED_get_ext_by_OBJ(x: ?*const X509_REVOKED, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509_REVOKED_get_ext_by_critical(x: ?*const X509_REVOKED, crit: c_int, lastpos: c_int) c_int;
pub extern fn X509_REVOKED_get_ext(x: ?*const X509_REVOKED, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_REVOKED_delete_ext(x: ?*X509_REVOKED, loc: c_int) ?*X509_EXTENSION;
pub extern fn X509_REVOKED_add_ext(x: ?*X509_REVOKED, ex: ?*X509_EXTENSION, loc: c_int) c_int;
pub extern fn X509_REVOKED_get_ext_d2i(x: ?*const X509_REVOKED, nid: c_int, crit: [*c]c_int, idx: [*c]c_int) ?*anyopaque;
pub extern fn X509_REVOKED_add1_ext_i2d(x: ?*X509_REVOKED, nid: c_int, value: ?*anyopaque, crit: c_int, flags: c_ulong) c_int;
pub extern fn X509_EXTENSION_create_by_NID(ex: [*c]?*X509_EXTENSION, nid: c_int, crit: c_int, data: [*c]ASN1_OCTET_STRING) ?*X509_EXTENSION;
pub extern fn X509_EXTENSION_create_by_OBJ(ex: [*c]?*X509_EXTENSION, obj: ?*const ASN1_OBJECT, crit: c_int, data: [*c]ASN1_OCTET_STRING) ?*X509_EXTENSION;
pub extern fn X509_EXTENSION_set_object(ex: ?*X509_EXTENSION, obj: ?*const ASN1_OBJECT) c_int;
pub extern fn X509_EXTENSION_set_critical(ex: ?*X509_EXTENSION, crit: c_int) c_int;
pub extern fn X509_EXTENSION_set_data(ex: ?*X509_EXTENSION, data: [*c]ASN1_OCTET_STRING) c_int;
pub extern fn X509_EXTENSION_get_object(ex: ?*X509_EXTENSION) ?*ASN1_OBJECT;
pub extern fn X509_EXTENSION_get_data(ne: ?*X509_EXTENSION) [*c]ASN1_OCTET_STRING;
pub extern fn X509_EXTENSION_get_critical(ex: ?*const X509_EXTENSION) c_int;
pub extern fn X509at_get_attr_count(x: ?*const struct_stack_st_X509_ATTRIBUTE) c_int;
pub extern fn X509at_get_attr_by_NID(x: ?*const struct_stack_st_X509_ATTRIBUTE, nid: c_int, lastpos: c_int) c_int;
pub extern fn X509at_get_attr_by_OBJ(sk: ?*const struct_stack_st_X509_ATTRIBUTE, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn X509at_get_attr(x: ?*const struct_stack_st_X509_ATTRIBUTE, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509at_delete_attr(x: ?*struct_stack_st_X509_ATTRIBUTE, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509at_add1_attr(x: [*c]?*struct_stack_st_X509_ATTRIBUTE, attr: ?*X509_ATTRIBUTE) ?*struct_stack_st_X509_ATTRIBUTE;
pub extern fn X509at_add1_attr_by_OBJ(x: [*c]?*struct_stack_st_X509_ATTRIBUTE, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*struct_stack_st_X509_ATTRIBUTE;
pub extern fn X509at_add1_attr_by_NID(x: [*c]?*struct_stack_st_X509_ATTRIBUTE, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*struct_stack_st_X509_ATTRIBUTE;
pub extern fn X509at_add1_attr_by_txt(x: [*c]?*struct_stack_st_X509_ATTRIBUTE, attrname: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*struct_stack_st_X509_ATTRIBUTE;
pub extern fn X509at_get0_data_by_OBJ(x: ?*const struct_stack_st_X509_ATTRIBUTE, obj: ?*const ASN1_OBJECT, lastpos: c_int, @"type": c_int) ?*anyopaque;
pub extern fn X509_ATTRIBUTE_create_by_NID(attr: [*c]?*X509_ATTRIBUTE, nid: c_int, atrtype: c_int, data: ?*const anyopaque, len: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509_ATTRIBUTE_create_by_OBJ(attr: [*c]?*X509_ATTRIBUTE, obj: ?*const ASN1_OBJECT, atrtype: c_int, data: ?*const anyopaque, len: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509_ATTRIBUTE_create_by_txt(attr: [*c]?*X509_ATTRIBUTE, atrname: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int) ?*X509_ATTRIBUTE;
pub extern fn X509_ATTRIBUTE_set1_object(attr: ?*X509_ATTRIBUTE, obj: ?*const ASN1_OBJECT) c_int;
pub extern fn X509_ATTRIBUTE_set1_data(attr: ?*X509_ATTRIBUTE, attrtype: c_int, data: ?*const anyopaque, len: c_int) c_int;
pub extern fn X509_ATTRIBUTE_get0_data(attr: ?*X509_ATTRIBUTE, idx: c_int, atrtype: c_int, data: ?*anyopaque) ?*anyopaque;
pub extern fn X509_ATTRIBUTE_count(attr: ?*const X509_ATTRIBUTE) c_int;
pub extern fn X509_ATTRIBUTE_get0_object(attr: ?*X509_ATTRIBUTE) ?*ASN1_OBJECT;
pub extern fn X509_ATTRIBUTE_get0_type(attr: ?*X509_ATTRIBUTE, idx: c_int) [*c]ASN1_TYPE;
pub extern fn EVP_PKEY_get_attr_count(key: ?*const EVP_PKEY) c_int;
pub extern fn EVP_PKEY_get_attr_by_NID(key: ?*const EVP_PKEY, nid: c_int, lastpos: c_int) c_int;
pub extern fn EVP_PKEY_get_attr_by_OBJ(key: ?*const EVP_PKEY, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn EVP_PKEY_get_attr(key: ?*const EVP_PKEY, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn EVP_PKEY_delete_attr(key: ?*EVP_PKEY, loc: c_int) ?*X509_ATTRIBUTE;
pub extern fn EVP_PKEY_add1_attr(key: ?*EVP_PKEY, attr: ?*X509_ATTRIBUTE) c_int;
pub extern fn EVP_PKEY_add1_attr_by_OBJ(key: ?*EVP_PKEY, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn EVP_PKEY_add1_attr_by_NID(key: ?*EVP_PKEY, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn EVP_PKEY_add1_attr_by_txt(key: ?*EVP_PKEY, attrname: [*c]const u8, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_find_by_issuer_and_serial(sk: ?*struct_stack_st_X509, name: ?*const X509_NAME, serial: [*c]const ASN1_INTEGER) ?*X509;
pub extern fn X509_find_by_subject(sk: ?*struct_stack_st_X509, name: ?*const X509_NAME) ?*X509;
pub extern fn PBEPARAM_new() [*c]PBEPARAM;
pub extern fn PBEPARAM_free(a: [*c]PBEPARAM) void;
pub extern fn d2i_PBEPARAM(a: [*c][*c]PBEPARAM, in: [*c][*c]const u8, len: c_long) [*c]PBEPARAM;
pub extern fn i2d_PBEPARAM(a: [*c]const PBEPARAM, out: [*c][*c]u8) c_int;
pub extern fn PBEPARAM_it() ?*const ASN1_ITEM;
pub extern fn PBE2PARAM_new() [*c]PBE2PARAM;
pub extern fn PBE2PARAM_free(a: [*c]PBE2PARAM) void;
pub extern fn d2i_PBE2PARAM(a: [*c][*c]PBE2PARAM, in: [*c][*c]const u8, len: c_long) [*c]PBE2PARAM;
pub extern fn i2d_PBE2PARAM(a: [*c]const PBE2PARAM, out: [*c][*c]u8) c_int;
pub extern fn PBE2PARAM_it() ?*const ASN1_ITEM;
pub extern fn PBKDF2PARAM_new() [*c]PBKDF2PARAM;
pub extern fn PBKDF2PARAM_free(a: [*c]PBKDF2PARAM) void;
pub extern fn d2i_PBKDF2PARAM(a: [*c][*c]PBKDF2PARAM, in: [*c][*c]const u8, len: c_long) [*c]PBKDF2PARAM;
pub extern fn i2d_PBKDF2PARAM(a: [*c]const PBKDF2PARAM, out: [*c][*c]u8) c_int;
pub extern fn PBKDF2PARAM_it() ?*const ASN1_ITEM;
pub extern fn PBMAC1PARAM_new() [*c]PBMAC1PARAM;
pub extern fn PBMAC1PARAM_free(a: [*c]PBMAC1PARAM) void;
pub extern fn d2i_PBMAC1PARAM(a: [*c][*c]PBMAC1PARAM, in: [*c][*c]const u8, len: c_long) [*c]PBMAC1PARAM;
pub extern fn i2d_PBMAC1PARAM(a: [*c]const PBMAC1PARAM, out: [*c][*c]u8) c_int;
pub extern fn PBMAC1PARAM_it() ?*const ASN1_ITEM;
pub extern fn SCRYPT_PARAMS_new() [*c]SCRYPT_PARAMS;
pub extern fn SCRYPT_PARAMS_free(a: [*c]SCRYPT_PARAMS) void;
pub extern fn d2i_SCRYPT_PARAMS(a: [*c][*c]SCRYPT_PARAMS, in: [*c][*c]const u8, len: c_long) [*c]SCRYPT_PARAMS;
pub extern fn i2d_SCRYPT_PARAMS(a: [*c]const SCRYPT_PARAMS, out: [*c][*c]u8) c_int;
pub extern fn SCRYPT_PARAMS_it() ?*const ASN1_ITEM;
pub extern fn PKCS5_pbe_set0_algor(algor: [*c]X509_ALGOR, alg: c_int, iter: c_int, salt: [*c]const u8, saltlen: c_int) c_int;
pub extern fn PKCS5_pbe_set0_algor_ex(algor: [*c]X509_ALGOR, alg: c_int, iter: c_int, salt: [*c]const u8, saltlen: c_int, libctx: ?*OSSL_LIB_CTX) c_int;
pub extern fn PKCS5_pbe_set(alg: c_int, iter: c_int, salt: [*c]const u8, saltlen: c_int) [*c]X509_ALGOR;
pub extern fn PKCS5_pbe_set_ex(alg: c_int, iter: c_int, salt: [*c]const u8, saltlen: c_int, libctx: ?*OSSL_LIB_CTX) [*c]X509_ALGOR;
pub extern fn PKCS5_pbe2_set(cipher: ?*const EVP_CIPHER, iter: c_int, salt: [*c]u8, saltlen: c_int) [*c]X509_ALGOR;
pub extern fn PKCS5_pbe2_set_iv(cipher: ?*const EVP_CIPHER, iter: c_int, salt: [*c]u8, saltlen: c_int, aiv: [*c]u8, prf_nid: c_int) [*c]X509_ALGOR;
pub extern fn PKCS5_pbe2_set_iv_ex(cipher: ?*const EVP_CIPHER, iter: c_int, salt: [*c]u8, saltlen: c_int, aiv: [*c]u8, prf_nid: c_int, libctx: ?*OSSL_LIB_CTX) [*c]X509_ALGOR;
pub extern fn PKCS5_pbe2_set_scrypt(cipher: ?*const EVP_CIPHER, salt: [*c]const u8, saltlen: c_int, aiv: [*c]u8, N: u64, r: u64, p: u64) [*c]X509_ALGOR;
pub extern fn PKCS5_pbkdf2_set(iter: c_int, salt: [*c]u8, saltlen: c_int, prf_nid: c_int, keylen: c_int) [*c]X509_ALGOR;
pub extern fn PKCS5_pbkdf2_set_ex(iter: c_int, salt: [*c]u8, saltlen: c_int, prf_nid: c_int, keylen: c_int, libctx: ?*OSSL_LIB_CTX) [*c]X509_ALGOR;
pub extern fn PBMAC1_get1_pbkdf2_param(macalg: [*c]const X509_ALGOR) [*c]PBKDF2PARAM;
pub extern fn PKCS8_PRIV_KEY_INFO_new() ?*PKCS8_PRIV_KEY_INFO;
pub extern fn PKCS8_PRIV_KEY_INFO_free(a: ?*PKCS8_PRIV_KEY_INFO) void;
pub extern fn d2i_PKCS8_PRIV_KEY_INFO(a: [*c]?*PKCS8_PRIV_KEY_INFO, in: [*c][*c]const u8, len: c_long) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn i2d_PKCS8_PRIV_KEY_INFO(a: ?*const PKCS8_PRIV_KEY_INFO, out: [*c][*c]u8) c_int;
pub extern fn PKCS8_PRIV_KEY_INFO_it() ?*const ASN1_ITEM;
pub extern fn EVP_PKCS82PKEY(p8: ?*const PKCS8_PRIV_KEY_INFO) ?*EVP_PKEY;
pub extern fn EVP_PKCS82PKEY_ex(p8: ?*const PKCS8_PRIV_KEY_INFO, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn EVP_PKEY2PKCS8(pkey: ?*const EVP_PKEY) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn PKCS8_pkey_set0(priv: ?*PKCS8_PRIV_KEY_INFO, aobj: ?*ASN1_OBJECT, version: c_int, ptype: c_int, pval: ?*anyopaque, penc: [*c]u8, penclen: c_int) c_int;
pub extern fn PKCS8_pkey_get0(ppkalg: [*c]?*const ASN1_OBJECT, pk: [*c][*c]const u8, ppklen: [*c]c_int, pa: [*c][*c]const X509_ALGOR, p8: ?*const PKCS8_PRIV_KEY_INFO) c_int;
pub extern fn PKCS8_pkey_get0_attrs(p8: ?*const PKCS8_PRIV_KEY_INFO) ?*const struct_stack_st_X509_ATTRIBUTE;
pub extern fn PKCS8_pkey_add1_attr(p8: ?*PKCS8_PRIV_KEY_INFO, attr: ?*X509_ATTRIBUTE) c_int;
pub extern fn PKCS8_pkey_add1_attr_by_NID(p8: ?*PKCS8_PRIV_KEY_INFO, nid: c_int, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn PKCS8_pkey_add1_attr_by_OBJ(p8: ?*PKCS8_PRIV_KEY_INFO, obj: ?*const ASN1_OBJECT, @"type": c_int, bytes: [*c]const u8, len: c_int) c_int;
pub extern fn X509_PUBKEY_set0_public_key(@"pub": ?*X509_PUBKEY, penc: [*c]u8, penclen: c_int) void;
pub extern fn X509_PUBKEY_set0_param(@"pub": ?*X509_PUBKEY, aobj: ?*ASN1_OBJECT, ptype: c_int, pval: ?*anyopaque, penc: [*c]u8, penclen: c_int) c_int;
pub extern fn X509_PUBKEY_get0_param(ppkalg: [*c]?*ASN1_OBJECT, pk: [*c][*c]const u8, ppklen: [*c]c_int, pa: [*c][*c]X509_ALGOR, @"pub": ?*const X509_PUBKEY) c_int;
pub extern fn X509_PUBKEY_eq(a: ?*const X509_PUBKEY, b: ?*const X509_PUBKEY) c_int;
pub extern fn PEM_get_EVP_CIPHER_INFO(header: [*c]u8, cipher: [*c]EVP_CIPHER_INFO) c_int;
pub extern fn PEM_do_header(cipher: [*c]EVP_CIPHER_INFO, data: [*c]u8, len: [*c]c_long, callback: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read_bio(bp: ?*BIO, name: [*c][*c]u8, header: [*c][*c]u8, data: [*c][*c]u8, len: [*c]c_long) c_int;
pub extern fn PEM_read_bio_ex(bp: ?*BIO, name: [*c][*c]u8, header: [*c][*c]u8, data: [*c][*c]u8, len: [*c]c_long, flags: c_uint) c_int;
pub extern fn PEM_bytes_read_bio_secmem(pdata: [*c][*c]u8, plen: [*c]c_long, pnm: [*c][*c]u8, name: [*c]const u8, bp: ?*BIO, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_bio(bp: ?*BIO, name: [*c]const u8, hdr: [*c]const u8, data: [*c]const u8, len: c_long) c_int;
pub extern fn PEM_bytes_read_bio(pdata: [*c][*c]u8, plen: [*c]c_long, pnm: [*c][*c]u8, name: [*c]const u8, bp: ?*BIO, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_ASN1_read_bio(d2i: ?*const d2i_of_void, name: [*c]const u8, bp: ?*BIO, x: [*c]?*anyopaque, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*anyopaque;
pub extern fn PEM_ASN1_write_bio(i2d: ?*const i2d_of_void, name: [*c]const u8, bp: ?*BIO, x: ?*const anyopaque, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_X509_INFO_read_bio(bp: ?*BIO, sk: ?*struct_stack_st_X509_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*struct_stack_st_X509_INFO;
pub extern fn PEM_X509_INFO_read_bio_ex(bp: ?*BIO, sk: ?*struct_stack_st_X509_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*struct_stack_st_X509_INFO;
pub extern fn PEM_X509_INFO_write_bio(bp: ?*BIO, xi: [*c]const X509_INFO, enc: ?*EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cd: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read(fp: [*c]FILE, name: [*c][*c]u8, header: [*c][*c]u8, data: [*c][*c]u8, len: [*c]c_long) c_int;
pub extern fn PEM_write(fp: [*c]FILE, name: [*c]const u8, hdr: [*c]const u8, data: [*c]const u8, len: c_long) c_int;
pub extern fn PEM_ASN1_read(d2i: ?*const d2i_of_void, name: [*c]const u8, fp: [*c]FILE, x: [*c]?*anyopaque, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*anyopaque;
pub extern fn PEM_ASN1_write(i2d: ?*const i2d_of_void, name: [*c]const u8, fp: [*c]FILE, x: ?*const anyopaque, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, callback: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_X509_INFO_read(fp: [*c]FILE, sk: ?*struct_stack_st_X509_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*struct_stack_st_X509_INFO;
pub extern fn PEM_X509_INFO_read_ex(fp: [*c]FILE, sk: ?*struct_stack_st_X509_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*struct_stack_st_X509_INFO;
pub extern fn PEM_SignInit(ctx: ?*EVP_MD_CTX, @"type": ?*EVP_MD) c_int;
pub extern fn PEM_SignUpdate(ctx: ?*EVP_MD_CTX, d: [*c]const u8, cnt: c_uint) c_int;
pub extern fn PEM_SignFinal(ctx: ?*EVP_MD_CTX, sigret: [*c]u8, siglen: [*c]c_uint, pkey: ?*EVP_PKEY) c_int;
pub extern fn PEM_def_callback(buf: [*c]u8, num: c_int, rwflag: c_int, userdata: ?*anyopaque) c_int;
pub extern fn PEM_proc_type(buf: [*c]u8, @"type": c_int) void;
pub extern fn PEM_dek_info(buf: [*c]u8, @"type": [*c]const u8, len: c_int, str: [*c]const u8) void;
pub extern fn PEM_read_bio_X509(out: ?*BIO, x: [*c]?*X509, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509;
pub extern fn PEM_read_X509(out: [*c]FILE, x: [*c]?*X509, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509;
pub extern fn PEM_write_bio_X509(out: ?*BIO, x: ?*const X509) c_int;
pub extern fn PEM_write_X509(out: [*c]FILE, x: ?*const X509) c_int;
pub extern fn PEM_read_bio_X509_AUX(out: ?*BIO, x: [*c]?*X509, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509;
pub extern fn PEM_read_X509_AUX(out: [*c]FILE, x: [*c]?*X509, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509;
pub extern fn PEM_write_bio_X509_AUX(out: ?*BIO, x: ?*const X509) c_int;
pub extern fn PEM_write_X509_AUX(out: [*c]FILE, x: ?*const X509) c_int;
pub extern fn PEM_read_bio_X509_REQ(out: ?*BIO, x: [*c]?*X509_REQ, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_REQ;
pub extern fn PEM_read_X509_REQ(out: [*c]FILE, x: [*c]?*X509_REQ, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_REQ;
pub extern fn PEM_write_bio_X509_REQ(out: ?*BIO, x: ?*const X509_REQ) c_int;
pub extern fn PEM_write_X509_REQ(out: [*c]FILE, x: ?*const X509_REQ) c_int;
pub extern fn PEM_write_bio_X509_REQ_NEW(out: ?*BIO, x: ?*const X509_REQ) c_int;
pub extern fn PEM_write_X509_REQ_NEW(out: [*c]FILE, x: ?*const X509_REQ) c_int;
pub extern fn PEM_read_bio_X509_CRL(out: ?*BIO, x: [*c]?*X509_CRL, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_CRL;
pub extern fn PEM_read_X509_CRL(out: [*c]FILE, x: [*c]?*X509_CRL, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_CRL;
pub extern fn PEM_write_bio_X509_CRL(out: ?*BIO, x: ?*const X509_CRL) c_int;
pub extern fn PEM_write_X509_CRL(out: [*c]FILE, x: ?*const X509_CRL) c_int;
pub extern fn PEM_read_bio_X509_PUBKEY(out: ?*BIO, x: [*c]?*X509_PUBKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_PUBKEY;
pub extern fn PEM_read_X509_PUBKEY(out: [*c]FILE, x: [*c]?*X509_PUBKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_PUBKEY;
pub extern fn PEM_write_bio_X509_PUBKEY(out: ?*BIO, x: ?*const X509_PUBKEY) c_int;
pub extern fn PEM_write_X509_PUBKEY(out: [*c]FILE, x: ?*const X509_PUBKEY) c_int;
pub extern fn PEM_read_bio_PKCS7(out: ?*BIO, x: [*c][*c]PKCS7, cb: ?*const pem_password_cb, u: ?*anyopaque) [*c]PKCS7;
pub extern fn PEM_read_PKCS7(out: [*c]FILE, x: [*c][*c]PKCS7, cb: ?*const pem_password_cb, u: ?*anyopaque) [*c]PKCS7;
pub extern fn PEM_write_bio_PKCS7(out: ?*BIO, x: [*c]const PKCS7) c_int;
pub extern fn PEM_write_PKCS7(out: [*c]FILE, x: [*c]const PKCS7) c_int;
pub extern fn PEM_read_bio_NETSCAPE_CERT_SEQUENCE(out: ?*BIO, x: [*c][*c]NETSCAPE_CERT_SEQUENCE, cb: ?*const pem_password_cb, u: ?*anyopaque) [*c]NETSCAPE_CERT_SEQUENCE;
pub extern fn PEM_read_NETSCAPE_CERT_SEQUENCE(out: [*c]FILE, x: [*c][*c]NETSCAPE_CERT_SEQUENCE, cb: ?*const pem_password_cb, u: ?*anyopaque) [*c]NETSCAPE_CERT_SEQUENCE;
pub extern fn PEM_write_bio_NETSCAPE_CERT_SEQUENCE(out: ?*BIO, x: [*c]const NETSCAPE_CERT_SEQUENCE) c_int;
pub extern fn PEM_write_NETSCAPE_CERT_SEQUENCE(out: [*c]FILE, x: [*c]const NETSCAPE_CERT_SEQUENCE) c_int;
pub extern fn PEM_read_bio_PKCS8(out: ?*BIO, x: [*c]?*X509_SIG, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_SIG;
pub extern fn PEM_read_PKCS8(out: [*c]FILE, x: [*c]?*X509_SIG, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*X509_SIG;
pub extern fn PEM_write_bio_PKCS8(out: ?*BIO, x: ?*const X509_SIG) c_int;
pub extern fn PEM_write_PKCS8(out: [*c]FILE, x: ?*const X509_SIG) c_int;
pub extern fn PEM_read_bio_PKCS8_PRIV_KEY_INFO(out: ?*BIO, x: [*c]?*PKCS8_PRIV_KEY_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn PEM_read_PKCS8_PRIV_KEY_INFO(out: [*c]FILE, x: [*c]?*PKCS8_PRIV_KEY_INFO, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*PKCS8_PRIV_KEY_INFO;
pub extern fn PEM_write_bio_PKCS8_PRIV_KEY_INFO(out: ?*BIO, x: ?*const PKCS8_PRIV_KEY_INFO) c_int;
pub extern fn PEM_write_PKCS8_PRIV_KEY_INFO(out: [*c]FILE, x: ?*const PKCS8_PRIV_KEY_INFO) c_int;
pub extern fn PEM_read_bio_RSAPrivateKey(out: ?*BIO, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_read_RSAPrivateKey(out: [*c]FILE, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_write_bio_RSAPrivateKey(out: ?*BIO, x: ?*const RSA, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_RSAPrivateKey(out: [*c]FILE, x: ?*const RSA, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read_bio_RSAPublicKey(out: ?*BIO, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_read_RSAPublicKey(out: [*c]FILE, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_write_bio_RSAPublicKey(out: ?*BIO, x: ?*const RSA) c_int;
pub extern fn PEM_write_RSAPublicKey(out: [*c]FILE, x: ?*const RSA) c_int;
pub extern fn PEM_read_bio_RSA_PUBKEY(out: ?*BIO, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_read_RSA_PUBKEY(out: [*c]FILE, x: [*c]?*RSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*RSA;
pub extern fn PEM_write_bio_RSA_PUBKEY(out: ?*BIO, x: ?*const RSA) c_int;
pub extern fn PEM_write_RSA_PUBKEY(out: [*c]FILE, x: ?*const RSA) c_int;
pub extern fn PEM_read_bio_DSAPrivateKey(out: ?*BIO, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_read_DSAPrivateKey(out: [*c]FILE, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_write_bio_DSAPrivateKey(out: ?*BIO, x: ?*const DSA, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_DSAPrivateKey(out: [*c]FILE, x: ?*const DSA, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read_bio_DSA_PUBKEY(out: ?*BIO, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_read_DSA_PUBKEY(out: [*c]FILE, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_write_bio_DSA_PUBKEY(out: ?*BIO, x: ?*const DSA) c_int;
pub extern fn PEM_write_DSA_PUBKEY(out: [*c]FILE, x: ?*const DSA) c_int;
pub extern fn PEM_read_bio_DSAparams(out: ?*BIO, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_read_DSAparams(out: [*c]FILE, x: [*c]?*DSA, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DSA;
pub extern fn PEM_write_bio_DSAparams(out: ?*BIO, x: ?*const DSA) c_int;
pub extern fn PEM_write_DSAparams(out: [*c]FILE, x: ?*const DSA) c_int;
pub extern fn PEM_read_bio_ECPKParameters(out: ?*BIO, x: [*c]?*EC_GROUP, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_GROUP;
pub extern fn PEM_read_ECPKParameters(out: [*c]FILE, x: [*c]?*EC_GROUP, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_GROUP;
pub extern fn PEM_write_bio_ECPKParameters(out: ?*BIO, x: ?*const EC_GROUP) c_int;
pub extern fn PEM_write_ECPKParameters(out: [*c]FILE, x: ?*const EC_GROUP) c_int;
pub extern fn PEM_read_bio_ECPrivateKey(out: ?*BIO, x: [*c]?*EC_KEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_KEY;
pub extern fn PEM_read_ECPrivateKey(out: [*c]FILE, x: [*c]?*EC_KEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_KEY;
pub extern fn PEM_write_bio_ECPrivateKey(out: ?*BIO, x: ?*const EC_KEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_ECPrivateKey(out: [*c]FILE, x: ?*const EC_KEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read_bio_EC_PUBKEY(out: ?*BIO, x: [*c]?*EC_KEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_KEY;
pub extern fn PEM_read_EC_PUBKEY(out: [*c]FILE, x: [*c]?*EC_KEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EC_KEY;
pub extern fn PEM_write_bio_EC_PUBKEY(out: ?*BIO, x: ?*const EC_KEY) c_int;
pub extern fn PEM_write_EC_PUBKEY(out: [*c]FILE, x: ?*const EC_KEY) c_int;
pub extern fn PEM_read_bio_DHparams(out: ?*BIO, x: [*c]?*DH, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DH;
pub extern fn PEM_read_DHparams(out: [*c]FILE, x: [*c]?*DH, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*DH;
pub extern fn PEM_write_bio_DHparams(out: ?*BIO, x: ?*const DH) c_int;
pub extern fn PEM_write_DHparams(out: [*c]FILE, x: ?*const DH) c_int;
pub extern fn PEM_write_bio_DHxparams(out: ?*BIO, x: ?*const DH) c_int;
pub extern fn PEM_write_DHxparams(out: [*c]FILE, x: ?*const DH) c_int;
pub extern fn PEM_read_bio_PrivateKey(out: ?*BIO, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn PEM_read_bio_PrivateKey_ex(out: ?*BIO, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn PEM_read_PrivateKey(out: [*c]FILE, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn PEM_read_PrivateKey_ex(out: [*c]FILE, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn PEM_write_bio_PrivateKey(out: ?*BIO, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_bio_PrivateKey_ex(out: ?*BIO, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PEM_write_PrivateKey(out: [*c]FILE, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_PrivateKey_ex(out: [*c]FILE, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PEM_read_bio_PUBKEY(out: ?*BIO, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn PEM_read_bio_PUBKEY_ex(out: ?*BIO, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn PEM_read_PUBKEY(out: [*c]FILE, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn PEM_read_PUBKEY_ex(out: [*c]FILE, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn PEM_write_bio_PUBKEY(out: ?*BIO, x: ?*const EVP_PKEY) c_int;
pub extern fn PEM_write_bio_PUBKEY_ex(out: ?*BIO, x: ?*const EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PEM_write_PUBKEY(out: [*c]FILE, x: ?*const EVP_PKEY) c_int;
pub extern fn PEM_write_PUBKEY_ex(out: [*c]FILE, x: ?*const EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn PEM_write_bio_PrivateKey_traditional(bp: ?*BIO, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_bio_PKCS8PrivateKey_nid(bp: ?*BIO, x: ?*const EVP_PKEY, nid: c_int, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_bio_PKCS8PrivateKey(?*BIO, ?*const EVP_PKEY, ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn i2d_PKCS8PrivateKey_bio(bp: ?*BIO, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn i2d_PKCS8PrivateKey_nid_bio(bp: ?*BIO, x: ?*const EVP_PKEY, nid: c_int, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn d2i_PKCS8PrivateKey_bio(bp: ?*BIO, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn i2d_PKCS8PrivateKey_fp(fp: [*c]FILE, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn i2d_PKCS8PrivateKey_nid_fp(fp: [*c]FILE, x: ?*const EVP_PKEY, nid: c_int, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_write_PKCS8PrivateKey_nid(fp: [*c]FILE, x: ?*const EVP_PKEY, nid: c_int, kstr: [*c]const u8, klen: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn d2i_PKCS8PrivateKey_fp(fp: [*c]FILE, x: [*c]?*EVP_PKEY, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn PEM_write_PKCS8PrivateKey(fp: [*c]FILE, x: ?*const EVP_PKEY, enc: ?*const EVP_CIPHER, kstr: [*c]const u8, klen: c_int, cd: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn PEM_read_bio_Parameters_ex(bp: ?*BIO, x: [*c]?*EVP_PKEY, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn PEM_read_bio_Parameters(bp: ?*BIO, x: [*c]?*EVP_PKEY) ?*EVP_PKEY;
pub extern fn PEM_write_bio_Parameters(bp: ?*BIO, x: ?*const EVP_PKEY) c_int;
pub extern fn b2i_PrivateKey(in: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn b2i_PublicKey(in: [*c][*c]const u8, length: c_long) ?*EVP_PKEY;
pub extern fn b2i_PrivateKey_bio(in: ?*BIO) ?*EVP_PKEY;
pub extern fn b2i_PublicKey_bio(in: ?*BIO) ?*EVP_PKEY;
pub extern fn i2b_PrivateKey_bio(out: ?*BIO, pk: ?*const EVP_PKEY) c_int;
pub extern fn i2b_PublicKey_bio(out: ?*BIO, pk: ?*const EVP_PKEY) c_int;
pub extern fn b2i_PVK_bio(in: ?*BIO, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*EVP_PKEY;
pub extern fn b2i_PVK_bio_ex(in: ?*BIO, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*EVP_PKEY;
pub extern fn i2b_PVK_bio(out: ?*BIO, pk: ?*const EVP_PKEY, enclevel: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque) c_int;
pub extern fn i2b_PVK_bio_ex(out: ?*BIO, pk: ?*const EVP_PKEY, enclevel: c_int, cb: ?*const pem_password_cb, u: ?*anyopaque, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn HMAC_size(e: ?*const HMAC_CTX) usize;
pub extern fn HMAC_CTX_new() ?*HMAC_CTX;
pub extern fn HMAC_CTX_reset(ctx: ?*HMAC_CTX) c_int;
pub extern fn HMAC_CTX_free(ctx: ?*HMAC_CTX) void;
pub extern fn HMAC_Init(ctx: ?*HMAC_CTX, key: ?*const anyopaque, len: c_int, md: ?*const EVP_MD) c_int;
pub extern fn HMAC_Init_ex(ctx: ?*HMAC_CTX, key: ?*const anyopaque, len: c_int, md: ?*const EVP_MD, impl: ?*ENGINE) c_int;
pub extern fn HMAC_Update(ctx: ?*HMAC_CTX, data: [*c]const u8, len: usize) c_int;
pub extern fn HMAC_Final(ctx: ?*HMAC_CTX, md: [*c]u8, len: [*c]c_uint) c_int;
pub extern fn HMAC_CTX_copy(dctx: ?*HMAC_CTX, sctx: ?*HMAC_CTX) c_int;
pub extern fn HMAC_CTX_set_flags(ctx: ?*HMAC_CTX, flags: c_ulong) void;
pub extern fn HMAC_CTX_get_md(ctx: ?*const HMAC_CTX) ?*const EVP_MD;
pub extern fn HMAC(evp_md: ?*const EVP_MD, key: ?*const anyopaque, key_len: c_int, data: [*c]const u8, data_len: usize, md: [*c]u8, md_len: [*c]c_uint) [*c]u8;
pub const struct_async_job_st = opaque {};
pub const ASYNC_JOB = struct_async_job_st;
pub const struct_async_wait_ctx_st = opaque {};
pub const ASYNC_WAIT_CTX = struct_async_wait_ctx_st;
pub const ASYNC_callback_fn = ?*const fn (?*anyopaque) callconv(.c) c_int;
pub extern fn ASYNC_init_thread(max_size: usize, init_size: usize) c_int;
pub extern fn ASYNC_cleanup_thread() void;
pub extern fn ASYNC_WAIT_CTX_new() ?*ASYNC_WAIT_CTX;
pub extern fn ASYNC_WAIT_CTX_free(ctx: ?*ASYNC_WAIT_CTX) void;
pub extern fn ASYNC_WAIT_CTX_set_wait_fd(ctx: ?*ASYNC_WAIT_CTX, key: ?*const anyopaque, fd: c_int, custom_data: ?*anyopaque, cleanup: ?*const fn (?*ASYNC_WAIT_CTX, ?*const anyopaque, c_int, ?*anyopaque) callconv(.c) void) c_int;
pub extern fn ASYNC_WAIT_CTX_get_fd(ctx: ?*ASYNC_WAIT_CTX, key: ?*const anyopaque, fd: [*c]c_int, custom_data: [*c]?*anyopaque) c_int;
pub extern fn ASYNC_WAIT_CTX_get_all_fds(ctx: ?*ASYNC_WAIT_CTX, fd: [*c]c_int, numfds: [*c]usize) c_int;
pub extern fn ASYNC_WAIT_CTX_get_callback(ctx: ?*ASYNC_WAIT_CTX, callback: [*c]ASYNC_callback_fn, callback_arg: [*c]?*anyopaque) c_int;
pub extern fn ASYNC_WAIT_CTX_set_callback(ctx: ?*ASYNC_WAIT_CTX, callback: ASYNC_callback_fn, callback_arg: ?*anyopaque) c_int;
pub extern fn ASYNC_WAIT_CTX_set_status(ctx: ?*ASYNC_WAIT_CTX, status: c_int) c_int;
pub extern fn ASYNC_WAIT_CTX_get_status(ctx: ?*ASYNC_WAIT_CTX) c_int;
pub extern fn ASYNC_WAIT_CTX_get_changed_fds(ctx: ?*ASYNC_WAIT_CTX, addfd: [*c]c_int, numaddfds: [*c]usize, delfd: [*c]c_int, numdelfds: [*c]usize) c_int;
pub extern fn ASYNC_WAIT_CTX_clear_fd(ctx: ?*ASYNC_WAIT_CTX, key: ?*const anyopaque) c_int;
pub extern fn ASYNC_is_capable() c_int;
pub const ASYNC_stack_alloc_fn = ?*const fn ([*c]usize) callconv(.c) ?*anyopaque;
pub const ASYNC_stack_free_fn = ?*const fn (?*anyopaque) callconv(.c) void;
pub extern fn ASYNC_set_mem_functions(alloc_fn: ASYNC_stack_alloc_fn, free_fn: ASYNC_stack_free_fn) c_int;
pub extern fn ASYNC_get_mem_functions(alloc_fn: [*c]ASYNC_stack_alloc_fn, free_fn: [*c]ASYNC_stack_free_fn) void;
pub extern fn ASYNC_start_job(job: [*c]?*ASYNC_JOB, ctx: ?*ASYNC_WAIT_CTX, ret: [*c]c_int, func: ?*const fn (?*anyopaque) callconv(.c) c_int, args: ?*anyopaque, size: usize) c_int;
pub extern fn ASYNC_pause_job() c_int;
pub extern fn ASYNC_get_current_job() ?*ASYNC_JOB;
pub extern fn ASYNC_get_wait_ctx(job: ?*ASYNC_JOB) ?*ASYNC_WAIT_CTX;
pub extern fn ASYNC_block_pause() void;
pub extern fn ASYNC_unblock_pause() void;
pub const struct_stack_st_SCT = opaque {};
pub const sk_SCT_compfunc = ?*const fn ([*c]const ?*const SCT, [*c]const ?*const SCT) callconv(.c) c_int;
pub const sk_SCT_freefunc = ?*const fn (?*SCT) callconv(.c) void;
pub const sk_SCT_copyfunc = ?*const fn (?*const SCT) callconv(.c) ?*SCT;
pub fn ossl_check_SCT_type(arg_ptr: ?*SCT) callconv(.c) ?*SCT {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_SCT_sk_type(arg_sk: ?*const struct_stack_st_SCT) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SCT_sk_type(arg_sk: ?*struct_stack_st_SCT) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SCT_compfunc_type(arg_cmp: sk_SCT_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_SCT_copyfunc_type(arg_cpy: sk_SCT_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_SCT_freefunc_type(arg_fr: sk_SCT_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_CTLOG = opaque {};
pub const sk_CTLOG_compfunc = ?*const fn ([*c]const ?*const CTLOG, [*c]const ?*const CTLOG) callconv(.c) c_int;
pub const sk_CTLOG_freefunc = ?*const fn (?*CTLOG) callconv(.c) void;
pub const sk_CTLOG_copyfunc = ?*const fn (?*const CTLOG) callconv(.c) ?*CTLOG;
pub fn ossl_check_CTLOG_type(arg_ptr: ?*CTLOG) callconv(.c) ?*CTLOG {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_CTLOG_sk_type(arg_sk: ?*const struct_stack_st_CTLOG) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_CTLOG_sk_type(arg_sk: ?*struct_stack_st_CTLOG) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_CTLOG_compfunc_type(arg_cmp: sk_CTLOG_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_CTLOG_copyfunc_type(arg_cpy: sk_CTLOG_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_CTLOG_freefunc_type(arg_fr: sk_CTLOG_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const CT_LOG_ENTRY_TYPE_NOT_SET: c_int = -1;
pub const CT_LOG_ENTRY_TYPE_X509: c_int = 0;
pub const CT_LOG_ENTRY_TYPE_PRECERT: c_int = 1;
pub const ct_log_entry_type_t = c_int;
pub const SCT_VERSION_NOT_SET: c_int = -1;
pub const SCT_VERSION_V1: c_int = 0;
pub const sct_version_t = c_int;
pub const SCT_SOURCE_UNKNOWN: c_int = 0;
pub const SCT_SOURCE_TLS_EXTENSION: c_int = 1;
pub const SCT_SOURCE_X509V3_EXTENSION: c_int = 2;
pub const SCT_SOURCE_OCSP_STAPLED_RESPONSE: c_int = 3;
pub const sct_source_t = c_uint;
pub const SCT_VALIDATION_STATUS_NOT_SET: c_int = 0;
pub const SCT_VALIDATION_STATUS_UNKNOWN_LOG: c_int = 1;
pub const SCT_VALIDATION_STATUS_VALID: c_int = 2;
pub const SCT_VALIDATION_STATUS_INVALID: c_int = 3;
pub const SCT_VALIDATION_STATUS_UNVERIFIED: c_int = 4;
pub const SCT_VALIDATION_STATUS_UNKNOWN_VERSION: c_int = 5;
pub const sct_validation_status_t = c_uint;
pub extern fn CT_POLICY_EVAL_CTX_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*CT_POLICY_EVAL_CTX;
pub extern fn CT_POLICY_EVAL_CTX_new() ?*CT_POLICY_EVAL_CTX;
pub extern fn CT_POLICY_EVAL_CTX_free(ctx: ?*CT_POLICY_EVAL_CTX) void;
pub extern fn CT_POLICY_EVAL_CTX_get0_cert(ctx: ?*const CT_POLICY_EVAL_CTX) ?*X509;
pub extern fn CT_POLICY_EVAL_CTX_set1_cert(ctx: ?*CT_POLICY_EVAL_CTX, cert: ?*X509) c_int;
pub extern fn CT_POLICY_EVAL_CTX_get0_issuer(ctx: ?*const CT_POLICY_EVAL_CTX) ?*X509;
pub extern fn CT_POLICY_EVAL_CTX_set1_issuer(ctx: ?*CT_POLICY_EVAL_CTX, issuer: ?*X509) c_int;
pub extern fn CT_POLICY_EVAL_CTX_get0_log_store(ctx: ?*const CT_POLICY_EVAL_CTX) ?*const CTLOG_STORE;
pub extern fn CT_POLICY_EVAL_CTX_set_shared_CTLOG_STORE(ctx: ?*CT_POLICY_EVAL_CTX, log_store: ?*CTLOG_STORE) void;
pub extern fn CT_POLICY_EVAL_CTX_get_time(ctx: ?*const CT_POLICY_EVAL_CTX) u64;
pub extern fn CT_POLICY_EVAL_CTX_set_time(ctx: ?*CT_POLICY_EVAL_CTX, time_in_ms: u64) void;
pub extern fn SCT_new() ?*SCT;
pub extern fn SCT_new_from_base64(version: u8, logid_base64: [*c]const u8, entry_type: ct_log_entry_type_t, timestamp: u64, extensions_base64: [*c]const u8, signature_base64: [*c]const u8) ?*SCT;
pub extern fn SCT_free(sct: ?*SCT) void;
pub extern fn SCT_LIST_free(a: ?*struct_stack_st_SCT) void;
pub extern fn SCT_get_version(sct: ?*const SCT) sct_version_t;
pub extern fn SCT_set_version(sct: ?*SCT, version: sct_version_t) c_int;
pub extern fn SCT_get_log_entry_type(sct: ?*const SCT) ct_log_entry_type_t;
pub extern fn SCT_set_log_entry_type(sct: ?*SCT, entry_type: ct_log_entry_type_t) c_int;
pub extern fn SCT_get0_log_id(sct: ?*const SCT, log_id: [*c][*c]u8) usize;
pub extern fn SCT_set0_log_id(sct: ?*SCT, log_id: [*c]u8, log_id_len: usize) c_int;
pub extern fn SCT_set1_log_id(sct: ?*SCT, log_id: [*c]const u8, log_id_len: usize) c_int;
pub extern fn SCT_get_timestamp(sct: ?*const SCT) u64;
pub extern fn SCT_set_timestamp(sct: ?*SCT, timestamp: u64) void;
pub extern fn SCT_get_signature_nid(sct: ?*const SCT) c_int;
pub extern fn SCT_set_signature_nid(sct: ?*SCT, nid: c_int) c_int;
pub extern fn SCT_get0_extensions(sct: ?*const SCT, ext: [*c][*c]u8) usize;
pub extern fn SCT_set0_extensions(sct: ?*SCT, ext: [*c]u8, ext_len: usize) void;
pub extern fn SCT_set1_extensions(sct: ?*SCT, ext: [*c]const u8, ext_len: usize) c_int;
pub extern fn SCT_get0_signature(sct: ?*const SCT, sig: [*c][*c]u8) usize;
pub extern fn SCT_set0_signature(sct: ?*SCT, sig: [*c]u8, sig_len: usize) void;
pub extern fn SCT_set1_signature(sct: ?*SCT, sig: [*c]const u8, sig_len: usize) c_int;
pub extern fn SCT_get_source(sct: ?*const SCT) sct_source_t;
pub extern fn SCT_set_source(sct: ?*SCT, source: sct_source_t) c_int;
pub extern fn SCT_validation_status_string(sct: ?*const SCT) [*c]const u8;
pub extern fn SCT_print(sct: ?*const SCT, out: ?*BIO, indent: c_int, logs: ?*const CTLOG_STORE) void;
pub extern fn SCT_LIST_print(sct_list: ?*const struct_stack_st_SCT, out: ?*BIO, indent: c_int, separator: [*c]const u8, logs: ?*const CTLOG_STORE) void;
pub extern fn SCT_get_validation_status(sct: ?*const SCT) sct_validation_status_t;
pub extern fn SCT_validate(sct: ?*SCT, ctx: ?*const CT_POLICY_EVAL_CTX) c_int;
pub extern fn SCT_LIST_validate(scts: ?*const struct_stack_st_SCT, ctx: ?*CT_POLICY_EVAL_CTX) c_int;
pub extern fn i2o_SCT_LIST(a: ?*const struct_stack_st_SCT, pp: [*c][*c]u8) c_int;
pub extern fn o2i_SCT_LIST(a: [*c]?*struct_stack_st_SCT, pp: [*c][*c]const u8, len: usize) ?*struct_stack_st_SCT;
pub extern fn i2d_SCT_LIST(a: ?*const struct_stack_st_SCT, pp: [*c][*c]u8) c_int;
pub extern fn d2i_SCT_LIST(a: [*c]?*struct_stack_st_SCT, pp: [*c][*c]const u8, len: c_long) ?*struct_stack_st_SCT;
pub extern fn i2o_SCT(sct: ?*const SCT, out: [*c][*c]u8) c_int;
pub extern fn o2i_SCT(psct: [*c]?*SCT, in: [*c][*c]const u8, len: usize) ?*SCT;
pub extern fn CTLOG_new_ex(public_key: ?*EVP_PKEY, name: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*CTLOG;
pub extern fn CTLOG_new(public_key: ?*EVP_PKEY, name: [*c]const u8) ?*CTLOG;
pub extern fn CTLOG_new_from_base64_ex(ct_log: [*c]?*CTLOG, pkey_base64: [*c]const u8, name: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn CTLOG_new_from_base64(ct_log: [*c]?*CTLOG, pkey_base64: [*c]const u8, name: [*c]const u8) c_int;
pub extern fn CTLOG_free(log: ?*CTLOG) void;
pub extern fn CTLOG_get0_name(log: ?*const CTLOG) [*c]const u8;
pub extern fn CTLOG_get0_log_id(log: ?*const CTLOG, log_id: [*c][*c]const u8, log_id_len: [*c]usize) void;
pub extern fn CTLOG_get0_public_key(log: ?*const CTLOG) ?*EVP_PKEY;
pub extern fn CTLOG_STORE_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*CTLOG_STORE;
pub extern fn CTLOG_STORE_new() ?*CTLOG_STORE;
pub extern fn CTLOG_STORE_free(store: ?*CTLOG_STORE) void;
pub extern fn CTLOG_STORE_get0_log_by_id(store: ?*const CTLOG_STORE, log_id: [*c]const u8, log_id_len: usize) ?*const CTLOG;
pub extern fn CTLOG_STORE_load_file(store: ?*CTLOG_STORE, file: [*c]const u8) c_int;
pub extern fn CTLOG_STORE_load_default_file(store: ?*CTLOG_STORE) c_int;
pub extern fn ERR_load_SSL_strings() c_int;
pub const ssl_crock_st = ?*struct_ssl_st;
pub const struct_tls_session_ticket_ext_st = extern struct {
    length: c_ushort = @import("std").mem.zeroes(c_ushort),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const TLS_SESSION_TICKET_EXT = struct_tls_session_ticket_ext_st;
pub const struct_ssl_method_st = opaque {};
pub const SSL_METHOD = struct_ssl_method_st;
pub const struct_ssl_cipher_st = opaque {};
pub const SSL_CIPHER = struct_ssl_cipher_st;
pub const struct_tls_sigalgs_st = opaque {};
pub const TLS_SIGALGS = struct_tls_sigalgs_st;
pub const struct_ssl_conf_ctx_st = opaque {};
pub const SSL_CONF_CTX = struct_ssl_conf_ctx_st;
pub const struct_stack_st_SSL_CIPHER = opaque {};
pub const struct_srtp_protection_profile_st = extern struct {
    name: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    id: c_ulong = @import("std").mem.zeroes(c_ulong),
};
pub const SRTP_PROTECTION_PROFILE = struct_srtp_protection_profile_st;
pub const struct_stack_st_SRTP_PROTECTION_PROFILE = opaque {};
pub const sk_SRTP_PROTECTION_PROFILE_compfunc = ?*const fn ([*c]const [*c]const SRTP_PROTECTION_PROFILE, [*c]const [*c]const SRTP_PROTECTION_PROFILE) callconv(.c) c_int;
pub const sk_SRTP_PROTECTION_PROFILE_freefunc = ?*const fn ([*c]SRTP_PROTECTION_PROFILE) callconv(.c) void;
pub const sk_SRTP_PROTECTION_PROFILE_copyfunc = ?*const fn ([*c]const SRTP_PROTECTION_PROFILE) callconv(.c) [*c]SRTP_PROTECTION_PROFILE;
pub fn ossl_check_SRTP_PROTECTION_PROFILE_type(arg_ptr: [*c]SRTP_PROTECTION_PROFILE) callconv(.c) [*c]SRTP_PROTECTION_PROFILE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(arg_sk: ?*const struct_stack_st_SRTP_PROTECTION_PROFILE) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SRTP_PROTECTION_PROFILE_sk_type(arg_sk: ?*struct_stack_st_SRTP_PROTECTION_PROFILE) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SRTP_PROTECTION_PROFILE_compfunc_type(arg_cmp: sk_SRTP_PROTECTION_PROFILE_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_SRTP_PROTECTION_PROFILE_copyfunc_type(arg_cpy: sk_SRTP_PROTECTION_PROFILE_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_SRTP_PROTECTION_PROFILE_freefunc_type(arg_fr: sk_SRTP_PROTECTION_PROFILE_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const tls_session_ticket_ext_cb_fn = ?*const fn (?*SSL, [*c]const u8, c_int, ?*anyopaque) callconv(.c) c_int;
pub const tls_session_secret_cb_fn = ?*const fn (?*SSL, ?*anyopaque, [*c]c_int, ?*struct_stack_st_SSL_CIPHER, [*c]?*const SSL_CIPHER, ?*anyopaque) callconv(.c) c_int;
pub const custom_ext_add_cb = ?*const fn (?*SSL, c_uint, [*c][*c]const u8, [*c]usize, [*c]c_int, ?*anyopaque) callconv(.c) c_int;
pub const custom_ext_free_cb = ?*const fn (?*SSL, c_uint, [*c]const u8, ?*anyopaque) callconv(.c) void;
pub const custom_ext_parse_cb = ?*const fn (?*SSL, c_uint, [*c]const u8, usize, [*c]c_int, ?*anyopaque) callconv(.c) c_int;
pub const SSL_custom_ext_add_cb_ex = ?*const fn (?*SSL, c_uint, c_uint, [*c][*c]const u8, [*c]usize, ?*X509, usize, [*c]c_int, ?*anyopaque) callconv(.c) c_int;
pub const SSL_custom_ext_free_cb_ex = ?*const fn (?*SSL, c_uint, c_uint, [*c]const u8, ?*anyopaque) callconv(.c) void;
pub const SSL_custom_ext_parse_cb_ex = ?*const fn (?*SSL, c_uint, c_uint, [*c]const u8, usize, ?*X509, usize, [*c]c_int, ?*anyopaque) callconv(.c) c_int;
pub const SSL_verify_cb = ?*const fn (c_int, ?*X509_STORE_CTX) callconv(.c) c_int;
pub const SSL_async_callback_fn = ?*const fn (?*SSL, ?*anyopaque) callconv(.c) c_int;
pub extern fn SSL_CTX_get_options(ctx: ?*const SSL_CTX) u64;
pub extern fn SSL_get_options(s: ?*const SSL) u64;
pub extern fn SSL_CTX_clear_options(ctx: ?*SSL_CTX, op: u64) u64;
pub extern fn SSL_clear_options(s: ?*SSL, op: u64) u64;
pub extern fn SSL_CTX_set_options(ctx: ?*SSL_CTX, op: u64) u64;
pub extern fn SSL_set_options(s: ?*SSL, op: u64) u64;
pub extern fn SSL_CTX_set_msg_callback(ctx: ?*SSL_CTX, cb: ?*const fn (c_int, c_int, c_int, ?*const anyopaque, usize, ?*SSL, ?*anyopaque) callconv(.c) void) void;
pub extern fn SSL_set_msg_callback(ssl: ?*SSL, cb: ?*const fn (c_int, c_int, c_int, ?*const anyopaque, usize, ?*SSL, ?*anyopaque) callconv(.c) void) void;
pub extern fn SSL_SRP_CTX_init(s: ?*SSL) c_int;
pub extern fn SSL_CTX_SRP_CTX_init(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_SRP_CTX_free(ctx: ?*SSL) c_int;
pub extern fn SSL_CTX_SRP_CTX_free(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_srp_server_param_with_username(s: ?*SSL, ad: [*c]c_int) c_int;
pub extern fn SRP_Calc_A_param(s: ?*SSL) c_int;
pub const GEN_SESSION_CB = ?*const fn (?*SSL, [*c]u8, [*c]c_uint) callconv(.c) c_int;
pub const struct_lhash_st_SSL_SESSION = opaque {};
pub extern fn SSL_CTX_sessions(ctx: ?*SSL_CTX) ?*struct_lhash_st_SSL_SESSION;
pub extern fn SSL_CTX_sess_set_new_cb(ctx: ?*SSL_CTX, new_session_cb: ?*const fn (?*struct_ssl_st, ?*SSL_SESSION) callconv(.c) c_int) void;
pub extern fn SSL_CTX_sess_get_new_cb(ctx: ?*SSL_CTX) ?*const fn (?*struct_ssl_st, ?*SSL_SESSION) callconv(.c) c_int;
pub extern fn SSL_CTX_sess_set_remove_cb(ctx: ?*SSL_CTX, remove_session_cb: ?*const fn (?*struct_ssl_ctx_st, ?*SSL_SESSION) callconv(.c) void) void;
pub extern fn SSL_CTX_sess_get_remove_cb(ctx: ?*SSL_CTX) ?*const fn (?*struct_ssl_ctx_st, ?*SSL_SESSION) callconv(.c) void;
pub extern fn SSL_CTX_sess_set_get_cb(ctx: ?*SSL_CTX, get_session_cb: ?*const fn (?*struct_ssl_st, [*c]const u8, c_int, [*c]c_int) callconv(.c) ?*SSL_SESSION) void;
pub extern fn SSL_CTX_sess_get_get_cb(ctx: ?*SSL_CTX) ?*const fn (?*struct_ssl_st, [*c]const u8, c_int, [*c]c_int) callconv(.c) ?*SSL_SESSION;
pub extern fn SSL_CTX_set_info_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*const SSL, c_int, c_int) callconv(.c) void) void;
pub extern fn SSL_CTX_get_info_callback(ctx: ?*SSL_CTX) ?*const fn (?*const SSL, c_int, c_int) callconv(.c) void;
pub extern fn SSL_CTX_set_client_cert_cb(ctx: ?*SSL_CTX, client_cert_cb: ?*const fn (?*SSL, [*c]?*X509, [*c]?*EVP_PKEY) callconv(.c) c_int) void;
pub extern fn SSL_CTX_get_client_cert_cb(ctx: ?*SSL_CTX) ?*const fn (?*SSL, [*c]?*X509, [*c]?*EVP_PKEY) callconv(.c) c_int;
pub extern fn SSL_CTX_set_client_cert_engine(ctx: ?*SSL_CTX, e: ?*ENGINE) c_int;
pub extern fn SSL_CTX_set_cookie_generate_cb(ctx: ?*SSL_CTX, app_gen_cookie_cb: ?*const fn (?*SSL, [*c]u8, [*c]c_uint) callconv(.c) c_int) void;
pub extern fn SSL_CTX_set_cookie_verify_cb(ctx: ?*SSL_CTX, app_verify_cookie_cb: ?*const fn (?*SSL, [*c]const u8, c_uint) callconv(.c) c_int) void;
pub extern fn SSL_CTX_set_stateless_cookie_generate_cb(ctx: ?*SSL_CTX, gen_stateless_cookie_cb: ?*const fn (?*SSL, [*c]u8, [*c]usize) callconv(.c) c_int) void;
pub extern fn SSL_CTX_set_stateless_cookie_verify_cb(ctx: ?*SSL_CTX, verify_stateless_cookie_cb: ?*const fn (?*SSL, [*c]const u8, usize) callconv(.c) c_int) void;
pub const SSL_CTX_npn_advertised_cb_func = ?*const fn (?*SSL, [*c][*c]const u8, [*c]c_uint, ?*anyopaque) callconv(.c) c_int;
pub extern fn SSL_CTX_set_next_protos_advertised_cb(s: ?*SSL_CTX, cb: SSL_CTX_npn_advertised_cb_func, arg: ?*anyopaque) void;
pub const SSL_CTX_npn_select_cb_func = ?*const fn (?*SSL, [*c][*c]u8, [*c]u8, [*c]const u8, c_uint, ?*anyopaque) callconv(.c) c_int;
pub extern fn SSL_CTX_set_next_proto_select_cb(s: ?*SSL_CTX, cb: SSL_CTX_npn_select_cb_func, arg: ?*anyopaque) void;
pub extern fn SSL_get0_next_proto_negotiated(s: ?*const SSL, data: [*c][*c]const u8, len: [*c]c_uint) void;
pub extern fn SSL_select_next_proto(out: [*c][*c]u8, outlen: [*c]u8, in: [*c]const u8, inlen: c_uint, client: [*c]const u8, client_len: c_uint) c_int;
pub extern fn SSL_CTX_set_alpn_protos(ctx: ?*SSL_CTX, protos: [*c]const u8, protos_len: c_uint) c_int;
pub extern fn SSL_set_alpn_protos(ssl: ?*SSL, protos: [*c]const u8, protos_len: c_uint) c_int;
pub const SSL_CTX_alpn_select_cb_func = ?*const fn (?*SSL, [*c][*c]const u8, [*c]u8, [*c]const u8, c_uint, ?*anyopaque) callconv(.c) c_int;
pub extern fn SSL_CTX_set_alpn_select_cb(ctx: ?*SSL_CTX, cb: SSL_CTX_alpn_select_cb_func, arg: ?*anyopaque) void;
pub extern fn SSL_get0_alpn_selected(ssl: ?*const SSL, data: [*c][*c]const u8, len: [*c]c_uint) void;
pub const SSL_psk_client_cb_func = ?*const fn (?*SSL, [*c]const u8, [*c]u8, c_uint, [*c]u8, c_uint) callconv(.c) c_uint;
pub extern fn SSL_CTX_set_psk_client_callback(ctx: ?*SSL_CTX, cb: SSL_psk_client_cb_func) void;
pub extern fn SSL_set_psk_client_callback(ssl: ?*SSL, cb: SSL_psk_client_cb_func) void;
pub const SSL_psk_server_cb_func = ?*const fn (?*SSL, [*c]const u8, [*c]u8, c_uint) callconv(.c) c_uint;
pub extern fn SSL_CTX_set_psk_server_callback(ctx: ?*SSL_CTX, cb: SSL_psk_server_cb_func) void;
pub extern fn SSL_set_psk_server_callback(ssl: ?*SSL, cb: SSL_psk_server_cb_func) void;
pub extern fn SSL_CTX_use_psk_identity_hint(ctx: ?*SSL_CTX, identity_hint: [*c]const u8) c_int;
pub extern fn SSL_use_psk_identity_hint(s: ?*SSL, identity_hint: [*c]const u8) c_int;
pub extern fn SSL_get_psk_identity_hint(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_get_psk_identity(s: ?*const SSL) [*c]const u8;
pub const SSL_psk_find_session_cb_func = ?*const fn (?*SSL, [*c]const u8, usize, [*c]?*SSL_SESSION) callconv(.c) c_int;
pub const SSL_psk_use_session_cb_func = ?*const fn (?*SSL, ?*const EVP_MD, [*c][*c]const u8, [*c]usize, [*c]?*SSL_SESSION) callconv(.c) c_int;
pub extern fn SSL_set_psk_find_session_callback(s: ?*SSL, cb: SSL_psk_find_session_cb_func) void;
pub extern fn SSL_CTX_set_psk_find_session_callback(ctx: ?*SSL_CTX, cb: SSL_psk_find_session_cb_func) void;
pub extern fn SSL_set_psk_use_session_callback(s: ?*SSL, cb: SSL_psk_use_session_cb_func) void;
pub extern fn SSL_CTX_set_psk_use_session_callback(ctx: ?*SSL_CTX, cb: SSL_psk_use_session_cb_func) void;
pub extern fn SSL_CTX_has_client_custom_ext(ctx: ?*const SSL_CTX, ext_type: c_uint) c_int;
pub extern fn SSL_CTX_add_client_custom_ext(ctx: ?*SSL_CTX, ext_type: c_uint, add_cb: custom_ext_add_cb, free_cb: custom_ext_free_cb, add_arg: ?*anyopaque, parse_cb: custom_ext_parse_cb, parse_arg: ?*anyopaque) c_int;
pub extern fn SSL_CTX_add_server_custom_ext(ctx: ?*SSL_CTX, ext_type: c_uint, add_cb: custom_ext_add_cb, free_cb: custom_ext_free_cb, add_arg: ?*anyopaque, parse_cb: custom_ext_parse_cb, parse_arg: ?*anyopaque) c_int;
pub extern fn SSL_CTX_add_custom_ext(ctx: ?*SSL_CTX, ext_type: c_uint, context: c_uint, add_cb: SSL_custom_ext_add_cb_ex, free_cb: SSL_custom_ext_free_cb_ex, add_arg: ?*anyopaque, parse_cb: SSL_custom_ext_parse_cb_ex, parse_arg: ?*anyopaque) c_int;
pub extern fn SSL_extension_supported(ext_type: c_uint) c_int;
pub const SSL_CTX_keylog_cb_func = ?*const fn (?*const SSL, [*c]const u8) callconv(.c) void;
pub extern fn SSL_CTX_set_keylog_callback(ctx: ?*SSL_CTX, cb: SSL_CTX_keylog_cb_func) void;
pub extern fn SSL_CTX_get_keylog_callback(ctx: ?*const SSL_CTX) SSL_CTX_keylog_cb_func;
pub extern fn SSL_CTX_set_max_early_data(ctx: ?*SSL_CTX, max_early_data: u32) c_int;
pub extern fn SSL_CTX_get_max_early_data(ctx: ?*const SSL_CTX) u32;
pub extern fn SSL_set_max_early_data(s: ?*SSL, max_early_data: u32) c_int;
pub extern fn SSL_get_max_early_data(s: ?*const SSL) u32;
pub extern fn SSL_CTX_set_recv_max_early_data(ctx: ?*SSL_CTX, recv_max_early_data: u32) c_int;
pub extern fn SSL_CTX_get_recv_max_early_data(ctx: ?*const SSL_CTX) u32;
pub extern fn SSL_set_recv_max_early_data(s: ?*SSL, recv_max_early_data: u32) c_int;
pub extern fn SSL_get_recv_max_early_data(s: ?*const SSL) u32;
pub extern fn SSL_CTX_set_tlsext_max_fragment_length(ctx: ?*SSL_CTX, mode: u8) c_int;
pub extern fn SSL_set_tlsext_max_fragment_length(ssl: ?*SSL, mode: u8) c_int;
pub extern fn SSL_get_servername(s: ?*const SSL, @"type": c_int) [*c]const u8;
pub extern fn SSL_get_servername_type(s: ?*const SSL) c_int;
pub extern fn SSL_export_keying_material(s: ?*SSL, out: [*c]u8, olen: usize, label: [*c]const u8, llen: usize, context: [*c]const u8, contextlen: usize, use_context: c_int) c_int;
pub extern fn SSL_export_keying_material_early(s: ?*SSL, out: [*c]u8, olen: usize, label: [*c]const u8, llen: usize, context: [*c]const u8, contextlen: usize) c_int;
pub extern fn SSL_get_peer_signature_type_nid(s: ?*const SSL, pnid: [*c]c_int) c_int;
pub extern fn SSL_get_signature_type_nid(s: ?*const SSL, pnid: [*c]c_int) c_int;
pub extern fn SSL_get_sigalgs(s: ?*SSL, idx: c_int, psign: [*c]c_int, phash: [*c]c_int, psignandhash: [*c]c_int, rsig: [*c]u8, rhash: [*c]u8) c_int;
pub extern fn SSL_get1_builtin_sigalgs(libctx: ?*OSSL_LIB_CTX) [*c]u8;
pub extern fn SSL_get_shared_sigalgs(s: ?*SSL, idx: c_int, psign: [*c]c_int, phash: [*c]c_int, psignandhash: [*c]c_int, rsig: [*c]u8, rhash: [*c]u8) c_int;
pub extern fn SSL_check_chain(s: ?*SSL, x: ?*X509, pk: ?*EVP_PKEY, chain: ?*struct_stack_st_X509) c_int;
pub extern fn SSL_CTX_set_tlsext_ticket_key_evp_cb(ctx: ?*SSL_CTX, fp: ?*const fn (?*SSL, [*c]u8, [*c]u8, ?*EVP_CIPHER_CTX, ?*EVP_MAC_CTX, c_int) callconv(.c) c_int) c_int;
pub extern fn SSL_CTX_set_tlsext_use_srtp(ctx: ?*SSL_CTX, profiles: [*c]const u8) c_int;
pub extern fn SSL_set_tlsext_use_srtp(ssl: ?*SSL, profiles: [*c]const u8) c_int;
pub extern fn SSL_get_srtp_profiles(ssl: ?*SSL) ?*struct_stack_st_SRTP_PROTECTION_PROFILE;
pub extern fn SSL_get_selected_srtp_profile(s: ?*SSL) [*c]SRTP_PROTECTION_PROFILE;
pub extern fn OSSL_QUIC_client_method() ?*const SSL_METHOD;
pub extern fn OSSL_QUIC_client_thread_method() ?*const SSL_METHOD;
pub const sk_SSL_CIPHER_compfunc = ?*const fn ([*c]const ?*const SSL_CIPHER, [*c]const ?*const SSL_CIPHER) callconv(.c) c_int;
pub const sk_SSL_CIPHER_freefunc = ?*const fn (?*SSL_CIPHER) callconv(.c) void;
pub const sk_SSL_CIPHER_copyfunc = ?*const fn (?*const SSL_CIPHER) callconv(.c) ?*SSL_CIPHER;
pub fn ossl_check_SSL_CIPHER_type(arg_ptr: ?*const SSL_CIPHER) callconv(.c) ?*const SSL_CIPHER {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_SSL_CIPHER_sk_type(arg_sk: ?*const struct_stack_st_SSL_CIPHER) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SSL_CIPHER_sk_type(arg_sk: ?*struct_stack_st_SSL_CIPHER) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SSL_CIPHER_compfunc_type(arg_cmp: sk_SSL_CIPHER_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_SSL_CIPHER_copyfunc_type(arg_cpy: sk_SSL_CIPHER_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_SSL_CIPHER_freefunc_type(arg_fr: sk_SSL_CIPHER_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn SSL_set_debug(s: ?*SSL, debug: c_int) void;
pub const TLS_ST_BEFORE: c_int = 0;
pub const TLS_ST_OK: c_int = 1;
pub const DTLS_ST_CR_HELLO_VERIFY_REQUEST: c_int = 2;
pub const TLS_ST_CR_SRVR_HELLO: c_int = 3;
pub const TLS_ST_CR_CERT: c_int = 4;
pub const TLS_ST_CR_COMP_CERT: c_int = 5;
pub const TLS_ST_CR_CERT_STATUS: c_int = 6;
pub const TLS_ST_CR_KEY_EXCH: c_int = 7;
pub const TLS_ST_CR_CERT_REQ: c_int = 8;
pub const TLS_ST_CR_SRVR_DONE: c_int = 9;
pub const TLS_ST_CR_SESSION_TICKET: c_int = 10;
pub const TLS_ST_CR_CHANGE: c_int = 11;
pub const TLS_ST_CR_FINISHED: c_int = 12;
pub const TLS_ST_CW_CLNT_HELLO: c_int = 13;
pub const TLS_ST_CW_CERT: c_int = 14;
pub const TLS_ST_CW_COMP_CERT: c_int = 15;
pub const TLS_ST_CW_KEY_EXCH: c_int = 16;
pub const TLS_ST_CW_CERT_VRFY: c_int = 17;
pub const TLS_ST_CW_CHANGE: c_int = 18;
pub const TLS_ST_CW_NEXT_PROTO: c_int = 19;
pub const TLS_ST_CW_FINISHED: c_int = 20;
pub const TLS_ST_SW_HELLO_REQ: c_int = 21;
pub const TLS_ST_SR_CLNT_HELLO: c_int = 22;
pub const DTLS_ST_SW_HELLO_VERIFY_REQUEST: c_int = 23;
pub const TLS_ST_SW_SRVR_HELLO: c_int = 24;
pub const TLS_ST_SW_CERT: c_int = 25;
pub const TLS_ST_SW_COMP_CERT: c_int = 26;
pub const TLS_ST_SW_KEY_EXCH: c_int = 27;
pub const TLS_ST_SW_CERT_REQ: c_int = 28;
pub const TLS_ST_SW_SRVR_DONE: c_int = 29;
pub const TLS_ST_SR_CERT: c_int = 30;
pub const TLS_ST_SR_COMP_CERT: c_int = 31;
pub const TLS_ST_SR_KEY_EXCH: c_int = 32;
pub const TLS_ST_SR_CERT_VRFY: c_int = 33;
pub const TLS_ST_SR_NEXT_PROTO: c_int = 34;
pub const TLS_ST_SR_CHANGE: c_int = 35;
pub const TLS_ST_SR_FINISHED: c_int = 36;
pub const TLS_ST_SW_SESSION_TICKET: c_int = 37;
pub const TLS_ST_SW_CERT_STATUS: c_int = 38;
pub const TLS_ST_SW_CHANGE: c_int = 39;
pub const TLS_ST_SW_FINISHED: c_int = 40;
pub const TLS_ST_SW_ENCRYPTED_EXTENSIONS: c_int = 41;
pub const TLS_ST_CR_ENCRYPTED_EXTENSIONS: c_int = 42;
pub const TLS_ST_CR_CERT_VRFY: c_int = 43;
pub const TLS_ST_SW_CERT_VRFY: c_int = 44;
pub const TLS_ST_CR_HELLO_REQ: c_int = 45;
pub const TLS_ST_SW_KEY_UPDATE: c_int = 46;
pub const TLS_ST_CW_KEY_UPDATE: c_int = 47;
pub const TLS_ST_SR_KEY_UPDATE: c_int = 48;
pub const TLS_ST_CR_KEY_UPDATE: c_int = 49;
pub const TLS_ST_EARLY_DATA: c_int = 50;
pub const TLS_ST_PENDING_EARLY_DATA_END: c_int = 51;
pub const TLS_ST_CW_END_OF_EARLY_DATA: c_int = 52;
pub const TLS_ST_SR_END_OF_EARLY_DATA: c_int = 53;
pub const OSSL_HANDSHAKE_STATE = c_uint;
pub extern fn SSL_in_init(s: ?*const SSL) c_int;
pub extern fn SSL_in_before(s: ?*const SSL) c_int;
pub extern fn SSL_is_init_finished(s: ?*const SSL) c_int;
pub extern fn SSL_get_finished(s: ?*const SSL, buf: ?*anyopaque, count: usize) usize;
pub extern fn SSL_get_peer_finished(s: ?*const SSL, buf: ?*anyopaque, count: usize) usize;
pub extern fn PEM_read_bio_SSL_SESSION(out: ?*BIO, x: [*c]?*SSL_SESSION, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*SSL_SESSION;
pub extern fn PEM_read_SSL_SESSION(out: [*c]FILE, x: [*c]?*SSL_SESSION, cb: ?*const pem_password_cb, u: ?*anyopaque) ?*SSL_SESSION;
pub extern fn PEM_write_bio_SSL_SESSION(out: ?*BIO, x: ?*const SSL_SESSION) c_int;
pub extern fn PEM_write_SSL_SESSION(out: [*c]FILE, x: ?*const SSL_SESSION) c_int;
pub extern fn SSL_get0_group_name(s: ?*SSL) [*c]const u8;
pub extern fn SSL_group_to_name(s: ?*SSL, id: c_int) [*c]const u8;
pub extern fn SSL_set0_tmp_dh_pkey(s: ?*SSL, dhpkey: ?*EVP_PKEY) c_int;
pub extern fn SSL_CTX_set0_tmp_dh_pkey(ctx: ?*SSL_CTX, dhpkey: ?*EVP_PKEY) c_int;
pub extern fn BIO_f_ssl() ?*const BIO_METHOD;
pub extern fn BIO_new_ssl(ctx: ?*SSL_CTX, client: c_int) ?*BIO;
pub extern fn BIO_new_ssl_connect(ctx: ?*SSL_CTX) ?*BIO;
pub extern fn BIO_new_buffer_ssl_connect(ctx: ?*SSL_CTX) ?*BIO;
pub extern fn BIO_ssl_copy_session_id(to: ?*BIO, from: ?*BIO) c_int;
pub extern fn BIO_ssl_shutdown(ssl_bio: ?*BIO) void;
pub extern fn SSL_CTX_set_cipher_list(?*SSL_CTX, str: [*c]const u8) c_int;
pub extern fn SSL_CTX_new(meth: ?*const SSL_METHOD) ?*SSL_CTX;
pub extern fn SSL_CTX_new_ex(libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8, meth: ?*const SSL_METHOD) ?*SSL_CTX;
pub extern fn SSL_CTX_up_ref(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_free(?*SSL_CTX) void;
pub extern fn SSL_CTX_set_timeout(ctx: ?*SSL_CTX, t: c_long) c_long;
pub extern fn SSL_CTX_get_timeout(ctx: ?*const SSL_CTX) c_long;
pub extern fn SSL_CTX_get_cert_store(?*const SSL_CTX) ?*X509_STORE;
pub extern fn SSL_CTX_set_cert_store(?*SSL_CTX, ?*X509_STORE) void;
pub extern fn SSL_CTX_set1_cert_store(?*SSL_CTX, ?*X509_STORE) void;
pub extern fn SSL_want(s: ?*const SSL) c_int;
pub extern fn SSL_clear(s: ?*SSL) c_int;
pub extern fn SSL_CTX_flush_sessions(ctx: ?*SSL_CTX, tm: c_long) void;
pub extern fn SSL_CTX_flush_sessions_ex(ctx: ?*SSL_CTX, tm: time_t) void;
pub extern fn SSL_get_current_cipher(s: ?*const SSL) ?*const SSL_CIPHER;
pub extern fn SSL_get_pending_cipher(s: ?*const SSL) ?*const SSL_CIPHER;
pub extern fn SSL_CIPHER_get_bits(c: ?*const SSL_CIPHER, alg_bits: [*c]c_int) c_int;
pub extern fn SSL_CIPHER_get_version(c: ?*const SSL_CIPHER) [*c]const u8;
pub extern fn SSL_CIPHER_get_name(c: ?*const SSL_CIPHER) [*c]const u8;
pub extern fn SSL_CIPHER_standard_name(c: ?*const SSL_CIPHER) [*c]const u8;
pub extern fn OPENSSL_cipher_name(rfc_name: [*c]const u8) [*c]const u8;
pub extern fn SSL_CIPHER_get_id(c: ?*const SSL_CIPHER) u32;
pub extern fn SSL_CIPHER_get_protocol_id(c: ?*const SSL_CIPHER) u16;
pub extern fn SSL_CIPHER_get_kx_nid(c: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_CIPHER_get_auth_nid(c: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_CIPHER_get_handshake_digest(c: ?*const SSL_CIPHER) ?*const EVP_MD;
pub extern fn SSL_CIPHER_is_aead(c: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_get_fd(s: ?*const SSL) c_int;
pub extern fn SSL_get_rfd(s: ?*const SSL) c_int;
pub extern fn SSL_get_wfd(s: ?*const SSL) c_int;
pub extern fn SSL_get_cipher_list(s: ?*const SSL, n: c_int) [*c]const u8;
pub extern fn SSL_get_shared_ciphers(s: ?*const SSL, buf: [*c]u8, size: c_int) [*c]u8;
pub extern fn SSL_get_read_ahead(s: ?*const SSL) c_int;
pub extern fn SSL_pending(s: ?*const SSL) c_int;
pub extern fn SSL_has_pending(s: ?*const SSL) c_int;
pub extern fn SSL_set_fd(s: ?*SSL, fd: c_int) c_int;
pub extern fn SSL_set_rfd(s: ?*SSL, fd: c_int) c_int;
pub extern fn SSL_set_wfd(s: ?*SSL, fd: c_int) c_int;
pub extern fn SSL_set0_rbio(s: ?*SSL, rbio: ?*BIO) void;
pub extern fn SSL_set0_wbio(s: ?*SSL, wbio: ?*BIO) void;
pub extern fn SSL_set_bio(s: ?*SSL, rbio: ?*BIO, wbio: ?*BIO) void;
pub extern fn SSL_get_rbio(s: ?*const SSL) ?*BIO;
pub extern fn SSL_get_wbio(s: ?*const SSL) ?*BIO;
pub extern fn SSL_set_cipher_list(s: ?*SSL, str: [*c]const u8) c_int;
pub extern fn SSL_CTX_set_ciphersuites(ctx: ?*SSL_CTX, str: [*c]const u8) c_int;
pub extern fn SSL_set_ciphersuites(s: ?*SSL, str: [*c]const u8) c_int;
pub extern fn SSL_set_read_ahead(s: ?*SSL, yes: c_int) void;
pub extern fn SSL_get_verify_mode(s: ?*const SSL) c_int;
pub extern fn SSL_get_verify_depth(s: ?*const SSL) c_int;
pub extern fn SSL_get_verify_callback(s: ?*const SSL) SSL_verify_cb;
pub extern fn SSL_set_verify(s: ?*SSL, mode: c_int, callback: SSL_verify_cb) void;
pub extern fn SSL_set_verify_depth(s: ?*SSL, depth: c_int) void;
pub extern fn SSL_set_cert_cb(s: ?*SSL, cb: ?*const fn (?*SSL, ?*anyopaque) callconv(.c) c_int, arg: ?*anyopaque) void;
pub extern fn SSL_use_RSAPrivateKey(ssl: ?*SSL, rsa: ?*RSA) c_int;
pub extern fn SSL_use_RSAPrivateKey_ASN1(ssl: ?*SSL, d: [*c]const u8, len: c_long) c_int;
pub extern fn SSL_use_PrivateKey(ssl: ?*SSL, pkey: ?*EVP_PKEY) c_int;
pub extern fn SSL_use_PrivateKey_ASN1(pk: c_int, ssl: ?*SSL, d: [*c]const u8, len: c_long) c_int;
pub extern fn SSL_use_certificate(ssl: ?*SSL, x: ?*X509) c_int;
pub extern fn SSL_use_certificate_ASN1(ssl: ?*SSL, d: [*c]const u8, len: c_int) c_int;
pub extern fn SSL_use_cert_and_key(ssl: ?*SSL, x509: ?*X509, privatekey: ?*EVP_PKEY, chain: ?*struct_stack_st_X509, override: c_int) c_int;
pub extern fn SSL_CTX_use_serverinfo(ctx: ?*SSL_CTX, serverinfo: [*c]const u8, serverinfo_length: usize) c_int;
pub extern fn SSL_CTX_use_serverinfo_ex(ctx: ?*SSL_CTX, version: c_uint, serverinfo: [*c]const u8, serverinfo_length: usize) c_int;
pub extern fn SSL_CTX_use_serverinfo_file(ctx: ?*SSL_CTX, file: [*c]const u8) c_int;
pub extern fn SSL_use_RSAPrivateKey_file(ssl: ?*SSL, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_use_PrivateKey_file(ssl: ?*SSL, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_use_certificate_file(ssl: ?*SSL, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_CTX_use_RSAPrivateKey_file(ctx: ?*SSL_CTX, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_CTX_use_PrivateKey_file(ctx: ?*SSL_CTX, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_CTX_use_certificate_file(ctx: ?*SSL_CTX, file: [*c]const u8, @"type": c_int) c_int;
pub extern fn SSL_CTX_use_certificate_chain_file(ctx: ?*SSL_CTX, file: [*c]const u8) c_int;
pub extern fn SSL_use_certificate_chain_file(ssl: ?*SSL, file: [*c]const u8) c_int;
pub extern fn SSL_load_client_CA_file(file: [*c]const u8) ?*struct_stack_st_X509_NAME;
pub extern fn SSL_load_client_CA_file_ex(file: [*c]const u8, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*struct_stack_st_X509_NAME;
pub extern fn SSL_add_file_cert_subjects_to_stack(stackCAs: ?*struct_stack_st_X509_NAME, file: [*c]const u8) c_int;
pub extern fn SSL_add_dir_cert_subjects_to_stack(stackCAs: ?*struct_stack_st_X509_NAME, dir: [*c]const u8) c_int;
pub extern fn SSL_add_store_cert_subjects_to_stack(stackCAs: ?*struct_stack_st_X509_NAME, uri: [*c]const u8) c_int;
pub extern fn SSL_state_string(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_rstate_string(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_state_string_long(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_rstate_string_long(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_SESSION_get_time(s: ?*const SSL_SESSION) c_long;
pub extern fn SSL_SESSION_set_time(s: ?*SSL_SESSION, t: c_long) c_long;
pub extern fn SSL_SESSION_get_timeout(s: ?*const SSL_SESSION) c_long;
pub extern fn SSL_SESSION_set_timeout(s: ?*SSL_SESSION, t: c_long) c_long;
pub extern fn SSL_SESSION_get_protocol_version(s: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_set_protocol_version(s: ?*SSL_SESSION, version: c_int) c_int;
pub extern fn SSL_SESSION_get_time_ex(s: ?*const SSL_SESSION) time_t;
pub extern fn SSL_SESSION_set_time_ex(s: ?*SSL_SESSION, t: time_t) time_t;
pub extern fn SSL_SESSION_get0_hostname(s: ?*const SSL_SESSION) [*c]const u8;
pub extern fn SSL_SESSION_set1_hostname(s: ?*SSL_SESSION, hostname: [*c]const u8) c_int;
pub extern fn SSL_SESSION_get0_alpn_selected(s: ?*const SSL_SESSION, alpn: [*c][*c]const u8, len: [*c]usize) void;
pub extern fn SSL_SESSION_set1_alpn_selected(s: ?*SSL_SESSION, alpn: [*c]const u8, len: usize) c_int;
pub extern fn SSL_SESSION_get0_cipher(s: ?*const SSL_SESSION) ?*const SSL_CIPHER;
pub extern fn SSL_SESSION_set_cipher(s: ?*SSL_SESSION, cipher: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_SESSION_has_ticket(s: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_get_ticket_lifetime_hint(s: ?*const SSL_SESSION) c_ulong;
pub extern fn SSL_SESSION_get0_ticket(s: ?*const SSL_SESSION, tick: [*c][*c]const u8, len: [*c]usize) void;
pub extern fn SSL_SESSION_get_max_early_data(s: ?*const SSL_SESSION) u32;
pub extern fn SSL_SESSION_set_max_early_data(s: ?*SSL_SESSION, max_early_data: u32) c_int;
pub extern fn SSL_copy_session_id(to: ?*SSL, from: ?*const SSL) c_int;
pub extern fn SSL_SESSION_get0_peer(s: ?*SSL_SESSION) ?*X509;
pub extern fn SSL_SESSION_set1_id_context(s: ?*SSL_SESSION, sid_ctx: [*c]const u8, sid_ctx_len: c_uint) c_int;
pub extern fn SSL_SESSION_set1_id(s: ?*SSL_SESSION, sid: [*c]const u8, sid_len: c_uint) c_int;
pub extern fn SSL_SESSION_is_resumable(s: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_new() ?*SSL_SESSION;
pub extern fn SSL_SESSION_dup(src: ?*const SSL_SESSION) ?*SSL_SESSION;
pub extern fn SSL_SESSION_get_id(s: ?*const SSL_SESSION, len: [*c]c_uint) [*c]const u8;
pub extern fn SSL_SESSION_get0_id_context(s: ?*const SSL_SESSION, len: [*c]c_uint) [*c]const u8;
pub extern fn SSL_SESSION_get_compress_id(s: ?*const SSL_SESSION) c_uint;
pub extern fn SSL_SESSION_print_fp(fp: [*c]FILE, ses: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_print(fp: ?*BIO, ses: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_print_keylog(bp: ?*BIO, x: ?*const SSL_SESSION) c_int;
pub extern fn SSL_SESSION_up_ref(ses: ?*SSL_SESSION) c_int;
pub extern fn SSL_SESSION_free(ses: ?*SSL_SESSION) void;
pub extern fn i2d_SSL_SESSION(in: ?*const SSL_SESSION, pp: [*c][*c]u8) c_int;
pub extern fn SSL_set_session(to: ?*SSL, session: ?*SSL_SESSION) c_int;
pub extern fn SSL_CTX_add_session(ctx: ?*SSL_CTX, session: ?*SSL_SESSION) c_int;
pub extern fn SSL_CTX_remove_session(ctx: ?*SSL_CTX, session: ?*SSL_SESSION) c_int;
pub extern fn SSL_CTX_set_generate_session_id(ctx: ?*SSL_CTX, cb: GEN_SESSION_CB) c_int;
pub extern fn SSL_set_generate_session_id(s: ?*SSL, cb: GEN_SESSION_CB) c_int;
pub extern fn SSL_has_matching_session_id(s: ?*const SSL, id: [*c]const u8, id_len: c_uint) c_int;
pub extern fn d2i_SSL_SESSION(a: [*c]?*SSL_SESSION, pp: [*c][*c]const u8, length: c_long) ?*SSL_SESSION;
pub extern fn d2i_SSL_SESSION_ex(a: [*c]?*SSL_SESSION, pp: [*c][*c]const u8, length: c_long, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) ?*SSL_SESSION;
pub extern fn SSL_get0_peer_certificate(s: ?*const SSL) ?*X509;
pub extern fn SSL_get1_peer_certificate(s: ?*const SSL) ?*X509;
pub extern fn SSL_get_peer_cert_chain(s: ?*const SSL) ?*struct_stack_st_X509;
pub extern fn SSL_CTX_get_verify_mode(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_CTX_get_verify_depth(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_CTX_get_verify_callback(ctx: ?*const SSL_CTX) SSL_verify_cb;
pub extern fn SSL_CTX_set_verify(ctx: ?*SSL_CTX, mode: c_int, callback: SSL_verify_cb) void;
pub extern fn SSL_CTX_set_verify_depth(ctx: ?*SSL_CTX, depth: c_int) void;
pub extern fn SSL_CTX_set_cert_verify_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*X509_STORE_CTX, ?*anyopaque) callconv(.c) c_int, arg: ?*anyopaque) void;
pub extern fn SSL_CTX_set_cert_cb(c: ?*SSL_CTX, cb: ?*const fn (?*SSL, ?*anyopaque) callconv(.c) c_int, arg: ?*anyopaque) void;
pub extern fn SSL_CTX_use_RSAPrivateKey(ctx: ?*SSL_CTX, rsa: ?*RSA) c_int;
pub extern fn SSL_CTX_use_RSAPrivateKey_ASN1(ctx: ?*SSL_CTX, d: [*c]const u8, len: c_long) c_int;
pub extern fn SSL_CTX_use_PrivateKey(ctx: ?*SSL_CTX, pkey: ?*EVP_PKEY) c_int;
pub extern fn SSL_CTX_use_PrivateKey_ASN1(pk: c_int, ctx: ?*SSL_CTX, d: [*c]const u8, len: c_long) c_int;
pub extern fn SSL_CTX_use_certificate(ctx: ?*SSL_CTX, x: ?*X509) c_int;
pub extern fn SSL_CTX_use_certificate_ASN1(ctx: ?*SSL_CTX, len: c_int, d: [*c]const u8) c_int;
pub extern fn SSL_CTX_use_cert_and_key(ctx: ?*SSL_CTX, x509: ?*X509, privatekey: ?*EVP_PKEY, chain: ?*struct_stack_st_X509, override: c_int) c_int;
pub extern fn SSL_CTX_set_default_passwd_cb(ctx: ?*SSL_CTX, cb: ?*const pem_password_cb) void;
pub extern fn SSL_CTX_set_default_passwd_cb_userdata(ctx: ?*SSL_CTX, u: ?*anyopaque) void;
pub extern fn SSL_CTX_get_default_passwd_cb(ctx: ?*SSL_CTX) ?*const pem_password_cb;
pub extern fn SSL_CTX_get_default_passwd_cb_userdata(ctx: ?*SSL_CTX) ?*anyopaque;
pub extern fn SSL_set_default_passwd_cb(s: ?*SSL, cb: ?*const pem_password_cb) void;
pub extern fn SSL_set_default_passwd_cb_userdata(s: ?*SSL, u: ?*anyopaque) void;
pub extern fn SSL_get_default_passwd_cb(s: ?*SSL) ?*const pem_password_cb;
pub extern fn SSL_get_default_passwd_cb_userdata(s: ?*SSL) ?*anyopaque;
pub extern fn SSL_CTX_check_private_key(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_check_private_key(ctx: ?*const SSL) c_int;
pub extern fn SSL_CTX_set_session_id_context(ctx: ?*SSL_CTX, sid_ctx: [*c]const u8, sid_ctx_len: c_uint) c_int;
pub extern fn SSL_new(ctx: ?*SSL_CTX) ?*SSL;
pub extern fn SSL_up_ref(s: ?*SSL) c_int;
pub extern fn SSL_is_dtls(s: ?*const SSL) c_int;
pub extern fn SSL_is_tls(s: ?*const SSL) c_int;
pub extern fn SSL_is_quic(s: ?*const SSL) c_int;
pub extern fn SSL_set_session_id_context(ssl: ?*SSL, sid_ctx: [*c]const u8, sid_ctx_len: c_uint) c_int;
pub extern fn SSL_CTX_set_purpose(ctx: ?*SSL_CTX, purpose: c_int) c_int;
pub extern fn SSL_set_purpose(ssl: ?*SSL, purpose: c_int) c_int;
pub extern fn SSL_CTX_set_trust(ctx: ?*SSL_CTX, trust: c_int) c_int;
pub extern fn SSL_set_trust(ssl: ?*SSL, trust: c_int) c_int;
pub extern fn SSL_set1_host(s: ?*SSL, hostname: [*c]const u8) c_int;
pub extern fn SSL_add1_host(s: ?*SSL, hostname: [*c]const u8) c_int;
pub extern fn SSL_get0_peername(s: ?*SSL) [*c]const u8;
pub extern fn SSL_set_hostflags(s: ?*SSL, flags: c_uint) void;
pub extern fn SSL_CTX_dane_enable(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_dane_mtype_set(ctx: ?*SSL_CTX, md: ?*const EVP_MD, mtype: u8, ord: u8) c_int;
pub extern fn SSL_dane_enable(s: ?*SSL, basedomain: [*c]const u8) c_int;
pub extern fn SSL_dane_tlsa_add(s: ?*SSL, usage: u8, selector: u8, mtype: u8, data: [*c]const u8, dlen: usize) c_int;
pub extern fn SSL_get0_dane_authority(s: ?*SSL, mcert: [*c]?*X509, mspki: [*c]?*EVP_PKEY) c_int;
pub extern fn SSL_get0_dane_tlsa(s: ?*SSL, usage: [*c]u8, selector: [*c]u8, mtype: [*c]u8, data: [*c][*c]const u8, dlen: [*c]usize) c_int;
pub extern fn SSL_get0_dane(ssl: ?*SSL) ?*SSL_DANE;
pub extern fn SSL_CTX_dane_set_flags(ctx: ?*SSL_CTX, flags: c_ulong) c_ulong;
pub extern fn SSL_CTX_dane_clear_flags(ctx: ?*SSL_CTX, flags: c_ulong) c_ulong;
pub extern fn SSL_dane_set_flags(ssl: ?*SSL, flags: c_ulong) c_ulong;
pub extern fn SSL_dane_clear_flags(ssl: ?*SSL, flags: c_ulong) c_ulong;
pub extern fn SSL_CTX_set1_param(ctx: ?*SSL_CTX, vpm: ?*X509_VERIFY_PARAM) c_int;
pub extern fn SSL_set1_param(ssl: ?*SSL, vpm: ?*X509_VERIFY_PARAM) c_int;
pub extern fn SSL_CTX_get0_param(ctx: ?*SSL_CTX) ?*X509_VERIFY_PARAM;
pub extern fn SSL_get0_param(ssl: ?*SSL) ?*X509_VERIFY_PARAM;
pub extern fn SSL_CTX_set_srp_username(ctx: ?*SSL_CTX, name: [*c]u8) c_int;
pub extern fn SSL_CTX_set_srp_password(ctx: ?*SSL_CTX, password: [*c]u8) c_int;
pub extern fn SSL_CTX_set_srp_strength(ctx: ?*SSL_CTX, strength: c_int) c_int;
pub extern fn SSL_CTX_set_srp_client_pwd_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*SSL, ?*anyopaque) callconv(.c) [*c]u8) c_int;
pub extern fn SSL_CTX_set_srp_verify_param_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*SSL, ?*anyopaque) callconv(.c) c_int) c_int;
pub extern fn SSL_CTX_set_srp_username_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*SSL, [*c]c_int, ?*anyopaque) callconv(.c) c_int) c_int;
pub extern fn SSL_CTX_set_srp_cb_arg(ctx: ?*SSL_CTX, arg: ?*anyopaque) c_int;
pub extern fn SSL_set_srp_server_param(s: ?*SSL, N: ?*const BIGNUM, g: ?*const BIGNUM, sa: ?*BIGNUM, v: ?*BIGNUM, info: [*c]u8) c_int;
pub extern fn SSL_set_srp_server_param_pw(s: ?*SSL, user: [*c]const u8, pass: [*c]const u8, grp: [*c]const u8) c_int;
pub extern fn SSL_get_srp_g(s: ?*SSL) ?*BIGNUM;
pub extern fn SSL_get_srp_N(s: ?*SSL) ?*BIGNUM;
pub extern fn SSL_get_srp_username(s: ?*SSL) [*c]u8;
pub extern fn SSL_get_srp_userinfo(s: ?*SSL) [*c]u8;
pub const SSL_client_hello_cb_fn = ?*const fn (?*SSL, [*c]c_int, ?*anyopaque) callconv(.c) c_int;
pub extern fn SSL_CTX_set_client_hello_cb(c: ?*SSL_CTX, cb: SSL_client_hello_cb_fn, arg: ?*anyopaque) void;
pub extern fn SSL_client_hello_isv2(s: ?*SSL) c_int;
pub extern fn SSL_client_hello_get0_legacy_version(s: ?*SSL) c_uint;
pub extern fn SSL_client_hello_get0_random(s: ?*SSL, out: [*c][*c]const u8) usize;
pub extern fn SSL_client_hello_get0_session_id(s: ?*SSL, out: [*c][*c]const u8) usize;
pub extern fn SSL_client_hello_get0_ciphers(s: ?*SSL, out: [*c][*c]const u8) usize;
pub extern fn SSL_client_hello_get0_compression_methods(s: ?*SSL, out: [*c][*c]const u8) usize;
pub extern fn SSL_client_hello_get1_extensions_present(s: ?*SSL, out: [*c][*c]c_int, outlen: [*c]usize) c_int;
pub extern fn SSL_client_hello_get_extension_order(s: ?*SSL, exts: [*c]u16, num_exts: [*c]usize) c_int;
pub extern fn SSL_client_hello_get0_ext(s: ?*SSL, @"type": c_uint, out: [*c][*c]const u8, outlen: [*c]usize) c_int;
pub extern fn SSL_certs_clear(s: ?*SSL) void;
pub extern fn SSL_free(ssl: ?*SSL) void;
pub extern fn SSL_waiting_for_async(s: ?*SSL) c_int;
pub extern fn SSL_get_all_async_fds(s: ?*SSL, fds: [*c]c_int, numfds: [*c]usize) c_int;
pub extern fn SSL_get_changed_async_fds(s: ?*SSL, addfd: [*c]c_int, numaddfds: [*c]usize, delfd: [*c]c_int, numdelfds: [*c]usize) c_int;
pub extern fn SSL_CTX_set_async_callback(ctx: ?*SSL_CTX, callback: SSL_async_callback_fn) c_int;
pub extern fn SSL_CTX_set_async_callback_arg(ctx: ?*SSL_CTX, arg: ?*anyopaque) c_int;
pub extern fn SSL_set_async_callback(s: ?*SSL, callback: SSL_async_callback_fn) c_int;
pub extern fn SSL_set_async_callback_arg(s: ?*SSL, arg: ?*anyopaque) c_int;
pub extern fn SSL_get_async_status(s: ?*SSL, status: [*c]c_int) c_int;
pub extern fn SSL_accept(ssl: ?*SSL) c_int;
pub extern fn SSL_stateless(s: ?*SSL) c_int;
pub extern fn SSL_connect(ssl: ?*SSL) c_int;
pub extern fn SSL_read(ssl: ?*SSL, buf: ?*anyopaque, num: c_int) c_int;
pub extern fn SSL_read_ex(ssl: ?*SSL, buf: ?*anyopaque, num: usize, readbytes: [*c]usize) c_int;
pub extern fn SSL_read_early_data(s: ?*SSL, buf: ?*anyopaque, num: usize, readbytes: [*c]usize) c_int;
pub extern fn SSL_peek(ssl: ?*SSL, buf: ?*anyopaque, num: c_int) c_int;
pub extern fn SSL_peek_ex(ssl: ?*SSL, buf: ?*anyopaque, num: usize, readbytes: [*c]usize) c_int;
pub extern fn SSL_sendfile(s: ?*SSL, fd: c_int, offset: off_t, size: usize, flags: c_int) isize;
pub extern fn SSL_write(ssl: ?*SSL, buf: ?*const anyopaque, num: c_int) c_int;
pub extern fn SSL_write_ex(s: ?*SSL, buf: ?*const anyopaque, num: usize, written: [*c]usize) c_int;
pub extern fn SSL_write_early_data(s: ?*SSL, buf: ?*const anyopaque, num: usize, written: [*c]usize) c_int;
pub extern fn SSL_ctrl(ssl: ?*SSL, cmd: c_int, larg: c_long, parg: ?*anyopaque) c_long;
pub extern fn SSL_callback_ctrl(?*SSL, c_int, ?*const fn () callconv(.c) void) c_long;
pub extern fn SSL_CTX_ctrl(ctx: ?*SSL_CTX, cmd: c_int, larg: c_long, parg: ?*anyopaque) c_long;
pub extern fn SSL_CTX_callback_ctrl(?*SSL_CTX, c_int, ?*const fn () callconv(.c) void) c_long;
pub extern fn SSL_write_ex2(s: ?*SSL, buf: ?*const anyopaque, num: usize, flags: u64, written: [*c]usize) c_int;
pub extern fn SSL_get_early_data_status(s: ?*const SSL) c_int;
pub extern fn SSL_get_error(s: ?*const SSL, ret_code: c_int) c_int;
pub extern fn SSL_get_version(s: ?*const SSL) [*c]const u8;
pub extern fn SSL_get_handshake_rtt(s: ?*const SSL, rtt: [*c]u64) c_int;
pub extern fn SSL_CTX_set_ssl_version(ctx: ?*SSL_CTX, meth: ?*const SSL_METHOD) c_int;
pub extern fn TLS_method() ?*const SSL_METHOD;
pub extern fn TLS_server_method() ?*const SSL_METHOD;
pub extern fn TLS_client_method() ?*const SSL_METHOD;
pub extern fn TLSv1_method() ?*const SSL_METHOD;
pub extern fn TLSv1_server_method() ?*const SSL_METHOD;
pub extern fn TLSv1_client_method() ?*const SSL_METHOD;
pub extern fn TLSv1_1_method() ?*const SSL_METHOD;
pub extern fn TLSv1_1_server_method() ?*const SSL_METHOD;
pub extern fn TLSv1_1_client_method() ?*const SSL_METHOD;
pub extern fn TLSv1_2_method() ?*const SSL_METHOD;
pub extern fn TLSv1_2_server_method() ?*const SSL_METHOD;
pub extern fn TLSv1_2_client_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_server_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_client_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_2_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_2_server_method() ?*const SSL_METHOD;
pub extern fn DTLSv1_2_client_method() ?*const SSL_METHOD;
pub extern fn DTLS_method() ?*const SSL_METHOD;
pub extern fn DTLS_server_method() ?*const SSL_METHOD;
pub extern fn DTLS_client_method() ?*const SSL_METHOD;
pub extern fn DTLS_get_data_mtu(s: ?*const SSL) usize;
pub extern fn SSL_get_ciphers(s: ?*const SSL) ?*struct_stack_st_SSL_CIPHER;
pub extern fn SSL_CTX_get_ciphers(ctx: ?*const SSL_CTX) ?*struct_stack_st_SSL_CIPHER;
pub extern fn SSL_get_client_ciphers(s: ?*const SSL) ?*struct_stack_st_SSL_CIPHER;
pub extern fn SSL_get1_supported_ciphers(s: ?*SSL) ?*struct_stack_st_SSL_CIPHER;
pub extern fn SSL_do_handshake(s: ?*SSL) c_int;
pub extern fn SSL_key_update(s: ?*SSL, updatetype: c_int) c_int;
pub extern fn SSL_get_key_update_type(s: ?*const SSL) c_int;
pub extern fn SSL_renegotiate(s: ?*SSL) c_int;
pub extern fn SSL_renegotiate_abbreviated(s: ?*SSL) c_int;
pub extern fn SSL_renegotiate_pending(s: ?*const SSL) c_int;
pub extern fn SSL_new_session_ticket(s: ?*SSL) c_int;
pub extern fn SSL_shutdown(s: ?*SSL) c_int;
pub extern fn SSL_verify_client_post_handshake(s: ?*SSL) c_int;
pub extern fn SSL_CTX_set_post_handshake_auth(ctx: ?*SSL_CTX, val: c_int) void;
pub extern fn SSL_set_post_handshake_auth(s: ?*SSL, val: c_int) void;
pub extern fn SSL_CTX_get_ssl_method(ctx: ?*const SSL_CTX) ?*const SSL_METHOD;
pub extern fn SSL_get_ssl_method(s: ?*const SSL) ?*const SSL_METHOD;
pub extern fn SSL_set_ssl_method(s: ?*SSL, method: ?*const SSL_METHOD) c_int;
pub extern fn SSL_alert_type_string_long(value: c_int) [*c]const u8;
pub extern fn SSL_alert_type_string(value: c_int) [*c]const u8;
pub extern fn SSL_alert_desc_string_long(value: c_int) [*c]const u8;
pub extern fn SSL_alert_desc_string(value: c_int) [*c]const u8;
pub extern fn SSL_set0_CA_list(s: ?*SSL, name_list: ?*struct_stack_st_X509_NAME) void;
pub extern fn SSL_CTX_set0_CA_list(ctx: ?*SSL_CTX, name_list: ?*struct_stack_st_X509_NAME) void;
pub extern fn SSL_get0_CA_list(s: ?*const SSL) ?*const struct_stack_st_X509_NAME;
pub extern fn SSL_CTX_get0_CA_list(ctx: ?*const SSL_CTX) ?*const struct_stack_st_X509_NAME;
pub extern fn SSL_add1_to_CA_list(ssl: ?*SSL, x: ?*const X509) c_int;
pub extern fn SSL_CTX_add1_to_CA_list(ctx: ?*SSL_CTX, x: ?*const X509) c_int;
pub extern fn SSL_get0_peer_CA_list(s: ?*const SSL) ?*const struct_stack_st_X509_NAME;
pub extern fn SSL_set_client_CA_list(s: ?*SSL, name_list: ?*struct_stack_st_X509_NAME) void;
pub extern fn SSL_CTX_set_client_CA_list(ctx: ?*SSL_CTX, name_list: ?*struct_stack_st_X509_NAME) void;
pub extern fn SSL_get_client_CA_list(s: ?*const SSL) ?*struct_stack_st_X509_NAME;
pub extern fn SSL_CTX_get_client_CA_list(s: ?*const SSL_CTX) ?*struct_stack_st_X509_NAME;
pub extern fn SSL_add_client_CA(ssl: ?*SSL, x: ?*X509) c_int;
pub extern fn SSL_CTX_add_client_CA(ctx: ?*SSL_CTX, x: ?*X509) c_int;
pub extern fn SSL_set_connect_state(s: ?*SSL) void;
pub extern fn SSL_set_accept_state(s: ?*SSL) void;
pub extern fn SSL_get_default_timeout(s: ?*const SSL) c_long;
pub extern fn SSL_CIPHER_description(?*const SSL_CIPHER, buf: [*c]u8, size: c_int) [*c]u8;
pub extern fn SSL_dup_CA_list(sk: ?*const struct_stack_st_X509_NAME) ?*struct_stack_st_X509_NAME;
pub extern fn SSL_dup(ssl: ?*SSL) ?*SSL;
pub extern fn SSL_get_certificate(ssl: ?*const SSL) ?*X509;
pub extern fn SSL_get_privatekey(ssl: ?*const SSL) ?*struct_evp_pkey_st;
pub extern fn SSL_CTX_get0_certificate(ctx: ?*const SSL_CTX) ?*X509;
pub extern fn SSL_CTX_get0_privatekey(ctx: ?*const SSL_CTX) ?*EVP_PKEY;
pub extern fn SSL_CTX_set_quiet_shutdown(ctx: ?*SSL_CTX, mode: c_int) void;
pub extern fn SSL_CTX_get_quiet_shutdown(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_set_quiet_shutdown(ssl: ?*SSL, mode: c_int) void;
pub extern fn SSL_get_quiet_shutdown(ssl: ?*const SSL) c_int;
pub extern fn SSL_set_shutdown(ssl: ?*SSL, mode: c_int) void;
pub extern fn SSL_get_shutdown(ssl: ?*const SSL) c_int;
pub extern fn SSL_version(ssl: ?*const SSL) c_int;
pub extern fn SSL_client_version(s: ?*const SSL) c_int;
pub extern fn SSL_CTX_set_default_verify_paths(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_set_default_verify_dir(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_set_default_verify_file(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_set_default_verify_store(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_load_verify_file(ctx: ?*SSL_CTX, CAfile: [*c]const u8) c_int;
pub extern fn SSL_CTX_load_verify_dir(ctx: ?*SSL_CTX, CApath: [*c]const u8) c_int;
pub extern fn SSL_CTX_load_verify_store(ctx: ?*SSL_CTX, CAstore: [*c]const u8) c_int;
pub extern fn SSL_CTX_load_verify_locations(ctx: ?*SSL_CTX, CAfile: [*c]const u8, CApath: [*c]const u8) c_int;
pub extern fn SSL_get_session(ssl: ?*const SSL) ?*SSL_SESSION;
pub extern fn SSL_get1_session(ssl: ?*SSL) ?*SSL_SESSION;
pub extern fn SSL_get_SSL_CTX(ssl: ?*const SSL) ?*SSL_CTX;
pub extern fn SSL_set_SSL_CTX(ssl: ?*SSL, ctx: ?*SSL_CTX) ?*SSL_CTX;
pub extern fn SSL_set_info_callback(ssl: ?*SSL, cb: ?*const fn (?*const SSL, c_int, c_int) callconv(.c) void) void;
pub extern fn SSL_get_info_callback(ssl: ?*const SSL) ?*const fn (?*const SSL, c_int, c_int) callconv(.c) void;
pub extern fn SSL_get_state(ssl: ?*const SSL) OSSL_HANDSHAKE_STATE;
pub extern fn SSL_set_verify_result(ssl: ?*SSL, v: c_long) void;
pub extern fn SSL_get_verify_result(ssl: ?*const SSL) c_long;
pub extern fn SSL_get0_verified_chain(s: ?*const SSL) ?*struct_stack_st_X509;
pub extern fn SSL_get_client_random(ssl: ?*const SSL, out: [*c]u8, outlen: usize) usize;
pub extern fn SSL_get_server_random(ssl: ?*const SSL, out: [*c]u8, outlen: usize) usize;
pub extern fn SSL_SESSION_get_master_key(sess: ?*const SSL_SESSION, out: [*c]u8, outlen: usize) usize;
pub extern fn SSL_SESSION_set1_master_key(sess: ?*SSL_SESSION, in: [*c]const u8, len: usize) c_int;
pub extern fn SSL_SESSION_get_max_fragment_length(sess: ?*const SSL_SESSION) u8;
pub extern fn SSL_set_ex_data(ssl: ?*SSL, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn SSL_get_ex_data(ssl: ?*const SSL, idx: c_int) ?*anyopaque;
pub extern fn SSL_SESSION_set_ex_data(ss: ?*SSL_SESSION, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn SSL_SESSION_get_ex_data(ss: ?*const SSL_SESSION, idx: c_int) ?*anyopaque;
pub extern fn SSL_CTX_set_ex_data(ssl: ?*SSL_CTX, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn SSL_CTX_get_ex_data(ssl: ?*const SSL_CTX, idx: c_int) ?*anyopaque;
pub extern fn SSL_get_ex_data_X509_STORE_CTX_idx() c_int;
pub extern fn SSL_CTX_set_default_read_buffer_len(ctx: ?*SSL_CTX, len: usize) void;
pub extern fn SSL_set_default_read_buffer_len(s: ?*SSL, len: usize) void;
pub extern fn SSL_CTX_set_tmp_dh_callback(ctx: ?*SSL_CTX, dh: ?*const fn (?*SSL, c_int, c_int) callconv(.c) ?*DH) void;
pub extern fn SSL_set_tmp_dh_callback(ssl: ?*SSL, dh: ?*const fn (?*SSL, c_int, c_int) callconv(.c) ?*DH) void;
pub extern fn SSL_get_current_compression(s: ?*const SSL) ?*const COMP_METHOD;
pub extern fn SSL_get_current_expansion(s: ?*const SSL) ?*const COMP_METHOD;
pub extern fn SSL_COMP_get_name(comp: ?*const COMP_METHOD) [*c]const u8;
pub extern fn SSL_COMP_get0_name(comp: ?*const SSL_COMP) [*c]const u8;
pub extern fn SSL_COMP_get_id(comp: ?*const SSL_COMP) c_int;
pub extern fn SSL_COMP_get_compression_methods() ?*struct_stack_st_SSL_COMP;
pub extern fn SSL_COMP_set0_compression_methods(meths: ?*struct_stack_st_SSL_COMP) ?*struct_stack_st_SSL_COMP;
pub extern fn SSL_COMP_add_compression_method(id: c_int, cm: ?*COMP_METHOD) c_int;
pub extern fn SSL_CIPHER_find(ssl: ?*SSL, ptr: [*c]const u8) ?*const SSL_CIPHER;
pub extern fn SSL_CIPHER_get_cipher_nid(c: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_CIPHER_get_digest_nid(c: ?*const SSL_CIPHER) c_int;
pub extern fn SSL_bytes_to_cipher_list(s: ?*SSL, bytes: [*c]const u8, len: usize, isv2format: c_int, sk: [*c]?*struct_stack_st_SSL_CIPHER, scsvs: [*c]?*struct_stack_st_SSL_CIPHER) c_int;
pub extern fn SSL_set_session_ticket_ext(s: ?*SSL, ext_data: ?*anyopaque, ext_len: c_int) c_int;
pub extern fn SSL_set_session_ticket_ext_cb(s: ?*SSL, cb: tls_session_ticket_ext_cb_fn, arg: ?*anyopaque) c_int;
pub extern fn SSL_set_session_secret_cb(s: ?*SSL, session_secret_cb: tls_session_secret_cb_fn, arg: ?*anyopaque) c_int;
pub extern fn SSL_CTX_set_not_resumable_session_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*SSL, c_int) callconv(.c) c_int) void;
pub extern fn SSL_set_not_resumable_session_callback(ssl: ?*SSL, cb: ?*const fn (?*SSL, c_int) callconv(.c) c_int) void;
pub extern fn SSL_CTX_set_record_padding_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*SSL, c_int, usize, ?*anyopaque) callconv(.c) usize) void;
pub extern fn SSL_CTX_set_record_padding_callback_arg(ctx: ?*SSL_CTX, arg: ?*anyopaque) void;
pub extern fn SSL_CTX_get_record_padding_callback_arg(ctx: ?*const SSL_CTX) ?*anyopaque;
pub extern fn SSL_CTX_set_block_padding(ctx: ?*SSL_CTX, block_size: usize) c_int;
pub extern fn SSL_CTX_set_block_padding_ex(ctx: ?*SSL_CTX, app_block_size: usize, hs_block_size: usize) c_int;
pub extern fn SSL_set_record_padding_callback(ssl: ?*SSL, cb: ?*const fn (?*SSL, c_int, usize, ?*anyopaque) callconv(.c) usize) c_int;
pub extern fn SSL_set_record_padding_callback_arg(ssl: ?*SSL, arg: ?*anyopaque) void;
pub extern fn SSL_get_record_padding_callback_arg(ssl: ?*const SSL) ?*anyopaque;
pub extern fn SSL_set_block_padding(ssl: ?*SSL, block_size: usize) c_int;
pub extern fn SSL_set_block_padding_ex(ssl: ?*SSL, app_block_size: usize, hs_block_size: usize) c_int;
pub extern fn SSL_set_num_tickets(s: ?*SSL, num_tickets: usize) c_int;
pub extern fn SSL_get_num_tickets(s: ?*const SSL) usize;
pub extern fn SSL_CTX_set_num_tickets(ctx: ?*SSL_CTX, num_tickets: usize) c_int;
pub extern fn SSL_CTX_get_num_tickets(ctx: ?*const SSL_CTX) usize;
pub extern fn SSL_handle_events(s: ?*SSL) c_int;
pub extern fn SSL_get_event_timeout(s: ?*SSL, tv: [*c]struct_timeval, is_infinite: [*c]c_int) c_int;
pub extern fn SSL_get_rpoll_descriptor(s: ?*SSL, desc: [*c]BIO_POLL_DESCRIPTOR) c_int;
pub extern fn SSL_get_wpoll_descriptor(s: ?*SSL, desc: [*c]BIO_POLL_DESCRIPTOR) c_int;
pub extern fn SSL_net_read_desired(s: ?*SSL) c_int;
pub extern fn SSL_net_write_desired(s: ?*SSL) c_int;
pub extern fn SSL_set_blocking_mode(s: ?*SSL, blocking: c_int) c_int;
pub extern fn SSL_get_blocking_mode(s: ?*SSL) c_int;
pub extern fn SSL_set1_initial_peer_addr(s: ?*SSL, peer_addr: ?*const BIO_ADDR) c_int;
pub extern fn SSL_get0_connection(s: ?*SSL) ?*SSL;
pub extern fn SSL_is_connection(s: ?*SSL) c_int;
pub extern fn SSL_get_stream_type(s: ?*SSL) c_int;
pub extern fn SSL_get_stream_id(s: ?*SSL) u64;
pub extern fn SSL_is_stream_local(s: ?*SSL) c_int;
pub extern fn SSL_set_default_stream_mode(s: ?*SSL, mode: u32) c_int;
pub extern fn SSL_new_stream(s: ?*SSL, flags: u64) ?*SSL;
pub extern fn SSL_set_incoming_stream_policy(s: ?*SSL, policy: c_int, aec: u64) c_int;
pub extern fn SSL_accept_stream(s: ?*SSL, flags: u64) ?*SSL;
pub extern fn SSL_get_accept_stream_queue_len(s: ?*SSL) usize;
pub extern fn SSL_inject_net_dgram(s: ?*SSL, buf: [*c]const u8, buf_len: usize, peer: ?*const BIO_ADDR, local: ?*const BIO_ADDR) c_int;
pub const struct_ssl_shutdown_ex_args_st = extern struct {
    quic_error_code: u64 = @import("std").mem.zeroes(u64),
    quic_reason: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const SSL_SHUTDOWN_EX_ARGS = struct_ssl_shutdown_ex_args_st;
pub extern fn SSL_shutdown_ex(ssl: ?*SSL, flags: u64, args: [*c]const SSL_SHUTDOWN_EX_ARGS, args_len: usize) c_int;
pub extern fn SSL_stream_conclude(ssl: ?*SSL, flags: u64) c_int;
pub const struct_ssl_stream_reset_args_st = extern struct {
    quic_error_code: u64 = @import("std").mem.zeroes(u64),
};
pub const SSL_STREAM_RESET_ARGS = struct_ssl_stream_reset_args_st;
pub extern fn SSL_stream_reset(ssl: ?*SSL, args: [*c]const SSL_STREAM_RESET_ARGS, args_len: usize) c_int;
pub extern fn SSL_get_stream_read_state(ssl: ?*SSL) c_int;
pub extern fn SSL_get_stream_write_state(ssl: ?*SSL) c_int;
pub extern fn SSL_get_stream_read_error_code(ssl: ?*SSL, app_error_code: [*c]u64) c_int;
pub extern fn SSL_get_stream_write_error_code(ssl: ?*SSL, app_error_code: [*c]u64) c_int;
pub const struct_ssl_conn_close_info_st = extern struct {
    error_code: u64 = @import("std").mem.zeroes(u64),
    frame_type: u64 = @import("std").mem.zeroes(u64),
    reason: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    reason_len: usize = @import("std").mem.zeroes(usize),
    flags: u32 = @import("std").mem.zeroes(u32),
};
pub const SSL_CONN_CLOSE_INFO = struct_ssl_conn_close_info_st;
pub extern fn SSL_get_conn_close_info(ssl: ?*SSL, info: [*c]SSL_CONN_CLOSE_INFO, info_len: usize) c_int;
pub extern fn SSL_get_value_uint(s: ?*SSL, class_: u32, id: u32, v: [*c]u64) c_int;
pub extern fn SSL_set_value_uint(s: ?*SSL, class_: u32, id: u32, v: u64) c_int;
pub const struct_ssl_poll_item_st = extern struct {
    desc: BIO_POLL_DESCRIPTOR = @import("std").mem.zeroes(BIO_POLL_DESCRIPTOR),
    events: u64 = @import("std").mem.zeroes(u64),
    revents: u64 = @import("std").mem.zeroes(u64),
};
pub const SSL_POLL_ITEM = struct_ssl_poll_item_st;
pub extern fn SSL_poll(items: [*c]SSL_POLL_ITEM, num_items: usize, stride: usize, timeout: [*c]const struct_timeval, flags: u64, result_count: [*c]usize) c_int;
pub fn SSL_as_poll_descriptor(arg_s: ?*SSL) callconv(.c) BIO_POLL_DESCRIPTOR {
    var s = arg_s;
    _ = &s;
    var d: BIO_POLL_DESCRIPTOR = undefined;
    _ = &d;
    d.type = 2;
    d.value.ssl = s;
    return d;
}
pub extern fn SSL_session_reused(s: ?*const SSL) c_int;
pub extern fn SSL_is_server(s: ?*const SSL) c_int;
pub extern fn SSL_CONF_CTX_new() ?*SSL_CONF_CTX;
pub extern fn SSL_CONF_CTX_finish(cctx: ?*SSL_CONF_CTX) c_int;
pub extern fn SSL_CONF_CTX_free(cctx: ?*SSL_CONF_CTX) void;
pub extern fn SSL_CONF_CTX_set_flags(cctx: ?*SSL_CONF_CTX, flags: c_uint) c_uint;
pub extern fn SSL_CONF_CTX_clear_flags(cctx: ?*SSL_CONF_CTX, flags: c_uint) c_uint;
pub extern fn SSL_CONF_CTX_set1_prefix(cctx: ?*SSL_CONF_CTX, pre: [*c]const u8) c_int;
pub extern fn SSL_CONF_CTX_set_ssl(cctx: ?*SSL_CONF_CTX, ssl: ?*SSL) void;
pub extern fn SSL_CONF_CTX_set_ssl_ctx(cctx: ?*SSL_CONF_CTX, ctx: ?*SSL_CTX) void;
pub extern fn SSL_CONF_cmd(cctx: ?*SSL_CONF_CTX, cmd: [*c]const u8, value: [*c]const u8) c_int;
pub extern fn SSL_CONF_cmd_argv(cctx: ?*SSL_CONF_CTX, pargc: [*c]c_int, pargv: [*c][*c][*c]u8) c_int;
pub extern fn SSL_CONF_cmd_value_type(cctx: ?*SSL_CONF_CTX, cmd: [*c]const u8) c_int;
pub extern fn SSL_add_ssl_module() void;
pub extern fn SSL_config(s: ?*SSL, name: [*c]const u8) c_int;
pub extern fn SSL_CTX_config(ctx: ?*SSL_CTX, name: [*c]const u8) c_int;
pub extern fn SSL_trace(write_p: c_int, version: c_int, content_type: c_int, buf: ?*const anyopaque, len: usize, ssl: ?*SSL, arg: ?*anyopaque) void;
pub extern fn DTLSv1_listen(s: ?*SSL, client: ?*BIO_ADDR) c_int;
pub const ssl_ct_validation_cb = ?*const fn (?*const CT_POLICY_EVAL_CTX, ?*const struct_stack_st_SCT, ?*anyopaque) callconv(.c) c_int;
pub extern fn SSL_set_ct_validation_callback(s: ?*SSL, callback: ssl_ct_validation_cb, arg: ?*anyopaque) c_int;
pub extern fn SSL_CTX_set_ct_validation_callback(ctx: ?*SSL_CTX, callback: ssl_ct_validation_cb, arg: ?*anyopaque) c_int;
pub const SSL_CT_VALIDATION_PERMISSIVE: c_int = 0;
pub const SSL_CT_VALIDATION_STRICT: c_int = 1;
const enum_unnamed_102 = c_uint;
pub extern fn SSL_enable_ct(s: ?*SSL, validation_mode: c_int) c_int;
pub extern fn SSL_CTX_enable_ct(ctx: ?*SSL_CTX, validation_mode: c_int) c_int;
pub extern fn SSL_ct_is_enabled(s: ?*const SSL) c_int;
pub extern fn SSL_CTX_ct_is_enabled(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_get0_peer_scts(s: ?*SSL) ?*const struct_stack_st_SCT;
pub extern fn SSL_CTX_set_default_ctlog_list_file(ctx: ?*SSL_CTX) c_int;
pub extern fn SSL_CTX_set_ctlog_list_file(ctx: ?*SSL_CTX, path: [*c]const u8) c_int;
pub extern fn SSL_CTX_set0_ctlog_store(ctx: ?*SSL_CTX, logs: ?*CTLOG_STORE) void;
pub extern fn SSL_CTX_get0_ctlog_store(ctx: ?*const SSL_CTX) ?*const CTLOG_STORE;
pub extern fn SSL_set_security_level(s: ?*SSL, level: c_int) void;
pub extern fn SSL_get_security_level(s: ?*const SSL) c_int;
pub extern fn SSL_set_security_callback(s: ?*SSL, cb: ?*const fn (?*const SSL, ?*const SSL_CTX, c_int, c_int, c_int, ?*anyopaque, ?*anyopaque) callconv(.c) c_int) void;
pub extern fn SSL_get_security_callback(s: ?*const SSL) ?*const fn (?*const SSL, ?*const SSL_CTX, c_int, c_int, c_int, ?*anyopaque, ?*anyopaque) callconv(.c) c_int;
pub extern fn SSL_set0_security_ex_data(s: ?*SSL, ex: ?*anyopaque) void;
pub extern fn SSL_get0_security_ex_data(s: ?*const SSL) ?*anyopaque;
pub extern fn SSL_CTX_set_security_level(ctx: ?*SSL_CTX, level: c_int) void;
pub extern fn SSL_CTX_get_security_level(ctx: ?*const SSL_CTX) c_int;
pub extern fn SSL_CTX_set_security_callback(ctx: ?*SSL_CTX, cb: ?*const fn (?*const SSL, ?*const SSL_CTX, c_int, c_int, c_int, ?*anyopaque, ?*anyopaque) callconv(.c) c_int) void;
pub extern fn SSL_CTX_get_security_callback(ctx: ?*const SSL_CTX) ?*const fn (?*const SSL, ?*const SSL_CTX, c_int, c_int, c_int, ?*anyopaque, ?*anyopaque) callconv(.c) c_int;
pub extern fn SSL_CTX_set0_security_ex_data(ctx: ?*SSL_CTX, ex: ?*anyopaque) void;
pub extern fn SSL_CTX_get0_security_ex_data(ctx: ?*const SSL_CTX) ?*anyopaque;
pub extern fn OPENSSL_init_ssl(opts: u64, settings: ?*const OPENSSL_INIT_SETTINGS) c_int;
pub extern fn SSL_free_buffers(ssl: ?*SSL) c_int;
pub extern fn SSL_alloc_buffers(ssl: ?*SSL) c_int;
pub const SSL_TICKET_STATUS = c_int;
pub const SSL_TICKET_RETURN = c_int;
pub const SSL_CTX_generate_session_ticket_fn = ?*const fn (?*SSL, ?*anyopaque) callconv(.c) c_int;
pub const SSL_CTX_decrypt_session_ticket_fn = ?*const fn (?*SSL, ?*SSL_SESSION, [*c]const u8, usize, SSL_TICKET_STATUS, ?*anyopaque) callconv(.c) SSL_TICKET_RETURN;
pub extern fn SSL_CTX_set_session_ticket_cb(ctx: ?*SSL_CTX, gen_cb: SSL_CTX_generate_session_ticket_fn, dec_cb: SSL_CTX_decrypt_session_ticket_fn, arg: ?*anyopaque) c_int;
pub extern fn SSL_SESSION_set1_ticket_appdata(ss: ?*SSL_SESSION, data: ?*const anyopaque, len: usize) c_int;
pub extern fn SSL_SESSION_get0_ticket_appdata(ss: ?*SSL_SESSION, data: [*c]?*anyopaque, len: [*c]usize) c_int;
pub const DTLS_timer_cb = ?*const fn (?*SSL, c_uint) callconv(.c) c_uint;
pub extern fn DTLS_set_timer_cb(s: ?*SSL, cb: DTLS_timer_cb) void;
pub const SSL_allow_early_data_cb_fn = ?*const fn (?*SSL, ?*anyopaque) callconv(.c) c_int;
pub extern fn SSL_CTX_set_allow_early_data_cb(ctx: ?*SSL_CTX, cb: SSL_allow_early_data_cb_fn, arg: ?*anyopaque) void;
pub extern fn SSL_set_allow_early_data_cb(s: ?*SSL, cb: SSL_allow_early_data_cb_fn, arg: ?*anyopaque) void;
pub extern fn OSSL_default_cipher_list() [*c]const u8;
pub extern fn OSSL_default_ciphersuites() [*c]const u8;
pub extern fn SSL_CTX_compress_certs(ctx: ?*SSL_CTX, alg: c_int) c_int;
pub extern fn SSL_compress_certs(ssl: ?*SSL, alg: c_int) c_int;
pub extern fn SSL_CTX_set1_cert_comp_preference(ctx: ?*SSL_CTX, algs: [*c]c_int, len: usize) c_int;
pub extern fn SSL_set1_cert_comp_preference(ssl: ?*SSL, algs: [*c]c_int, len: usize) c_int;
pub extern fn SSL_CTX_set1_compressed_cert(ctx: ?*SSL_CTX, algorithm: c_int, comp_data: [*c]u8, comp_length: usize, orig_length: usize) c_int;
pub extern fn SSL_set1_compressed_cert(ssl: ?*SSL, algorithm: c_int, comp_data: [*c]u8, comp_length: usize, orig_length: usize) c_int;
pub extern fn SSL_CTX_get1_compressed_cert(ctx: ?*SSL_CTX, alg: c_int, data: [*c][*c]u8, orig_len: [*c]usize) usize;
pub extern fn SSL_get1_compressed_cert(ssl: ?*SSL, alg: c_int, data: [*c][*c]u8, orig_len: [*c]usize) usize;
pub extern fn SSL_add_expected_rpk(s: ?*SSL, rpk: ?*EVP_PKEY) c_int;
pub extern fn SSL_get0_peer_rpk(s: ?*const SSL) ?*EVP_PKEY;
pub extern fn SSL_SESSION_get0_peer_rpk(s: ?*SSL_SESSION) ?*EVP_PKEY;
pub extern fn SSL_get_negotiated_client_cert_type(s: ?*const SSL) c_int;
pub extern fn SSL_get_negotiated_server_cert_type(s: ?*const SSL) c_int;
pub extern fn SSL_set1_client_cert_type(s: ?*SSL, val: [*c]const u8, len: usize) c_int;
pub extern fn SSL_set1_server_cert_type(s: ?*SSL, val: [*c]const u8, len: usize) c_int;
pub extern fn SSL_CTX_set1_client_cert_type(ctx: ?*SSL_CTX, val: [*c]const u8, len: usize) c_int;
pub extern fn SSL_CTX_set1_server_cert_type(ctx: ?*SSL_CTX, val: [*c]const u8, len: usize) c_int;
pub extern fn SSL_get0_client_cert_type(s: ?*const SSL, t: [*c][*c]u8, len: [*c]usize) c_int;
pub extern fn SSL_get0_server_cert_type(s: ?*const SSL, t: [*c][*c]u8, len: [*c]usize) c_int;
pub extern fn SSL_CTX_get0_client_cert_type(ctx: ?*const SSL_CTX, t: [*c][*c]u8, len: [*c]usize) c_int;
pub extern fn SSL_CTX_get0_server_cert_type(s: ?*const SSL_CTX, t: [*c][*c]u8, len: [*c]usize) c_int;
pub fn ERR_GET_LIB(arg_errcode: c_ulong) callconv(.c) c_int {
    var errcode = arg_errcode;
    _ = &errcode;
    if ((errcode & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, @bitCast(@as(c_int, 2147483647))) +% @as(c_uint, @bitCast(@as(c_int, 1))))))) != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) return 2;
    return @as(c_int, @bitCast(@as(c_uint, @truncate((errcode >> @intCast(23)) & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 255))))))));
}
pub fn ERR_GET_RFLAGS(arg_errcode: c_ulong) callconv(.c) c_int {
    var errcode = arg_errcode;
    _ = &errcode;
    if ((errcode & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, @bitCast(@as(c_int, 2147483647))) +% @as(c_uint, @bitCast(@as(c_int, 1))))))) != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) return 0;
    return @as(c_int, @bitCast(@as(c_uint, @truncate(errcode & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 31) << @intCast(18))))))));
}
pub fn ERR_GET_REASON(arg_errcode: c_ulong) callconv(.c) c_int {
    var errcode = arg_errcode;
    _ = &errcode;
    if ((errcode & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, @bitCast(@as(c_int, 2147483647))) +% @as(c_uint, @bitCast(@as(c_int, 1))))))) != @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 0))))) return @as(c_int, @bitCast(@as(c_uint, @truncate(errcode & @as(c_ulong, @bitCast(@as(c_ulong, @as(c_uint, @bitCast(@as(c_int, 2147483647))))))))));
    return @as(c_int, @bitCast(@as(c_uint, @truncate(errcode & @as(c_ulong, @bitCast(@as(c_long, @as(c_int, 8388607))))))));
}
pub fn ERR_FATAL_ERROR(arg_errcode: c_ulong) callconv(.c) c_int {
    var errcode = arg_errcode;
    _ = &errcode;
    return @intFromBool((ERR_GET_RFLAGS(errcode) & (@as(c_int, 1) << @intCast(18))) != @as(c_int, 0));
}
pub fn ERR_COMMON_ERROR(arg_errcode: c_ulong) callconv(.c) c_int {
    var errcode = arg_errcode;
    _ = &errcode;
    return @intFromBool((ERR_GET_RFLAGS(errcode) & (@as(c_int, 2) << @intCast(18))) != @as(c_int, 0));
}
pub const struct_ERR_string_data_st = extern struct {
    @"error": c_ulong = @import("std").mem.zeroes(c_ulong),
    string: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
};
pub const ERR_STRING_DATA = struct_ERR_string_data_st;
pub const union_lh_ERR_STRING_DATA_dummy_103 = extern union {
    d1: ?*anyopaque,
    d2: c_ulong,
    d3: c_int,
};
pub const struct_lhash_st_ERR_STRING_DATA = extern struct {
    dummy: union_lh_ERR_STRING_DATA_dummy_103 = @import("std").mem.zeroes(union_lh_ERR_STRING_DATA_dummy_103),
};
pub const lh_ERR_STRING_DATA_compfunc = ?*const fn ([*c]const ERR_STRING_DATA, [*c]const ERR_STRING_DATA) callconv(.c) c_int;
pub const lh_ERR_STRING_DATA_hashfunc = ?*const fn ([*c]const ERR_STRING_DATA) callconv(.c) c_ulong;
pub const lh_ERR_STRING_DATA_doallfunc = ?*const fn ([*c]ERR_STRING_DATA) callconv(.c) void;
pub fn lh_ERR_STRING_DATA_hash_thunk(arg_data: ?*const anyopaque, arg_hfn: OPENSSL_LH_HASHFUNC) callconv(.c) c_ulong {
    var data = arg_data;
    _ = &data;
    var hfn = arg_hfn;
    _ = &hfn;
    var hfn_conv: ?*const fn ([*c]const ERR_STRING_DATA) callconv(.c) c_ulong = @as(?*const fn ([*c]const ERR_STRING_DATA) callconv(.c) c_ulong, @ptrCast(@alignCast(hfn)));
    _ = &hfn_conv;
    return hfn_conv.?(@as([*c]const ERR_STRING_DATA, @ptrCast(@alignCast(data))));
}
pub fn lh_ERR_STRING_DATA_comp_thunk(arg_da: ?*const anyopaque, arg_db: ?*const anyopaque, arg_cfn: OPENSSL_LH_COMPFUNC) callconv(.c) c_int {
    var da = arg_da;
    _ = &da;
    var db = arg_db;
    _ = &db;
    var cfn = arg_cfn;
    _ = &cfn;
    var cfn_conv: ?*const fn ([*c]const ERR_STRING_DATA, [*c]const ERR_STRING_DATA) callconv(.c) c_int = @as(?*const fn ([*c]const ERR_STRING_DATA, [*c]const ERR_STRING_DATA) callconv(.c) c_int, @ptrCast(@alignCast(cfn)));
    _ = &cfn_conv;
    return cfn_conv.?(@as([*c]const ERR_STRING_DATA, @ptrCast(@alignCast(da))), @as([*c]const ERR_STRING_DATA, @ptrCast(@alignCast(db))));
}
pub fn lh_ERR_STRING_DATA_doall_thunk(arg_node: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNC) callconv(.c) void {
    var node = arg_node;
    _ = &node;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]ERR_STRING_DATA) callconv(.c) void = @as(?*const fn ([*c]ERR_STRING_DATA) callconv(.c) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]ERR_STRING_DATA, @ptrCast(@alignCast(node))));
}
pub fn lh_ERR_STRING_DATA_doall_arg_thunk(arg_node: ?*anyopaque, arg_arg: ?*anyopaque, arg_doall: OPENSSL_LH_DOALL_FUNCARG) callconv(.c) void {
    var node = arg_node;
    _ = &node;
    var arg = arg_arg;
    _ = &arg;
    var doall = arg_doall;
    _ = &doall;
    var doall_conv: ?*const fn ([*c]ERR_STRING_DATA, ?*anyopaque) callconv(.c) void = @as(?*const fn ([*c]ERR_STRING_DATA, ?*anyopaque) callconv(.c) void, @ptrCast(@alignCast(doall)));
    _ = &doall_conv;
    doall_conv.?(@as([*c]ERR_STRING_DATA, @ptrCast(@alignCast(node))), arg);
}
pub fn ossl_check_ERR_STRING_DATA_lh_plain_type(arg_ptr: [*c]ERR_STRING_DATA) callconv(.c) [*c]ERR_STRING_DATA {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ERR_STRING_DATA_lh_plain_type(arg_ptr: [*c]const ERR_STRING_DATA) callconv(.c) [*c]const ERR_STRING_DATA {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ERR_STRING_DATA_lh_type(arg_lh: [*c]const struct_lhash_st_ERR_STRING_DATA) callconv(.c) ?*const OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*const OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_ERR_STRING_DATA_lh_type(arg_lh: [*c]struct_lhash_st_ERR_STRING_DATA) callconv(.c) ?*OPENSSL_LHASH {
    var lh = arg_lh;
    _ = &lh;
    return @as(?*OPENSSL_LHASH, @ptrCast(lh));
}
pub fn ossl_check_ERR_STRING_DATA_lh_compfunc_type(arg_cmp: lh_ERR_STRING_DATA_compfunc) callconv(.c) OPENSSL_LH_COMPFUNC {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_LH_COMPFUNC, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ERR_STRING_DATA_lh_hashfunc_type(arg_hfn: lh_ERR_STRING_DATA_hashfunc) callconv(.c) OPENSSL_LH_HASHFUNC {
    var hfn = arg_hfn;
    _ = &hfn;
    return @as(OPENSSL_LH_HASHFUNC, @ptrCast(@alignCast(hfn)));
}
pub fn ossl_check_ERR_STRING_DATA_lh_doallfunc_type(arg_dfn: lh_ERR_STRING_DATA_doallfunc) callconv(.c) OPENSSL_LH_DOALL_FUNC {
    var dfn = arg_dfn;
    _ = &dfn;
    return @as(OPENSSL_LH_DOALL_FUNC, @ptrCast(@alignCast(dfn)));
}
pub extern fn ERR_new() void;
pub extern fn ERR_set_debug(file: [*c]const u8, line: c_int, func: [*c]const u8) void;
pub extern fn ERR_set_error(lib: c_int, reason: c_int, fmt: [*c]const u8, ...) void;
pub extern fn ERR_vset_error(lib: c_int, reason: c_int, fmt: [*c]const u8, args: [*c]struct___va_list_tag_5) void;
pub extern fn ERR_set_error_data(data: [*c]u8, flags: c_int) void;
pub extern fn ERR_get_error() c_ulong;
pub extern fn ERR_get_error_all(file: [*c][*c]const u8, line: [*c]c_int, func: [*c][*c]const u8, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_get_error_line(file: [*c][*c]const u8, line: [*c]c_int) c_ulong;
pub extern fn ERR_get_error_line_data(file: [*c][*c]const u8, line: [*c]c_int, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_error() c_ulong;
pub extern fn ERR_peek_error_line(file: [*c][*c]const u8, line: [*c]c_int) c_ulong;
pub extern fn ERR_peek_error_func(func: [*c][*c]const u8) c_ulong;
pub extern fn ERR_peek_error_data(data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_error_all(file: [*c][*c]const u8, line: [*c]c_int, func: [*c][*c]const u8, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_error_line_data(file: [*c][*c]const u8, line: [*c]c_int, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_last_error() c_ulong;
pub extern fn ERR_peek_last_error_line(file: [*c][*c]const u8, line: [*c]c_int) c_ulong;
pub extern fn ERR_peek_last_error_func(func: [*c][*c]const u8) c_ulong;
pub extern fn ERR_peek_last_error_data(data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_last_error_all(file: [*c][*c]const u8, line: [*c]c_int, func: [*c][*c]const u8, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_peek_last_error_line_data(file: [*c][*c]const u8, line: [*c]c_int, data: [*c][*c]const u8, flags: [*c]c_int) c_ulong;
pub extern fn ERR_clear_error() void;
pub extern fn ERR_error_string(e: c_ulong, buf: [*c]u8) [*c]u8;
pub extern fn ERR_error_string_n(e: c_ulong, buf: [*c]u8, len: usize) void;
pub extern fn ERR_lib_error_string(e: c_ulong) [*c]const u8;
pub extern fn ERR_func_error_string(e: c_ulong) [*c]const u8;
pub extern fn ERR_reason_error_string(e: c_ulong) [*c]const u8;
pub extern fn ERR_print_errors_cb(cb: ?*const fn ([*c]const u8, usize, ?*anyopaque) callconv(.c) c_int, u: ?*anyopaque) void;
pub extern fn ERR_print_errors_fp(fp: [*c]FILE) void;
pub extern fn ERR_print_errors(bp: ?*BIO) void;
pub extern fn ERR_add_error_data(num: c_int, ...) void;
pub extern fn ERR_add_error_vdata(num: c_int, args: [*c]struct___va_list_tag_5) void;
pub extern fn ERR_add_error_txt(sepr: [*c]const u8, txt: [*c]const u8) void;
pub extern fn ERR_add_error_mem_bio(sep: [*c]const u8, bio: ?*BIO) void;
pub extern fn ERR_load_strings(lib: c_int, str: [*c]ERR_STRING_DATA) c_int;
pub extern fn ERR_load_strings_const(str: [*c]const ERR_STRING_DATA) c_int;
pub extern fn ERR_unload_strings(lib: c_int, str: [*c]ERR_STRING_DATA) c_int;
pub extern fn ERR_remove_thread_state(?*anyopaque) void;
pub extern fn ERR_remove_state(pid: c_ulong) void;
pub extern fn ERR_get_state() [*c]ERR_STATE;
pub extern fn ERR_get_next_error_library() c_int;
pub extern fn ERR_set_mark() c_int;
pub extern fn ERR_pop_to_mark() c_int;
pub extern fn ERR_clear_last_mark() c_int;
pub extern fn ERR_count_to_mark() c_int;
pub extern fn ERR_pop() c_int;
pub extern fn OSSL_ERR_STATE_new() [*c]ERR_STATE;
pub extern fn OSSL_ERR_STATE_save(es: [*c]ERR_STATE) void;
pub extern fn OSSL_ERR_STATE_save_to_mark(es: [*c]ERR_STATE) void;
pub extern fn OSSL_ERR_STATE_restore(es: [*c]const ERR_STATE) void;
pub extern fn OSSL_ERR_STATE_free(es: [*c]ERR_STATE) void;
pub extern fn RAND_set_rand_method(meth: [*c]const RAND_METHOD) c_int;
pub extern fn RAND_get_rand_method() [*c]const RAND_METHOD;
pub extern fn RAND_set_rand_engine(engine: ?*ENGINE) c_int;
pub extern fn RAND_OpenSSL() [*c]RAND_METHOD;
pub extern fn RAND_bytes(buf: [*c]u8, num: c_int) c_int;
pub extern fn RAND_priv_bytes(buf: [*c]u8, num: c_int) c_int;
pub extern fn RAND_priv_bytes_ex(ctx: ?*OSSL_LIB_CTX, buf: [*c]u8, num: usize, strength: c_uint) c_int;
pub extern fn RAND_bytes_ex(ctx: ?*OSSL_LIB_CTX, buf: [*c]u8, num: usize, strength: c_uint) c_int;
pub extern fn RAND_pseudo_bytes(buf: [*c]u8, num: c_int) c_int;
pub extern fn RAND_get0_primary(ctx: ?*OSSL_LIB_CTX) ?*EVP_RAND_CTX;
pub extern fn RAND_get0_public(ctx: ?*OSSL_LIB_CTX) ?*EVP_RAND_CTX;
pub extern fn RAND_get0_private(ctx: ?*OSSL_LIB_CTX) ?*EVP_RAND_CTX;
pub extern fn RAND_set0_public(ctx: ?*OSSL_LIB_CTX, rand: ?*EVP_RAND_CTX) c_int;
pub extern fn RAND_set0_private(ctx: ?*OSSL_LIB_CTX, rand: ?*EVP_RAND_CTX) c_int;
pub extern fn RAND_set_DRBG_type(ctx: ?*OSSL_LIB_CTX, drbg: [*c]const u8, propq: [*c]const u8, cipher: [*c]const u8, digest: [*c]const u8) c_int;
pub extern fn RAND_set_seed_source_type(ctx: ?*OSSL_LIB_CTX, seed: [*c]const u8, propq: [*c]const u8) c_int;
pub extern fn RAND_seed(buf: ?*const anyopaque, num: c_int) void;
pub extern fn RAND_keep_random_devices_open(keep: c_int) void;
pub extern fn RAND_add(buf: ?*const anyopaque, num: c_int, randomness: f64) void;
pub extern fn RAND_load_file(file: [*c]const u8, max_bytes: c_long) c_int;
pub extern fn RAND_write_file(file: [*c]const u8) c_int;
pub extern fn RAND_file_name(file: [*c]u8, num: usize) [*c]const u8;
pub extern fn RAND_status() c_int;
pub extern fn RAND_poll() c_int;
pub extern fn UI_new() ?*UI;
pub extern fn UI_new_method(method: ?*const UI_METHOD) ?*UI;
pub extern fn UI_free(ui: ?*UI) void;
pub extern fn UI_add_input_string(ui: ?*UI, prompt: [*c]const u8, flags: c_int, result_buf: [*c]u8, minsize: c_int, maxsize: c_int) c_int;
pub extern fn UI_dup_input_string(ui: ?*UI, prompt: [*c]const u8, flags: c_int, result_buf: [*c]u8, minsize: c_int, maxsize: c_int) c_int;
pub extern fn UI_add_verify_string(ui: ?*UI, prompt: [*c]const u8, flags: c_int, result_buf: [*c]u8, minsize: c_int, maxsize: c_int, test_buf: [*c]const u8) c_int;
pub extern fn UI_dup_verify_string(ui: ?*UI, prompt: [*c]const u8, flags: c_int, result_buf: [*c]u8, minsize: c_int, maxsize: c_int, test_buf: [*c]const u8) c_int;
pub extern fn UI_add_input_boolean(ui: ?*UI, prompt: [*c]const u8, action_desc: [*c]const u8, ok_chars: [*c]const u8, cancel_chars: [*c]const u8, flags: c_int, result_buf: [*c]u8) c_int;
pub extern fn UI_dup_input_boolean(ui: ?*UI, prompt: [*c]const u8, action_desc: [*c]const u8, ok_chars: [*c]const u8, cancel_chars: [*c]const u8, flags: c_int, result_buf: [*c]u8) c_int;
pub extern fn UI_add_info_string(ui: ?*UI, text: [*c]const u8) c_int;
pub extern fn UI_dup_info_string(ui: ?*UI, text: [*c]const u8) c_int;
pub extern fn UI_add_error_string(ui: ?*UI, text: [*c]const u8) c_int;
pub extern fn UI_dup_error_string(ui: ?*UI, text: [*c]const u8) c_int;
pub extern fn UI_construct_prompt(ui_method: ?*UI, phrase_desc: [*c]const u8, object_name: [*c]const u8) [*c]u8;
pub extern fn UI_add_user_data(ui: ?*UI, user_data: ?*anyopaque) ?*anyopaque;
pub extern fn UI_dup_user_data(ui: ?*UI, user_data: ?*anyopaque) c_int;
pub extern fn UI_get0_user_data(ui: ?*UI) ?*anyopaque;
pub extern fn UI_get0_result(ui: ?*UI, i: c_int) [*c]const u8;
pub extern fn UI_get_result_length(ui: ?*UI, i: c_int) c_int;
pub extern fn UI_process(ui: ?*UI) c_int;
pub extern fn UI_ctrl(ui: ?*UI, cmd: c_int, i: c_long, p: ?*anyopaque, f: ?*const fn () callconv(.c) void) c_int;
pub extern fn UI_set_ex_data(r: ?*UI, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn UI_get_ex_data(r: ?*const UI, idx: c_int) ?*anyopaque;
pub extern fn UI_set_default_method(meth: ?*const UI_METHOD) void;
pub extern fn UI_get_default_method() ?*const UI_METHOD;
pub extern fn UI_get_method(ui: ?*UI) ?*const UI_METHOD;
pub extern fn UI_set_method(ui: ?*UI, meth: ?*const UI_METHOD) ?*const UI_METHOD;
pub extern fn UI_OpenSSL() ?*UI_METHOD;
pub extern fn UI_null() ?*const UI_METHOD;
pub const struct_ui_string_st = opaque {};
pub const UI_STRING = struct_ui_string_st;
pub const struct_stack_st_UI_STRING = opaque {};
pub const sk_UI_STRING_compfunc = ?*const fn ([*c]const ?*const UI_STRING, [*c]const ?*const UI_STRING) callconv(.c) c_int;
pub const sk_UI_STRING_freefunc = ?*const fn (?*UI_STRING) callconv(.c) void;
pub const sk_UI_STRING_copyfunc = ?*const fn (?*const UI_STRING) callconv(.c) ?*UI_STRING;
pub fn ossl_check_UI_STRING_type(arg_ptr: ?*UI_STRING) callconv(.c) ?*UI_STRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_UI_STRING_sk_type(arg_sk: ?*const struct_stack_st_UI_STRING) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_UI_STRING_sk_type(arg_sk: ?*struct_stack_st_UI_STRING) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_UI_STRING_compfunc_type(arg_cmp: sk_UI_STRING_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_UI_STRING_copyfunc_type(arg_cpy: sk_UI_STRING_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_UI_STRING_freefunc_type(arg_fr: sk_UI_STRING_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const UIT_NONE: c_int = 0;
pub const UIT_PROMPT: c_int = 1;
pub const UIT_VERIFY: c_int = 2;
pub const UIT_BOOLEAN: c_int = 3;
pub const UIT_INFO: c_int = 4;
pub const UIT_ERROR: c_int = 5;
pub const enum_UI_string_types = c_uint;
pub extern fn UI_create_method(name: [*c]const u8) ?*UI_METHOD;
pub extern fn UI_destroy_method(ui_method: ?*UI_METHOD) void;
pub extern fn UI_method_set_opener(method: ?*UI_METHOD, opener: ?*const fn (?*UI) callconv(.c) c_int) c_int;
pub extern fn UI_method_set_writer(method: ?*UI_METHOD, writer: ?*const fn (?*UI, ?*UI_STRING) callconv(.c) c_int) c_int;
pub extern fn UI_method_set_flusher(method: ?*UI_METHOD, flusher: ?*const fn (?*UI) callconv(.c) c_int) c_int;
pub extern fn UI_method_set_reader(method: ?*UI_METHOD, reader: ?*const fn (?*UI, ?*UI_STRING) callconv(.c) c_int) c_int;
pub extern fn UI_method_set_closer(method: ?*UI_METHOD, closer: ?*const fn (?*UI) callconv(.c) c_int) c_int;
pub extern fn UI_method_set_data_duplicator(method: ?*UI_METHOD, duplicator: ?*const fn (?*UI, ?*anyopaque) callconv(.c) ?*anyopaque, destructor: ?*const fn (?*UI, ?*anyopaque) callconv(.c) void) c_int;
pub extern fn UI_method_set_prompt_constructor(method: ?*UI_METHOD, prompt_constructor: ?*const fn (?*UI, [*c]const u8, [*c]const u8) callconv(.c) [*c]u8) c_int;
pub extern fn UI_method_set_ex_data(method: ?*UI_METHOD, idx: c_int, data: ?*anyopaque) c_int;
pub extern fn UI_method_get_opener(method: ?*const UI_METHOD) ?*const fn (?*UI) callconv(.c) c_int;
pub extern fn UI_method_get_writer(method: ?*const UI_METHOD) ?*const fn (?*UI, ?*UI_STRING) callconv(.c) c_int;
pub extern fn UI_method_get_flusher(method: ?*const UI_METHOD) ?*const fn (?*UI) callconv(.c) c_int;
pub extern fn UI_method_get_reader(method: ?*const UI_METHOD) ?*const fn (?*UI, ?*UI_STRING) callconv(.c) c_int;
pub extern fn UI_method_get_closer(method: ?*const UI_METHOD) ?*const fn (?*UI) callconv(.c) c_int;
pub extern fn UI_method_get_prompt_constructor(method: ?*const UI_METHOD) ?*const fn (?*UI, [*c]const u8, [*c]const u8) callconv(.c) [*c]u8;
pub extern fn UI_method_get_data_duplicator(method: ?*const UI_METHOD) ?*const fn (?*UI, ?*anyopaque) callconv(.c) ?*anyopaque;
pub extern fn UI_method_get_data_destructor(method: ?*const UI_METHOD) ?*const fn (?*UI, ?*anyopaque) callconv(.c) void;
pub extern fn UI_method_get_ex_data(method: ?*const UI_METHOD, idx: c_int) ?*const anyopaque;
pub extern fn UI_get_string_type(uis: ?*UI_STRING) enum_UI_string_types;
pub extern fn UI_get_input_flags(uis: ?*UI_STRING) c_int;
pub extern fn UI_get0_output_string(uis: ?*UI_STRING) [*c]const u8;
pub extern fn UI_get0_action_string(uis: ?*UI_STRING) [*c]const u8;
pub extern fn UI_get0_result_string(uis: ?*UI_STRING) [*c]const u8;
pub extern fn UI_get_result_string_length(uis: ?*UI_STRING) c_int;
pub extern fn UI_get0_test_string(uis: ?*UI_STRING) [*c]const u8;
pub extern fn UI_get_result_minsize(uis: ?*UI_STRING) c_int;
pub extern fn UI_get_result_maxsize(uis: ?*UI_STRING) c_int;
pub extern fn UI_set_result(ui: ?*UI, uis: ?*UI_STRING, result: [*c]const u8) c_int;
pub extern fn UI_set_result_ex(ui: ?*UI, uis: ?*UI_STRING, result: [*c]const u8, len: c_int) c_int;
pub extern fn UI_UTIL_read_pw_string(buf: [*c]u8, length: c_int, prompt: [*c]const u8, verify: c_int) c_int;
pub extern fn UI_UTIL_read_pw(buf: [*c]u8, buff: [*c]u8, size: c_int, prompt: [*c]const u8, verify: c_int) c_int;
pub extern fn UI_UTIL_wrap_read_pem_callback(cb: ?*const pem_password_cb, rwflag: c_int) ?*UI_METHOD;
pub const struct_ENGINE_CMD_DEFN_st = extern struct {
    cmd_num: c_uint = @import("std").mem.zeroes(c_uint),
    cmd_name: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    cmd_desc: [*c]const u8 = @import("std").mem.zeroes([*c]const u8),
    cmd_flags: c_uint = @import("std").mem.zeroes(c_uint),
};
pub const ENGINE_CMD_DEFN = struct_ENGINE_CMD_DEFN_st;
pub const ENGINE_GEN_FUNC_PTR = ?*const fn () callconv(.c) c_int;
pub const ENGINE_GEN_INT_FUNC_PTR = ?*const fn (?*ENGINE) callconv(.c) c_int;
pub const ENGINE_CTRL_FUNC_PTR = ?*const fn (?*ENGINE, c_int, c_long, ?*anyopaque, ?*const fn () callconv(.c) void) callconv(.c) c_int;
pub const ENGINE_LOAD_KEY_PTR = ?*const fn (?*ENGINE, [*c]const u8, ?*UI_METHOD, ?*anyopaque) callconv(.c) ?*EVP_PKEY;
pub const ENGINE_SSL_CLIENT_CERT_PTR = ?*const fn (?*ENGINE, ?*SSL, ?*struct_stack_st_X509_NAME, [*c]?*X509, [*c]?*EVP_PKEY, [*c]?*struct_stack_st_X509, ?*UI_METHOD, ?*anyopaque) callconv(.c) c_int;
pub const ENGINE_CIPHERS_PTR = ?*const fn (?*ENGINE, [*c]?*const EVP_CIPHER, [*c][*c]const c_int, c_int) callconv(.c) c_int;
pub const ENGINE_DIGESTS_PTR = ?*const fn (?*ENGINE, [*c]?*const EVP_MD, [*c][*c]const c_int, c_int) callconv(.c) c_int;
pub const ENGINE_PKEY_METHS_PTR = ?*const fn (?*ENGINE, [*c]?*EVP_PKEY_METHOD, [*c][*c]const c_int, c_int) callconv(.c) c_int;
pub const ENGINE_PKEY_ASN1_METHS_PTR = ?*const fn (?*ENGINE, [*c]?*EVP_PKEY_ASN1_METHOD, [*c][*c]const c_int, c_int) callconv(.c) c_int;
pub extern fn ENGINE_get_first() ?*ENGINE;
pub extern fn ENGINE_get_last() ?*ENGINE;
pub extern fn ENGINE_get_next(e: ?*ENGINE) ?*ENGINE;
pub extern fn ENGINE_get_prev(e: ?*ENGINE) ?*ENGINE;
pub extern fn ENGINE_add(e: ?*ENGINE) c_int;
pub extern fn ENGINE_remove(e: ?*ENGINE) c_int;
pub extern fn ENGINE_by_id(id: [*c]const u8) ?*ENGINE;
pub extern fn ENGINE_load_builtin_engines() void;
pub extern fn ENGINE_get_table_flags() c_uint;
pub extern fn ENGINE_set_table_flags(flags: c_uint) void;
pub extern fn ENGINE_register_RSA(e: ?*ENGINE) c_int;
pub extern fn ENGINE_unregister_RSA(e: ?*ENGINE) void;
pub extern fn ENGINE_register_all_RSA() void;
pub extern fn ENGINE_register_DSA(e: ?*ENGINE) c_int;
pub extern fn ENGINE_unregister_DSA(e: ?*ENGINE) void;
pub extern fn ENGINE_register_all_DSA() void;
pub extern fn ENGINE_register_EC(e: ?*ENGINE) c_int;
pub extern fn ENGINE_unregister_EC(e: ?*ENGINE) void;
pub extern fn ENGINE_register_all_EC() void;
pub extern fn ENGINE_register_DH(e: ?*ENGINE) c_int;
pub extern fn ENGINE_unregister_DH(e: ?*ENGINE) void;
pub extern fn ENGINE_register_all_DH() void;
pub extern fn ENGINE_register_RAND(e: ?*ENGINE) c_int;
pub extern fn ENGINE_unregister_RAND(e: ?*ENGINE) void;
pub extern fn ENGINE_register_all_RAND() void;
pub extern fn ENGINE_register_ciphers(e: ?*ENGINE) c_int;
pub extern fn ENGINE_unregister_ciphers(e: ?*ENGINE) void;
pub extern fn ENGINE_register_all_ciphers() void;
pub extern fn ENGINE_register_digests(e: ?*ENGINE) c_int;
pub extern fn ENGINE_unregister_digests(e: ?*ENGINE) void;
pub extern fn ENGINE_register_all_digests() void;
pub extern fn ENGINE_register_pkey_meths(e: ?*ENGINE) c_int;
pub extern fn ENGINE_unregister_pkey_meths(e: ?*ENGINE) void;
pub extern fn ENGINE_register_all_pkey_meths() void;
pub extern fn ENGINE_register_pkey_asn1_meths(e: ?*ENGINE) c_int;
pub extern fn ENGINE_unregister_pkey_asn1_meths(e: ?*ENGINE) void;
pub extern fn ENGINE_register_all_pkey_asn1_meths() void;
pub extern fn ENGINE_register_complete(e: ?*ENGINE) c_int;
pub extern fn ENGINE_register_all_complete() c_int;
pub extern fn ENGINE_ctrl(e: ?*ENGINE, cmd: c_int, i: c_long, p: ?*anyopaque, f: ?*const fn () callconv(.c) void) c_int;
pub extern fn ENGINE_cmd_is_executable(e: ?*ENGINE, cmd: c_int) c_int;
pub extern fn ENGINE_ctrl_cmd(e: ?*ENGINE, cmd_name: [*c]const u8, i: c_long, p: ?*anyopaque, f: ?*const fn () callconv(.c) void, cmd_optional: c_int) c_int;
pub extern fn ENGINE_ctrl_cmd_string(e: ?*ENGINE, cmd_name: [*c]const u8, arg: [*c]const u8, cmd_optional: c_int) c_int;
pub extern fn ENGINE_new() ?*ENGINE;
pub extern fn ENGINE_free(e: ?*ENGINE) c_int;
pub extern fn ENGINE_up_ref(e: ?*ENGINE) c_int;
pub extern fn ENGINE_set_id(e: ?*ENGINE, id: [*c]const u8) c_int;
pub extern fn ENGINE_set_name(e: ?*ENGINE, name: [*c]const u8) c_int;
pub extern fn ENGINE_set_RSA(e: ?*ENGINE, rsa_meth: ?*const RSA_METHOD) c_int;
pub extern fn ENGINE_set_DSA(e: ?*ENGINE, dsa_meth: ?*const DSA_METHOD) c_int;
pub extern fn ENGINE_set_EC(e: ?*ENGINE, ecdsa_meth: ?*const EC_KEY_METHOD) c_int;
pub extern fn ENGINE_set_DH(e: ?*ENGINE, dh_meth: ?*const DH_METHOD) c_int;
pub extern fn ENGINE_set_RAND(e: ?*ENGINE, rand_meth: [*c]const RAND_METHOD) c_int;
pub extern fn ENGINE_set_destroy_function(e: ?*ENGINE, destroy_f: ENGINE_GEN_INT_FUNC_PTR) c_int;
pub extern fn ENGINE_set_init_function(e: ?*ENGINE, init_f: ENGINE_GEN_INT_FUNC_PTR) c_int;
pub extern fn ENGINE_set_finish_function(e: ?*ENGINE, finish_f: ENGINE_GEN_INT_FUNC_PTR) c_int;
pub extern fn ENGINE_set_ctrl_function(e: ?*ENGINE, ctrl_f: ENGINE_CTRL_FUNC_PTR) c_int;
pub extern fn ENGINE_set_load_privkey_function(e: ?*ENGINE, loadpriv_f: ENGINE_LOAD_KEY_PTR) c_int;
pub extern fn ENGINE_set_load_pubkey_function(e: ?*ENGINE, loadpub_f: ENGINE_LOAD_KEY_PTR) c_int;
pub extern fn ENGINE_set_load_ssl_client_cert_function(e: ?*ENGINE, loadssl_f: ENGINE_SSL_CLIENT_CERT_PTR) c_int;
pub extern fn ENGINE_set_ciphers(e: ?*ENGINE, f: ENGINE_CIPHERS_PTR) c_int;
pub extern fn ENGINE_set_digests(e: ?*ENGINE, f: ENGINE_DIGESTS_PTR) c_int;
pub extern fn ENGINE_set_pkey_meths(e: ?*ENGINE, f: ENGINE_PKEY_METHS_PTR) c_int;
pub extern fn ENGINE_set_pkey_asn1_meths(e: ?*ENGINE, f: ENGINE_PKEY_ASN1_METHS_PTR) c_int;
pub extern fn ENGINE_set_flags(e: ?*ENGINE, flags: c_int) c_int;
pub extern fn ENGINE_set_cmd_defns(e: ?*ENGINE, defns: [*c]const ENGINE_CMD_DEFN) c_int;
pub extern fn ENGINE_set_ex_data(e: ?*ENGINE, idx: c_int, arg: ?*anyopaque) c_int;
pub extern fn ENGINE_get_ex_data(e: ?*const ENGINE, idx: c_int) ?*anyopaque;
pub extern fn ENGINE_get_id(e: ?*const ENGINE) [*c]const u8;
pub extern fn ENGINE_get_name(e: ?*const ENGINE) [*c]const u8;
pub extern fn ENGINE_get_RSA(e: ?*const ENGINE) ?*const RSA_METHOD;
pub extern fn ENGINE_get_DSA(e: ?*const ENGINE) ?*const DSA_METHOD;
pub extern fn ENGINE_get_EC(e: ?*const ENGINE) ?*const EC_KEY_METHOD;
pub extern fn ENGINE_get_DH(e: ?*const ENGINE) ?*const DH_METHOD;
pub extern fn ENGINE_get_RAND(e: ?*const ENGINE) [*c]const RAND_METHOD;
pub extern fn ENGINE_get_destroy_function(e: ?*const ENGINE) ENGINE_GEN_INT_FUNC_PTR;
pub extern fn ENGINE_get_init_function(e: ?*const ENGINE) ENGINE_GEN_INT_FUNC_PTR;
pub extern fn ENGINE_get_finish_function(e: ?*const ENGINE) ENGINE_GEN_INT_FUNC_PTR;
pub extern fn ENGINE_get_ctrl_function(e: ?*const ENGINE) ENGINE_CTRL_FUNC_PTR;
pub extern fn ENGINE_get_load_privkey_function(e: ?*const ENGINE) ENGINE_LOAD_KEY_PTR;
pub extern fn ENGINE_get_load_pubkey_function(e: ?*const ENGINE) ENGINE_LOAD_KEY_PTR;
pub extern fn ENGINE_get_ssl_client_cert_function(e: ?*const ENGINE) ENGINE_SSL_CLIENT_CERT_PTR;
pub extern fn ENGINE_get_ciphers(e: ?*const ENGINE) ENGINE_CIPHERS_PTR;
pub extern fn ENGINE_get_digests(e: ?*const ENGINE) ENGINE_DIGESTS_PTR;
pub extern fn ENGINE_get_pkey_meths(e: ?*const ENGINE) ENGINE_PKEY_METHS_PTR;
pub extern fn ENGINE_get_pkey_asn1_meths(e: ?*const ENGINE) ENGINE_PKEY_ASN1_METHS_PTR;
pub extern fn ENGINE_get_cipher(e: ?*ENGINE, nid: c_int) ?*const EVP_CIPHER;
pub extern fn ENGINE_get_digest(e: ?*ENGINE, nid: c_int) ?*const EVP_MD;
pub extern fn ENGINE_get_pkey_meth(e: ?*ENGINE, nid: c_int) ?*const EVP_PKEY_METHOD;
pub extern fn ENGINE_get_pkey_asn1_meth(e: ?*ENGINE, nid: c_int) ?*const EVP_PKEY_ASN1_METHOD;
pub extern fn ENGINE_get_pkey_asn1_meth_str(e: ?*ENGINE, str: [*c]const u8, len: c_int) ?*const EVP_PKEY_ASN1_METHOD;
pub extern fn ENGINE_pkey_asn1_find_str(pe: [*c]?*ENGINE, str: [*c]const u8, len: c_int) ?*const EVP_PKEY_ASN1_METHOD;
pub extern fn ENGINE_get_cmd_defns(e: ?*const ENGINE) [*c]const ENGINE_CMD_DEFN;
pub extern fn ENGINE_get_flags(e: ?*const ENGINE) c_int;
pub extern fn ENGINE_init(e: ?*ENGINE) c_int;
pub extern fn ENGINE_finish(e: ?*ENGINE) c_int;
pub extern fn ENGINE_load_private_key(e: ?*ENGINE, key_id: [*c]const u8, ui_method: ?*UI_METHOD, callback_data: ?*anyopaque) ?*EVP_PKEY;
pub extern fn ENGINE_load_public_key(e: ?*ENGINE, key_id: [*c]const u8, ui_method: ?*UI_METHOD, callback_data: ?*anyopaque) ?*EVP_PKEY;
pub extern fn ENGINE_load_ssl_client_cert(e: ?*ENGINE, s: ?*SSL, ca_dn: ?*struct_stack_st_X509_NAME, pcert: [*c]?*X509, ppkey: [*c]?*EVP_PKEY, pother: [*c]?*struct_stack_st_X509, ui_method: ?*UI_METHOD, callback_data: ?*anyopaque) c_int;
pub extern fn ENGINE_get_default_RSA() ?*ENGINE;
pub extern fn ENGINE_get_default_DSA() ?*ENGINE;
pub extern fn ENGINE_get_default_EC() ?*ENGINE;
pub extern fn ENGINE_get_default_DH() ?*ENGINE;
pub extern fn ENGINE_get_default_RAND() ?*ENGINE;
pub extern fn ENGINE_get_cipher_engine(nid: c_int) ?*ENGINE;
pub extern fn ENGINE_get_digest_engine(nid: c_int) ?*ENGINE;
pub extern fn ENGINE_get_pkey_meth_engine(nid: c_int) ?*ENGINE;
pub extern fn ENGINE_get_pkey_asn1_meth_engine(nid: c_int) ?*ENGINE;
pub extern fn ENGINE_set_default_RSA(e: ?*ENGINE) c_int;
pub extern fn ENGINE_set_default_string(e: ?*ENGINE, def_list: [*c]const u8) c_int;
pub extern fn ENGINE_set_default_DSA(e: ?*ENGINE) c_int;
pub extern fn ENGINE_set_default_EC(e: ?*ENGINE) c_int;
pub extern fn ENGINE_set_default_DH(e: ?*ENGINE) c_int;
pub extern fn ENGINE_set_default_RAND(e: ?*ENGINE) c_int;
pub extern fn ENGINE_set_default_ciphers(e: ?*ENGINE) c_int;
pub extern fn ENGINE_set_default_digests(e: ?*ENGINE) c_int;
pub extern fn ENGINE_set_default_pkey_meths(e: ?*ENGINE) c_int;
pub extern fn ENGINE_set_default_pkey_asn1_meths(e: ?*ENGINE) c_int;
pub extern fn ENGINE_set_default(e: ?*ENGINE, flags: c_uint) c_int;
pub extern fn ENGINE_add_conf_module() void;
pub const dyn_MEM_malloc_fn = ?*const fn (usize, [*c]const u8, c_int) callconv(.c) ?*anyopaque;
pub const dyn_MEM_realloc_fn = ?*const fn (?*anyopaque, usize, [*c]const u8, c_int) callconv(.c) ?*anyopaque;
pub const dyn_MEM_free_fn = ?*const fn (?*anyopaque, [*c]const u8, c_int) callconv(.c) void;
pub const struct_st_dynamic_MEM_fns = extern struct {
    malloc_fn: dyn_MEM_malloc_fn = @import("std").mem.zeroes(dyn_MEM_malloc_fn),
    realloc_fn: dyn_MEM_realloc_fn = @import("std").mem.zeroes(dyn_MEM_realloc_fn),
    free_fn: dyn_MEM_free_fn = @import("std").mem.zeroes(dyn_MEM_free_fn),
};
pub const dynamic_MEM_fns = struct_st_dynamic_MEM_fns;
pub const struct_st_dynamic_fns = extern struct {
    static_state: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    mem_fns: dynamic_MEM_fns = @import("std").mem.zeroes(dynamic_MEM_fns),
};
pub const dynamic_fns = struct_st_dynamic_fns;
pub const dynamic_v_check_fn = ?*const fn (c_ulong) callconv(.c) c_ulong;
pub const dynamic_bind_engine = ?*const fn (?*ENGINE, [*c]const u8, [*c]const dynamic_fns) callconv(.c) c_int;
pub extern fn ENGINE_get_static_state() ?*anyopaque;
pub const X509V3_EXT_NEW = ?*const fn () callconv(.c) ?*anyopaque;
pub const X509V3_EXT_FREE = ?*const fn (?*anyopaque) callconv(.c) void;
pub const X509V3_EXT_D2I = ?*const fn (?*anyopaque, [*c][*c]const u8, c_long) callconv(.c) ?*anyopaque;
pub const X509V3_EXT_I2D = ?*const fn (?*const anyopaque, [*c][*c]u8) callconv(.c) c_int;
pub const X509V3_EXT_I2S = ?*const fn ([*c]const struct_v3_ext_method, ?*anyopaque) callconv(.c) [*c]u8;
pub const X509V3_EXT_S2I = ?*const fn ([*c]const struct_v3_ext_method, [*c]struct_v3_ext_ctx, [*c]const u8) callconv(.c) ?*anyopaque;
pub const X509V3_EXT_I2V = ?*const fn ([*c]const struct_v3_ext_method, ?*anyopaque, ?*struct_stack_st_CONF_VALUE) callconv(.c) ?*struct_stack_st_CONF_VALUE;
pub const X509V3_EXT_V2I = ?*const fn ([*c]const struct_v3_ext_method, [*c]struct_v3_ext_ctx, ?*struct_stack_st_CONF_VALUE) callconv(.c) ?*anyopaque;
pub const X509V3_EXT_I2R = ?*const fn ([*c]const struct_v3_ext_method, ?*anyopaque, ?*BIO, c_int) callconv(.c) c_int;
pub const X509V3_EXT_R2I = ?*const fn ([*c]const struct_v3_ext_method, [*c]struct_v3_ext_ctx, [*c]const u8) callconv(.c) ?*anyopaque;
pub const struct_v3_ext_method = extern struct {
    ext_nid: c_int = @import("std").mem.zeroes(c_int),
    ext_flags: c_int = @import("std").mem.zeroes(c_int),
    it: ?*const ASN1_ITEM_EXP = @import("std").mem.zeroes(?*const ASN1_ITEM_EXP),
    ext_new: X509V3_EXT_NEW = @import("std").mem.zeroes(X509V3_EXT_NEW),
    ext_free: X509V3_EXT_FREE = @import("std").mem.zeroes(X509V3_EXT_FREE),
    d2i: X509V3_EXT_D2I = @import("std").mem.zeroes(X509V3_EXT_D2I),
    i2d: X509V3_EXT_I2D = @import("std").mem.zeroes(X509V3_EXT_I2D),
    i2s: X509V3_EXT_I2S = @import("std").mem.zeroes(X509V3_EXT_I2S),
    s2i: X509V3_EXT_S2I = @import("std").mem.zeroes(X509V3_EXT_S2I),
    i2v: X509V3_EXT_I2V = @import("std").mem.zeroes(X509V3_EXT_I2V),
    v2i: X509V3_EXT_V2I = @import("std").mem.zeroes(X509V3_EXT_V2I),
    i2r: X509V3_EXT_I2R = @import("std").mem.zeroes(X509V3_EXT_I2R),
    r2i: X509V3_EXT_R2I = @import("std").mem.zeroes(X509V3_EXT_R2I),
    usr_data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const X509V3_EXT_METHOD = struct_v3_ext_method;
pub const struct_stack_st_X509V3_EXT_METHOD = opaque {};
pub const sk_X509V3_EXT_METHOD_compfunc = ?*const fn ([*c]const [*c]const X509V3_EXT_METHOD, [*c]const [*c]const X509V3_EXT_METHOD) callconv(.c) c_int;
pub const sk_X509V3_EXT_METHOD_freefunc = ?*const fn ([*c]X509V3_EXT_METHOD) callconv(.c) void;
pub const sk_X509V3_EXT_METHOD_copyfunc = ?*const fn ([*c]const X509V3_EXT_METHOD) callconv(.c) [*c]X509V3_EXT_METHOD;
pub fn ossl_check_X509V3_EXT_METHOD_type(arg_ptr: [*c]X509V3_EXT_METHOD) callconv(.c) [*c]X509V3_EXT_METHOD {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509V3_EXT_METHOD_sk_type(arg_sk: ?*const struct_stack_st_X509V3_EXT_METHOD) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509V3_EXT_METHOD_sk_type(arg_sk: ?*struct_stack_st_X509V3_EXT_METHOD) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509V3_EXT_METHOD_compfunc_type(arg_cmp: sk_X509V3_EXT_METHOD_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509V3_EXT_METHOD_copyfunc_type(arg_cpy: sk_X509V3_EXT_METHOD_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509V3_EXT_METHOD_freefunc_type(arg_fr: sk_X509V3_EXT_METHOD_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const ENUMERATED_NAMES = BIT_STRING_BITNAME;
pub const struct_BASIC_CONSTRAINTS_st = extern struct {
    ca: c_int = @import("std").mem.zeroes(c_int),
    pathlen: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const BASIC_CONSTRAINTS = struct_BASIC_CONSTRAINTS_st;
pub const struct_OSSL_BASIC_ATTR_CONSTRAINTS_st = extern struct {
    authority: c_int = @import("std").mem.zeroes(c_int),
    pathlen: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const OSSL_BASIC_ATTR_CONSTRAINTS = struct_OSSL_BASIC_ATTR_CONSTRAINTS_st;
pub const struct_PKEY_USAGE_PERIOD_st = extern struct {
    notBefore: [*c]ASN1_GENERALIZEDTIME = @import("std").mem.zeroes([*c]ASN1_GENERALIZEDTIME),
    notAfter: [*c]ASN1_GENERALIZEDTIME = @import("std").mem.zeroes([*c]ASN1_GENERALIZEDTIME),
};
pub const PKEY_USAGE_PERIOD = struct_PKEY_USAGE_PERIOD_st;
pub const struct_otherName_st = extern struct {
    type_id: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    value: [*c]ASN1_TYPE = @import("std").mem.zeroes([*c]ASN1_TYPE),
};
pub const OTHERNAME = struct_otherName_st;
pub const struct_EDIPartyName_st = extern struct {
    nameAssigner: [*c]ASN1_STRING = @import("std").mem.zeroes([*c]ASN1_STRING),
    partyName: [*c]ASN1_STRING = @import("std").mem.zeroes([*c]ASN1_STRING),
};
pub const EDIPARTYNAME = struct_EDIPartyName_st;
const union_unnamed_104 = extern union {
    ptr: [*c]u8,
    otherName: [*c]OTHERNAME,
    rfc822Name: [*c]ASN1_IA5STRING,
    dNSName: [*c]ASN1_IA5STRING,
    x400Address: [*c]ASN1_STRING,
    directoryName: ?*X509_NAME,
    ediPartyName: [*c]EDIPARTYNAME,
    uniformResourceIdentifier: [*c]ASN1_IA5STRING,
    iPAddress: [*c]ASN1_OCTET_STRING,
    registeredID: ?*ASN1_OBJECT,
    ip: [*c]ASN1_OCTET_STRING,
    dirn: ?*X509_NAME,
    ia5: [*c]ASN1_IA5STRING,
    rid: ?*ASN1_OBJECT,
    other: [*c]ASN1_TYPE,
};
pub const struct_GENERAL_NAME_st = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    d: union_unnamed_104 = @import("std").mem.zeroes(union_unnamed_104),
};
pub const GENERAL_NAME = struct_GENERAL_NAME_st;
pub const struct_ACCESS_DESCRIPTION_st = extern struct {
    method: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    location: [*c]GENERAL_NAME = @import("std").mem.zeroes([*c]GENERAL_NAME),
};
pub const ACCESS_DESCRIPTION = struct_ACCESS_DESCRIPTION_st;
pub extern fn GENERAL_NAME_set1_X509_NAME(tgt: [*c][*c]GENERAL_NAME, src: ?*const X509_NAME) c_int;
pub const struct_stack_st_ACCESS_DESCRIPTION = opaque {};
pub const sk_ACCESS_DESCRIPTION_compfunc = ?*const fn ([*c]const [*c]const ACCESS_DESCRIPTION, [*c]const [*c]const ACCESS_DESCRIPTION) callconv(.c) c_int;
pub const sk_ACCESS_DESCRIPTION_freefunc = ?*const fn ([*c]ACCESS_DESCRIPTION) callconv(.c) void;
pub const sk_ACCESS_DESCRIPTION_copyfunc = ?*const fn ([*c]const ACCESS_DESCRIPTION) callconv(.c) [*c]ACCESS_DESCRIPTION;
pub fn ossl_check_ACCESS_DESCRIPTION_type(arg_ptr: [*c]ACCESS_DESCRIPTION) callconv(.c) [*c]ACCESS_DESCRIPTION {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ACCESS_DESCRIPTION_sk_type(arg_sk: ?*const struct_stack_st_ACCESS_DESCRIPTION) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ACCESS_DESCRIPTION_sk_type(arg_sk: ?*struct_stack_st_ACCESS_DESCRIPTION) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ACCESS_DESCRIPTION_compfunc_type(arg_cmp: sk_ACCESS_DESCRIPTION_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ACCESS_DESCRIPTION_copyfunc_type(arg_cpy: sk_ACCESS_DESCRIPTION_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ACCESS_DESCRIPTION_freefunc_type(arg_fr: sk_ACCESS_DESCRIPTION_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const sk_GENERAL_NAME_compfunc = ?*const fn ([*c]const [*c]const GENERAL_NAME, [*c]const [*c]const GENERAL_NAME) callconv(.c) c_int;
pub const sk_GENERAL_NAME_freefunc = ?*const fn ([*c]GENERAL_NAME) callconv(.c) void;
pub const sk_GENERAL_NAME_copyfunc = ?*const fn ([*c]const GENERAL_NAME) callconv(.c) [*c]GENERAL_NAME;
pub fn ossl_check_GENERAL_NAME_type(arg_ptr: [*c]GENERAL_NAME) callconv(.c) [*c]GENERAL_NAME {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_GENERAL_NAME_sk_type(arg_sk: ?*const struct_stack_st_GENERAL_NAME) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_GENERAL_NAME_sk_type(arg_sk: ?*struct_stack_st_GENERAL_NAME) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_GENERAL_NAME_compfunc_type(arg_cmp: sk_GENERAL_NAME_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_GENERAL_NAME_copyfunc_type(arg_cpy: sk_GENERAL_NAME_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_GENERAL_NAME_freefunc_type(arg_fr: sk_GENERAL_NAME_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const AUTHORITY_INFO_ACCESS = struct_stack_st_ACCESS_DESCRIPTION;
pub const EXTENDED_KEY_USAGE = struct_stack_st_ASN1_OBJECT;
pub const TLS_FEATURE = struct_stack_st_ASN1_INTEGER;
pub const struct_stack_st_GENERAL_NAMES = opaque {};
pub const sk_GENERAL_NAMES_compfunc = ?*const fn ([*c]const ?*const GENERAL_NAMES, [*c]const ?*const GENERAL_NAMES) callconv(.c) c_int;
pub const sk_GENERAL_NAMES_freefunc = ?*const fn (?*GENERAL_NAMES) callconv(.c) void;
pub const sk_GENERAL_NAMES_copyfunc = ?*const fn (?*const GENERAL_NAMES) callconv(.c) ?*GENERAL_NAMES;
pub fn ossl_check_GENERAL_NAMES_type(arg_ptr: ?*GENERAL_NAMES) callconv(.c) ?*GENERAL_NAMES {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_GENERAL_NAMES_sk_type(arg_sk: ?*const struct_stack_st_GENERAL_NAMES) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_GENERAL_NAMES_sk_type(arg_sk: ?*struct_stack_st_GENERAL_NAMES) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_GENERAL_NAMES_compfunc_type(arg_cmp: sk_GENERAL_NAMES_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_GENERAL_NAMES_copyfunc_type(arg_cpy: sk_GENERAL_NAMES_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_GENERAL_NAMES_freefunc_type(arg_fr: sk_GENERAL_NAMES_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn DIST_POINT_NAME_dup(a: [*c]const DIST_POINT_NAME) [*c]DIST_POINT_NAME;
pub const struct_stack_st_DIST_POINT = opaque {};
pub const sk_DIST_POINT_compfunc = ?*const fn ([*c]const [*c]const DIST_POINT, [*c]const [*c]const DIST_POINT) callconv(.c) c_int;
pub const sk_DIST_POINT_freefunc = ?*const fn ([*c]DIST_POINT) callconv(.c) void;
pub const sk_DIST_POINT_copyfunc = ?*const fn ([*c]const DIST_POINT) callconv(.c) [*c]DIST_POINT;
pub fn ossl_check_DIST_POINT_type(arg_ptr: [*c]DIST_POINT) callconv(.c) [*c]DIST_POINT {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_DIST_POINT_sk_type(arg_sk: ?*const struct_stack_st_DIST_POINT) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_DIST_POINT_sk_type(arg_sk: ?*struct_stack_st_DIST_POINT) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_DIST_POINT_compfunc_type(arg_cmp: sk_DIST_POINT_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_DIST_POINT_copyfunc_type(arg_cpy: sk_DIST_POINT_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_DIST_POINT_freefunc_type(arg_fr: sk_DIST_POINT_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const CRL_DIST_POINTS = struct_stack_st_DIST_POINT;
pub const struct_SXNET_ID_st = extern struct {
    zone: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    user: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
};
pub const SXNETID = struct_SXNET_ID_st;
pub const struct_stack_st_SXNETID = opaque {};
pub const sk_SXNETID_compfunc = ?*const fn ([*c]const [*c]const SXNETID, [*c]const [*c]const SXNETID) callconv(.c) c_int;
pub const sk_SXNETID_freefunc = ?*const fn ([*c]SXNETID) callconv(.c) void;
pub const sk_SXNETID_copyfunc = ?*const fn ([*c]const SXNETID) callconv(.c) [*c]SXNETID;
pub fn ossl_check_SXNETID_type(arg_ptr: [*c]SXNETID) callconv(.c) [*c]SXNETID {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_SXNETID_sk_type(arg_sk: ?*const struct_stack_st_SXNETID) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SXNETID_sk_type(arg_sk: ?*struct_stack_st_SXNETID) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_SXNETID_compfunc_type(arg_cmp: sk_SXNETID_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_SXNETID_copyfunc_type(arg_cpy: sk_SXNETID_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_SXNETID_freefunc_type(arg_fr: sk_SXNETID_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_SXNET_st = extern struct {
    version: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    ids: ?*struct_stack_st_SXNETID = @import("std").mem.zeroes(?*struct_stack_st_SXNETID),
};
pub const SXNET = struct_SXNET_st;
pub const struct_ISSUER_SIGN_TOOL_st = extern struct {
    signTool: [*c]ASN1_UTF8STRING = @import("std").mem.zeroes([*c]ASN1_UTF8STRING),
    cATool: [*c]ASN1_UTF8STRING = @import("std").mem.zeroes([*c]ASN1_UTF8STRING),
    signToolCert: [*c]ASN1_UTF8STRING = @import("std").mem.zeroes([*c]ASN1_UTF8STRING),
    cAToolCert: [*c]ASN1_UTF8STRING = @import("std").mem.zeroes([*c]ASN1_UTF8STRING),
};
pub const ISSUER_SIGN_TOOL = struct_ISSUER_SIGN_TOOL_st;
pub const struct_NOTICEREF_st = extern struct {
    organization: [*c]ASN1_STRING = @import("std").mem.zeroes([*c]ASN1_STRING),
    noticenos: ?*struct_stack_st_ASN1_INTEGER = @import("std").mem.zeroes(?*struct_stack_st_ASN1_INTEGER),
};
pub const NOTICEREF = struct_NOTICEREF_st;
pub const struct_USERNOTICE_st = extern struct {
    noticeref: [*c]NOTICEREF = @import("std").mem.zeroes([*c]NOTICEREF),
    exptext: [*c]ASN1_STRING = @import("std").mem.zeroes([*c]ASN1_STRING),
};
pub const USERNOTICE = struct_USERNOTICE_st;
const union_unnamed_105 = extern union {
    cpsuri: [*c]ASN1_IA5STRING,
    usernotice: [*c]USERNOTICE,
    other: [*c]ASN1_TYPE,
};
pub const struct_POLICYQUALINFO_st = extern struct {
    pqualid: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    d: union_unnamed_105 = @import("std").mem.zeroes(union_unnamed_105),
};
pub const POLICYQUALINFO = struct_POLICYQUALINFO_st;
pub const sk_POLICYQUALINFO_compfunc = ?*const fn ([*c]const [*c]const POLICYQUALINFO, [*c]const [*c]const POLICYQUALINFO) callconv(.c) c_int;
pub const sk_POLICYQUALINFO_freefunc = ?*const fn ([*c]POLICYQUALINFO) callconv(.c) void;
pub const sk_POLICYQUALINFO_copyfunc = ?*const fn ([*c]const POLICYQUALINFO) callconv(.c) [*c]POLICYQUALINFO;
pub fn ossl_check_POLICYQUALINFO_type(arg_ptr: [*c]POLICYQUALINFO) callconv(.c) [*c]POLICYQUALINFO {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_POLICYQUALINFO_sk_type(arg_sk: ?*const struct_stack_st_POLICYQUALINFO) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_POLICYQUALINFO_sk_type(arg_sk: ?*struct_stack_st_POLICYQUALINFO) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_POLICYQUALINFO_compfunc_type(arg_cmp: sk_POLICYQUALINFO_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_POLICYQUALINFO_copyfunc_type(arg_cpy: sk_POLICYQUALINFO_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_POLICYQUALINFO_freefunc_type(arg_fr: sk_POLICYQUALINFO_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_POLICYINFO_st = extern struct {
    policyid: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    qualifiers: ?*struct_stack_st_POLICYQUALINFO = @import("std").mem.zeroes(?*struct_stack_st_POLICYQUALINFO),
};
pub const POLICYINFO = struct_POLICYINFO_st;
pub const struct_stack_st_POLICYINFO = opaque {};
pub const sk_POLICYINFO_compfunc = ?*const fn ([*c]const [*c]const POLICYINFO, [*c]const [*c]const POLICYINFO) callconv(.c) c_int;
pub const sk_POLICYINFO_freefunc = ?*const fn ([*c]POLICYINFO) callconv(.c) void;
pub const sk_POLICYINFO_copyfunc = ?*const fn ([*c]const POLICYINFO) callconv(.c) [*c]POLICYINFO;
pub fn ossl_check_POLICYINFO_type(arg_ptr: [*c]POLICYINFO) callconv(.c) [*c]POLICYINFO {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_POLICYINFO_sk_type(arg_sk: ?*const struct_stack_st_POLICYINFO) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_POLICYINFO_sk_type(arg_sk: ?*struct_stack_st_POLICYINFO) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_POLICYINFO_compfunc_type(arg_cmp: sk_POLICYINFO_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_POLICYINFO_copyfunc_type(arg_cpy: sk_POLICYINFO_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_POLICYINFO_freefunc_type(arg_fr: sk_POLICYINFO_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const CERTIFICATEPOLICIES = struct_stack_st_POLICYINFO;
pub const struct_POLICY_MAPPING_st = extern struct {
    issuerDomainPolicy: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    subjectDomainPolicy: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
};
pub const POLICY_MAPPING = struct_POLICY_MAPPING_st;
pub const struct_stack_st_POLICY_MAPPING = opaque {};
pub const sk_POLICY_MAPPING_compfunc = ?*const fn ([*c]const [*c]const POLICY_MAPPING, [*c]const [*c]const POLICY_MAPPING) callconv(.c) c_int;
pub const sk_POLICY_MAPPING_freefunc = ?*const fn ([*c]POLICY_MAPPING) callconv(.c) void;
pub const sk_POLICY_MAPPING_copyfunc = ?*const fn ([*c]const POLICY_MAPPING) callconv(.c) [*c]POLICY_MAPPING;
pub fn ossl_check_POLICY_MAPPING_type(arg_ptr: [*c]POLICY_MAPPING) callconv(.c) [*c]POLICY_MAPPING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_POLICY_MAPPING_sk_type(arg_sk: ?*const struct_stack_st_POLICY_MAPPING) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_POLICY_MAPPING_sk_type(arg_sk: ?*struct_stack_st_POLICY_MAPPING) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_POLICY_MAPPING_compfunc_type(arg_cmp: sk_POLICY_MAPPING_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_POLICY_MAPPING_copyfunc_type(arg_cpy: sk_POLICY_MAPPING_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_POLICY_MAPPING_freefunc_type(arg_fr: sk_POLICY_MAPPING_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const POLICY_MAPPINGS = struct_stack_st_POLICY_MAPPING;
pub const struct_GENERAL_SUBTREE_st = extern struct {
    base: [*c]GENERAL_NAME = @import("std").mem.zeroes([*c]GENERAL_NAME),
    minimum: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    maximum: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const GENERAL_SUBTREE = struct_GENERAL_SUBTREE_st;
pub const sk_GENERAL_SUBTREE_compfunc = ?*const fn ([*c]const [*c]const GENERAL_SUBTREE, [*c]const [*c]const GENERAL_SUBTREE) callconv(.c) c_int;
pub const sk_GENERAL_SUBTREE_freefunc = ?*const fn ([*c]GENERAL_SUBTREE) callconv(.c) void;
pub const sk_GENERAL_SUBTREE_copyfunc = ?*const fn ([*c]const GENERAL_SUBTREE) callconv(.c) [*c]GENERAL_SUBTREE;
pub fn ossl_check_GENERAL_SUBTREE_type(arg_ptr: [*c]GENERAL_SUBTREE) callconv(.c) [*c]GENERAL_SUBTREE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_GENERAL_SUBTREE_sk_type(arg_sk: ?*const struct_stack_st_GENERAL_SUBTREE) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_GENERAL_SUBTREE_sk_type(arg_sk: ?*struct_stack_st_GENERAL_SUBTREE) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_GENERAL_SUBTREE_compfunc_type(arg_cmp: sk_GENERAL_SUBTREE_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_GENERAL_SUBTREE_copyfunc_type(arg_cpy: sk_GENERAL_SUBTREE_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_GENERAL_SUBTREE_freefunc_type(arg_fr: sk_GENERAL_SUBTREE_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_POLICY_CONSTRAINTS_st = extern struct {
    requireExplicitPolicy: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    inhibitPolicyMapping: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const POLICY_CONSTRAINTS = struct_POLICY_CONSTRAINTS_st;
pub const struct_PROXY_POLICY_st = extern struct {
    policyLanguage: ?*ASN1_OBJECT = @import("std").mem.zeroes(?*ASN1_OBJECT),
    policy: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
};
pub const PROXY_POLICY = struct_PROXY_POLICY_st;
pub const struct_PROXY_CERT_INFO_EXTENSION_st = extern struct {
    pcPathLengthConstraint: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    proxyPolicy: [*c]PROXY_POLICY = @import("std").mem.zeroes([*c]PROXY_POLICY),
};
pub const PROXY_CERT_INFO_EXTENSION = struct_PROXY_CERT_INFO_EXTENSION_st;
pub extern fn PROXY_POLICY_new() [*c]PROXY_POLICY;
pub extern fn PROXY_POLICY_free(a: [*c]PROXY_POLICY) void;
pub extern fn d2i_PROXY_POLICY(a: [*c][*c]PROXY_POLICY, in: [*c][*c]const u8, len: c_long) [*c]PROXY_POLICY;
pub extern fn i2d_PROXY_POLICY(a: [*c]const PROXY_POLICY, out: [*c][*c]u8) c_int;
pub extern fn PROXY_POLICY_it() ?*const ASN1_ITEM;
pub extern fn PROXY_CERT_INFO_EXTENSION_new() [*c]PROXY_CERT_INFO_EXTENSION;
pub extern fn PROXY_CERT_INFO_EXTENSION_free(a: [*c]PROXY_CERT_INFO_EXTENSION) void;
pub extern fn d2i_PROXY_CERT_INFO_EXTENSION(a: [*c][*c]PROXY_CERT_INFO_EXTENSION, in: [*c][*c]const u8, len: c_long) [*c]PROXY_CERT_INFO_EXTENSION;
pub extern fn i2d_PROXY_CERT_INFO_EXTENSION(a: [*c]const PROXY_CERT_INFO_EXTENSION, out: [*c][*c]u8) c_int;
pub extern fn PROXY_CERT_INFO_EXTENSION_it() ?*const ASN1_ITEM;
pub const struct_x509_purpose_st = extern struct {
    purpose: c_int = @import("std").mem.zeroes(c_int),
    trust: c_int = @import("std").mem.zeroes(c_int),
    flags: c_int = @import("std").mem.zeroes(c_int),
    check_purpose: ?*const fn ([*c]const struct_x509_purpose_st, ?*const X509, c_int) callconv(.c) c_int = @import("std").mem.zeroes(?*const fn ([*c]const struct_x509_purpose_st, ?*const X509, c_int) callconv(.c) c_int),
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    sname: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    usr_data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const X509_PURPOSE = struct_x509_purpose_st;
pub const struct_stack_st_X509_PURPOSE = opaque {};
pub const sk_X509_PURPOSE_compfunc = ?*const fn ([*c]const [*c]const X509_PURPOSE, [*c]const [*c]const X509_PURPOSE) callconv(.c) c_int;
pub const sk_X509_PURPOSE_freefunc = ?*const fn ([*c]X509_PURPOSE) callconv(.c) void;
pub const sk_X509_PURPOSE_copyfunc = ?*const fn ([*c]const X509_PURPOSE) callconv(.c) [*c]X509_PURPOSE;
pub fn ossl_check_X509_PURPOSE_type(arg_ptr: [*c]X509_PURPOSE) callconv(.c) [*c]X509_PURPOSE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_PURPOSE_sk_type(arg_sk: ?*const struct_stack_st_X509_PURPOSE) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_PURPOSE_sk_type(arg_sk: ?*struct_stack_st_X509_PURPOSE) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_PURPOSE_compfunc_type(arg_cmp: sk_X509_PURPOSE_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_PURPOSE_copyfunc_type(arg_cpy: sk_X509_PURPOSE_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_PURPOSE_freefunc_type(arg_fr: sk_X509_PURPOSE_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub extern fn BASIC_CONSTRAINTS_new() [*c]BASIC_CONSTRAINTS;
pub extern fn BASIC_CONSTRAINTS_free(a: [*c]BASIC_CONSTRAINTS) void;
pub extern fn d2i_BASIC_CONSTRAINTS(a: [*c][*c]BASIC_CONSTRAINTS, in: [*c][*c]const u8, len: c_long) [*c]BASIC_CONSTRAINTS;
pub extern fn i2d_BASIC_CONSTRAINTS(a: [*c]const BASIC_CONSTRAINTS, out: [*c][*c]u8) c_int;
pub extern fn BASIC_CONSTRAINTS_it() ?*const ASN1_ITEM;
pub extern fn OSSL_BASIC_ATTR_CONSTRAINTS_new() [*c]OSSL_BASIC_ATTR_CONSTRAINTS;
pub extern fn OSSL_BASIC_ATTR_CONSTRAINTS_free(a: [*c]OSSL_BASIC_ATTR_CONSTRAINTS) void;
pub extern fn d2i_OSSL_BASIC_ATTR_CONSTRAINTS(a: [*c][*c]OSSL_BASIC_ATTR_CONSTRAINTS, in: [*c][*c]const u8, len: c_long) [*c]OSSL_BASIC_ATTR_CONSTRAINTS;
pub extern fn i2d_OSSL_BASIC_ATTR_CONSTRAINTS(a: [*c]const OSSL_BASIC_ATTR_CONSTRAINTS, out: [*c][*c]u8) c_int;
pub extern fn OSSL_BASIC_ATTR_CONSTRAINTS_it() ?*const ASN1_ITEM;
pub extern fn SXNET_new() [*c]SXNET;
pub extern fn SXNET_free(a: [*c]SXNET) void;
pub extern fn d2i_SXNET(a: [*c][*c]SXNET, in: [*c][*c]const u8, len: c_long) [*c]SXNET;
pub extern fn i2d_SXNET(a: [*c]const SXNET, out: [*c][*c]u8) c_int;
pub extern fn SXNET_it() ?*const ASN1_ITEM;
pub extern fn SXNETID_new() [*c]SXNETID;
pub extern fn SXNETID_free(a: [*c]SXNETID) void;
pub extern fn d2i_SXNETID(a: [*c][*c]SXNETID, in: [*c][*c]const u8, len: c_long) [*c]SXNETID;
pub extern fn i2d_SXNETID(a: [*c]const SXNETID, out: [*c][*c]u8) c_int;
pub extern fn SXNETID_it() ?*const ASN1_ITEM;
pub extern fn ISSUER_SIGN_TOOL_new() [*c]ISSUER_SIGN_TOOL;
pub extern fn ISSUER_SIGN_TOOL_free(a: [*c]ISSUER_SIGN_TOOL) void;
pub extern fn d2i_ISSUER_SIGN_TOOL(a: [*c][*c]ISSUER_SIGN_TOOL, in: [*c][*c]const u8, len: c_long) [*c]ISSUER_SIGN_TOOL;
pub extern fn i2d_ISSUER_SIGN_TOOL(a: [*c]const ISSUER_SIGN_TOOL, out: [*c][*c]u8) c_int;
pub extern fn ISSUER_SIGN_TOOL_it() ?*const ASN1_ITEM;
pub extern fn SXNET_add_id_asc(psx: [*c][*c]SXNET, zone: [*c]const u8, user: [*c]const u8, userlen: c_int) c_int;
pub extern fn SXNET_add_id_ulong(psx: [*c][*c]SXNET, lzone: c_ulong, user: [*c]const u8, userlen: c_int) c_int;
pub extern fn SXNET_add_id_INTEGER(psx: [*c][*c]SXNET, izone: [*c]ASN1_INTEGER, user: [*c]const u8, userlen: c_int) c_int;
pub extern fn SXNET_get_id_asc(sx: [*c]SXNET, zone: [*c]const u8) [*c]ASN1_OCTET_STRING;
pub extern fn SXNET_get_id_ulong(sx: [*c]SXNET, lzone: c_ulong) [*c]ASN1_OCTET_STRING;
pub extern fn SXNET_get_id_INTEGER(sx: [*c]SXNET, zone: [*c]ASN1_INTEGER) [*c]ASN1_OCTET_STRING;
pub extern fn AUTHORITY_KEYID_new() [*c]AUTHORITY_KEYID;
pub extern fn AUTHORITY_KEYID_free(a: [*c]AUTHORITY_KEYID) void;
pub extern fn d2i_AUTHORITY_KEYID(a: [*c][*c]AUTHORITY_KEYID, in: [*c][*c]const u8, len: c_long) [*c]AUTHORITY_KEYID;
pub extern fn i2d_AUTHORITY_KEYID(a: [*c]const AUTHORITY_KEYID, out: [*c][*c]u8) c_int;
pub extern fn AUTHORITY_KEYID_it() ?*const ASN1_ITEM;
pub extern fn PKEY_USAGE_PERIOD_new() [*c]PKEY_USAGE_PERIOD;
pub extern fn PKEY_USAGE_PERIOD_free(a: [*c]PKEY_USAGE_PERIOD) void;
pub extern fn d2i_PKEY_USAGE_PERIOD(a: [*c][*c]PKEY_USAGE_PERIOD, in: [*c][*c]const u8, len: c_long) [*c]PKEY_USAGE_PERIOD;
pub extern fn i2d_PKEY_USAGE_PERIOD(a: [*c]const PKEY_USAGE_PERIOD, out: [*c][*c]u8) c_int;
pub extern fn PKEY_USAGE_PERIOD_it() ?*const ASN1_ITEM;
pub extern fn GENERAL_NAME_new() [*c]GENERAL_NAME;
pub extern fn GENERAL_NAME_free(a: [*c]GENERAL_NAME) void;
pub extern fn d2i_GENERAL_NAME(a: [*c][*c]GENERAL_NAME, in: [*c][*c]const u8, len: c_long) [*c]GENERAL_NAME;
pub extern fn i2d_GENERAL_NAME(a: [*c]const GENERAL_NAME, out: [*c][*c]u8) c_int;
pub extern fn GENERAL_NAME_it() ?*const ASN1_ITEM;
pub extern fn GENERAL_NAME_dup(a: [*c]const GENERAL_NAME) [*c]GENERAL_NAME;
pub extern fn GENERAL_NAME_cmp(a: [*c]GENERAL_NAME, b: [*c]GENERAL_NAME) c_int;
pub extern fn v2i_ASN1_BIT_STRING(method: [*c]X509V3_EXT_METHOD, ctx: [*c]X509V3_CTX, nval: ?*struct_stack_st_CONF_VALUE) [*c]ASN1_BIT_STRING;
pub extern fn i2v_ASN1_BIT_STRING(method: [*c]X509V3_EXT_METHOD, bits: [*c]ASN1_BIT_STRING, extlist: ?*struct_stack_st_CONF_VALUE) ?*struct_stack_st_CONF_VALUE;
pub extern fn i2s_ASN1_IA5STRING(method: [*c]X509V3_EXT_METHOD, ia5: [*c]ASN1_IA5STRING) [*c]u8;
pub extern fn s2i_ASN1_IA5STRING(method: [*c]X509V3_EXT_METHOD, ctx: [*c]X509V3_CTX, str: [*c]const u8) [*c]ASN1_IA5STRING;
pub extern fn i2s_ASN1_UTF8STRING(method: [*c]X509V3_EXT_METHOD, utf8: [*c]ASN1_UTF8STRING) [*c]u8;
pub extern fn s2i_ASN1_UTF8STRING(method: [*c]X509V3_EXT_METHOD, ctx: [*c]X509V3_CTX, str: [*c]const u8) [*c]ASN1_UTF8STRING;
pub extern fn i2v_GENERAL_NAME(method: [*c]X509V3_EXT_METHOD, gen: [*c]GENERAL_NAME, ret: ?*struct_stack_st_CONF_VALUE) ?*struct_stack_st_CONF_VALUE;
pub extern fn GENERAL_NAME_print(out: ?*BIO, gen: [*c]GENERAL_NAME) c_int;
pub extern fn GENERAL_NAMES_new() ?*GENERAL_NAMES;
pub extern fn GENERAL_NAMES_free(a: ?*GENERAL_NAMES) void;
pub extern fn d2i_GENERAL_NAMES(a: [*c]?*GENERAL_NAMES, in: [*c][*c]const u8, len: c_long) ?*GENERAL_NAMES;
pub extern fn i2d_GENERAL_NAMES(a: ?*const GENERAL_NAMES, out: [*c][*c]u8) c_int;
pub extern fn GENERAL_NAMES_it() ?*const ASN1_ITEM;
pub extern fn i2v_GENERAL_NAMES(method: [*c]X509V3_EXT_METHOD, gen: ?*GENERAL_NAMES, extlist: ?*struct_stack_st_CONF_VALUE) ?*struct_stack_st_CONF_VALUE;
pub extern fn v2i_GENERAL_NAMES(method: [*c]const X509V3_EXT_METHOD, ctx: [*c]X509V3_CTX, nval: ?*struct_stack_st_CONF_VALUE) ?*GENERAL_NAMES;
pub extern fn OTHERNAME_new() [*c]OTHERNAME;
pub extern fn OTHERNAME_free(a: [*c]OTHERNAME) void;
pub extern fn d2i_OTHERNAME(a: [*c][*c]OTHERNAME, in: [*c][*c]const u8, len: c_long) [*c]OTHERNAME;
pub extern fn i2d_OTHERNAME(a: [*c]const OTHERNAME, out: [*c][*c]u8) c_int;
pub extern fn OTHERNAME_it() ?*const ASN1_ITEM;
pub extern fn EDIPARTYNAME_new() [*c]EDIPARTYNAME;
pub extern fn EDIPARTYNAME_free(a: [*c]EDIPARTYNAME) void;
pub extern fn d2i_EDIPARTYNAME(a: [*c][*c]EDIPARTYNAME, in: [*c][*c]const u8, len: c_long) [*c]EDIPARTYNAME;
pub extern fn i2d_EDIPARTYNAME(a: [*c]const EDIPARTYNAME, out: [*c][*c]u8) c_int;
pub extern fn EDIPARTYNAME_it() ?*const ASN1_ITEM;
pub extern fn OTHERNAME_cmp(a: [*c]OTHERNAME, b: [*c]OTHERNAME) c_int;
pub extern fn GENERAL_NAME_set0_value(a: [*c]GENERAL_NAME, @"type": c_int, value: ?*anyopaque) void;
pub extern fn GENERAL_NAME_get0_value(a: [*c]const GENERAL_NAME, ptype: [*c]c_int) ?*anyopaque;
pub extern fn GENERAL_NAME_set0_othername(gen: [*c]GENERAL_NAME, oid: ?*ASN1_OBJECT, value: [*c]ASN1_TYPE) c_int;
pub extern fn GENERAL_NAME_get0_otherName(gen: [*c]const GENERAL_NAME, poid: [*c]?*ASN1_OBJECT, pvalue: [*c][*c]ASN1_TYPE) c_int;
pub extern fn i2s_ASN1_OCTET_STRING(method: [*c]X509V3_EXT_METHOD, ia5: [*c]const ASN1_OCTET_STRING) [*c]u8;
pub extern fn s2i_ASN1_OCTET_STRING(method: [*c]X509V3_EXT_METHOD, ctx: [*c]X509V3_CTX, str: [*c]const u8) [*c]ASN1_OCTET_STRING;
pub extern fn EXTENDED_KEY_USAGE_new() ?*EXTENDED_KEY_USAGE;
pub extern fn EXTENDED_KEY_USAGE_free(a: ?*EXTENDED_KEY_USAGE) void;
pub extern fn d2i_EXTENDED_KEY_USAGE(a: [*c]?*EXTENDED_KEY_USAGE, in: [*c][*c]const u8, len: c_long) ?*EXTENDED_KEY_USAGE;
pub extern fn i2d_EXTENDED_KEY_USAGE(a: ?*const EXTENDED_KEY_USAGE, out: [*c][*c]u8) c_int;
pub extern fn EXTENDED_KEY_USAGE_it() ?*const ASN1_ITEM;
pub extern fn i2a_ACCESS_DESCRIPTION(bp: ?*BIO, a: [*c]const ACCESS_DESCRIPTION) c_int;
pub extern fn TLS_FEATURE_new() ?*TLS_FEATURE;
pub extern fn TLS_FEATURE_free(a: ?*TLS_FEATURE) void;
pub extern fn CERTIFICATEPOLICIES_new() ?*CERTIFICATEPOLICIES;
pub extern fn CERTIFICATEPOLICIES_free(a: ?*CERTIFICATEPOLICIES) void;
pub extern fn d2i_CERTIFICATEPOLICIES(a: [*c]?*CERTIFICATEPOLICIES, in: [*c][*c]const u8, len: c_long) ?*CERTIFICATEPOLICIES;
pub extern fn i2d_CERTIFICATEPOLICIES(a: ?*const CERTIFICATEPOLICIES, out: [*c][*c]u8) c_int;
pub extern fn CERTIFICATEPOLICIES_it() ?*const ASN1_ITEM;
pub extern fn POLICYINFO_new() [*c]POLICYINFO;
pub extern fn POLICYINFO_free(a: [*c]POLICYINFO) void;
pub extern fn d2i_POLICYINFO(a: [*c][*c]POLICYINFO, in: [*c][*c]const u8, len: c_long) [*c]POLICYINFO;
pub extern fn i2d_POLICYINFO(a: [*c]const POLICYINFO, out: [*c][*c]u8) c_int;
pub extern fn POLICYINFO_it() ?*const ASN1_ITEM;
pub extern fn POLICYQUALINFO_new() [*c]POLICYQUALINFO;
pub extern fn POLICYQUALINFO_free(a: [*c]POLICYQUALINFO) void;
pub extern fn d2i_POLICYQUALINFO(a: [*c][*c]POLICYQUALINFO, in: [*c][*c]const u8, len: c_long) [*c]POLICYQUALINFO;
pub extern fn i2d_POLICYQUALINFO(a: [*c]const POLICYQUALINFO, out: [*c][*c]u8) c_int;
pub extern fn POLICYQUALINFO_it() ?*const ASN1_ITEM;
pub extern fn USERNOTICE_new() [*c]USERNOTICE;
pub extern fn USERNOTICE_free(a: [*c]USERNOTICE) void;
pub extern fn d2i_USERNOTICE(a: [*c][*c]USERNOTICE, in: [*c][*c]const u8, len: c_long) [*c]USERNOTICE;
pub extern fn i2d_USERNOTICE(a: [*c]const USERNOTICE, out: [*c][*c]u8) c_int;
pub extern fn USERNOTICE_it() ?*const ASN1_ITEM;
pub extern fn NOTICEREF_new() [*c]NOTICEREF;
pub extern fn NOTICEREF_free(a: [*c]NOTICEREF) void;
pub extern fn d2i_NOTICEREF(a: [*c][*c]NOTICEREF, in: [*c][*c]const u8, len: c_long) [*c]NOTICEREF;
pub extern fn i2d_NOTICEREF(a: [*c]const NOTICEREF, out: [*c][*c]u8) c_int;
pub extern fn NOTICEREF_it() ?*const ASN1_ITEM;
pub extern fn CRL_DIST_POINTS_new() ?*CRL_DIST_POINTS;
pub extern fn CRL_DIST_POINTS_free(a: ?*CRL_DIST_POINTS) void;
pub extern fn d2i_CRL_DIST_POINTS(a: [*c]?*CRL_DIST_POINTS, in: [*c][*c]const u8, len: c_long) ?*CRL_DIST_POINTS;
pub extern fn i2d_CRL_DIST_POINTS(a: ?*const CRL_DIST_POINTS, out: [*c][*c]u8) c_int;
pub extern fn CRL_DIST_POINTS_it() ?*const ASN1_ITEM;
pub extern fn DIST_POINT_new() [*c]DIST_POINT;
pub extern fn DIST_POINT_free(a: [*c]DIST_POINT) void;
pub extern fn d2i_DIST_POINT(a: [*c][*c]DIST_POINT, in: [*c][*c]const u8, len: c_long) [*c]DIST_POINT;
pub extern fn i2d_DIST_POINT(a: [*c]const DIST_POINT, out: [*c][*c]u8) c_int;
pub extern fn DIST_POINT_it() ?*const ASN1_ITEM;
pub extern fn DIST_POINT_NAME_new() [*c]DIST_POINT_NAME;
pub extern fn DIST_POINT_NAME_free(a: [*c]DIST_POINT_NAME) void;
pub extern fn d2i_DIST_POINT_NAME(a: [*c][*c]DIST_POINT_NAME, in: [*c][*c]const u8, len: c_long) [*c]DIST_POINT_NAME;
pub extern fn i2d_DIST_POINT_NAME(a: [*c]const DIST_POINT_NAME, out: [*c][*c]u8) c_int;
pub extern fn DIST_POINT_NAME_it() ?*const ASN1_ITEM;
pub extern fn ISSUING_DIST_POINT_new() [*c]ISSUING_DIST_POINT;
pub extern fn ISSUING_DIST_POINT_free(a: [*c]ISSUING_DIST_POINT) void;
pub extern fn d2i_ISSUING_DIST_POINT(a: [*c][*c]ISSUING_DIST_POINT, in: [*c][*c]const u8, len: c_long) [*c]ISSUING_DIST_POINT;
pub extern fn i2d_ISSUING_DIST_POINT(a: [*c]const ISSUING_DIST_POINT, out: [*c][*c]u8) c_int;
pub extern fn ISSUING_DIST_POINT_it() ?*const ASN1_ITEM;
pub extern fn DIST_POINT_set_dpname(dpn: [*c]DIST_POINT_NAME, iname: ?*const X509_NAME) c_int;
pub extern fn NAME_CONSTRAINTS_check(x: ?*X509, nc: [*c]NAME_CONSTRAINTS) c_int;
pub extern fn NAME_CONSTRAINTS_check_CN(x: ?*X509, nc: [*c]NAME_CONSTRAINTS) c_int;
pub extern fn ACCESS_DESCRIPTION_new() [*c]ACCESS_DESCRIPTION;
pub extern fn ACCESS_DESCRIPTION_free(a: [*c]ACCESS_DESCRIPTION) void;
pub extern fn d2i_ACCESS_DESCRIPTION(a: [*c][*c]ACCESS_DESCRIPTION, in: [*c][*c]const u8, len: c_long) [*c]ACCESS_DESCRIPTION;
pub extern fn i2d_ACCESS_DESCRIPTION(a: [*c]const ACCESS_DESCRIPTION, out: [*c][*c]u8) c_int;
pub extern fn ACCESS_DESCRIPTION_it() ?*const ASN1_ITEM;
pub extern fn AUTHORITY_INFO_ACCESS_new() ?*AUTHORITY_INFO_ACCESS;
pub extern fn AUTHORITY_INFO_ACCESS_free(a: ?*AUTHORITY_INFO_ACCESS) void;
pub extern fn d2i_AUTHORITY_INFO_ACCESS(a: [*c]?*AUTHORITY_INFO_ACCESS, in: [*c][*c]const u8, len: c_long) ?*AUTHORITY_INFO_ACCESS;
pub extern fn i2d_AUTHORITY_INFO_ACCESS(a: ?*const AUTHORITY_INFO_ACCESS, out: [*c][*c]u8) c_int;
pub extern fn AUTHORITY_INFO_ACCESS_it() ?*const ASN1_ITEM;
pub extern fn POLICY_MAPPING_it() ?*const ASN1_ITEM;
pub extern fn POLICY_MAPPING_new() [*c]POLICY_MAPPING;
pub extern fn POLICY_MAPPING_free(a: [*c]POLICY_MAPPING) void;
pub extern fn POLICY_MAPPINGS_it() ?*const ASN1_ITEM;
pub extern fn GENERAL_SUBTREE_it() ?*const ASN1_ITEM;
pub extern fn GENERAL_SUBTREE_new() [*c]GENERAL_SUBTREE;
pub extern fn GENERAL_SUBTREE_free(a: [*c]GENERAL_SUBTREE) void;
pub extern fn NAME_CONSTRAINTS_it() ?*const ASN1_ITEM;
pub extern fn NAME_CONSTRAINTS_new() [*c]NAME_CONSTRAINTS;
pub extern fn NAME_CONSTRAINTS_free(a: [*c]NAME_CONSTRAINTS) void;
pub extern fn POLICY_CONSTRAINTS_new() [*c]POLICY_CONSTRAINTS;
pub extern fn POLICY_CONSTRAINTS_free(a: [*c]POLICY_CONSTRAINTS) void;
pub extern fn POLICY_CONSTRAINTS_it() ?*const ASN1_ITEM;
pub extern fn a2i_GENERAL_NAME(out: [*c]GENERAL_NAME, method: [*c]const X509V3_EXT_METHOD, ctx: [*c]X509V3_CTX, gen_type: c_int, value: [*c]const u8, is_nc: c_int) [*c]GENERAL_NAME;
pub extern fn v2i_GENERAL_NAME(method: [*c]const X509V3_EXT_METHOD, ctx: [*c]X509V3_CTX, cnf: [*c]CONF_VALUE) [*c]GENERAL_NAME;
pub extern fn v2i_GENERAL_NAME_ex(out: [*c]GENERAL_NAME, method: [*c]const X509V3_EXT_METHOD, ctx: [*c]X509V3_CTX, cnf: [*c]CONF_VALUE, is_nc: c_int) [*c]GENERAL_NAME;
pub extern fn X509V3_conf_free(val: [*c]CONF_VALUE) void;
pub extern fn X509V3_EXT_nconf_nid(conf: [*c]CONF, ctx: [*c]X509V3_CTX, ext_nid: c_int, value: [*c]const u8) ?*X509_EXTENSION;
pub extern fn X509V3_EXT_nconf(conf: [*c]CONF, ctx: [*c]X509V3_CTX, name: [*c]const u8, value: [*c]const u8) ?*X509_EXTENSION;
pub extern fn X509V3_EXT_add_nconf_sk(conf: [*c]CONF, ctx: [*c]X509V3_CTX, section: [*c]const u8, sk: [*c]?*struct_stack_st_X509_EXTENSION) c_int;
pub extern fn X509V3_EXT_add_nconf(conf: [*c]CONF, ctx: [*c]X509V3_CTX, section: [*c]const u8, cert: ?*X509) c_int;
pub extern fn X509V3_EXT_REQ_add_nconf(conf: [*c]CONF, ctx: [*c]X509V3_CTX, section: [*c]const u8, req: ?*X509_REQ) c_int;
pub extern fn X509V3_EXT_CRL_add_nconf(conf: [*c]CONF, ctx: [*c]X509V3_CTX, section: [*c]const u8, crl: ?*X509_CRL) c_int;
pub extern fn X509V3_EXT_conf_nid(conf: [*c]struct_lhash_st_CONF_VALUE, ctx: [*c]X509V3_CTX, ext_nid: c_int, value: [*c]const u8) ?*X509_EXTENSION;
pub extern fn X509V3_EXT_conf(conf: [*c]struct_lhash_st_CONF_VALUE, ctx: [*c]X509V3_CTX, name: [*c]const u8, value: [*c]const u8) ?*X509_EXTENSION;
pub extern fn X509V3_EXT_add_conf(conf: [*c]struct_lhash_st_CONF_VALUE, ctx: [*c]X509V3_CTX, section: [*c]const u8, cert: ?*X509) c_int;
pub extern fn X509V3_EXT_REQ_add_conf(conf: [*c]struct_lhash_st_CONF_VALUE, ctx: [*c]X509V3_CTX, section: [*c]const u8, req: ?*X509_REQ) c_int;
pub extern fn X509V3_EXT_CRL_add_conf(conf: [*c]struct_lhash_st_CONF_VALUE, ctx: [*c]X509V3_CTX, section: [*c]const u8, crl: ?*X509_CRL) c_int;
pub extern fn X509V3_add_value_bool_nf(name: [*c]const u8, asn1_bool: c_int, extlist: [*c]?*struct_stack_st_CONF_VALUE) c_int;
pub extern fn X509V3_get_value_bool(value: [*c]const CONF_VALUE, asn1_bool: [*c]c_int) c_int;
pub extern fn X509V3_get_value_int(value: [*c]const CONF_VALUE, aint: [*c][*c]ASN1_INTEGER) c_int;
pub extern fn X509V3_set_nconf(ctx: [*c]X509V3_CTX, conf: [*c]CONF) void;
pub extern fn X509V3_set_conf_lhash(ctx: [*c]X509V3_CTX, lhash: [*c]struct_lhash_st_CONF_VALUE) void;
pub extern fn X509V3_get_string(ctx: [*c]X509V3_CTX, name: [*c]const u8, section: [*c]const u8) [*c]u8;
pub extern fn X509V3_get_section(ctx: [*c]X509V3_CTX, section: [*c]const u8) ?*struct_stack_st_CONF_VALUE;
pub extern fn X509V3_string_free(ctx: [*c]X509V3_CTX, str: [*c]u8) void;
pub extern fn X509V3_section_free(ctx: [*c]X509V3_CTX, section: ?*struct_stack_st_CONF_VALUE) void;
pub extern fn X509V3_set_ctx(ctx: [*c]X509V3_CTX, issuer: ?*X509, subject: ?*X509, req: ?*X509_REQ, crl: ?*X509_CRL, flags: c_int) void;
pub extern fn X509V3_set_issuer_pkey(ctx: [*c]X509V3_CTX, pkey: ?*EVP_PKEY) c_int;
pub extern fn X509V3_add_value(name: [*c]const u8, value: [*c]const u8, extlist: [*c]?*struct_stack_st_CONF_VALUE) c_int;
pub extern fn X509V3_add_value_uchar(name: [*c]const u8, value: [*c]const u8, extlist: [*c]?*struct_stack_st_CONF_VALUE) c_int;
pub extern fn X509V3_add_value_bool(name: [*c]const u8, asn1_bool: c_int, extlist: [*c]?*struct_stack_st_CONF_VALUE) c_int;
pub extern fn X509V3_add_value_int(name: [*c]const u8, aint: [*c]const ASN1_INTEGER, extlist: [*c]?*struct_stack_st_CONF_VALUE) c_int;
pub extern fn i2s_ASN1_INTEGER(meth: [*c]X509V3_EXT_METHOD, aint: [*c]const ASN1_INTEGER) [*c]u8;
pub extern fn s2i_ASN1_INTEGER(meth: [*c]X509V3_EXT_METHOD, value: [*c]const u8) [*c]ASN1_INTEGER;
pub extern fn i2s_ASN1_ENUMERATED(meth: [*c]X509V3_EXT_METHOD, aint: [*c]const ASN1_ENUMERATED) [*c]u8;
pub extern fn i2s_ASN1_ENUMERATED_TABLE(meth: [*c]X509V3_EXT_METHOD, aint: [*c]const ASN1_ENUMERATED) [*c]u8;
pub extern fn X509V3_EXT_add(ext: [*c]X509V3_EXT_METHOD) c_int;
pub extern fn X509V3_EXT_add_list(extlist: [*c]X509V3_EXT_METHOD) c_int;
pub extern fn X509V3_EXT_add_alias(nid_to: c_int, nid_from: c_int) c_int;
pub extern fn X509V3_EXT_cleanup() void;
pub extern fn X509V3_EXT_get(ext: ?*X509_EXTENSION) [*c]const X509V3_EXT_METHOD;
pub extern fn X509V3_EXT_get_nid(nid: c_int) [*c]const X509V3_EXT_METHOD;
pub extern fn X509V3_add_standard_extensions() c_int;
pub extern fn X509V3_parse_list(line: [*c]const u8) ?*struct_stack_st_CONF_VALUE;
pub extern fn X509V3_EXT_d2i(ext: ?*X509_EXTENSION) ?*anyopaque;
pub extern fn X509V3_get_d2i(x: ?*const struct_stack_st_X509_EXTENSION, nid: c_int, crit: [*c]c_int, idx: [*c]c_int) ?*anyopaque;
pub extern fn X509V3_EXT_i2d(ext_nid: c_int, crit: c_int, ext_struc: ?*anyopaque) ?*X509_EXTENSION;
pub extern fn X509V3_add1_i2d(x: [*c]?*struct_stack_st_X509_EXTENSION, nid: c_int, value: ?*anyopaque, crit: c_int, flags: c_ulong) c_int;
pub extern fn X509V3_EXT_val_prn(out: ?*BIO, val: ?*struct_stack_st_CONF_VALUE, indent: c_int, ml: c_int) void;
pub extern fn X509V3_EXT_print(out: ?*BIO, ext: ?*X509_EXTENSION, flag: c_ulong, indent: c_int) c_int;
pub extern fn X509V3_EXT_print_fp(out: [*c]FILE, ext: ?*X509_EXTENSION, flag: c_int, indent: c_int) c_int;
pub extern fn X509V3_extensions_print(out: ?*BIO, title: [*c]const u8, exts: ?*const struct_stack_st_X509_EXTENSION, flag: c_ulong, indent: c_int) c_int;
pub extern fn X509_check_ca(x: ?*X509) c_int;
pub extern fn X509_check_purpose(x: ?*X509, id: c_int, ca: c_int) c_int;
pub extern fn X509_supported_extension(ex: ?*X509_EXTENSION) c_int;
pub extern fn X509_PURPOSE_set(p: [*c]c_int, purpose: c_int) c_int;
pub extern fn X509_check_issued(issuer: ?*X509, subject: ?*X509) c_int;
pub extern fn X509_check_akid(issuer: ?*const X509, akid: [*c]const AUTHORITY_KEYID) c_int;
pub extern fn X509_set_proxy_flag(x: ?*X509) void;
pub extern fn X509_set_proxy_pathlen(x: ?*X509, l: c_long) void;
pub extern fn X509_get_proxy_pathlen(x: ?*X509) c_long;
pub extern fn X509_get_extension_flags(x: ?*X509) u32;
pub extern fn X509_get_key_usage(x: ?*X509) u32;
pub extern fn X509_get_extended_key_usage(x: ?*X509) u32;
pub extern fn X509_get0_subject_key_id(x: ?*X509) [*c]const ASN1_OCTET_STRING;
pub extern fn X509_get0_authority_key_id(x: ?*X509) [*c]const ASN1_OCTET_STRING;
pub extern fn X509_get0_authority_issuer(x: ?*X509) ?*const GENERAL_NAMES;
pub extern fn X509_get0_authority_serial(x: ?*X509) [*c]const ASN1_INTEGER;
pub extern fn X509_PURPOSE_get_count() c_int;
pub extern fn X509_PURPOSE_get0(idx: c_int) [*c]X509_PURPOSE;
pub extern fn X509_PURPOSE_get_by_sname(sname: [*c]const u8) c_int;
pub extern fn X509_PURPOSE_get_by_id(id: c_int) c_int;
pub extern fn X509_PURPOSE_add(id: c_int, trust: c_int, flags: c_int, ck: ?*const fn ([*c]const X509_PURPOSE, ?*const X509, c_int) callconv(.c) c_int, name: [*c]const u8, sname: [*c]const u8, arg: ?*anyopaque) c_int;
pub extern fn X509_PURPOSE_get0_name(xp: [*c]const X509_PURPOSE) [*c]u8;
pub extern fn X509_PURPOSE_get0_sname(xp: [*c]const X509_PURPOSE) [*c]u8;
pub extern fn X509_PURPOSE_get_trust(xp: [*c]const X509_PURPOSE) c_int;
pub extern fn X509_PURPOSE_cleanup() void;
pub extern fn X509_PURPOSE_get_id([*c]const X509_PURPOSE) c_int;
pub extern fn X509_get1_email(x: ?*X509) ?*struct_stack_st_OPENSSL_STRING;
pub extern fn X509_REQ_get1_email(x: ?*X509_REQ) ?*struct_stack_st_OPENSSL_STRING;
pub extern fn X509_email_free(sk: ?*struct_stack_st_OPENSSL_STRING) void;
pub extern fn X509_get1_ocsp(x: ?*X509) ?*struct_stack_st_OPENSSL_STRING;
pub extern fn X509_check_host(x: ?*X509, chk: [*c]const u8, chklen: usize, flags: c_uint, peername: [*c][*c]u8) c_int;
pub extern fn X509_check_email(x: ?*X509, chk: [*c]const u8, chklen: usize, flags: c_uint) c_int;
pub extern fn X509_check_ip(x: ?*X509, chk: [*c]const u8, chklen: usize, flags: c_uint) c_int;
pub extern fn X509_check_ip_asc(x: ?*X509, ipasc: [*c]const u8, flags: c_uint) c_int;
pub extern fn a2i_IPADDRESS(ipasc: [*c]const u8) [*c]ASN1_OCTET_STRING;
pub extern fn a2i_IPADDRESS_NC(ipasc: [*c]const u8) [*c]ASN1_OCTET_STRING;
pub extern fn X509V3_NAME_from_section(nm: ?*X509_NAME, dn_sk: ?*struct_stack_st_CONF_VALUE, chtype: c_ulong) c_int;
pub extern fn X509_POLICY_NODE_print(out: ?*BIO, node: ?*X509_POLICY_NODE, indent: c_int) void;
pub const sk_X509_POLICY_NODE_compfunc = ?*const fn ([*c]const ?*const X509_POLICY_NODE, [*c]const ?*const X509_POLICY_NODE) callconv(.c) c_int;
pub const sk_X509_POLICY_NODE_freefunc = ?*const fn (?*X509_POLICY_NODE) callconv(.c) void;
pub const sk_X509_POLICY_NODE_copyfunc = ?*const fn (?*const X509_POLICY_NODE) callconv(.c) ?*X509_POLICY_NODE;
pub fn ossl_check_X509_POLICY_NODE_type(arg_ptr: ?*X509_POLICY_NODE) callconv(.c) ?*X509_POLICY_NODE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_X509_POLICY_NODE_sk_type(arg_sk: ?*const struct_stack_st_X509_POLICY_NODE) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_POLICY_NODE_sk_type(arg_sk: ?*struct_stack_st_X509_POLICY_NODE) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_X509_POLICY_NODE_compfunc_type(arg_cmp: sk_X509_POLICY_NODE_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_X509_POLICY_NODE_copyfunc_type(arg_cpy: sk_X509_POLICY_NODE_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_X509_POLICY_NODE_freefunc_type(arg_fr: sk_X509_POLICY_NODE_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_ASRange_st = extern struct {
    min: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
    max: [*c]ASN1_INTEGER = @import("std").mem.zeroes([*c]ASN1_INTEGER),
};
pub const ASRange = struct_ASRange_st;
const union_unnamed_106 = extern union {
    id: [*c]ASN1_INTEGER,
    range: [*c]ASRange,
};
pub const struct_ASIdOrRange_st = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    u: union_unnamed_106 = @import("std").mem.zeroes(union_unnamed_106),
};
pub const ASIdOrRange = struct_ASIdOrRange_st;
pub const struct_stack_st_ASIdOrRange = opaque {};
pub const sk_ASIdOrRange_compfunc = ?*const fn ([*c]const [*c]const ASIdOrRange, [*c]const [*c]const ASIdOrRange) callconv(.c) c_int;
pub const sk_ASIdOrRange_freefunc = ?*const fn ([*c]ASIdOrRange) callconv(.c) void;
pub const sk_ASIdOrRange_copyfunc = ?*const fn ([*c]const ASIdOrRange) callconv(.c) [*c]ASIdOrRange;
pub fn ossl_check_ASIdOrRange_type(arg_ptr: [*c]ASIdOrRange) callconv(.c) [*c]ASIdOrRange {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASIdOrRange_sk_type(arg_sk: ?*const struct_stack_st_ASIdOrRange) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASIdOrRange_sk_type(arg_sk: ?*struct_stack_st_ASIdOrRange) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASIdOrRange_compfunc_type(arg_cmp: sk_ASIdOrRange_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASIdOrRange_copyfunc_type(arg_cpy: sk_ASIdOrRange_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASIdOrRange_freefunc_type(arg_fr: sk_ASIdOrRange_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const ASIdOrRanges = struct_stack_st_ASIdOrRange;
const union_unnamed_107 = extern union {
    inherit: [*c]ASN1_NULL,
    asIdsOrRanges: ?*ASIdOrRanges,
};
pub const struct_ASIdentifierChoice_st = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    u: union_unnamed_107 = @import("std").mem.zeroes(union_unnamed_107),
};
pub const ASIdentifierChoice = struct_ASIdentifierChoice_st;
pub const struct_ASIdentifiers_st = extern struct {
    asnum: [*c]ASIdentifierChoice = @import("std").mem.zeroes([*c]ASIdentifierChoice),
    rdi: [*c]ASIdentifierChoice = @import("std").mem.zeroes([*c]ASIdentifierChoice),
};
pub const ASIdentifiers = struct_ASIdentifiers_st;
pub extern fn ASRange_new() [*c]ASRange;
pub extern fn ASRange_free(a: [*c]ASRange) void;
pub extern fn d2i_ASRange(a: [*c][*c]ASRange, in: [*c][*c]const u8, len: c_long) [*c]ASRange;
pub extern fn i2d_ASRange(a: [*c]const ASRange, out: [*c][*c]u8) c_int;
pub extern fn ASRange_it() ?*const ASN1_ITEM;
pub extern fn ASIdOrRange_new() [*c]ASIdOrRange;
pub extern fn ASIdOrRange_free(a: [*c]ASIdOrRange) void;
pub extern fn d2i_ASIdOrRange(a: [*c][*c]ASIdOrRange, in: [*c][*c]const u8, len: c_long) [*c]ASIdOrRange;
pub extern fn i2d_ASIdOrRange(a: [*c]const ASIdOrRange, out: [*c][*c]u8) c_int;
pub extern fn ASIdOrRange_it() ?*const ASN1_ITEM;
pub extern fn ASIdentifierChoice_new() [*c]ASIdentifierChoice;
pub extern fn ASIdentifierChoice_free(a: [*c]ASIdentifierChoice) void;
pub extern fn d2i_ASIdentifierChoice(a: [*c][*c]ASIdentifierChoice, in: [*c][*c]const u8, len: c_long) [*c]ASIdentifierChoice;
pub extern fn i2d_ASIdentifierChoice(a: [*c]const ASIdentifierChoice, out: [*c][*c]u8) c_int;
pub extern fn ASIdentifierChoice_it() ?*const ASN1_ITEM;
pub extern fn ASIdentifiers_new() [*c]ASIdentifiers;
pub extern fn ASIdentifiers_free(a: [*c]ASIdentifiers) void;
pub extern fn d2i_ASIdentifiers(a: [*c][*c]ASIdentifiers, in: [*c][*c]const u8, len: c_long) [*c]ASIdentifiers;
pub extern fn i2d_ASIdentifiers(a: [*c]const ASIdentifiers, out: [*c][*c]u8) c_int;
pub extern fn ASIdentifiers_it() ?*const ASN1_ITEM;
pub const struct_IPAddressRange_st = extern struct {
    min: [*c]ASN1_BIT_STRING = @import("std").mem.zeroes([*c]ASN1_BIT_STRING),
    max: [*c]ASN1_BIT_STRING = @import("std").mem.zeroes([*c]ASN1_BIT_STRING),
};
pub const IPAddressRange = struct_IPAddressRange_st;
const union_unnamed_108 = extern union {
    addressPrefix: [*c]ASN1_BIT_STRING,
    addressRange: [*c]IPAddressRange,
};
pub const struct_IPAddressOrRange_st = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    u: union_unnamed_108 = @import("std").mem.zeroes(union_unnamed_108),
};
pub const IPAddressOrRange = struct_IPAddressOrRange_st;
pub const struct_stack_st_IPAddressOrRange = opaque {};
pub const sk_IPAddressOrRange_compfunc = ?*const fn ([*c]const [*c]const IPAddressOrRange, [*c]const [*c]const IPAddressOrRange) callconv(.c) c_int;
pub const sk_IPAddressOrRange_freefunc = ?*const fn ([*c]IPAddressOrRange) callconv(.c) void;
pub const sk_IPAddressOrRange_copyfunc = ?*const fn ([*c]const IPAddressOrRange) callconv(.c) [*c]IPAddressOrRange;
pub fn ossl_check_IPAddressOrRange_type(arg_ptr: [*c]IPAddressOrRange) callconv(.c) [*c]IPAddressOrRange {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_IPAddressOrRange_sk_type(arg_sk: ?*const struct_stack_st_IPAddressOrRange) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_IPAddressOrRange_sk_type(arg_sk: ?*struct_stack_st_IPAddressOrRange) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_IPAddressOrRange_compfunc_type(arg_cmp: sk_IPAddressOrRange_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_IPAddressOrRange_copyfunc_type(arg_cpy: sk_IPAddressOrRange_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_IPAddressOrRange_freefunc_type(arg_fr: sk_IPAddressOrRange_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const IPAddressOrRanges = struct_stack_st_IPAddressOrRange;
const union_unnamed_109 = extern union {
    inherit: [*c]ASN1_NULL,
    addressesOrRanges: ?*IPAddressOrRanges,
};
pub const struct_IPAddressChoice_st = extern struct {
    type: c_int = @import("std").mem.zeroes(c_int),
    u: union_unnamed_109 = @import("std").mem.zeroes(union_unnamed_109),
};
pub const IPAddressChoice = struct_IPAddressChoice_st;
pub const struct_IPAddressFamily_st = extern struct {
    addressFamily: [*c]ASN1_OCTET_STRING = @import("std").mem.zeroes([*c]ASN1_OCTET_STRING),
    ipAddressChoice: [*c]IPAddressChoice = @import("std").mem.zeroes([*c]IPAddressChoice),
};
pub const IPAddressFamily = struct_IPAddressFamily_st;
pub const struct_stack_st_IPAddressFamily = opaque {};
pub const sk_IPAddressFamily_compfunc = ?*const fn ([*c]const [*c]const IPAddressFamily, [*c]const [*c]const IPAddressFamily) callconv(.c) c_int;
pub const sk_IPAddressFamily_freefunc = ?*const fn ([*c]IPAddressFamily) callconv(.c) void;
pub const sk_IPAddressFamily_copyfunc = ?*const fn ([*c]const IPAddressFamily) callconv(.c) [*c]IPAddressFamily;
pub fn ossl_check_IPAddressFamily_type(arg_ptr: [*c]IPAddressFamily) callconv(.c) [*c]IPAddressFamily {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_IPAddressFamily_sk_type(arg_sk: ?*const struct_stack_st_IPAddressFamily) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_IPAddressFamily_sk_type(arg_sk: ?*struct_stack_st_IPAddressFamily) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_IPAddressFamily_compfunc_type(arg_cmp: sk_IPAddressFamily_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_IPAddressFamily_copyfunc_type(arg_cpy: sk_IPAddressFamily_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_IPAddressFamily_freefunc_type(arg_fr: sk_IPAddressFamily_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const IPAddrBlocks = struct_stack_st_IPAddressFamily;
pub extern fn IPAddressRange_new() [*c]IPAddressRange;
pub extern fn IPAddressRange_free(a: [*c]IPAddressRange) void;
pub extern fn d2i_IPAddressRange(a: [*c][*c]IPAddressRange, in: [*c][*c]const u8, len: c_long) [*c]IPAddressRange;
pub extern fn i2d_IPAddressRange(a: [*c]const IPAddressRange, out: [*c][*c]u8) c_int;
pub extern fn IPAddressRange_it() ?*const ASN1_ITEM;
pub extern fn IPAddressOrRange_new() [*c]IPAddressOrRange;
pub extern fn IPAddressOrRange_free(a: [*c]IPAddressOrRange) void;
pub extern fn d2i_IPAddressOrRange(a: [*c][*c]IPAddressOrRange, in: [*c][*c]const u8, len: c_long) [*c]IPAddressOrRange;
pub extern fn i2d_IPAddressOrRange(a: [*c]const IPAddressOrRange, out: [*c][*c]u8) c_int;
pub extern fn IPAddressOrRange_it() ?*const ASN1_ITEM;
pub extern fn IPAddressChoice_new() [*c]IPAddressChoice;
pub extern fn IPAddressChoice_free(a: [*c]IPAddressChoice) void;
pub extern fn d2i_IPAddressChoice(a: [*c][*c]IPAddressChoice, in: [*c][*c]const u8, len: c_long) [*c]IPAddressChoice;
pub extern fn i2d_IPAddressChoice(a: [*c]const IPAddressChoice, out: [*c][*c]u8) c_int;
pub extern fn IPAddressChoice_it() ?*const ASN1_ITEM;
pub extern fn IPAddressFamily_new() [*c]IPAddressFamily;
pub extern fn IPAddressFamily_free(a: [*c]IPAddressFamily) void;
pub extern fn d2i_IPAddressFamily(a: [*c][*c]IPAddressFamily, in: [*c][*c]const u8, len: c_long) [*c]IPAddressFamily;
pub extern fn i2d_IPAddressFamily(a: [*c]const IPAddressFamily, out: [*c][*c]u8) c_int;
pub extern fn IPAddressFamily_it() ?*const ASN1_ITEM;
pub extern fn X509v3_asid_add_inherit(asid: [*c]ASIdentifiers, which: c_int) c_int;
pub extern fn X509v3_asid_add_id_or_range(asid: [*c]ASIdentifiers, which: c_int, min: [*c]ASN1_INTEGER, max: [*c]ASN1_INTEGER) c_int;
pub extern fn X509v3_addr_add_inherit(addr: ?*IPAddrBlocks, afi: c_uint, safi: [*c]const c_uint) c_int;
pub extern fn X509v3_addr_add_prefix(addr: ?*IPAddrBlocks, afi: c_uint, safi: [*c]const c_uint, a: [*c]u8, prefixlen: c_int) c_int;
pub extern fn X509v3_addr_add_range(addr: ?*IPAddrBlocks, afi: c_uint, safi: [*c]const c_uint, min: [*c]u8, max: [*c]u8) c_int;
pub extern fn X509v3_addr_get_afi(f: [*c]const IPAddressFamily) c_uint;
pub extern fn X509v3_addr_get_range(aor: [*c]IPAddressOrRange, afi: c_uint, min: [*c]u8, max: [*c]u8, length: c_int) c_int;
pub extern fn X509v3_asid_is_canonical(asid: [*c]ASIdentifiers) c_int;
pub extern fn X509v3_addr_is_canonical(addr: ?*IPAddrBlocks) c_int;
pub extern fn X509v3_asid_canonize(asid: [*c]ASIdentifiers) c_int;
pub extern fn X509v3_addr_canonize(addr: ?*IPAddrBlocks) c_int;
pub extern fn X509v3_asid_inherits(asid: [*c]ASIdentifiers) c_int;
pub extern fn X509v3_addr_inherits(addr: ?*IPAddrBlocks) c_int;
pub extern fn X509v3_asid_subset(a: [*c]ASIdentifiers, b: [*c]ASIdentifiers) c_int;
pub extern fn X509v3_addr_subset(a: ?*IPAddrBlocks, b: ?*IPAddrBlocks) c_int;
pub extern fn X509v3_asid_validate_path(?*X509_STORE_CTX) c_int;
pub extern fn X509v3_addr_validate_path(?*X509_STORE_CTX) c_int;
pub extern fn X509v3_asid_validate_resource_set(chain: ?*struct_stack_st_X509, ext: [*c]ASIdentifiers, allow_inheritance: c_int) c_int;
pub extern fn X509v3_addr_validate_resource_set(chain: ?*struct_stack_st_X509, ext: ?*IPAddrBlocks, allow_inheritance: c_int) c_int;
pub const struct_stack_st_ASN1_STRING = opaque {};
pub const sk_ASN1_STRING_compfunc = ?*const fn ([*c]const [*c]const ASN1_STRING, [*c]const [*c]const ASN1_STRING) callconv(.c) c_int;
pub const sk_ASN1_STRING_freefunc = ?*const fn ([*c]ASN1_STRING) callconv(.c) void;
pub const sk_ASN1_STRING_copyfunc = ?*const fn ([*c]const ASN1_STRING) callconv(.c) [*c]ASN1_STRING;
pub fn ossl_check_ASN1_STRING_type(arg_ptr: [*c]ASN1_STRING) callconv(.c) [*c]ASN1_STRING {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ASN1_STRING_sk_type(arg_sk: ?*const struct_stack_st_ASN1_STRING) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_STRING_sk_type(arg_sk: ?*struct_stack_st_ASN1_STRING) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ASN1_STRING_compfunc_type(arg_cmp: sk_ASN1_STRING_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ASN1_STRING_copyfunc_type(arg_cpy: sk_ASN1_STRING_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ASN1_STRING_freefunc_type(arg_fr: sk_ASN1_STRING_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_NamingAuthority_st = opaque {};
pub const NAMING_AUTHORITY = struct_NamingAuthority_st;
pub const struct_ProfessionInfo_st = opaque {};
pub const PROFESSION_INFO = struct_ProfessionInfo_st;
pub const struct_Admissions_st = opaque {};
pub const ADMISSIONS = struct_Admissions_st;
pub const struct_AdmissionSyntax_st = opaque {};
pub const ADMISSION_SYNTAX = struct_AdmissionSyntax_st;
pub extern fn NAMING_AUTHORITY_new() ?*NAMING_AUTHORITY;
pub extern fn NAMING_AUTHORITY_free(a: ?*NAMING_AUTHORITY) void;
pub extern fn d2i_NAMING_AUTHORITY(a: [*c]?*NAMING_AUTHORITY, in: [*c][*c]const u8, len: c_long) ?*NAMING_AUTHORITY;
pub extern fn i2d_NAMING_AUTHORITY(a: ?*const NAMING_AUTHORITY, out: [*c][*c]u8) c_int;
pub extern fn NAMING_AUTHORITY_it() ?*const ASN1_ITEM;
pub extern fn PROFESSION_INFO_new() ?*PROFESSION_INFO;
pub extern fn PROFESSION_INFO_free(a: ?*PROFESSION_INFO) void;
pub extern fn d2i_PROFESSION_INFO(a: [*c]?*PROFESSION_INFO, in: [*c][*c]const u8, len: c_long) ?*PROFESSION_INFO;
pub extern fn i2d_PROFESSION_INFO(a: ?*const PROFESSION_INFO, out: [*c][*c]u8) c_int;
pub extern fn PROFESSION_INFO_it() ?*const ASN1_ITEM;
pub extern fn ADMISSIONS_new() ?*ADMISSIONS;
pub extern fn ADMISSIONS_free(a: ?*ADMISSIONS) void;
pub extern fn d2i_ADMISSIONS(a: [*c]?*ADMISSIONS, in: [*c][*c]const u8, len: c_long) ?*ADMISSIONS;
pub extern fn i2d_ADMISSIONS(a: ?*const ADMISSIONS, out: [*c][*c]u8) c_int;
pub extern fn ADMISSIONS_it() ?*const ASN1_ITEM;
pub extern fn ADMISSION_SYNTAX_new() ?*ADMISSION_SYNTAX;
pub extern fn ADMISSION_SYNTAX_free(a: ?*ADMISSION_SYNTAX) void;
pub extern fn d2i_ADMISSION_SYNTAX(a: [*c]?*ADMISSION_SYNTAX, in: [*c][*c]const u8, len: c_long) ?*ADMISSION_SYNTAX;
pub extern fn i2d_ADMISSION_SYNTAX(a: ?*const ADMISSION_SYNTAX, out: [*c][*c]u8) c_int;
pub extern fn ADMISSION_SYNTAX_it() ?*const ASN1_ITEM;
pub const struct_stack_st_PROFESSION_INFO = opaque {};
pub const sk_PROFESSION_INFO_compfunc = ?*const fn ([*c]const ?*const PROFESSION_INFO, [*c]const ?*const PROFESSION_INFO) callconv(.c) c_int;
pub const sk_PROFESSION_INFO_freefunc = ?*const fn (?*PROFESSION_INFO) callconv(.c) void;
pub const sk_PROFESSION_INFO_copyfunc = ?*const fn (?*const PROFESSION_INFO) callconv(.c) ?*PROFESSION_INFO;
pub fn ossl_check_PROFESSION_INFO_type(arg_ptr: ?*PROFESSION_INFO) callconv(.c) ?*PROFESSION_INFO {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_PROFESSION_INFO_sk_type(arg_sk: ?*const struct_stack_st_PROFESSION_INFO) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PROFESSION_INFO_sk_type(arg_sk: ?*struct_stack_st_PROFESSION_INFO) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_PROFESSION_INFO_compfunc_type(arg_cmp: sk_PROFESSION_INFO_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_PROFESSION_INFO_copyfunc_type(arg_cpy: sk_PROFESSION_INFO_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_PROFESSION_INFO_freefunc_type(arg_fr: sk_PROFESSION_INFO_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_ADMISSIONS = opaque {};
pub const sk_ADMISSIONS_compfunc = ?*const fn ([*c]const ?*const ADMISSIONS, [*c]const ?*const ADMISSIONS) callconv(.c) c_int;
pub const sk_ADMISSIONS_freefunc = ?*const fn (?*ADMISSIONS) callconv(.c) void;
pub const sk_ADMISSIONS_copyfunc = ?*const fn (?*const ADMISSIONS) callconv(.c) ?*ADMISSIONS;
pub fn ossl_check_ADMISSIONS_type(arg_ptr: ?*ADMISSIONS) callconv(.c) ?*ADMISSIONS {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_ADMISSIONS_sk_type(arg_sk: ?*const struct_stack_st_ADMISSIONS) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ADMISSIONS_sk_type(arg_sk: ?*struct_stack_st_ADMISSIONS) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_ADMISSIONS_compfunc_type(arg_cmp: sk_ADMISSIONS_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_ADMISSIONS_copyfunc_type(arg_cpy: sk_ADMISSIONS_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_ADMISSIONS_freefunc_type(arg_fr: sk_ADMISSIONS_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const PROFESSION_INFOS = struct_stack_st_PROFESSION_INFO;
pub extern fn NAMING_AUTHORITY_get0_authorityId(n: ?*const NAMING_AUTHORITY) ?*const ASN1_OBJECT;
pub extern fn NAMING_AUTHORITY_get0_authorityURL(n: ?*const NAMING_AUTHORITY) [*c]const ASN1_IA5STRING;
pub extern fn NAMING_AUTHORITY_get0_authorityText(n: ?*const NAMING_AUTHORITY) [*c]const ASN1_STRING;
pub extern fn NAMING_AUTHORITY_set0_authorityId(n: ?*NAMING_AUTHORITY, namingAuthorityId: ?*ASN1_OBJECT) void;
pub extern fn NAMING_AUTHORITY_set0_authorityURL(n: ?*NAMING_AUTHORITY, namingAuthorityUrl: [*c]ASN1_IA5STRING) void;
pub extern fn NAMING_AUTHORITY_set0_authorityText(n: ?*NAMING_AUTHORITY, namingAuthorityText: [*c]ASN1_STRING) void;
pub extern fn ADMISSION_SYNTAX_get0_admissionAuthority(as: ?*const ADMISSION_SYNTAX) [*c]const GENERAL_NAME;
pub extern fn ADMISSION_SYNTAX_set0_admissionAuthority(as: ?*ADMISSION_SYNTAX, aa: [*c]GENERAL_NAME) void;
pub extern fn ADMISSION_SYNTAX_get0_contentsOfAdmissions(as: ?*const ADMISSION_SYNTAX) ?*const struct_stack_st_ADMISSIONS;
pub extern fn ADMISSION_SYNTAX_set0_contentsOfAdmissions(as: ?*ADMISSION_SYNTAX, a: ?*struct_stack_st_ADMISSIONS) void;
pub extern fn ADMISSIONS_get0_admissionAuthority(a: ?*const ADMISSIONS) [*c]const GENERAL_NAME;
pub extern fn ADMISSIONS_set0_admissionAuthority(a: ?*ADMISSIONS, aa: [*c]GENERAL_NAME) void;
pub extern fn ADMISSIONS_get0_namingAuthority(a: ?*const ADMISSIONS) ?*const NAMING_AUTHORITY;
pub extern fn ADMISSIONS_set0_namingAuthority(a: ?*ADMISSIONS, na: ?*NAMING_AUTHORITY) void;
pub extern fn ADMISSIONS_get0_professionInfos(a: ?*const ADMISSIONS) ?*const PROFESSION_INFOS;
pub extern fn ADMISSIONS_set0_professionInfos(a: ?*ADMISSIONS, pi: ?*PROFESSION_INFOS) void;
pub extern fn PROFESSION_INFO_get0_addProfessionInfo(pi: ?*const PROFESSION_INFO) [*c]const ASN1_OCTET_STRING;
pub extern fn PROFESSION_INFO_set0_addProfessionInfo(pi: ?*PROFESSION_INFO, aos: [*c]ASN1_OCTET_STRING) void;
pub extern fn PROFESSION_INFO_get0_namingAuthority(pi: ?*const PROFESSION_INFO) ?*const NAMING_AUTHORITY;
pub extern fn PROFESSION_INFO_set0_namingAuthority(pi: ?*PROFESSION_INFO, na: ?*NAMING_AUTHORITY) void;
pub extern fn PROFESSION_INFO_get0_professionItems(pi: ?*const PROFESSION_INFO) ?*const struct_stack_st_ASN1_STRING;
pub extern fn PROFESSION_INFO_set0_professionItems(pi: ?*PROFESSION_INFO, as: ?*struct_stack_st_ASN1_STRING) void;
pub extern fn PROFESSION_INFO_get0_professionOIDs(pi: ?*const PROFESSION_INFO) ?*const struct_stack_st_ASN1_OBJECT;
pub extern fn PROFESSION_INFO_set0_professionOIDs(pi: ?*PROFESSION_INFO, po: ?*struct_stack_st_ASN1_OBJECT) void;
pub extern fn PROFESSION_INFO_get0_registrationNumber(pi: ?*const PROFESSION_INFO) [*c]const ASN1_PRINTABLESTRING;
pub extern fn PROFESSION_INFO_set0_registrationNumber(pi: ?*PROFESSION_INFO, rn: [*c]ASN1_PRINTABLESTRING) void;
pub extern fn OSSL_GENERAL_NAMES_print(out: ?*BIO, gens: ?*GENERAL_NAMES, indent: c_int) c_int;
pub const OSSL_ATTRIBUTES_SYNTAX = struct_stack_st_X509_ATTRIBUTE;
pub extern fn OSSL_ATTRIBUTES_SYNTAX_new() ?*OSSL_ATTRIBUTES_SYNTAX;
pub extern fn OSSL_ATTRIBUTES_SYNTAX_free(a: ?*OSSL_ATTRIBUTES_SYNTAX) void;
pub extern fn d2i_OSSL_ATTRIBUTES_SYNTAX(a: [*c]?*OSSL_ATTRIBUTES_SYNTAX, in: [*c][*c]const u8, len: c_long) ?*OSSL_ATTRIBUTES_SYNTAX;
pub extern fn i2d_OSSL_ATTRIBUTES_SYNTAX(a: ?*const OSSL_ATTRIBUTES_SYNTAX, out: [*c][*c]u8) c_int;
pub extern fn OSSL_ATTRIBUTES_SYNTAX_it() ?*const ASN1_ITEM;
pub const struct_stack_st_USERNOTICE = opaque {};
pub const OSSL_USER_NOTICE_SYNTAX = struct_stack_st_USERNOTICE;
pub extern fn OSSL_USER_NOTICE_SYNTAX_new() ?*OSSL_USER_NOTICE_SYNTAX;
pub extern fn OSSL_USER_NOTICE_SYNTAX_free(a: ?*OSSL_USER_NOTICE_SYNTAX) void;
pub extern fn d2i_OSSL_USER_NOTICE_SYNTAX(a: [*c]?*OSSL_USER_NOTICE_SYNTAX, in: [*c][*c]const u8, len: c_long) ?*OSSL_USER_NOTICE_SYNTAX;
pub extern fn i2d_OSSL_USER_NOTICE_SYNTAX(a: ?*const OSSL_USER_NOTICE_SYNTAX, out: [*c][*c]u8) c_int;
pub extern fn OSSL_USER_NOTICE_SYNTAX_it() ?*const ASN1_ITEM;
pub const sk_USERNOTICE_compfunc = ?*const fn ([*c]const [*c]const USERNOTICE, [*c]const [*c]const USERNOTICE) callconv(.c) c_int;
pub const sk_USERNOTICE_freefunc = ?*const fn ([*c]USERNOTICE) callconv(.c) void;
pub const sk_USERNOTICE_copyfunc = ?*const fn ([*c]const USERNOTICE) callconv(.c) [*c]USERNOTICE;
pub fn ossl_check_USERNOTICE_type(arg_ptr: [*c]USERNOTICE) callconv(.c) [*c]USERNOTICE {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_USERNOTICE_sk_type(arg_sk: ?*const struct_stack_st_USERNOTICE) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_USERNOTICE_sk_type(arg_sk: ?*struct_stack_st_USERNOTICE) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_USERNOTICE_compfunc_type(arg_cmp: sk_USERNOTICE_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_USERNOTICE_copyfunc_type(arg_cpy: sk_USERNOTICE_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_USERNOTICE_freefunc_type(arg_fr: sk_USERNOTICE_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_ocsp_cert_id_st = opaque {};
pub const OCSP_CERTID = struct_ocsp_cert_id_st;
pub const struct_ocsp_one_request_st = opaque {};
pub const OCSP_ONEREQ = struct_ocsp_one_request_st;
pub const struct_ocsp_req_info_st = opaque {};
pub const OCSP_REQINFO = struct_ocsp_req_info_st;
pub const struct_ocsp_signature_st = opaque {};
pub const OCSP_SIGNATURE = struct_ocsp_signature_st;
pub const struct_ocsp_request_st = opaque {};
pub const OCSP_REQUEST = struct_ocsp_request_st;
pub const struct_stack_st_OCSP_CERTID = opaque {};
pub const sk_OCSP_CERTID_compfunc = ?*const fn ([*c]const ?*const OCSP_CERTID, [*c]const ?*const OCSP_CERTID) callconv(.c) c_int;
pub const sk_OCSP_CERTID_freefunc = ?*const fn (?*OCSP_CERTID) callconv(.c) void;
pub const sk_OCSP_CERTID_copyfunc = ?*const fn (?*const OCSP_CERTID) callconv(.c) ?*OCSP_CERTID;
pub fn ossl_check_OCSP_CERTID_type(arg_ptr: ?*OCSP_CERTID) callconv(.c) ?*OCSP_CERTID {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OCSP_CERTID_sk_type(arg_sk: ?*const struct_stack_st_OCSP_CERTID) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OCSP_CERTID_sk_type(arg_sk: ?*struct_stack_st_OCSP_CERTID) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OCSP_CERTID_compfunc_type(arg_cmp: sk_OCSP_CERTID_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OCSP_CERTID_copyfunc_type(arg_cpy: sk_OCSP_CERTID_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_OCSP_CERTID_freefunc_type(arg_fr: sk_OCSP_CERTID_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_stack_st_OCSP_ONEREQ = opaque {};
pub const sk_OCSP_ONEREQ_compfunc = ?*const fn ([*c]const ?*const OCSP_ONEREQ, [*c]const ?*const OCSP_ONEREQ) callconv(.c) c_int;
pub const sk_OCSP_ONEREQ_freefunc = ?*const fn (?*OCSP_ONEREQ) callconv(.c) void;
pub const sk_OCSP_ONEREQ_copyfunc = ?*const fn (?*const OCSP_ONEREQ) callconv(.c) ?*OCSP_ONEREQ;
pub fn ossl_check_OCSP_ONEREQ_type(arg_ptr: ?*OCSP_ONEREQ) callconv(.c) ?*OCSP_ONEREQ {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OCSP_ONEREQ_sk_type(arg_sk: ?*const struct_stack_st_OCSP_ONEREQ) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OCSP_ONEREQ_sk_type(arg_sk: ?*struct_stack_st_OCSP_ONEREQ) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OCSP_ONEREQ_compfunc_type(arg_cmp: sk_OCSP_ONEREQ_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OCSP_ONEREQ_copyfunc_type(arg_cpy: sk_OCSP_ONEREQ_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_OCSP_ONEREQ_freefunc_type(arg_fr: sk_OCSP_ONEREQ_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_ocsp_resp_bytes_st = opaque {};
pub const OCSP_RESPBYTES = struct_ocsp_resp_bytes_st;
pub const struct_stack_st_OCSP_RESPID = opaque {};
pub const sk_OCSP_RESPID_compfunc = ?*const fn ([*c]const ?*const OCSP_RESPID, [*c]const ?*const OCSP_RESPID) callconv(.c) c_int;
pub const sk_OCSP_RESPID_freefunc = ?*const fn (?*OCSP_RESPID) callconv(.c) void;
pub const sk_OCSP_RESPID_copyfunc = ?*const fn (?*const OCSP_RESPID) callconv(.c) ?*OCSP_RESPID;
pub fn ossl_check_OCSP_RESPID_type(arg_ptr: ?*OCSP_RESPID) callconv(.c) ?*OCSP_RESPID {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OCSP_RESPID_sk_type(arg_sk: ?*const struct_stack_st_OCSP_RESPID) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OCSP_RESPID_sk_type(arg_sk: ?*struct_stack_st_OCSP_RESPID) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OCSP_RESPID_compfunc_type(arg_cmp: sk_OCSP_RESPID_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OCSP_RESPID_copyfunc_type(arg_cpy: sk_OCSP_RESPID_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_OCSP_RESPID_freefunc_type(arg_fr: sk_OCSP_RESPID_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_ocsp_revoked_info_st = opaque {};
pub const OCSP_REVOKEDINFO = struct_ocsp_revoked_info_st;
pub const struct_ocsp_cert_status_st = opaque {};
pub const OCSP_CERTSTATUS = struct_ocsp_cert_status_st;
pub const struct_ocsp_single_response_st = opaque {};
pub const OCSP_SINGLERESP = struct_ocsp_single_response_st;
pub const struct_stack_st_OCSP_SINGLERESP = opaque {};
pub const sk_OCSP_SINGLERESP_compfunc = ?*const fn ([*c]const ?*const OCSP_SINGLERESP, [*c]const ?*const OCSP_SINGLERESP) callconv(.c) c_int;
pub const sk_OCSP_SINGLERESP_freefunc = ?*const fn (?*OCSP_SINGLERESP) callconv(.c) void;
pub const sk_OCSP_SINGLERESP_copyfunc = ?*const fn (?*const OCSP_SINGLERESP) callconv(.c) ?*OCSP_SINGLERESP;
pub fn ossl_check_OCSP_SINGLERESP_type(arg_ptr: ?*OCSP_SINGLERESP) callconv(.c) ?*OCSP_SINGLERESP {
    var ptr = arg_ptr;
    _ = &ptr;
    return ptr;
}
pub fn ossl_check_const_OCSP_SINGLERESP_sk_type(arg_sk: ?*const struct_stack_st_OCSP_SINGLERESP) callconv(.c) ?*const OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*const OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OCSP_SINGLERESP_sk_type(arg_sk: ?*struct_stack_st_OCSP_SINGLERESP) callconv(.c) ?*OPENSSL_STACK {
    var sk = arg_sk;
    _ = &sk;
    return @as(?*OPENSSL_STACK, @ptrCast(sk));
}
pub fn ossl_check_OCSP_SINGLERESP_compfunc_type(arg_cmp: sk_OCSP_SINGLERESP_compfunc) callconv(.c) OPENSSL_sk_compfunc {
    var cmp = arg_cmp;
    _ = &cmp;
    return @as(OPENSSL_sk_compfunc, @ptrCast(@alignCast(cmp)));
}
pub fn ossl_check_OCSP_SINGLERESP_copyfunc_type(arg_cpy: sk_OCSP_SINGLERESP_copyfunc) callconv(.c) OPENSSL_sk_copyfunc {
    var cpy = arg_cpy;
    _ = &cpy;
    return @as(OPENSSL_sk_copyfunc, @ptrCast(@alignCast(cpy)));
}
pub fn ossl_check_OCSP_SINGLERESP_freefunc_type(arg_fr: sk_OCSP_SINGLERESP_freefunc) callconv(.c) OPENSSL_sk_freefunc {
    var fr = arg_fr;
    _ = &fr;
    return @as(OPENSSL_sk_freefunc, @ptrCast(@alignCast(fr)));
}
pub const struct_ocsp_response_data_st = opaque {};
pub const OCSP_RESPDATA = struct_ocsp_response_data_st;
pub const struct_ocsp_basic_response_st = opaque {};
pub const OCSP_BASICRESP = struct_ocsp_basic_response_st;
pub const struct_ocsp_crl_id_st = opaque {};
pub const OCSP_CRLID = struct_ocsp_crl_id_st;
pub const struct_ocsp_service_locator_st = opaque {};
pub const OCSP_SERVICELOC = struct_ocsp_service_locator_st;
pub extern fn OCSP_CERTID_dup(a: ?*const OCSP_CERTID) ?*OCSP_CERTID;
pub extern fn OCSP_sendreq_new(io: ?*BIO, path: [*c]const u8, req: ?*const OCSP_REQUEST, buf_size: c_int) ?*OSSL_HTTP_REQ_CTX;
pub extern fn OCSP_sendreq_bio(b: ?*BIO, path: [*c]const u8, req: ?*OCSP_REQUEST) ?*OCSP_RESPONSE;
pub const OCSP_REQ_CTX = OSSL_HTTP_REQ_CTX;
pub extern fn OCSP_cert_to_id(dgst: ?*const EVP_MD, subject: ?*const X509, issuer: ?*const X509) ?*OCSP_CERTID;
pub extern fn OCSP_cert_id_new(dgst: ?*const EVP_MD, issuerName: ?*const X509_NAME, issuerKey: [*c]const ASN1_BIT_STRING, serialNumber: [*c]const ASN1_INTEGER) ?*OCSP_CERTID;
pub extern fn OCSP_request_add0_id(req: ?*OCSP_REQUEST, cid: ?*OCSP_CERTID) ?*OCSP_ONEREQ;
pub extern fn OCSP_request_add1_nonce(req: ?*OCSP_REQUEST, val: [*c]u8, len: c_int) c_int;
pub extern fn OCSP_basic_add1_nonce(resp: ?*OCSP_BASICRESP, val: [*c]u8, len: c_int) c_int;
pub extern fn OCSP_check_nonce(req: ?*OCSP_REQUEST, bs: ?*OCSP_BASICRESP) c_int;
pub extern fn OCSP_copy_nonce(resp: ?*OCSP_BASICRESP, req: ?*OCSP_REQUEST) c_int;
pub extern fn OCSP_request_set1_name(req: ?*OCSP_REQUEST, nm: ?*const X509_NAME) c_int;
pub extern fn OCSP_request_add1_cert(req: ?*OCSP_REQUEST, cert: ?*X509) c_int;
pub extern fn OCSP_request_sign(req: ?*OCSP_REQUEST, signer: ?*X509, key: ?*EVP_PKEY, dgst: ?*const EVP_MD, certs: ?*struct_stack_st_X509, flags: c_ulong) c_int;
pub extern fn OCSP_response_status(resp: ?*OCSP_RESPONSE) c_int;
pub extern fn OCSP_response_get1_basic(resp: ?*OCSP_RESPONSE) ?*OCSP_BASICRESP;
pub extern fn OCSP_resp_get0_signature(bs: ?*const OCSP_BASICRESP) [*c]const ASN1_OCTET_STRING;
pub extern fn OCSP_resp_get0_tbs_sigalg(bs: ?*const OCSP_BASICRESP) [*c]const X509_ALGOR;
pub extern fn OCSP_resp_get0_respdata(bs: ?*const OCSP_BASICRESP) ?*const OCSP_RESPDATA;
pub extern fn OCSP_resp_get0_signer(bs: ?*OCSP_BASICRESP, signer: [*c]?*X509, extra_certs: ?*struct_stack_st_X509) c_int;
pub extern fn OCSP_resp_count(bs: ?*OCSP_BASICRESP) c_int;
pub extern fn OCSP_resp_get0(bs: ?*OCSP_BASICRESP, idx: c_int) ?*OCSP_SINGLERESP;
pub extern fn OCSP_resp_get0_produced_at(bs: ?*const OCSP_BASICRESP) [*c]const ASN1_GENERALIZEDTIME;
pub extern fn OCSP_resp_get0_certs(bs: ?*const OCSP_BASICRESP) ?*const struct_stack_st_X509;
pub extern fn OCSP_resp_get0_id(bs: ?*const OCSP_BASICRESP, pid: [*c][*c]const ASN1_OCTET_STRING, pname: [*c]?*const X509_NAME) c_int;
pub extern fn OCSP_resp_get1_id(bs: ?*const OCSP_BASICRESP, pid: [*c][*c]ASN1_OCTET_STRING, pname: [*c]?*X509_NAME) c_int;
pub extern fn OCSP_resp_find(bs: ?*OCSP_BASICRESP, id: ?*OCSP_CERTID, last: c_int) c_int;
pub extern fn OCSP_single_get0_status(single: ?*OCSP_SINGLERESP, reason: [*c]c_int, revtime: [*c][*c]ASN1_GENERALIZEDTIME, thisupd: [*c][*c]ASN1_GENERALIZEDTIME, nextupd: [*c][*c]ASN1_GENERALIZEDTIME) c_int;
pub extern fn OCSP_resp_find_status(bs: ?*OCSP_BASICRESP, id: ?*OCSP_CERTID, status: [*c]c_int, reason: [*c]c_int, revtime: [*c][*c]ASN1_GENERALIZEDTIME, thisupd: [*c][*c]ASN1_GENERALIZEDTIME, nextupd: [*c][*c]ASN1_GENERALIZEDTIME) c_int;
pub extern fn OCSP_check_validity(thisupd: [*c]ASN1_GENERALIZEDTIME, nextupd: [*c]ASN1_GENERALIZEDTIME, sec: c_long, maxsec: c_long) c_int;
pub extern fn OCSP_request_verify(req: ?*OCSP_REQUEST, certs: ?*struct_stack_st_X509, store: ?*X509_STORE, flags: c_ulong) c_int;
pub extern fn OCSP_id_issuer_cmp(a: ?*const OCSP_CERTID, b: ?*const OCSP_CERTID) c_int;
pub extern fn OCSP_id_cmp(a: ?*const OCSP_CERTID, b: ?*const OCSP_CERTID) c_int;
pub extern fn OCSP_request_onereq_count(req: ?*OCSP_REQUEST) c_int;
pub extern fn OCSP_request_onereq_get0(req: ?*OCSP_REQUEST, i: c_int) ?*OCSP_ONEREQ;
pub extern fn OCSP_onereq_get0_id(one: ?*OCSP_ONEREQ) ?*OCSP_CERTID;
pub extern fn OCSP_id_get0_info(piNameHash: [*c][*c]ASN1_OCTET_STRING, pmd: [*c]?*ASN1_OBJECT, pikeyHash: [*c][*c]ASN1_OCTET_STRING, pserial: [*c][*c]ASN1_INTEGER, cid: ?*OCSP_CERTID) c_int;
pub extern fn OCSP_request_is_signed(req: ?*OCSP_REQUEST) c_int;
pub extern fn OCSP_response_create(status: c_int, bs: ?*OCSP_BASICRESP) ?*OCSP_RESPONSE;
pub extern fn OCSP_basic_add1_status(rsp: ?*OCSP_BASICRESP, cid: ?*OCSP_CERTID, status: c_int, reason: c_int, revtime: [*c]ASN1_TIME, thisupd: [*c]ASN1_TIME, nextupd: [*c]ASN1_TIME) ?*OCSP_SINGLERESP;
pub extern fn OCSP_basic_add1_cert(resp: ?*OCSP_BASICRESP, cert: ?*X509) c_int;
pub extern fn OCSP_basic_sign(brsp: ?*OCSP_BASICRESP, signer: ?*X509, key: ?*EVP_PKEY, dgst: ?*const EVP_MD, certs: ?*struct_stack_st_X509, flags: c_ulong) c_int;
pub extern fn OCSP_basic_sign_ctx(brsp: ?*OCSP_BASICRESP, signer: ?*X509, ctx: ?*EVP_MD_CTX, certs: ?*struct_stack_st_X509, flags: c_ulong) c_int;
pub extern fn OCSP_RESPID_set_by_name(respid: ?*OCSP_RESPID, cert: ?*X509) c_int;
pub extern fn OCSP_RESPID_set_by_key_ex(respid: ?*OCSP_RESPID, cert: ?*X509, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn OCSP_RESPID_set_by_key(respid: ?*OCSP_RESPID, cert: ?*X509) c_int;
pub extern fn OCSP_RESPID_match_ex(respid: ?*OCSP_RESPID, cert: ?*X509, libctx: ?*OSSL_LIB_CTX, propq: [*c]const u8) c_int;
pub extern fn OCSP_RESPID_match(respid: ?*OCSP_RESPID, cert: ?*X509) c_int;
pub extern fn OCSP_crlID_new(url: [*c]const u8, n: [*c]c_long, tim: [*c]u8) ?*X509_EXTENSION;
pub extern fn OCSP_accept_responses_new(oids: [*c][*c]u8) ?*X509_EXTENSION;
pub extern fn OCSP_archive_cutoff_new(tim: [*c]u8) ?*X509_EXTENSION;
pub extern fn OCSP_url_svcloc_new(issuer: ?*const X509_NAME, urls: [*c][*c]const u8) ?*X509_EXTENSION;
pub extern fn OCSP_REQUEST_get_ext_count(x: ?*OCSP_REQUEST) c_int;
pub extern fn OCSP_REQUEST_get_ext_by_NID(x: ?*OCSP_REQUEST, nid: c_int, lastpos: c_int) c_int;
pub extern fn OCSP_REQUEST_get_ext_by_OBJ(x: ?*OCSP_REQUEST, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn OCSP_REQUEST_get_ext_by_critical(x: ?*OCSP_REQUEST, crit: c_int, lastpos: c_int) c_int;
pub extern fn OCSP_REQUEST_get_ext(x: ?*OCSP_REQUEST, loc: c_int) ?*X509_EXTENSION;
pub extern fn OCSP_REQUEST_delete_ext(x: ?*OCSP_REQUEST, loc: c_int) ?*X509_EXTENSION;
pub extern fn OCSP_REQUEST_get1_ext_d2i(x: ?*OCSP_REQUEST, nid: c_int, crit: [*c]c_int, idx: [*c]c_int) ?*anyopaque;
pub extern fn OCSP_REQUEST_add1_ext_i2d(x: ?*OCSP_REQUEST, nid: c_int, value: ?*anyopaque, crit: c_int, flags: c_ulong) c_int;
pub extern fn OCSP_REQUEST_add_ext(x: ?*OCSP_REQUEST, ex: ?*X509_EXTENSION, loc: c_int) c_int;
pub extern fn OCSP_ONEREQ_get_ext_count(x: ?*OCSP_ONEREQ) c_int;
pub extern fn OCSP_ONEREQ_get_ext_by_NID(x: ?*OCSP_ONEREQ, nid: c_int, lastpos: c_int) c_int;
pub extern fn OCSP_ONEREQ_get_ext_by_OBJ(x: ?*OCSP_ONEREQ, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn OCSP_ONEREQ_get_ext_by_critical(x: ?*OCSP_ONEREQ, crit: c_int, lastpos: c_int) c_int;
pub extern fn OCSP_ONEREQ_get_ext(x: ?*OCSP_ONEREQ, loc: c_int) ?*X509_EXTENSION;
pub extern fn OCSP_ONEREQ_delete_ext(x: ?*OCSP_ONEREQ, loc: c_int) ?*X509_EXTENSION;
pub extern fn OCSP_ONEREQ_get1_ext_d2i(x: ?*OCSP_ONEREQ, nid: c_int, crit: [*c]c_int, idx: [*c]c_int) ?*anyopaque;
pub extern fn OCSP_ONEREQ_add1_ext_i2d(x: ?*OCSP_ONEREQ, nid: c_int, value: ?*anyopaque, crit: c_int, flags: c_ulong) c_int;
pub extern fn OCSP_ONEREQ_add_ext(x: ?*OCSP_ONEREQ, ex: ?*X509_EXTENSION, loc: c_int) c_int;
pub extern fn OCSP_BASICRESP_get_ext_count(x: ?*OCSP_BASICRESP) c_int;
pub extern fn OCSP_BASICRESP_get_ext_by_NID(x: ?*OCSP_BASICRESP, nid: c_int, lastpos: c_int) c_int;
pub extern fn OCSP_BASICRESP_get_ext_by_OBJ(x: ?*OCSP_BASICRESP, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn OCSP_BASICRESP_get_ext_by_critical(x: ?*OCSP_BASICRESP, crit: c_int, lastpos: c_int) c_int;
pub extern fn OCSP_BASICRESP_get_ext(x: ?*OCSP_BASICRESP, loc: c_int) ?*X509_EXTENSION;
pub extern fn OCSP_BASICRESP_delete_ext(x: ?*OCSP_BASICRESP, loc: c_int) ?*X509_EXTENSION;
pub extern fn OCSP_BASICRESP_get1_ext_d2i(x: ?*OCSP_BASICRESP, nid: c_int, crit: [*c]c_int, idx: [*c]c_int) ?*anyopaque;
pub extern fn OCSP_BASICRESP_add1_ext_i2d(x: ?*OCSP_BASICRESP, nid: c_int, value: ?*anyopaque, crit: c_int, flags: c_ulong) c_int;
pub extern fn OCSP_BASICRESP_add_ext(x: ?*OCSP_BASICRESP, ex: ?*X509_EXTENSION, loc: c_int) c_int;
pub extern fn OCSP_SINGLERESP_get_ext_count(x: ?*OCSP_SINGLERESP) c_int;
pub extern fn OCSP_SINGLERESP_get_ext_by_NID(x: ?*OCSP_SINGLERESP, nid: c_int, lastpos: c_int) c_int;
pub extern fn OCSP_SINGLERESP_get_ext_by_OBJ(x: ?*OCSP_SINGLERESP, obj: ?*const ASN1_OBJECT, lastpos: c_int) c_int;
pub extern fn OCSP_SINGLERESP_get_ext_by_critical(x: ?*OCSP_SINGLERESP, crit: c_int, lastpos: c_int) c_int;
pub extern fn OCSP_SINGLERESP_get_ext(x: ?*OCSP_SINGLERESP, loc: c_int) ?*X509_EXTENSION;
pub extern fn OCSP_SINGLERESP_delete_ext(x: ?*OCSP_SINGLERESP, loc: c_int) ?*X509_EXTENSION;
pub extern fn OCSP_SINGLERESP_get1_ext_d2i(x: ?*OCSP_SINGLERESP, nid: c_int, crit: [*c]c_int, idx: [*c]c_int) ?*anyopaque;
pub extern fn OCSP_SINGLERESP_add1_ext_i2d(x: ?*OCSP_SINGLERESP, nid: c_int, value: ?*anyopaque, crit: c_int, flags: c_ulong) c_int;
pub extern fn OCSP_SINGLERESP_add_ext(x: ?*OCSP_SINGLERESP, ex: ?*X509_EXTENSION, loc: c_int) c_int;
pub extern fn OCSP_SINGLERESP_get0_id(x: ?*const OCSP_SINGLERESP) ?*const OCSP_CERTID;
pub extern fn OCSP_SINGLERESP_new() ?*OCSP_SINGLERESP;
pub extern fn OCSP_SINGLERESP_free(a: ?*OCSP_SINGLERESP) void;
pub extern fn d2i_OCSP_SINGLERESP(a: [*c]?*OCSP_SINGLERESP, in: [*c][*c]const u8, len: c_long) ?*OCSP_SINGLERESP;
pub extern fn i2d_OCSP_SINGLERESP(a: ?*const OCSP_SINGLERESP, out: [*c][*c]u8) c_int;
pub extern fn OCSP_SINGLERESP_it() ?*const ASN1_ITEM;
pub extern fn OCSP_CERTSTATUS_new() ?*OCSP_CERTSTATUS;
pub extern fn OCSP_CERTSTATUS_free(a: ?*OCSP_CERTSTATUS) void;
pub extern fn d2i_OCSP_CERTSTATUS(a: [*c]?*OCSP_CERTSTATUS, in: [*c][*c]const u8, len: c_long) ?*OCSP_CERTSTATUS;
pub extern fn i2d_OCSP_CERTSTATUS(a: ?*const OCSP_CERTSTATUS, out: [*c][*c]u8) c_int;
pub extern fn OCSP_CERTSTATUS_it() ?*const ASN1_ITEM;
pub extern fn OCSP_REVOKEDINFO_new() ?*OCSP_REVOKEDINFO;
pub extern fn OCSP_REVOKEDINFO_free(a: ?*OCSP_REVOKEDINFO) void;
pub extern fn d2i_OCSP_REVOKEDINFO(a: [*c]?*OCSP_REVOKEDINFO, in: [*c][*c]const u8, len: c_long) ?*OCSP_REVOKEDINFO;
pub extern fn i2d_OCSP_REVOKEDINFO(a: ?*const OCSP_REVOKEDINFO, out: [*c][*c]u8) c_int;
pub extern fn OCSP_REVOKEDINFO_it() ?*const ASN1_ITEM;
pub extern fn OCSP_BASICRESP_new() ?*OCSP_BASICRESP;
pub extern fn OCSP_BASICRESP_free(a: ?*OCSP_BASICRESP) void;
pub extern fn d2i_OCSP_BASICRESP(a: [*c]?*OCSP_BASICRESP, in: [*c][*c]const u8, len: c_long) ?*OCSP_BASICRESP;
pub extern fn i2d_OCSP_BASICRESP(a: ?*const OCSP_BASICRESP, out: [*c][*c]u8) c_int;
pub extern fn OCSP_BASICRESP_it() ?*const ASN1_ITEM;
pub extern fn OCSP_RESPDATA_new() ?*OCSP_RESPDATA;
pub extern fn OCSP_RESPDATA_free(a: ?*OCSP_RESPDATA) void;
pub extern fn d2i_OCSP_RESPDATA(a: [*c]?*OCSP_RESPDATA, in: [*c][*c]const u8, len: c_long) ?*OCSP_RESPDATA;
pub extern fn i2d_OCSP_RESPDATA(a: ?*const OCSP_RESPDATA, out: [*c][*c]u8) c_int;
pub extern fn OCSP_RESPDATA_it() ?*const ASN1_ITEM;
pub extern fn OCSP_RESPID_new() ?*OCSP_RESPID;
pub extern fn OCSP_RESPID_free(a: ?*OCSP_RESPID) void;
pub extern fn d2i_OCSP_RESPID(a: [*c]?*OCSP_RESPID, in: [*c][*c]const u8, len: c_long) ?*OCSP_RESPID;
pub extern fn i2d_OCSP_RESPID(a: ?*const OCSP_RESPID, out: [*c][*c]u8) c_int;
pub extern fn OCSP_RESPID_it() ?*const ASN1_ITEM;
pub extern fn OCSP_RESPONSE_new() ?*OCSP_RESPONSE;
pub extern fn OCSP_RESPONSE_free(a: ?*OCSP_RESPONSE) void;
pub extern fn d2i_OCSP_RESPONSE(a: [*c]?*OCSP_RESPONSE, in: [*c][*c]const u8, len: c_long) ?*OCSP_RESPONSE;
pub extern fn i2d_OCSP_RESPONSE(a: ?*const OCSP_RESPONSE, out: [*c][*c]u8) c_int;
pub extern fn OCSP_RESPONSE_it() ?*const ASN1_ITEM;
pub extern fn OCSP_RESPBYTES_new() ?*OCSP_RESPBYTES;
pub extern fn OCSP_RESPBYTES_free(a: ?*OCSP_RESPBYTES) void;
pub extern fn d2i_OCSP_RESPBYTES(a: [*c]?*OCSP_RESPBYTES, in: [*c][*c]const u8, len: c_long) ?*OCSP_RESPBYTES;
pub extern fn i2d_OCSP_RESPBYTES(a: ?*const OCSP_RESPBYTES, out: [*c][*c]u8) c_int;
pub extern fn OCSP_RESPBYTES_it() ?*const ASN1_ITEM;
pub extern fn OCSP_ONEREQ_new() ?*OCSP_ONEREQ;
pub extern fn OCSP_ONEREQ_free(a: ?*OCSP_ONEREQ) void;
pub extern fn d2i_OCSP_ONEREQ(a: [*c]?*OCSP_ONEREQ, in: [*c][*c]const u8, len: c_long) ?*OCSP_ONEREQ;
pub extern fn i2d_OCSP_ONEREQ(a: ?*const OCSP_ONEREQ, out: [*c][*c]u8) c_int;
pub extern fn OCSP_ONEREQ_it() ?*const ASN1_ITEM;
pub extern fn OCSP_CERTID_new() ?*OCSP_CERTID;
pub extern fn OCSP_CERTID_free(a: ?*OCSP_CERTID) void;
pub extern fn d2i_OCSP_CERTID(a: [*c]?*OCSP_CERTID, in: [*c][*c]const u8, len: c_long) ?*OCSP_CERTID;
pub extern fn i2d_OCSP_CERTID(a: ?*const OCSP_CERTID, out: [*c][*c]u8) c_int;
pub extern fn OCSP_CERTID_it() ?*const ASN1_ITEM;
pub extern fn OCSP_REQUEST_new() ?*OCSP_REQUEST;
pub extern fn OCSP_REQUEST_free(a: ?*OCSP_REQUEST) void;
pub extern fn d2i_OCSP_REQUEST(a: [*c]?*OCSP_REQUEST, in: [*c][*c]const u8, len: c_long) ?*OCSP_REQUEST;
pub extern fn i2d_OCSP_REQUEST(a: ?*const OCSP_REQUEST, out: [*c][*c]u8) c_int;
pub extern fn OCSP_REQUEST_it() ?*const ASN1_ITEM;
pub extern fn OCSP_SIGNATURE_new() ?*OCSP_SIGNATURE;
pub extern fn OCSP_SIGNATURE_free(a: ?*OCSP_SIGNATURE) void;
pub extern fn d2i_OCSP_SIGNATURE(a: [*c]?*OCSP_SIGNATURE, in: [*c][*c]const u8, len: c_long) ?*OCSP_SIGNATURE;
pub extern fn i2d_OCSP_SIGNATURE(a: ?*const OCSP_SIGNATURE, out: [*c][*c]u8) c_int;
pub extern fn OCSP_SIGNATURE_it() ?*const ASN1_ITEM;
pub extern fn OCSP_REQINFO_new() ?*OCSP_REQINFO;
pub extern fn OCSP_REQINFO_free(a: ?*OCSP_REQINFO) void;
pub extern fn d2i_OCSP_REQINFO(a: [*c]?*OCSP_REQINFO, in: [*c][*c]const u8, len: c_long) ?*OCSP_REQINFO;
pub extern fn i2d_OCSP_REQINFO(a: ?*const OCSP_REQINFO, out: [*c][*c]u8) c_int;
pub extern fn OCSP_REQINFO_it() ?*const ASN1_ITEM;
pub extern fn OCSP_CRLID_new() ?*OCSP_CRLID;
pub extern fn OCSP_CRLID_free(a: ?*OCSP_CRLID) void;
pub extern fn d2i_OCSP_CRLID(a: [*c]?*OCSP_CRLID, in: [*c][*c]const u8, len: c_long) ?*OCSP_CRLID;
pub extern fn i2d_OCSP_CRLID(a: ?*const OCSP_CRLID, out: [*c][*c]u8) c_int;
pub extern fn OCSP_CRLID_it() ?*const ASN1_ITEM;
pub extern fn OCSP_SERVICELOC_new() ?*OCSP_SERVICELOC;
pub extern fn OCSP_SERVICELOC_free(a: ?*OCSP_SERVICELOC) void;
pub extern fn d2i_OCSP_SERVICELOC(a: [*c]?*OCSP_SERVICELOC, in: [*c][*c]const u8, len: c_long) ?*OCSP_SERVICELOC;
pub extern fn i2d_OCSP_SERVICELOC(a: ?*const OCSP_SERVICELOC, out: [*c][*c]u8) c_int;
pub extern fn OCSP_SERVICELOC_it() ?*const ASN1_ITEM;
pub extern fn OCSP_response_status_str(s: c_long) [*c]const u8;
pub extern fn OCSP_cert_status_str(s: c_long) [*c]const u8;
pub extern fn OCSP_crl_reason_str(s: c_long) [*c]const u8;
pub extern fn OCSP_REQUEST_print(bp: ?*BIO, a: ?*OCSP_REQUEST, flags: c_ulong) c_int;
pub extern fn OCSP_RESPONSE_print(bp: ?*BIO, o: ?*OCSP_RESPONSE, flags: c_ulong) c_int;
pub extern fn OCSP_basic_verify(bs: ?*OCSP_BASICRESP, certs: ?*struct_stack_st_X509, st: ?*X509_STORE, flags: c_ulong) c_int;
pub const struct_ngx_ssl_sess_id_s = extern struct {
    node: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    len: usize = @import("std").mem.zeroes(usize),
    queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    expire: time_t = @import("std").mem.zeroes(time_t),
    id: [32]u_char = @import("std").mem.zeroes([32]u_char),
    session: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
};
pub const ngx_ssl_sess_id_t = struct_ngx_ssl_sess_id_s;
const ngx_ssl_ticket_key_flags_t = packed struct {
    size: u8,
    shared: bool,
    padding: u23,
};
pub const ngx_ssl_ticket_key_t = extern struct {
    name: [16]u_char = @import("std").mem.zeroes([16]u_char),
    hmac_key: [32]u_char = @import("std").mem.zeroes([32]u_char),
    aes_key: [32]u_char = @import("std").mem.zeroes([32]u_char),
    expire: time_t = @import("std").mem.zeroes(time_t),
    flags: ngx_ssl_ticket_key_flags_t = @import("std").mem.zeroes(ngx_ssl_ticket_key_flags_t),
};
pub const ngx_ssl_session_cache_t = extern struct {
    session_rbtree: ngx_rbtree_t = @import("std").mem.zeroes(ngx_rbtree_t),
    sentinel: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    expire_queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    ticket_keys: [3]ngx_ssl_ticket_key_t = @import("std").mem.zeroes([3]ngx_ssl_ticket_key_t),
    fail_time: time_t = @import("std").mem.zeroes(time_t),
};
pub extern fn ngx_ssl_init(log: [*c]ngx_log_t) ngx_int_t;
pub extern fn ngx_ssl_create(ssl: [*c]ngx_ssl_t, protocols: ngx_uint_t, data: ?*anyopaque) ngx_int_t;
pub extern fn ngx_ssl_certificates(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, certs: [*c]ngx_array_t, keys: [*c]ngx_array_t, passwords: [*c]ngx_array_t) ngx_int_t;
pub extern fn ngx_ssl_certificate(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, cert: [*c]ngx_str_t, key: [*c]ngx_str_t, passwords: [*c]ngx_array_t) ngx_int_t;
pub extern fn ngx_ssl_connection_certificate(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, cert: [*c]ngx_str_t, key: [*c]ngx_str_t, passwords: [*c]ngx_array_t) ngx_int_t;
pub extern fn ngx_ssl_ciphers(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, ciphers: [*c]ngx_str_t, prefer_server_ciphers: ngx_uint_t) ngx_int_t;
pub extern fn ngx_ssl_client_certificate(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, cert: [*c]ngx_str_t, depth: ngx_int_t) ngx_int_t;
pub extern fn ngx_ssl_trusted_certificate(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, cert: [*c]ngx_str_t, depth: ngx_int_t) ngx_int_t;
pub extern fn ngx_ssl_crl(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, crl: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_stapling(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, file: [*c]ngx_str_t, responder: [*c]ngx_str_t, verify: ngx_uint_t) ngx_int_t;
pub extern fn ngx_ssl_stapling_resolver(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, resolver: [*c]ngx_resolver_t, resolver_timeout: ngx_msec_t) ngx_int_t;
pub extern fn ngx_ssl_ocsp(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, responder: [*c]ngx_str_t, depth: ngx_uint_t, shm_zone: [*c]ngx_shm_zone_t) ngx_int_t;
pub extern fn ngx_ssl_ocsp_resolver(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, resolver: [*c]ngx_resolver_t, resolver_timeout: ngx_msec_t) ngx_int_t;
pub extern fn ngx_ssl_ocsp_validate(c: [*c]ngx_connection_t) ngx_int_t;
pub extern fn ngx_ssl_ocsp_get_status(c: [*c]ngx_connection_t, s: [*c][*c]const u8) ngx_int_t;
pub extern fn ngx_ssl_ocsp_cleanup(c: [*c]ngx_connection_t) void;
pub extern fn ngx_ssl_ocsp_cache_init(shm_zone: [*c]ngx_shm_zone_t, data: ?*anyopaque) ngx_int_t;
pub extern fn ngx_ssl_cache_fetch(cf: [*c]ngx_conf_t, index: ngx_uint_t, err: [*c][*c]u8, path: [*c]ngx_str_t, data: ?*anyopaque) ?*anyopaque;
pub extern fn ngx_ssl_cache_connection_fetch(pool: [*c]ngx_pool_t, index: ngx_uint_t, err: [*c][*c]u8, path: [*c]ngx_str_t, data: ?*anyopaque) ?*anyopaque;
pub extern fn ngx_ssl_read_password_file(cf: [*c]ngx_conf_t, file: [*c]ngx_str_t) [*c]ngx_array_t;
pub extern fn ngx_ssl_preserve_passwords(cf: [*c]ngx_conf_t, passwords: [*c]ngx_array_t) [*c]ngx_array_t;
pub extern fn ngx_ssl_dhparam(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, file: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_ecdh_curve(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, name: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_early_data(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, enable: ngx_uint_t) ngx_int_t;
pub extern fn ngx_ssl_conf_commands(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, commands: [*c]ngx_array_t) ngx_int_t;
pub extern fn ngx_ssl_client_session_cache(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, enable: ngx_uint_t) ngx_int_t;
pub extern fn ngx_ssl_session_cache(ssl: [*c]ngx_ssl_t, sess_ctx: [*c]ngx_str_t, certificates: [*c]ngx_array_t, builtin_session_cache: isize, shm_zone: [*c]ngx_shm_zone_t, timeout: time_t) ngx_int_t;
pub extern fn ngx_ssl_session_ticket_keys(cf: [*c]ngx_conf_t, ssl: [*c]ngx_ssl_t, paths: [*c]ngx_array_t) ngx_int_t;
pub extern fn ngx_ssl_session_cache_init(shm_zone: [*c]ngx_shm_zone_t, data: ?*anyopaque) ngx_int_t;
pub extern fn ngx_ssl_create_connection(ssl: [*c]ngx_ssl_t, c: [*c]ngx_connection_t, flags: ngx_uint_t) ngx_int_t;
pub extern fn ngx_ssl_remove_cached_session(ssl: ?*SSL_CTX, sess: ?*SSL_SESSION) void;
pub extern fn ngx_ssl_set_session(c: [*c]ngx_connection_t, session: ?*SSL_SESSION) ngx_int_t;
pub extern fn ngx_ssl_get_session(c: [*c]ngx_connection_t) ?*SSL_SESSION;
pub extern fn ngx_ssl_get0_session(c: [*c]ngx_connection_t) ?*SSL_SESSION;
pub extern fn ngx_ssl_check_host(c: [*c]ngx_connection_t, name: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_protocol(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_cipher_name(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_ciphers(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_curve(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_curves(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_session_id(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_session_reused(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_early_data(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_server_name(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_alpn_protocol(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_raw_certificate(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_certificate(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_escaped_certificate(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_subject_dn(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_issuer_dn(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_subject_dn_legacy(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_issuer_dn_legacy(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_serial_number(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_fingerprint(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_client_verify(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_client_v_start(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_client_v_end(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_get_client_v_remain(c: [*c]ngx_connection_t, pool: [*c]ngx_pool_t, s: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_ssl_handshake(c: [*c]ngx_connection_t) ngx_int_t;
pub extern fn ngx_ssl_recv(c: [*c]ngx_connection_t, buf: [*c]u_char, size: usize) isize;
pub extern fn ngx_ssl_write(c: [*c]ngx_connection_t, data: [*c]u_char, size: usize) isize;
pub extern fn ngx_ssl_recv_chain(c: [*c]ngx_connection_t, cl: [*c]ngx_chain_t, limit: off_t) isize;
pub extern fn ngx_ssl_send_chain(c: [*c]ngx_connection_t, in: [*c]ngx_chain_t, limit: off_t) [*c]ngx_chain_t;
pub extern fn ngx_ssl_free_buffer(c: [*c]ngx_connection_t) void;
pub extern fn ngx_ssl_shutdown(c: [*c]ngx_connection_t) ngx_int_t;
pub extern fn ngx_ssl_error(level: ngx_uint_t, log: [*c]ngx_log_t, err: ngx_err_t, fmt: [*c]u8, ...) void;
pub extern fn ngx_ssl_cleanup_ctx(data: ?*anyopaque) void;
pub extern var ngx_ssl_connection_index: c_int;
pub extern var ngx_ssl_server_conf_index: c_int;
pub extern var ngx_ssl_session_cache_index: c_int;
pub extern var ngx_ssl_ticket_keys_index: c_int;
pub extern var ngx_ssl_ocsp_index: c_int;
pub extern var ngx_ssl_index: c_int;
pub extern var ngx_ssl_certificate_name_index: c_int;
pub const ngx_cache_manager_ctx_t = extern struct {
    handler: ngx_event_handler_pt = @import("std").mem.zeroes(ngx_event_handler_pt),
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    delay: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
};
pub extern fn ngx_master_process_cycle(cycle: [*c]ngx_cycle_t) void;
pub extern fn ngx_single_process_cycle(cycle: [*c]ngx_cycle_t) void;
pub extern var ngx_process: ngx_uint_t;
pub extern var ngx_worker: ngx_uint_t;
pub extern var ngx_new_binary: ngx_pid_t;
pub extern var ngx_inherited: ngx_uint_t;
pub extern var ngx_daemonized: ngx_uint_t;
pub extern var ngx_exiting: ngx_uint_t;
pub extern var ngx_reap: sig_atomic_t;
pub extern var ngx_sigio: sig_atomic_t;
pub extern var ngx_sigalrm: sig_atomic_t;
pub extern var ngx_quit: sig_atomic_t;
pub extern var ngx_debug_quit: sig_atomic_t;
pub extern var ngx_terminate: sig_atomic_t;
pub extern var ngx_noaccept: sig_atomic_t;
pub extern var ngx_reconfigure: sig_atomic_t;
pub extern var ngx_reopen: sig_atomic_t;
pub extern var ngx_change_binary: sig_atomic_t;
pub const ngx_conf_file_t = extern struct {
    file: ngx_file_t = @import("std").mem.zeroes(ngx_file_t),
    buffer: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    dump: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    line: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_conf_dump_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    buffer: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
};
pub const ngx_conf_post_handler_pt = ?*const fn ([*c]ngx_conf_t, ?*anyopaque, ?*anyopaque) callconv(.c) [*c]u8;
pub const ngx_conf_post_t = extern struct {
    post_handler: ngx_conf_post_handler_pt = @import("std").mem.zeroes(ngx_conf_post_handler_pt),
};
pub const ngx_conf_deprecated_t = extern struct {
    post_handler: ngx_conf_post_handler_pt = @import("std").mem.zeroes(ngx_conf_post_handler_pt),
    old_name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    new_name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
};
pub const ngx_conf_num_bounds_t = extern struct {
    post_handler: ngx_conf_post_handler_pt = @import("std").mem.zeroes(ngx_conf_post_handler_pt),
    low: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    high: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
};
pub const ngx_conf_enum_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    value: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_conf_bitmask_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    mask: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub extern fn ngx_conf_deprecated(cf: [*c]ngx_conf_t, post: ?*anyopaque, data: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_check_num_bounds(cf: [*c]ngx_conf_t, post: ?*anyopaque, data: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_param(cf: [*c]ngx_conf_t) [*c]u8;
pub extern fn ngx_conf_parse(cf: [*c]ngx_conf_t, filename: [*c]ngx_str_t) [*c]u8;
pub extern fn ngx_conf_include(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_full_name(cycle: [*c]ngx_cycle_t, name: [*c]ngx_str_t, conf_prefix: ngx_uint_t) ngx_int_t;
pub extern fn ngx_conf_open_file(cycle: [*c]ngx_cycle_t, name: [*c]ngx_str_t) [*c]ngx_open_file_t;
pub extern fn ngx_conf_log_error(level: ngx_uint_t, cf: [*c]ngx_conf_t, err: ngx_err_t, fmt: [*c]const u8, ...) void;
pub extern fn ngx_conf_set_flag_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_set_str_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_set_str_array_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_set_keyval_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_set_num_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_set_size_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_set_off_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_set_msec_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_set_sec_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_set_bufs_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_set_enum_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_conf_set_bitmask_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub const ngx_core_module_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    create_conf: ?*const fn ([*c]ngx_cycle_t) callconv(.c) ?*anyopaque = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t) callconv(.c) ?*anyopaque),
    init_conf: ?*const fn ([*c]ngx_cycle_t, ?*anyopaque) callconv(.c) [*c]u8 = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t, ?*anyopaque) callconv(.c) [*c]u8),
};
pub extern fn ngx_preinit_modules() ngx_int_t;
pub extern fn ngx_cycle_modules(cycle: [*c]ngx_cycle_t) ngx_int_t;
pub extern fn ngx_init_modules(cycle: [*c]ngx_cycle_t) ngx_int_t;
pub extern fn ngx_count_modules(cycle: [*c]ngx_cycle_t, @"type": ngx_uint_t) ngx_int_t;
pub extern fn ngx_add_module(cf: [*c]ngx_conf_t, file: [*c]ngx_str_t, module: [*c]ngx_module_t, order: [*c][*c]u8) ngx_int_t;
pub const ngx_modules: [*c][*c]ngx_module_t = @extern([*c][*c]ngx_module_t, .{
    .name = "ngx_modules",
});
pub extern var ngx_max_module: ngx_uint_t;
pub const ngx_module_names: [*c][*c]u8 = @extern([*c][*c]u8, .{
    .name = "ngx_module_names",
});
const ngx_open_file_info_flags_t = packed struct {
    disable_symlinks: u2,
    test_dir: bool,
    test_only: bool,
    log: bool,
    errors: bool,
    events: bool,
    is_dir: bool,
    is_file: bool,
    is_link: bool,
    is_exec: bool,
    is_directio: bool,
    padding: u20,
};
pub const ngx_open_file_info_t = extern struct {
    fd: ngx_fd_t = @import("std").mem.zeroes(ngx_fd_t),
    uniq: ngx_file_uniq_t = @import("std").mem.zeroes(ngx_file_uniq_t),
    mtime: time_t = @import("std").mem.zeroes(time_t),
    size: off_t = @import("std").mem.zeroes(off_t),
    fs_size: off_t = @import("std").mem.zeroes(off_t),
    directio: off_t = @import("std").mem.zeroes(off_t),
    read_ahead: usize = @import("std").mem.zeroes(usize),
    err: ngx_err_t = @import("std").mem.zeroes(ngx_err_t),
    failed: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    valid: time_t = @import("std").mem.zeroes(time_t),
    min_uses: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    disable_symlinks_from: usize = @import("std").mem.zeroes(usize),
    flags: ngx_open_file_info_flags_t = @import("std").mem.zeroes(ngx_open_file_info_flags_t),
};
const struct_ngx_cached_open_file_flags_s = packed struct {
    disable_symlinks: u2,
    count: u24,
    close: bool,
    use_event: bool,
    is_dir: bool,
    is_file: bool,
    is_link: bool,
    is_exec: bool,
    is_directio: bool,
    padding: u31,
};
pub const struct_ngx_cached_open_file_s = extern struct {
    node: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    name: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    created: time_t = @import("std").mem.zeroes(time_t),
    accessed: time_t = @import("std").mem.zeroes(time_t),
    fd: ngx_fd_t = @import("std").mem.zeroes(ngx_fd_t),
    uniq: ngx_file_uniq_t = @import("std").mem.zeroes(ngx_file_uniq_t),
    mtime: time_t = @import("std").mem.zeroes(time_t),
    size: off_t = @import("std").mem.zeroes(off_t),
    err: ngx_err_t = @import("std").mem.zeroes(ngx_err_t),
    uses: u32 = @import("std").mem.zeroes(u32),
    disable_symlinks_from: usize = @import("std").mem.zeroes(usize),
    flags: struct_ngx_cached_open_file_flags_s = @import("std").mem.zeroes(struct_ngx_cached_open_file_flags_s),
    event: [*c]ngx_event_t = @import("std").mem.zeroes([*c]ngx_event_t),
};
pub const ngx_cached_open_file_t = struct_ngx_cached_open_file_s;
pub const ngx_open_file_cache_t = extern struct {
    rbtree: ngx_rbtree_t = @import("std").mem.zeroes(ngx_rbtree_t),
    sentinel: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    expire_queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    current: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    max: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    inactive: time_t = @import("std").mem.zeroes(time_t),
};
pub const ngx_open_file_cache_cleanup_t = extern struct {
    cache: [*c]ngx_open_file_cache_t = @import("std").mem.zeroes([*c]ngx_open_file_cache_t),
    file: [*c]ngx_cached_open_file_t = @import("std").mem.zeroes([*c]ngx_cached_open_file_t),
    min_uses: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
};
pub const ngx_open_file_cache_event_t = extern struct {
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    read: [*c]ngx_event_t = @import("std").mem.zeroes([*c]ngx_event_t),
    write: [*c]ngx_event_t = @import("std").mem.zeroes([*c]ngx_event_t),
    fd: ngx_fd_t = @import("std").mem.zeroes(ngx_fd_t),
    file: [*c]ngx_cached_open_file_t = @import("std").mem.zeroes([*c]ngx_cached_open_file_t),
    cache: [*c]ngx_open_file_cache_t = @import("std").mem.zeroes([*c]ngx_open_file_cache_t),
};
pub extern fn ngx_open_file_cache_init(pool: [*c]ngx_pool_t, max: ngx_uint_t, inactive: time_t) [*c]ngx_open_file_cache_t;
pub extern fn ngx_open_cached_file(cache: [*c]ngx_open_file_cache_t, name: [*c]ngx_str_t, of: [*c]ngx_open_file_info_t, pool: [*c]ngx_pool_t) ngx_int_t;
pub const ngx_os_io_t = extern struct {
    recv: ngx_recv_pt = @import("std").mem.zeroes(ngx_recv_pt),
    recv_chain: ngx_recv_chain_pt = @import("std").mem.zeroes(ngx_recv_chain_pt),
    udp_recv: ngx_recv_pt = @import("std").mem.zeroes(ngx_recv_pt),
    send: ngx_send_pt = @import("std").mem.zeroes(ngx_send_pt),
    udp_send: ngx_send_pt = @import("std").mem.zeroes(ngx_send_pt),
    udp_send_chain: ngx_send_chain_pt = @import("std").mem.zeroes(ngx_send_chain_pt),
    send_chain: ngx_send_chain_pt = @import("std").mem.zeroes(ngx_send_chain_pt),
    flags: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub extern fn ngx_os_init(log: [*c]ngx_log_t) ngx_int_t;
pub extern fn ngx_os_status(log: [*c]ngx_log_t) void;
pub extern fn ngx_os_specific_init(log: [*c]ngx_log_t) ngx_int_t;
pub extern fn ngx_os_specific_status(log: [*c]ngx_log_t) void;
pub extern fn ngx_daemon(log: [*c]ngx_log_t) ngx_int_t;
pub extern fn ngx_os_signal_process(cycle: [*c]ngx_cycle_t, sig: [*c]u8, pid: ngx_pid_t) ngx_int_t;
pub extern fn ngx_unix_recv(c: [*c]ngx_connection_t, buf: [*c]u_char, size: usize) isize;
pub extern fn ngx_readv_chain(c: [*c]ngx_connection_t, entry: [*c]ngx_chain_t, limit: off_t) isize;
pub extern fn ngx_udp_unix_recv(c: [*c]ngx_connection_t, buf: [*c]u_char, size: usize) isize;
pub extern fn ngx_unix_send(c: [*c]ngx_connection_t, buf: [*c]u_char, size: usize) isize;
pub extern fn ngx_writev_chain(c: [*c]ngx_connection_t, in: [*c]ngx_chain_t, limit: off_t) [*c]ngx_chain_t;
pub extern fn ngx_udp_unix_send(c: [*c]ngx_connection_t, buf: [*c]u_char, size: usize) isize;
pub extern fn ngx_udp_unix_sendmsg_chain(c: [*c]ngx_connection_t, in: [*c]ngx_chain_t, limit: off_t) [*c]ngx_chain_t;
pub const ngx_iovec_t = extern struct {
    iovs: [*c]struct_iovec = @import("std").mem.zeroes([*c]struct_iovec),
    count: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    size: usize = @import("std").mem.zeroes(usize),
    nalloc: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub extern fn ngx_output_chain_to_iovec(vec: [*c]ngx_iovec_t, in: [*c]ngx_chain_t, limit: usize, log: [*c]ngx_log_t) [*c]ngx_chain_t;
pub extern fn ngx_writev(c: [*c]ngx_connection_t, vec: [*c]ngx_iovec_t) isize;
pub extern var ngx_os_io: ngx_os_io_t;
pub extern var ngx_ncpu: ngx_int_t;
pub extern var ngx_max_sockets: ngx_int_t;
pub extern var ngx_inherited_nonblocking: ngx_uint_t;
pub extern var ngx_tcp_nodelay_and_tcp_nopush: ngx_uint_t;
pub extern fn ngx_linux_sendfile_chain(c: [*c]ngx_connection_t, in: [*c]ngx_chain_t, limit: off_t) [*c]ngx_chain_t;
pub const NGX_ERROR_ALERT: c_int = 0;
pub const NGX_ERROR_ERR: c_int = 1;
pub const NGX_ERROR_INFO: c_int = 2;
pub const NGX_ERROR_IGNORE_ECONNRESET: c_int = 3;
pub const NGX_ERROR_IGNORE_EINVAL: c_int = 4;
pub const NGX_ERROR_IGNORE_EMSGSIZE: c_int = 5;
pub const ngx_connection_log_error_e = c_uint;
pub const NGX_TCP_NODELAY_UNSET: c_int = 0;
pub const NGX_TCP_NODELAY_SET: c_int = 1;
pub const NGX_TCP_NODELAY_DISABLED: c_int = 2;
pub const ngx_connection_tcp_nodelay_e = c_uint;
pub const NGX_TCP_NOPUSH_UNSET: c_int = 0;
pub const NGX_TCP_NOPUSH_SET: c_int = 1;
pub const NGX_TCP_NOPUSH_DISABLED: c_int = 2;
pub const ngx_connection_tcp_nopush_e = c_uint;
pub extern fn ngx_create_listening(cf: [*c]ngx_conf_t, sockaddr: [*c]struct_sockaddr, socklen: socklen_t) [*c]ngx_listening_t;
pub extern fn ngx_clone_listening(cycle: [*c]ngx_cycle_t, ls: [*c]ngx_listening_t) ngx_int_t;
pub extern fn ngx_set_inherited_sockets(cycle: [*c]ngx_cycle_t) ngx_int_t;
pub extern fn ngx_open_listening_sockets(cycle: [*c]ngx_cycle_t) ngx_int_t;
pub extern fn ngx_configure_listening_sockets(cycle: [*c]ngx_cycle_t) void;
pub extern fn ngx_close_listening_sockets(cycle: [*c]ngx_cycle_t) void;
pub extern fn ngx_close_connection(c: [*c]ngx_connection_t) void;
pub extern fn ngx_close_idle_connections(cycle: [*c]ngx_cycle_t) void;
pub extern fn ngx_connection_local_sockaddr(c: [*c]ngx_connection_t, s: [*c]ngx_str_t, port: ngx_uint_t) ngx_int_t;
pub extern fn ngx_tcp_nodelay(c: [*c]ngx_connection_t) ngx_int_t;
pub extern fn ngx_connection_error(c: [*c]ngx_connection_t, err: ngx_err_t, text: [*c]u8) ngx_int_t;
pub extern fn ngx_get_connection(s: ngx_socket_t, log: [*c]ngx_log_t) [*c]ngx_connection_t;
pub extern fn ngx_free_connection(c: [*c]ngx_connection_t) void;
pub extern fn ngx_reusable_connection(c: [*c]ngx_connection_t, reusable: ngx_uint_t) void;
const ngx_syslog_peer_flags_t = packed struct {
    busy: bool,
    nohostname: bool,
    padding: u30,
};
pub const ngx_syslog_peer_t = extern struct {
    facility: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    severity: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    tag: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    hostname: [*c]ngx_str_t = @import("std").mem.zeroes([*c]ngx_str_t),
    server: ngx_addr_t = @import("std").mem.zeroes(ngx_addr_t),
    conn: ngx_connection_t = @import("std").mem.zeroes(ngx_connection_t),
    log: ngx_log_t = @import("std").mem.zeroes(ngx_log_t),
    logp: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    flags: ngx_syslog_peer_flags_t = @import("std").mem.zeroes(ngx_syslog_peer_flags_t),
};
pub extern fn ngx_syslog_process_conf(cf: [*c]ngx_conf_t, peer: [*c]ngx_syslog_peer_t) [*c]u8;
pub extern fn ngx_syslog_add_header(peer: [*c]ngx_syslog_peer_t, buf: [*c]u_char) [*c]u_char;
pub extern fn ngx_syslog_writer(log: [*c]ngx_log_t, level: ngx_uint_t, buf: [*c]u_char, len: usize) void;
pub extern fn ngx_syslog_send(peer: [*c]ngx_syslog_peer_t, buf: [*c]u_char, len: usize) isize;
pub extern fn ngx_proxy_protocol_read(c: [*c]ngx_connection_t, buf: [*c]u_char, last: [*c]u_char) [*c]u_char;
pub extern fn ngx_proxy_protocol_write(c: [*c]ngx_connection_t, buf: [*c]u_char, last: [*c]u_char) [*c]u_char;
pub extern fn ngx_proxy_protocol_get_tlv(c: [*c]ngx_connection_t, name: [*c]ngx_str_t, value: [*c]ngx_str_t) ngx_int_t;
pub const BPF_MAY_GOTO: c_int = 0;
pub const enum_bpf_cond_pseudo_jmp = c_uint;
pub const BPF_REG_0: c_int = 0;
pub const BPF_REG_1: c_int = 1;
pub const BPF_REG_2: c_int = 2;
pub const BPF_REG_3: c_int = 3;
pub const BPF_REG_4: c_int = 4;
pub const BPF_REG_5: c_int = 5;
pub const BPF_REG_6: c_int = 6;
pub const BPF_REG_7: c_int = 7;
pub const BPF_REG_8: c_int = 8;
pub const BPF_REG_9: c_int = 9;
pub const BPF_REG_10: c_int = 10;
pub const __MAX_BPF_REG: c_int = 11;
const enum_unnamed_110 = c_uint;
// /usr/include/linux/bpf.h:79:7: warning: struct demoted to opaque type - has bitfield
pub const struct_bpf_insn = opaque {};
pub const struct_bpf_lpm_trie_key = extern struct {
    prefixlen: __u32 align(4) = @import("std").mem.zeroes(__u32),
    pub fn data(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        return @as(ReturnType, @ptrCast(@alignCast(@as(Intermediate, @ptrCast(self)) + 4)));
    }
};
pub const struct_bpf_lpm_trie_key_hdr = extern struct {
    prefixlen: __u32 = @import("std").mem.zeroes(__u32),
};
const union_unnamed_111 = extern union {
    hdr: struct_bpf_lpm_trie_key_hdr,
    prefixlen: __u32,
};
pub const struct_bpf_lpm_trie_key_u8 = extern struct {
    unnamed_0: union_unnamed_111 align(4) = @import("std").mem.zeroes(union_unnamed_111),
    pub fn data(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        return @as(ReturnType, @ptrCast(@alignCast(@as(Intermediate, @ptrCast(self)) + 4)));
    }
};
pub const struct_bpf_cgroup_storage_key = extern struct {
    cgroup_inode_id: __u64 = @import("std").mem.zeroes(__u64),
    attach_type: __u32 = @import("std").mem.zeroes(__u32),
};
pub const BPF_CGROUP_ITER_ORDER_UNSPEC: c_int = 0;
pub const BPF_CGROUP_ITER_SELF_ONLY: c_int = 1;
pub const BPF_CGROUP_ITER_DESCENDANTS_PRE: c_int = 2;
pub const BPF_CGROUP_ITER_DESCENDANTS_POST: c_int = 3;
pub const BPF_CGROUP_ITER_ANCESTORS_UP: c_int = 4;
pub const enum_bpf_cgroup_iter_order = c_uint;
const struct_unnamed_112 = extern struct {
    map_fd: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_113 = extern struct {
    order: enum_bpf_cgroup_iter_order = @import("std").mem.zeroes(enum_bpf_cgroup_iter_order),
    cgroup_fd: __u32 = @import("std").mem.zeroes(__u32),
    cgroup_id: __u64 = @import("std").mem.zeroes(__u64),
};
const struct_unnamed_114 = extern struct {
    tid: __u32 = @import("std").mem.zeroes(__u32),
    pid: __u32 = @import("std").mem.zeroes(__u32),
    pid_fd: __u32 = @import("std").mem.zeroes(__u32),
};
pub const union_bpf_iter_link_info = extern union {
    map: struct_unnamed_112,
    cgroup: struct_unnamed_113,
    task: struct_unnamed_114,
};
pub const BPF_MAP_CREATE: c_int = 0;
pub const BPF_MAP_LOOKUP_ELEM: c_int = 1;
pub const BPF_MAP_UPDATE_ELEM: c_int = 2;
pub const BPF_MAP_DELETE_ELEM: c_int = 3;
pub const BPF_MAP_GET_NEXT_KEY: c_int = 4;
pub const BPF_PROG_LOAD: c_int = 5;
pub const BPF_OBJ_PIN: c_int = 6;
pub const BPF_OBJ_GET: c_int = 7;
pub const BPF_PROG_ATTACH: c_int = 8;
pub const BPF_PROG_DETACH: c_int = 9;
pub const BPF_PROG_TEST_RUN: c_int = 10;
pub const BPF_PROG_RUN: c_int = 10;
pub const BPF_PROG_GET_NEXT_ID: c_int = 11;
pub const BPF_MAP_GET_NEXT_ID: c_int = 12;
pub const BPF_PROG_GET_FD_BY_ID: c_int = 13;
pub const BPF_MAP_GET_FD_BY_ID: c_int = 14;
pub const BPF_OBJ_GET_INFO_BY_FD: c_int = 15;
pub const BPF_PROG_QUERY: c_int = 16;
pub const BPF_RAW_TRACEPOINT_OPEN: c_int = 17;
pub const BPF_BTF_LOAD: c_int = 18;
pub const BPF_BTF_GET_FD_BY_ID: c_int = 19;
pub const BPF_TASK_FD_QUERY: c_int = 20;
pub const BPF_MAP_LOOKUP_AND_DELETE_ELEM: c_int = 21;
pub const BPF_MAP_FREEZE: c_int = 22;
pub const BPF_BTF_GET_NEXT_ID: c_int = 23;
pub const BPF_MAP_LOOKUP_BATCH: c_int = 24;
pub const BPF_MAP_LOOKUP_AND_DELETE_BATCH: c_int = 25;
pub const BPF_MAP_UPDATE_BATCH: c_int = 26;
pub const BPF_MAP_DELETE_BATCH: c_int = 27;
pub const BPF_LINK_CREATE: c_int = 28;
pub const BPF_LINK_UPDATE: c_int = 29;
pub const BPF_LINK_GET_FD_BY_ID: c_int = 30;
pub const BPF_LINK_GET_NEXT_ID: c_int = 31;
pub const BPF_ENABLE_STATS: c_int = 32;
pub const BPF_ITER_CREATE: c_int = 33;
pub const BPF_LINK_DETACH: c_int = 34;
pub const BPF_PROG_BIND_MAP: c_int = 35;
pub const BPF_TOKEN_CREATE: c_int = 36;
pub const __MAX_BPF_CMD: c_int = 37;
pub const enum_bpf_cmd = c_uint;
pub const BPF_MAP_TYPE_UNSPEC: c_int = 0;
pub const BPF_MAP_TYPE_HASH: c_int = 1;
pub const BPF_MAP_TYPE_ARRAY: c_int = 2;
pub const BPF_MAP_TYPE_PROG_ARRAY: c_int = 3;
pub const BPF_MAP_TYPE_PERF_EVENT_ARRAY: c_int = 4;
pub const BPF_MAP_TYPE_PERCPU_HASH: c_int = 5;
pub const BPF_MAP_TYPE_PERCPU_ARRAY: c_int = 6;
pub const BPF_MAP_TYPE_STACK_TRACE: c_int = 7;
pub const BPF_MAP_TYPE_CGROUP_ARRAY: c_int = 8;
pub const BPF_MAP_TYPE_LRU_HASH: c_int = 9;
pub const BPF_MAP_TYPE_LRU_PERCPU_HASH: c_int = 10;
pub const BPF_MAP_TYPE_LPM_TRIE: c_int = 11;
pub const BPF_MAP_TYPE_ARRAY_OF_MAPS: c_int = 12;
pub const BPF_MAP_TYPE_HASH_OF_MAPS: c_int = 13;
pub const BPF_MAP_TYPE_DEVMAP: c_int = 14;
pub const BPF_MAP_TYPE_SOCKMAP: c_int = 15;
pub const BPF_MAP_TYPE_CPUMAP: c_int = 16;
pub const BPF_MAP_TYPE_XSKMAP: c_int = 17;
pub const BPF_MAP_TYPE_SOCKHASH: c_int = 18;
pub const BPF_MAP_TYPE_CGROUP_STORAGE_DEPRECATED: c_int = 19;
pub const BPF_MAP_TYPE_CGROUP_STORAGE: c_int = 19;
pub const BPF_MAP_TYPE_REUSEPORT_SOCKARRAY: c_int = 20;
pub const BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE_DEPRECATED: c_int = 21;
pub const BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE: c_int = 21;
pub const BPF_MAP_TYPE_QUEUE: c_int = 22;
pub const BPF_MAP_TYPE_STACK: c_int = 23;
pub const BPF_MAP_TYPE_SK_STORAGE: c_int = 24;
pub const BPF_MAP_TYPE_DEVMAP_HASH: c_int = 25;
pub const BPF_MAP_TYPE_STRUCT_OPS: c_int = 26;
pub const BPF_MAP_TYPE_RINGBUF: c_int = 27;
pub const BPF_MAP_TYPE_INODE_STORAGE: c_int = 28;
pub const BPF_MAP_TYPE_TASK_STORAGE: c_int = 29;
pub const BPF_MAP_TYPE_BLOOM_FILTER: c_int = 30;
pub const BPF_MAP_TYPE_USER_RINGBUF: c_int = 31;
pub const BPF_MAP_TYPE_CGRP_STORAGE: c_int = 32;
pub const BPF_MAP_TYPE_ARENA: c_int = 33;
pub const __MAX_BPF_MAP_TYPE: c_int = 34;
pub const enum_bpf_map_type = c_uint;
pub const BPF_PROG_TYPE_UNSPEC: c_int = 0;
pub const BPF_PROG_TYPE_SOCKET_FILTER: c_int = 1;
pub const BPF_PROG_TYPE_KPROBE: c_int = 2;
pub const BPF_PROG_TYPE_SCHED_CLS: c_int = 3;
pub const BPF_PROG_TYPE_SCHED_ACT: c_int = 4;
pub const BPF_PROG_TYPE_TRACEPOINT: c_int = 5;
pub const BPF_PROG_TYPE_XDP: c_int = 6;
pub const BPF_PROG_TYPE_PERF_EVENT: c_int = 7;
pub const BPF_PROG_TYPE_CGROUP_SKB: c_int = 8;
pub const BPF_PROG_TYPE_CGROUP_SOCK: c_int = 9;
pub const BPF_PROG_TYPE_LWT_IN: c_int = 10;
pub const BPF_PROG_TYPE_LWT_OUT: c_int = 11;
pub const BPF_PROG_TYPE_LWT_XMIT: c_int = 12;
pub const BPF_PROG_TYPE_SOCK_OPS: c_int = 13;
pub const BPF_PROG_TYPE_SK_SKB: c_int = 14;
pub const BPF_PROG_TYPE_CGROUP_DEVICE: c_int = 15;
pub const BPF_PROG_TYPE_SK_MSG: c_int = 16;
pub const BPF_PROG_TYPE_RAW_TRACEPOINT: c_int = 17;
pub const BPF_PROG_TYPE_CGROUP_SOCK_ADDR: c_int = 18;
pub const BPF_PROG_TYPE_LWT_SEG6LOCAL: c_int = 19;
pub const BPF_PROG_TYPE_LIRC_MODE2: c_int = 20;
pub const BPF_PROG_TYPE_SK_REUSEPORT: c_int = 21;
pub const BPF_PROG_TYPE_FLOW_DISSECTOR: c_int = 22;
pub const BPF_PROG_TYPE_CGROUP_SYSCTL: c_int = 23;
pub const BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE: c_int = 24;
pub const BPF_PROG_TYPE_CGROUP_SOCKOPT: c_int = 25;
pub const BPF_PROG_TYPE_TRACING: c_int = 26;
pub const BPF_PROG_TYPE_STRUCT_OPS: c_int = 27;
pub const BPF_PROG_TYPE_EXT: c_int = 28;
pub const BPF_PROG_TYPE_LSM: c_int = 29;
pub const BPF_PROG_TYPE_SK_LOOKUP: c_int = 30;
pub const BPF_PROG_TYPE_SYSCALL: c_int = 31;
pub const BPF_PROG_TYPE_NETFILTER: c_int = 32;
pub const __MAX_BPF_PROG_TYPE: c_int = 33;
pub const enum_bpf_prog_type = c_uint;
pub const BPF_CGROUP_INET_INGRESS: c_int = 0;
pub const BPF_CGROUP_INET_EGRESS: c_int = 1;
pub const BPF_CGROUP_INET_SOCK_CREATE: c_int = 2;
pub const BPF_CGROUP_SOCK_OPS: c_int = 3;
pub const BPF_SK_SKB_STREAM_PARSER: c_int = 4;
pub const BPF_SK_SKB_STREAM_VERDICT: c_int = 5;
pub const BPF_CGROUP_DEVICE: c_int = 6;
pub const BPF_SK_MSG_VERDICT: c_int = 7;
pub const BPF_CGROUP_INET4_BIND: c_int = 8;
pub const BPF_CGROUP_INET6_BIND: c_int = 9;
pub const BPF_CGROUP_INET4_CONNECT: c_int = 10;
pub const BPF_CGROUP_INET6_CONNECT: c_int = 11;
pub const BPF_CGROUP_INET4_POST_BIND: c_int = 12;
pub const BPF_CGROUP_INET6_POST_BIND: c_int = 13;
pub const BPF_CGROUP_UDP4_SENDMSG: c_int = 14;
pub const BPF_CGROUP_UDP6_SENDMSG: c_int = 15;
pub const BPF_LIRC_MODE2: c_int = 16;
pub const BPF_FLOW_DISSECTOR: c_int = 17;
pub const BPF_CGROUP_SYSCTL: c_int = 18;
pub const BPF_CGROUP_UDP4_RECVMSG: c_int = 19;
pub const BPF_CGROUP_UDP6_RECVMSG: c_int = 20;
pub const BPF_CGROUP_GETSOCKOPT: c_int = 21;
pub const BPF_CGROUP_SETSOCKOPT: c_int = 22;
pub const BPF_TRACE_RAW_TP: c_int = 23;
pub const BPF_TRACE_FENTRY: c_int = 24;
pub const BPF_TRACE_FEXIT: c_int = 25;
pub const BPF_MODIFY_RETURN: c_int = 26;
pub const BPF_LSM_MAC: c_int = 27;
pub const BPF_TRACE_ITER: c_int = 28;
pub const BPF_CGROUP_INET4_GETPEERNAME: c_int = 29;
pub const BPF_CGROUP_INET6_GETPEERNAME: c_int = 30;
pub const BPF_CGROUP_INET4_GETSOCKNAME: c_int = 31;
pub const BPF_CGROUP_INET6_GETSOCKNAME: c_int = 32;
pub const BPF_XDP_DEVMAP: c_int = 33;
pub const BPF_CGROUP_INET_SOCK_RELEASE: c_int = 34;
pub const BPF_XDP_CPUMAP: c_int = 35;
pub const BPF_SK_LOOKUP: c_int = 36;
pub const BPF_XDP: c_int = 37;
pub const BPF_SK_SKB_VERDICT: c_int = 38;
pub const BPF_SK_REUSEPORT_SELECT: c_int = 39;
pub const BPF_SK_REUSEPORT_SELECT_OR_MIGRATE: c_int = 40;
pub const BPF_PERF_EVENT: c_int = 41;
pub const BPF_TRACE_KPROBE_MULTI: c_int = 42;
pub const BPF_LSM_CGROUP: c_int = 43;
pub const BPF_STRUCT_OPS: c_int = 44;
pub const BPF_NETFILTER: c_int = 45;
pub const BPF_TCX_INGRESS: c_int = 46;
pub const BPF_TCX_EGRESS: c_int = 47;
pub const BPF_TRACE_UPROBE_MULTI: c_int = 48;
pub const BPF_CGROUP_UNIX_CONNECT: c_int = 49;
pub const BPF_CGROUP_UNIX_SENDMSG: c_int = 50;
pub const BPF_CGROUP_UNIX_RECVMSG: c_int = 51;
pub const BPF_CGROUP_UNIX_GETPEERNAME: c_int = 52;
pub const BPF_CGROUP_UNIX_GETSOCKNAME: c_int = 53;
pub const BPF_NETKIT_PRIMARY: c_int = 54;
pub const BPF_NETKIT_PEER: c_int = 55;
pub const BPF_TRACE_KPROBE_SESSION: c_int = 56;
pub const __MAX_BPF_ATTACH_TYPE: c_int = 57;
pub const enum_bpf_attach_type = c_uint;
pub const BPF_LINK_TYPE_UNSPEC: c_int = 0;
pub const BPF_LINK_TYPE_RAW_TRACEPOINT: c_int = 1;
pub const BPF_LINK_TYPE_TRACING: c_int = 2;
pub const BPF_LINK_TYPE_CGROUP: c_int = 3;
pub const BPF_LINK_TYPE_ITER: c_int = 4;
pub const BPF_LINK_TYPE_NETNS: c_int = 5;
pub const BPF_LINK_TYPE_XDP: c_int = 6;
pub const BPF_LINK_TYPE_PERF_EVENT: c_int = 7;
pub const BPF_LINK_TYPE_KPROBE_MULTI: c_int = 8;
pub const BPF_LINK_TYPE_STRUCT_OPS: c_int = 9;
pub const BPF_LINK_TYPE_NETFILTER: c_int = 10;
pub const BPF_LINK_TYPE_TCX: c_int = 11;
pub const BPF_LINK_TYPE_UPROBE_MULTI: c_int = 12;
pub const BPF_LINK_TYPE_NETKIT: c_int = 13;
pub const BPF_LINK_TYPE_SOCKMAP: c_int = 14;
pub const __MAX_BPF_LINK_TYPE: c_int = 15;
pub const enum_bpf_link_type = c_uint;
pub const BPF_PERF_EVENT_UNSPEC: c_int = 0;
pub const BPF_PERF_EVENT_UPROBE: c_int = 1;
pub const BPF_PERF_EVENT_URETPROBE: c_int = 2;
pub const BPF_PERF_EVENT_KPROBE: c_int = 3;
pub const BPF_PERF_EVENT_KRETPROBE: c_int = 4;
pub const BPF_PERF_EVENT_TRACEPOINT: c_int = 5;
pub const BPF_PERF_EVENT_EVENT: c_int = 6;
pub const enum_bpf_perf_event_type = c_uint;
pub const BPF_F_KPROBE_MULTI_RETURN: c_int = 1;
const enum_unnamed_115 = c_uint;
pub const BPF_F_UPROBE_MULTI_RETURN: c_int = 1;
const enum_unnamed_116 = c_uint;
pub const BPF_ADDR_SPACE_CAST: c_int = 1;
pub const enum_bpf_addr_space_cast = c_uint;
pub const BPF_ANY: c_int = 0;
pub const BPF_NOEXIST: c_int = 1;
pub const BPF_EXIST: c_int = 2;
pub const BPF_F_LOCK: c_int = 4;
const enum_unnamed_117 = c_uint;
pub const BPF_F_NO_PREALLOC: c_int = 1;
pub const BPF_F_NO_COMMON_LRU: c_int = 2;
pub const BPF_F_NUMA_NODE: c_int = 4;
pub const BPF_F_RDONLY: c_int = 8;
pub const BPF_F_WRONLY: c_int = 16;
pub const BPF_F_STACK_BUILD_ID: c_int = 32;
pub const BPF_F_ZERO_SEED: c_int = 64;
pub const BPF_F_RDONLY_PROG: c_int = 128;
pub const BPF_F_WRONLY_PROG: c_int = 256;
pub const BPF_F_CLONE: c_int = 512;
pub const BPF_F_MMAPABLE: c_int = 1024;
pub const BPF_F_PRESERVE_ELEMS: c_int = 2048;
pub const BPF_F_INNER_MAP: c_int = 4096;
pub const BPF_F_LINK: c_int = 8192;
pub const BPF_F_PATH_FD: c_int = 16384;
pub const BPF_F_VTYPE_BTF_OBJ_FD: c_int = 32768;
pub const BPF_F_TOKEN_FD: c_int = 65536;
pub const BPF_F_SEGV_ON_FAULT: c_int = 131072;
pub const BPF_F_NO_USER_CONV: c_int = 262144;
const enum_unnamed_118 = c_uint;
pub const BPF_STATS_RUN_TIME: c_int = 0;
pub const enum_bpf_stats_type = c_uint;
pub const BPF_STACK_BUILD_ID_EMPTY: c_int = 0;
pub const BPF_STACK_BUILD_ID_VALID: c_int = 1;
pub const BPF_STACK_BUILD_ID_IP: c_int = 2;
pub const enum_bpf_stack_build_id_status = c_uint;
const union_unnamed_119 = extern union {
    offset: __u64,
    ip: __u64,
};
pub const struct_bpf_stack_build_id = extern struct {
    status: __s32 = @import("std").mem.zeroes(__s32),
    build_id: [20]u8 = @import("std").mem.zeroes([20]u8),
    unnamed_0: union_unnamed_119 = @import("std").mem.zeroes(union_unnamed_119),
};
const struct_unnamed_120 = extern struct {
    map_type: __u32 = @import("std").mem.zeroes(__u32),
    key_size: __u32 = @import("std").mem.zeroes(__u32),
    value_size: __u32 = @import("std").mem.zeroes(__u32),
    max_entries: __u32 = @import("std").mem.zeroes(__u32),
    map_flags: __u32 = @import("std").mem.zeroes(__u32),
    inner_map_fd: __u32 = @import("std").mem.zeroes(__u32),
    numa_node: __u32 = @import("std").mem.zeroes(__u32),
    map_name: [16]u8 = @import("std").mem.zeroes([16]u8),
    map_ifindex: __u32 = @import("std").mem.zeroes(__u32),
    btf_fd: __u32 = @import("std").mem.zeroes(__u32),
    btf_key_type_id: __u32 = @import("std").mem.zeroes(__u32),
    btf_value_type_id: __u32 = @import("std").mem.zeroes(__u32),
    btf_vmlinux_value_type_id: __u32 = @import("std").mem.zeroes(__u32),
    map_extra: __u64 = @import("std").mem.zeroes(__u64),
    value_type_btf_obj_fd: __s32 = @import("std").mem.zeroes(__s32),
    map_token_fd: __s32 = @import("std").mem.zeroes(__s32),
};
const union_unnamed_122 = extern union {
    value: __u64 align(8),
    next_key: __u64 align(8),
};
const struct_unnamed_121 = extern struct {
    map_fd: __u32 = @import("std").mem.zeroes(__u32),
    key: __u64 align(8) = @import("std").mem.zeroes(__u64),
    unnamed_0: union_unnamed_122 = @import("std").mem.zeroes(union_unnamed_122),
    flags: __u64 = @import("std").mem.zeroes(__u64),
};
const struct_unnamed_123 = extern struct {
    in_batch: __u64 align(8) = @import("std").mem.zeroes(__u64),
    out_batch: __u64 align(8) = @import("std").mem.zeroes(__u64),
    keys: __u64 align(8) = @import("std").mem.zeroes(__u64),
    values: __u64 align(8) = @import("std").mem.zeroes(__u64),
    count: __u32 = @import("std").mem.zeroes(__u32),
    map_fd: __u32 = @import("std").mem.zeroes(__u32),
    elem_flags: __u64 = @import("std").mem.zeroes(__u64),
    flags: __u64 = @import("std").mem.zeroes(__u64),
};
const union_unnamed_125 = extern union {
    attach_prog_fd: __u32,
    attach_btf_obj_fd: __u32,
};
const struct_unnamed_124 = extern struct {
    prog_type: __u32 = @import("std").mem.zeroes(__u32),
    insn_cnt: __u32 = @import("std").mem.zeroes(__u32),
    insns: __u64 align(8) = @import("std").mem.zeroes(__u64),
    license: __u64 align(8) = @import("std").mem.zeroes(__u64),
    log_level: __u32 = @import("std").mem.zeroes(__u32),
    log_size: __u32 = @import("std").mem.zeroes(__u32),
    log_buf: __u64 align(8) = @import("std").mem.zeroes(__u64),
    kern_version: __u32 = @import("std").mem.zeroes(__u32),
    prog_flags: __u32 = @import("std").mem.zeroes(__u32),
    prog_name: [16]u8 = @import("std").mem.zeroes([16]u8),
    prog_ifindex: __u32 = @import("std").mem.zeroes(__u32),
    expected_attach_type: __u32 = @import("std").mem.zeroes(__u32),
    prog_btf_fd: __u32 = @import("std").mem.zeroes(__u32),
    func_info_rec_size: __u32 = @import("std").mem.zeroes(__u32),
    func_info: __u64 align(8) = @import("std").mem.zeroes(__u64),
    func_info_cnt: __u32 = @import("std").mem.zeroes(__u32),
    line_info_rec_size: __u32 = @import("std").mem.zeroes(__u32),
    line_info: __u64 align(8) = @import("std").mem.zeroes(__u64),
    line_info_cnt: __u32 = @import("std").mem.zeroes(__u32),
    attach_btf_id: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_0: union_unnamed_125 = @import("std").mem.zeroes(union_unnamed_125),
    core_relo_cnt: __u32 = @import("std").mem.zeroes(__u32),
    fd_array: __u64 align(8) = @import("std").mem.zeroes(__u64),
    core_relos: __u64 align(8) = @import("std").mem.zeroes(__u64),
    core_relo_rec_size: __u32 = @import("std").mem.zeroes(__u32),
    log_true_size: __u32 = @import("std").mem.zeroes(__u32),
    prog_token_fd: __s32 = @import("std").mem.zeroes(__s32),
};
const struct_unnamed_126 = extern struct {
    pathname: __u64 align(8) = @import("std").mem.zeroes(__u64),
    bpf_fd: __u32 = @import("std").mem.zeroes(__u32),
    file_flags: __u32 = @import("std").mem.zeroes(__u32),
    path_fd: __s32 = @import("std").mem.zeroes(__s32),
};
const union_unnamed_128 = extern union {
    target_fd: __u32,
    target_ifindex: __u32,
};
const union_unnamed_129 = extern union {
    relative_fd: __u32,
    relative_id: __u32,
};
const struct_unnamed_127 = extern struct {
    unnamed_0: union_unnamed_128 = @import("std").mem.zeroes(union_unnamed_128),
    attach_bpf_fd: __u32 = @import("std").mem.zeroes(__u32),
    attach_type: __u32 = @import("std").mem.zeroes(__u32),
    attach_flags: __u32 = @import("std").mem.zeroes(__u32),
    replace_bpf_fd: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_1: union_unnamed_129 = @import("std").mem.zeroes(union_unnamed_129),
    expected_revision: __u64 = @import("std").mem.zeroes(__u64),
};
const struct_unnamed_130 = extern struct {
    prog_fd: __u32 = @import("std").mem.zeroes(__u32),
    retval: __u32 = @import("std").mem.zeroes(__u32),
    data_size_in: __u32 = @import("std").mem.zeroes(__u32),
    data_size_out: __u32 = @import("std").mem.zeroes(__u32),
    data_in: __u64 align(8) = @import("std").mem.zeroes(__u64),
    data_out: __u64 align(8) = @import("std").mem.zeroes(__u64),
    repeat: __u32 = @import("std").mem.zeroes(__u32),
    duration: __u32 = @import("std").mem.zeroes(__u32),
    ctx_size_in: __u32 = @import("std").mem.zeroes(__u32),
    ctx_size_out: __u32 = @import("std").mem.zeroes(__u32),
    ctx_in: __u64 align(8) = @import("std").mem.zeroes(__u64),
    ctx_out: __u64 align(8) = @import("std").mem.zeroes(__u64),
    flags: __u32 = @import("std").mem.zeroes(__u32),
    cpu: __u32 = @import("std").mem.zeroes(__u32),
    batch_size: __u32 = @import("std").mem.zeroes(__u32),
};
const union_unnamed_132 = extern union {
    start_id: __u32,
    prog_id: __u32,
    map_id: __u32,
    btf_id: __u32,
    link_id: __u32,
};
const struct_unnamed_131 = extern struct {
    unnamed_0: union_unnamed_132 = @import("std").mem.zeroes(union_unnamed_132),
    next_id: __u32 = @import("std").mem.zeroes(__u32),
    open_flags: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_133 = extern struct {
    bpf_fd: __u32 = @import("std").mem.zeroes(__u32),
    info_len: __u32 = @import("std").mem.zeroes(__u32),
    info: __u64 align(8) = @import("std").mem.zeroes(__u64),
};
const union_unnamed_135 = extern union {
    target_fd: __u32,
    target_ifindex: __u32,
};
const union_unnamed_136 = extern union {
    prog_cnt: __u32,
    count: __u32,
};
// /usr/include/linux/bpf.h:1656:3: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_134 = opaque {};
// /usr/include/linux/bpf.h:1669:3: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_137 = opaque {};
const struct_unnamed_138 = extern struct {
    btf: __u64 align(8) = @import("std").mem.zeroes(__u64),
    btf_log_buf: __u64 align(8) = @import("std").mem.zeroes(__u64),
    btf_size: __u32 = @import("std").mem.zeroes(__u32),
    btf_log_size: __u32 = @import("std").mem.zeroes(__u32),
    btf_log_level: __u32 = @import("std").mem.zeroes(__u32),
    btf_log_true_size: __u32 = @import("std").mem.zeroes(__u32),
    btf_flags: __u32 = @import("std").mem.zeroes(__u32),
    btf_token_fd: __s32 = @import("std").mem.zeroes(__s32),
};
const struct_unnamed_139 = extern struct {
    pid: __u32 = @import("std").mem.zeroes(__u32),
    fd: __u32 = @import("std").mem.zeroes(__u32),
    flags: __u32 = @import("std").mem.zeroes(__u32),
    buf_len: __u32 = @import("std").mem.zeroes(__u32),
    buf: __u64 align(8) = @import("std").mem.zeroes(__u64),
    prog_id: __u32 = @import("std").mem.zeroes(__u32),
    fd_type: __u32 = @import("std").mem.zeroes(__u32),
    probe_offset: __u64 = @import("std").mem.zeroes(__u64),
    probe_addr: __u64 = @import("std").mem.zeroes(__u64),
};
const union_unnamed_141 = extern union {
    prog_fd: __u32,
    map_fd: __u32,
};
const union_unnamed_142 = extern union {
    target_fd: __u32,
    target_ifindex: __u32,
};
const struct_unnamed_144 = extern struct {
    iter_info: __u64 align(8) = @import("std").mem.zeroes(__u64),
    iter_info_len: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_145 = extern struct {
    bpf_cookie: __u64 = @import("std").mem.zeroes(__u64),
};
const struct_unnamed_146 = extern struct {
    flags: __u32 = @import("std").mem.zeroes(__u32),
    cnt: __u32 = @import("std").mem.zeroes(__u32),
    syms: __u64 align(8) = @import("std").mem.zeroes(__u64),
    addrs: __u64 align(8) = @import("std").mem.zeroes(__u64),
    cookies: __u64 align(8) = @import("std").mem.zeroes(__u64),
};
const struct_unnamed_147 = extern struct {
    target_btf_id: __u32 = @import("std").mem.zeroes(__u32),
    cookie: __u64 = @import("std").mem.zeroes(__u64),
};
const struct_unnamed_148 = extern struct {
    pf: __u32 = @import("std").mem.zeroes(__u32),
    hooknum: __u32 = @import("std").mem.zeroes(__u32),
    priority: __s32 = @import("std").mem.zeroes(__s32),
    flags: __u32 = @import("std").mem.zeroes(__u32),
};
const union_unnamed_150 = extern union {
    relative_fd: __u32,
    relative_id: __u32,
};
const struct_unnamed_149 = extern struct {
    unnamed_0: union_unnamed_150 = @import("std").mem.zeroes(union_unnamed_150),
    expected_revision: __u64 = @import("std").mem.zeroes(__u64),
};
const struct_unnamed_151 = extern struct {
    path: __u64 align(8) = @import("std").mem.zeroes(__u64),
    offsets: __u64 align(8) = @import("std").mem.zeroes(__u64),
    ref_ctr_offsets: __u64 align(8) = @import("std").mem.zeroes(__u64),
    cookies: __u64 align(8) = @import("std").mem.zeroes(__u64),
    cnt: __u32 = @import("std").mem.zeroes(__u32),
    flags: __u32 = @import("std").mem.zeroes(__u32),
    pid: __u32 = @import("std").mem.zeroes(__u32),
};
const union_unnamed_153 = extern union {
    relative_fd: __u32,
    relative_id: __u32,
};
const struct_unnamed_152 = extern struct {
    unnamed_0: union_unnamed_153 = @import("std").mem.zeroes(union_unnamed_153),
    expected_revision: __u64 = @import("std").mem.zeroes(__u64),
};
const union_unnamed_143 = extern union {
    target_btf_id: __u32,
    unnamed_0: struct_unnamed_144,
    perf_event: struct_unnamed_145,
    kprobe_multi: struct_unnamed_146,
    tracing: struct_unnamed_147,
    netfilter: struct_unnamed_148,
    tcx: struct_unnamed_149,
    uprobe_multi: struct_unnamed_151,
    netkit: struct_unnamed_152,
};
const struct_unnamed_140 = extern struct {
    unnamed_0: union_unnamed_141 = @import("std").mem.zeroes(union_unnamed_141),
    unnamed_1: union_unnamed_142 = @import("std").mem.zeroes(union_unnamed_142),
    attach_type: __u32 = @import("std").mem.zeroes(__u32),
    flags: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_2: union_unnamed_143 = @import("std").mem.zeroes(union_unnamed_143),
};
const union_unnamed_155 = extern union {
    new_prog_fd: __u32,
    new_map_fd: __u32,
};
const union_unnamed_156 = extern union {
    old_prog_fd: __u32,
    old_map_fd: __u32,
};
const struct_unnamed_154 = extern struct {
    link_fd: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_0: union_unnamed_155 = @import("std").mem.zeroes(union_unnamed_155),
    flags: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_1: union_unnamed_156 = @import("std").mem.zeroes(union_unnamed_156),
};
const struct_unnamed_157 = extern struct {
    link_fd: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_158 = extern struct {
    type: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_159 = extern struct {
    link_fd: __u32 = @import("std").mem.zeroes(__u32),
    flags: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_160 = extern struct {
    prog_fd: __u32 = @import("std").mem.zeroes(__u32),
    map_fd: __u32 = @import("std").mem.zeroes(__u32),
    flags: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_161 = extern struct {
    flags: __u32 = @import("std").mem.zeroes(__u32),
    bpffs_fd: __u32 = @import("std").mem.zeroes(__u32),
};
pub const union_bpf_attr = extern union {
    unnamed_0: struct_unnamed_120,
    unnamed_1: struct_unnamed_121,
    batch: struct_unnamed_123,
    unnamed_2: struct_unnamed_124,
    unnamed_3: struct_unnamed_126,
    unnamed_4: struct_unnamed_127,
    @"test": struct_unnamed_130,
    unnamed_5: struct_unnamed_131,
    info: struct_unnamed_133,
    query: struct_unnamed_134,
    raw_tracepoint: struct_unnamed_137,
    unnamed_6: struct_unnamed_138,
    task_fd_query: struct_unnamed_139,
    link_create: struct_unnamed_140,
    link_update: struct_unnamed_154,
    link_detach: struct_unnamed_157,
    enable_stats: struct_unnamed_158,
    iter_create: struct_unnamed_159,
    prog_bind_map: struct_unnamed_160,
    token_create: struct_unnamed_161,
};
pub const BPF_FUNC_unspec: c_int = 0;
pub const BPF_FUNC_map_lookup_elem: c_int = 1;
pub const BPF_FUNC_map_update_elem: c_int = 2;
pub const BPF_FUNC_map_delete_elem: c_int = 3;
pub const BPF_FUNC_probe_read: c_int = 4;
pub const BPF_FUNC_ktime_get_ns: c_int = 5;
pub const BPF_FUNC_trace_printk: c_int = 6;
pub const BPF_FUNC_get_prandom_u32: c_int = 7;
pub const BPF_FUNC_get_smp_processor_id: c_int = 8;
pub const BPF_FUNC_skb_store_bytes: c_int = 9;
pub const BPF_FUNC_l3_csum_replace: c_int = 10;
pub const BPF_FUNC_l4_csum_replace: c_int = 11;
pub const BPF_FUNC_tail_call: c_int = 12;
pub const BPF_FUNC_clone_redirect: c_int = 13;
pub const BPF_FUNC_get_current_pid_tgid: c_int = 14;
pub const BPF_FUNC_get_current_uid_gid: c_int = 15;
pub const BPF_FUNC_get_current_comm: c_int = 16;
pub const BPF_FUNC_get_cgroup_classid: c_int = 17;
pub const BPF_FUNC_skb_vlan_push: c_int = 18;
pub const BPF_FUNC_skb_vlan_pop: c_int = 19;
pub const BPF_FUNC_skb_get_tunnel_key: c_int = 20;
pub const BPF_FUNC_skb_set_tunnel_key: c_int = 21;
pub const BPF_FUNC_perf_event_read: c_int = 22;
pub const BPF_FUNC_redirect: c_int = 23;
pub const BPF_FUNC_get_route_realm: c_int = 24;
pub const BPF_FUNC_perf_event_output: c_int = 25;
pub const BPF_FUNC_skb_load_bytes: c_int = 26;
pub const BPF_FUNC_get_stackid: c_int = 27;
pub const BPF_FUNC_csum_diff: c_int = 28;
pub const BPF_FUNC_skb_get_tunnel_opt: c_int = 29;
pub const BPF_FUNC_skb_set_tunnel_opt: c_int = 30;
pub const BPF_FUNC_skb_change_proto: c_int = 31;
pub const BPF_FUNC_skb_change_type: c_int = 32;
pub const BPF_FUNC_skb_under_cgroup: c_int = 33;
pub const BPF_FUNC_get_hash_recalc: c_int = 34;
pub const BPF_FUNC_get_current_task: c_int = 35;
pub const BPF_FUNC_probe_write_user: c_int = 36;
pub const BPF_FUNC_current_task_under_cgroup: c_int = 37;
pub const BPF_FUNC_skb_change_tail: c_int = 38;
pub const BPF_FUNC_skb_pull_data: c_int = 39;
pub const BPF_FUNC_csum_update: c_int = 40;
pub const BPF_FUNC_set_hash_invalid: c_int = 41;
pub const BPF_FUNC_get_numa_node_id: c_int = 42;
pub const BPF_FUNC_skb_change_head: c_int = 43;
pub const BPF_FUNC_xdp_adjust_head: c_int = 44;
pub const BPF_FUNC_probe_read_str: c_int = 45;
pub const BPF_FUNC_get_socket_cookie: c_int = 46;
pub const BPF_FUNC_get_socket_uid: c_int = 47;
pub const BPF_FUNC_set_hash: c_int = 48;
pub const BPF_FUNC_setsockopt: c_int = 49;
pub const BPF_FUNC_skb_adjust_room: c_int = 50;
pub const BPF_FUNC_redirect_map: c_int = 51;
pub const BPF_FUNC_sk_redirect_map: c_int = 52;
pub const BPF_FUNC_sock_map_update: c_int = 53;
pub const BPF_FUNC_xdp_adjust_meta: c_int = 54;
pub const BPF_FUNC_perf_event_read_value: c_int = 55;
pub const BPF_FUNC_perf_prog_read_value: c_int = 56;
pub const BPF_FUNC_getsockopt: c_int = 57;
pub const BPF_FUNC_override_return: c_int = 58;
pub const BPF_FUNC_sock_ops_cb_flags_set: c_int = 59;
pub const BPF_FUNC_msg_redirect_map: c_int = 60;
pub const BPF_FUNC_msg_apply_bytes: c_int = 61;
pub const BPF_FUNC_msg_cork_bytes: c_int = 62;
pub const BPF_FUNC_msg_pull_data: c_int = 63;
pub const BPF_FUNC_bind: c_int = 64;
pub const BPF_FUNC_xdp_adjust_tail: c_int = 65;
pub const BPF_FUNC_skb_get_xfrm_state: c_int = 66;
pub const BPF_FUNC_get_stack: c_int = 67;
pub const BPF_FUNC_skb_load_bytes_relative: c_int = 68;
pub const BPF_FUNC_fib_lookup: c_int = 69;
pub const BPF_FUNC_sock_hash_update: c_int = 70;
pub const BPF_FUNC_msg_redirect_hash: c_int = 71;
pub const BPF_FUNC_sk_redirect_hash: c_int = 72;
pub const BPF_FUNC_lwt_push_encap: c_int = 73;
pub const BPF_FUNC_lwt_seg6_store_bytes: c_int = 74;
pub const BPF_FUNC_lwt_seg6_adjust_srh: c_int = 75;
pub const BPF_FUNC_lwt_seg6_action: c_int = 76;
pub const BPF_FUNC_rc_repeat: c_int = 77;
pub const BPF_FUNC_rc_keydown: c_int = 78;
pub const BPF_FUNC_skb_cgroup_id: c_int = 79;
pub const BPF_FUNC_get_current_cgroup_id: c_int = 80;
pub const BPF_FUNC_get_local_storage: c_int = 81;
pub const BPF_FUNC_sk_select_reuseport: c_int = 82;
pub const BPF_FUNC_skb_ancestor_cgroup_id: c_int = 83;
pub const BPF_FUNC_sk_lookup_tcp: c_int = 84;
pub const BPF_FUNC_sk_lookup_udp: c_int = 85;
pub const BPF_FUNC_sk_release: c_int = 86;
pub const BPF_FUNC_map_push_elem: c_int = 87;
pub const BPF_FUNC_map_pop_elem: c_int = 88;
pub const BPF_FUNC_map_peek_elem: c_int = 89;
pub const BPF_FUNC_msg_push_data: c_int = 90;
pub const BPF_FUNC_msg_pop_data: c_int = 91;
pub const BPF_FUNC_rc_pointer_rel: c_int = 92;
pub const BPF_FUNC_spin_lock: c_int = 93;
pub const BPF_FUNC_spin_unlock: c_int = 94;
pub const BPF_FUNC_sk_fullsock: c_int = 95;
pub const BPF_FUNC_tcp_sock: c_int = 96;
pub const BPF_FUNC_skb_ecn_set_ce: c_int = 97;
pub const BPF_FUNC_get_listener_sock: c_int = 98;
pub const BPF_FUNC_skc_lookup_tcp: c_int = 99;
pub const BPF_FUNC_tcp_check_syncookie: c_int = 100;
pub const BPF_FUNC_sysctl_get_name: c_int = 101;
pub const BPF_FUNC_sysctl_get_current_value: c_int = 102;
pub const BPF_FUNC_sysctl_get_new_value: c_int = 103;
pub const BPF_FUNC_sysctl_set_new_value: c_int = 104;
pub const BPF_FUNC_strtol: c_int = 105;
pub const BPF_FUNC_strtoul: c_int = 106;
pub const BPF_FUNC_sk_storage_get: c_int = 107;
pub const BPF_FUNC_sk_storage_delete: c_int = 108;
pub const BPF_FUNC_send_signal: c_int = 109;
pub const BPF_FUNC_tcp_gen_syncookie: c_int = 110;
pub const BPF_FUNC_skb_output: c_int = 111;
pub const BPF_FUNC_probe_read_user: c_int = 112;
pub const BPF_FUNC_probe_read_kernel: c_int = 113;
pub const BPF_FUNC_probe_read_user_str: c_int = 114;
pub const BPF_FUNC_probe_read_kernel_str: c_int = 115;
pub const BPF_FUNC_tcp_send_ack: c_int = 116;
pub const BPF_FUNC_send_signal_thread: c_int = 117;
pub const BPF_FUNC_jiffies64: c_int = 118;
pub const BPF_FUNC_read_branch_records: c_int = 119;
pub const BPF_FUNC_get_ns_current_pid_tgid: c_int = 120;
pub const BPF_FUNC_xdp_output: c_int = 121;
pub const BPF_FUNC_get_netns_cookie: c_int = 122;
pub const BPF_FUNC_get_current_ancestor_cgroup_id: c_int = 123;
pub const BPF_FUNC_sk_assign: c_int = 124;
pub const BPF_FUNC_ktime_get_boot_ns: c_int = 125;
pub const BPF_FUNC_seq_printf: c_int = 126;
pub const BPF_FUNC_seq_write: c_int = 127;
pub const BPF_FUNC_sk_cgroup_id: c_int = 128;
pub const BPF_FUNC_sk_ancestor_cgroup_id: c_int = 129;
pub const BPF_FUNC_ringbuf_output: c_int = 130;
pub const BPF_FUNC_ringbuf_reserve: c_int = 131;
pub const BPF_FUNC_ringbuf_submit: c_int = 132;
pub const BPF_FUNC_ringbuf_discard: c_int = 133;
pub const BPF_FUNC_ringbuf_query: c_int = 134;
pub const BPF_FUNC_csum_level: c_int = 135;
pub const BPF_FUNC_skc_to_tcp6_sock: c_int = 136;
pub const BPF_FUNC_skc_to_tcp_sock: c_int = 137;
pub const BPF_FUNC_skc_to_tcp_timewait_sock: c_int = 138;
pub const BPF_FUNC_skc_to_tcp_request_sock: c_int = 139;
pub const BPF_FUNC_skc_to_udp6_sock: c_int = 140;
pub const BPF_FUNC_get_task_stack: c_int = 141;
pub const BPF_FUNC_load_hdr_opt: c_int = 142;
pub const BPF_FUNC_store_hdr_opt: c_int = 143;
pub const BPF_FUNC_reserve_hdr_opt: c_int = 144;
pub const BPF_FUNC_inode_storage_get: c_int = 145;
pub const BPF_FUNC_inode_storage_delete: c_int = 146;
pub const BPF_FUNC_d_path: c_int = 147;
pub const BPF_FUNC_copy_from_user: c_int = 148;
pub const BPF_FUNC_snprintf_btf: c_int = 149;
pub const BPF_FUNC_seq_printf_btf: c_int = 150;
pub const BPF_FUNC_skb_cgroup_classid: c_int = 151;
pub const BPF_FUNC_redirect_neigh: c_int = 152;
pub const BPF_FUNC_per_cpu_ptr: c_int = 153;
pub const BPF_FUNC_this_cpu_ptr: c_int = 154;
pub const BPF_FUNC_redirect_peer: c_int = 155;
pub const BPF_FUNC_task_storage_get: c_int = 156;
pub const BPF_FUNC_task_storage_delete: c_int = 157;
pub const BPF_FUNC_get_current_task_btf: c_int = 158;
pub const BPF_FUNC_bprm_opts_set: c_int = 159;
pub const BPF_FUNC_ktime_get_coarse_ns: c_int = 160;
pub const BPF_FUNC_ima_inode_hash: c_int = 161;
pub const BPF_FUNC_sock_from_file: c_int = 162;
pub const BPF_FUNC_check_mtu: c_int = 163;
pub const BPF_FUNC_for_each_map_elem: c_int = 164;
pub const BPF_FUNC_snprintf: c_int = 165;
pub const BPF_FUNC_sys_bpf: c_int = 166;
pub const BPF_FUNC_btf_find_by_name_kind: c_int = 167;
pub const BPF_FUNC_sys_close: c_int = 168;
pub const BPF_FUNC_timer_init: c_int = 169;
pub const BPF_FUNC_timer_set_callback: c_int = 170;
pub const BPF_FUNC_timer_start: c_int = 171;
pub const BPF_FUNC_timer_cancel: c_int = 172;
pub const BPF_FUNC_get_func_ip: c_int = 173;
pub const BPF_FUNC_get_attach_cookie: c_int = 174;
pub const BPF_FUNC_task_pt_regs: c_int = 175;
pub const BPF_FUNC_get_branch_snapshot: c_int = 176;
pub const BPF_FUNC_trace_vprintk: c_int = 177;
pub const BPF_FUNC_skc_to_unix_sock: c_int = 178;
pub const BPF_FUNC_kallsyms_lookup_name: c_int = 179;
pub const BPF_FUNC_find_vma: c_int = 180;
pub const BPF_FUNC_loop: c_int = 181;
pub const BPF_FUNC_strncmp: c_int = 182;
pub const BPF_FUNC_get_func_arg: c_int = 183;
pub const BPF_FUNC_get_func_ret: c_int = 184;
pub const BPF_FUNC_get_func_arg_cnt: c_int = 185;
pub const BPF_FUNC_get_retval: c_int = 186;
pub const BPF_FUNC_set_retval: c_int = 187;
pub const BPF_FUNC_xdp_get_buff_len: c_int = 188;
pub const BPF_FUNC_xdp_load_bytes: c_int = 189;
pub const BPF_FUNC_xdp_store_bytes: c_int = 190;
pub const BPF_FUNC_copy_from_user_task: c_int = 191;
pub const BPF_FUNC_skb_set_tstamp: c_int = 192;
pub const BPF_FUNC_ima_file_hash: c_int = 193;
pub const BPF_FUNC_kptr_xchg: c_int = 194;
pub const BPF_FUNC_map_lookup_percpu_elem: c_int = 195;
pub const BPF_FUNC_skc_to_mptcp_sock: c_int = 196;
pub const BPF_FUNC_dynptr_from_mem: c_int = 197;
pub const BPF_FUNC_ringbuf_reserve_dynptr: c_int = 198;
pub const BPF_FUNC_ringbuf_submit_dynptr: c_int = 199;
pub const BPF_FUNC_ringbuf_discard_dynptr: c_int = 200;
pub const BPF_FUNC_dynptr_read: c_int = 201;
pub const BPF_FUNC_dynptr_write: c_int = 202;
pub const BPF_FUNC_dynptr_data: c_int = 203;
pub const BPF_FUNC_tcp_raw_gen_syncookie_ipv4: c_int = 204;
pub const BPF_FUNC_tcp_raw_gen_syncookie_ipv6: c_int = 205;
pub const BPF_FUNC_tcp_raw_check_syncookie_ipv4: c_int = 206;
pub const BPF_FUNC_tcp_raw_check_syncookie_ipv6: c_int = 207;
pub const BPF_FUNC_ktime_get_tai_ns: c_int = 208;
pub const BPF_FUNC_user_ringbuf_drain: c_int = 209;
pub const BPF_FUNC_cgrp_storage_get: c_int = 210;
pub const BPF_FUNC_cgrp_storage_delete: c_int = 211;
pub const __BPF_FUNC_MAX_ID: c_int = 212;
pub const enum_bpf_func_id = c_uint;
pub const BPF_F_RECOMPUTE_CSUM: c_int = 1;
pub const BPF_F_INVALIDATE_HASH: c_int = 2;
const enum_unnamed_162 = c_uint;
pub const BPF_F_HDR_FIELD_MASK: c_int = 15;
const enum_unnamed_163 = c_uint;
pub const BPF_F_PSEUDO_HDR: c_int = 16;
pub const BPF_F_MARK_MANGLED_0: c_int = 32;
pub const BPF_F_MARK_ENFORCE: c_int = 64;
const enum_unnamed_164 = c_uint;
pub const BPF_F_INGRESS: c_int = 1;
const enum_unnamed_165 = c_uint;
pub const BPF_F_TUNINFO_IPV6: c_int = 1;
const enum_unnamed_166 = c_uint;
pub const BPF_F_SKIP_FIELD_MASK: c_int = 255;
pub const BPF_F_USER_STACK: c_int = 256;
pub const BPF_F_FAST_STACK_CMP: c_int = 512;
pub const BPF_F_REUSE_STACKID: c_int = 1024;
pub const BPF_F_USER_BUILD_ID: c_int = 2048;
const enum_unnamed_167 = c_uint;
pub const BPF_F_ZERO_CSUM_TX: c_int = 2;
pub const BPF_F_DONT_FRAGMENT: c_int = 4;
pub const BPF_F_SEQ_NUMBER: c_int = 8;
pub const BPF_F_NO_TUNNEL_KEY: c_int = 16;
const enum_unnamed_168 = c_uint;
pub const BPF_F_TUNINFO_FLAGS: c_int = 16;
const enum_unnamed_169 = c_uint;
pub const BPF_F_INDEX_MASK: c_ulong = 4294967295;
pub const BPF_F_CURRENT_CPU: c_ulong = 4294967295;
pub const BPF_F_CTXLEN_MASK: c_ulong = 4503595332403200;
const enum_unnamed_170 = c_ulong;
pub const BPF_F_CURRENT_NETNS: c_int = -1;
const enum_unnamed_171 = c_int;
pub const BPF_CSUM_LEVEL_QUERY: c_int = 0;
pub const BPF_CSUM_LEVEL_INC: c_int = 1;
pub const BPF_CSUM_LEVEL_DEC: c_int = 2;
pub const BPF_CSUM_LEVEL_RESET: c_int = 3;
const enum_unnamed_172 = c_uint;
pub const BPF_F_ADJ_ROOM_FIXED_GSO: c_int = 1;
pub const BPF_F_ADJ_ROOM_ENCAP_L3_IPV4: c_int = 2;
pub const BPF_F_ADJ_ROOM_ENCAP_L3_IPV6: c_int = 4;
pub const BPF_F_ADJ_ROOM_ENCAP_L4_GRE: c_int = 8;
pub const BPF_F_ADJ_ROOM_ENCAP_L4_UDP: c_int = 16;
pub const BPF_F_ADJ_ROOM_NO_CSUM_RESET: c_int = 32;
pub const BPF_F_ADJ_ROOM_ENCAP_L2_ETH: c_int = 64;
pub const BPF_F_ADJ_ROOM_DECAP_L3_IPV4: c_int = 128;
pub const BPF_F_ADJ_ROOM_DECAP_L3_IPV6: c_int = 256;
const enum_unnamed_173 = c_uint;
pub const BPF_ADJ_ROOM_ENCAP_L2_MASK: c_int = 255;
pub const BPF_ADJ_ROOM_ENCAP_L2_SHIFT: c_int = 56;
const enum_unnamed_174 = c_uint;
pub const BPF_F_SYSCTL_BASE_NAME: c_int = 1;
const enum_unnamed_175 = c_uint;
pub const BPF_LOCAL_STORAGE_GET_F_CREATE: c_int = 1;
pub const BPF_SK_STORAGE_GET_F_CREATE: c_int = 1;
const enum_unnamed_176 = c_uint;
pub const BPF_F_GET_BRANCH_RECORDS_SIZE: c_int = 1;
const enum_unnamed_177 = c_uint;
pub const BPF_RB_NO_WAKEUP: c_int = 1;
pub const BPF_RB_FORCE_WAKEUP: c_int = 2;
const enum_unnamed_178 = c_uint;
pub const BPF_RB_AVAIL_DATA: c_int = 0;
pub const BPF_RB_RING_SIZE: c_int = 1;
pub const BPF_RB_CONS_POS: c_int = 2;
pub const BPF_RB_PROD_POS: c_int = 3;
const enum_unnamed_179 = c_uint;
pub const BPF_RINGBUF_BUSY_BIT: c_uint = 2147483648;
pub const BPF_RINGBUF_DISCARD_BIT: c_int = 1073741824;
pub const BPF_RINGBUF_HDR_SZ: c_int = 8;
const enum_unnamed_180 = c_uint;
pub const BPF_SK_LOOKUP_F_REPLACE: c_int = 1;
pub const BPF_SK_LOOKUP_F_NO_REUSEPORT: c_int = 2;
const enum_unnamed_181 = c_uint;
pub const BPF_ADJ_ROOM_NET: c_int = 0;
pub const BPF_ADJ_ROOM_MAC: c_int = 1;
pub const enum_bpf_adj_room_mode = c_uint;
pub const BPF_HDR_START_MAC: c_int = 0;
pub const BPF_HDR_START_NET: c_int = 1;
pub const enum_bpf_hdr_start_off = c_uint;
pub const BPF_LWT_ENCAP_SEG6: c_int = 0;
pub const BPF_LWT_ENCAP_SEG6_INLINE: c_int = 1;
pub const BPF_LWT_ENCAP_IP: c_int = 2;
pub const enum_bpf_lwt_encap_mode = c_uint;
pub const BPF_F_BPRM_SECUREEXEC: c_int = 1;
const enum_unnamed_182 = c_uint;
pub const BPF_F_BROADCAST: c_int = 8;
pub const BPF_F_EXCLUDE_INGRESS: c_int = 16;
const enum_unnamed_183 = c_uint;
pub const BPF_SKB_TSTAMP_UNSPEC: c_int = 0;
pub const BPF_SKB_TSTAMP_DELIVERY_MONO: c_int = 1;
const enum_unnamed_184 = c_uint;
const struct_unnamed_187 = extern struct {
    ipv4_src: __be32 = @import("std").mem.zeroes(__be32),
    ipv4_dst: __be32 = @import("std").mem.zeroes(__be32),
};
const struct_unnamed_188 = extern struct {
    ipv6_src: [4]__u32 = @import("std").mem.zeroes([4]__u32),
    ipv6_dst: [4]__u32 = @import("std").mem.zeroes([4]__u32),
};
const union_unnamed_186 = extern union {
    unnamed_0: struct_unnamed_187,
    unnamed_1: struct_unnamed_188,
};
pub const struct_bpf_flow_keys = extern struct {
    nhoff: __u16 = @import("std").mem.zeroes(__u16),
    thoff: __u16 = @import("std").mem.zeroes(__u16),
    addr_proto: __u16 = @import("std").mem.zeroes(__u16),
    is_frag: __u8 = @import("std").mem.zeroes(__u8),
    is_first_frag: __u8 = @import("std").mem.zeroes(__u8),
    is_encap: __u8 = @import("std").mem.zeroes(__u8),
    ip_proto: __u8 = @import("std").mem.zeroes(__u8),
    n_proto: __be16 = @import("std").mem.zeroes(__be16),
    sport: __be16 = @import("std").mem.zeroes(__be16),
    dport: __be16 = @import("std").mem.zeroes(__be16),
    unnamed_0: union_unnamed_186 = @import("std").mem.zeroes(union_unnamed_186),
    flags: __u32 = @import("std").mem.zeroes(__u32),
    flow_label: __be32 = @import("std").mem.zeroes(__be32),
};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_185 = opaque {};
// /usr/include/linux/bpf.h:6338:2: warning: struct demoted to opaque type - has bitfield
pub const struct_bpf_sock = opaque {};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_189 = opaque {};
// /usr/include/linux/bpf.h:6260:2: warning: struct demoted to opaque type - has bitfield
pub const struct___sk_buff = opaque {};
const union_unnamed_190 = extern union {
    remote_ipv4: __u32,
    remote_ipv6: [4]__u32,
};
const union_unnamed_191 = extern union {
    tunnel_ext: __u16,
    tunnel_flags: __be16,
};
const union_unnamed_192 = extern union {
    local_ipv4: __u32,
    local_ipv6: [4]__u32,
};
pub const struct_bpf_tunnel_key = extern struct {
    tunnel_id: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_0: union_unnamed_190 = @import("std").mem.zeroes(union_unnamed_190),
    tunnel_tos: __u8 = @import("std").mem.zeroes(__u8),
    tunnel_ttl: __u8 = @import("std").mem.zeroes(__u8),
    unnamed_1: union_unnamed_191 = @import("std").mem.zeroes(union_unnamed_191),
    tunnel_label: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_2: union_unnamed_192 = @import("std").mem.zeroes(union_unnamed_192),
};
const union_unnamed_193 = extern union {
    remote_ipv4: __u32,
    remote_ipv6: [4]__u32,
};
pub const struct_bpf_xfrm_state = extern struct {
    reqid: __u32 = @import("std").mem.zeroes(__u32),
    spi: __u32 = @import("std").mem.zeroes(__u32),
    family: __u16 = @import("std").mem.zeroes(__u16),
    ext: __u16 = @import("std").mem.zeroes(__u16),
    unnamed_0: union_unnamed_193 = @import("std").mem.zeroes(union_unnamed_193),
};
pub const BPF_OK: c_int = 0;
pub const BPF_DROP: c_int = 2;
pub const BPF_REDIRECT: c_int = 7;
pub const BPF_LWT_REROUTE: c_int = 128;
pub const BPF_FLOW_DISSECTOR_CONTINUE: c_int = 129;
pub const enum_bpf_ret_code = c_uint;
pub const struct_bpf_tcp_sock = extern struct {
    snd_cwnd: __u32 = @import("std").mem.zeroes(__u32),
    srtt_us: __u32 = @import("std").mem.zeroes(__u32),
    rtt_min: __u32 = @import("std").mem.zeroes(__u32),
    snd_ssthresh: __u32 = @import("std").mem.zeroes(__u32),
    rcv_nxt: __u32 = @import("std").mem.zeroes(__u32),
    snd_nxt: __u32 = @import("std").mem.zeroes(__u32),
    snd_una: __u32 = @import("std").mem.zeroes(__u32),
    mss_cache: __u32 = @import("std").mem.zeroes(__u32),
    ecn_flags: __u32 = @import("std").mem.zeroes(__u32),
    rate_delivered: __u32 = @import("std").mem.zeroes(__u32),
    rate_interval_us: __u32 = @import("std").mem.zeroes(__u32),
    packets_out: __u32 = @import("std").mem.zeroes(__u32),
    retrans_out: __u32 = @import("std").mem.zeroes(__u32),
    total_retrans: __u32 = @import("std").mem.zeroes(__u32),
    segs_in: __u32 = @import("std").mem.zeroes(__u32),
    data_segs_in: __u32 = @import("std").mem.zeroes(__u32),
    segs_out: __u32 = @import("std").mem.zeroes(__u32),
    data_segs_out: __u32 = @import("std").mem.zeroes(__u32),
    lost_out: __u32 = @import("std").mem.zeroes(__u32),
    sacked_out: __u32 = @import("std").mem.zeroes(__u32),
    bytes_received: __u64 = @import("std").mem.zeroes(__u64),
    bytes_acked: __u64 = @import("std").mem.zeroes(__u64),
    dsack_dups: __u32 = @import("std").mem.zeroes(__u32),
    delivered: __u32 = @import("std").mem.zeroes(__u32),
    delivered_ce: __u32 = @import("std").mem.zeroes(__u32),
    icsk_retransmits: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_195 = extern struct {
    saddr: __be32 = @import("std").mem.zeroes(__be32),
    daddr: __be32 = @import("std").mem.zeroes(__be32),
    sport: __be16 = @import("std").mem.zeroes(__be16),
    dport: __be16 = @import("std").mem.zeroes(__be16),
};
const struct_unnamed_196 = extern struct {
    saddr: [4]__be32 = @import("std").mem.zeroes([4]__be32),
    daddr: [4]__be32 = @import("std").mem.zeroes([4]__be32),
    sport: __be16 = @import("std").mem.zeroes(__be16),
    dport: __be16 = @import("std").mem.zeroes(__be16),
};
const union_unnamed_194 = extern union {
    ipv4: struct_unnamed_195,
    ipv6: struct_unnamed_196,
};
pub const struct_bpf_sock_tuple = extern struct {
    unnamed_0: union_unnamed_194 = @import("std").mem.zeroes(union_unnamed_194),
};
pub const TCX_NEXT: c_int = -1;
pub const TCX_PASS: c_int = 0;
pub const TCX_DROP: c_int = 2;
pub const TCX_REDIRECT: c_int = 7;
pub const enum_tcx_action_base = c_int;
pub const struct_bpf_xdp_sock = extern struct {
    queue_id: __u32 = @import("std").mem.zeroes(__u32),
};
pub const XDP_ABORTED: c_int = 0;
pub const XDP_DROP: c_int = 1;
pub const XDP_PASS: c_int = 2;
pub const XDP_TX: c_int = 3;
pub const XDP_REDIRECT: c_int = 4;
pub const enum_xdp_action = c_uint;
pub const struct_xdp_md = extern struct {
    data: __u32 = @import("std").mem.zeroes(__u32),
    data_end: __u32 = @import("std").mem.zeroes(__u32),
    data_meta: __u32 = @import("std").mem.zeroes(__u32),
    ingress_ifindex: __u32 = @import("std").mem.zeroes(__u32),
    rx_queue_index: __u32 = @import("std").mem.zeroes(__u32),
    egress_ifindex: __u32 = @import("std").mem.zeroes(__u32),
};
const union_unnamed_197 = extern union {
    fd: c_int,
    id: __u32,
};
pub const struct_bpf_devmap_val = extern struct {
    ifindex: __u32 = @import("std").mem.zeroes(__u32),
    bpf_prog: union_unnamed_197 = @import("std").mem.zeroes(union_unnamed_197),
};
const union_unnamed_198 = extern union {
    fd: c_int,
    id: __u32,
};
pub const struct_bpf_cpumap_val = extern struct {
    qsize: __u32 = @import("std").mem.zeroes(__u32),
    bpf_prog: union_unnamed_198 = @import("std").mem.zeroes(union_unnamed_198),
};
pub const SK_DROP: c_int = 0;
pub const SK_PASS: c_int = 1;
pub const enum_sk_action = c_uint;
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_199 = opaque {};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_200 = opaque {};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_201 = opaque {};
pub const struct_sk_msg_md = extern struct {
    unnamed_0: union_unnamed_199 = @import("std").mem.zeroes(union_unnamed_199),
    unnamed_1: union_unnamed_200 = @import("std").mem.zeroes(union_unnamed_200),
    family: __u32 = @import("std").mem.zeroes(__u32),
    remote_ip4: __u32 = @import("std").mem.zeroes(__u32),
    local_ip4: __u32 = @import("std").mem.zeroes(__u32),
    remote_ip6: [4]__u32 = @import("std").mem.zeroes([4]__u32),
    local_ip6: [4]__u32 = @import("std").mem.zeroes([4]__u32),
    remote_port: __u32 = @import("std").mem.zeroes(__u32),
    local_port: __u32 = @import("std").mem.zeroes(__u32),
    size: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_2: union_unnamed_201 = @import("std").mem.zeroes(union_unnamed_201),
};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_202 = opaque {};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_203 = opaque {};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_204 = opaque {};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_205 = opaque {};
pub const struct_sk_reuseport_md = extern struct {
    unnamed_0: union_unnamed_202 = @import("std").mem.zeroes(union_unnamed_202),
    unnamed_1: union_unnamed_203 = @import("std").mem.zeroes(union_unnamed_203),
    len: __u32 = @import("std").mem.zeroes(__u32),
    eth_protocol: __u32 = @import("std").mem.zeroes(__u32),
    ip_protocol: __u32 = @import("std").mem.zeroes(__u32),
    bind_inany: __u32 = @import("std").mem.zeroes(__u32),
    hash: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_2: union_unnamed_204 = @import("std").mem.zeroes(union_unnamed_204),
    unnamed_3: union_unnamed_205 = @import("std").mem.zeroes(union_unnamed_205),
};
// /usr/include/linux/bpf.h:6558:8: warning: struct demoted to opaque type - has bitfield
pub const struct_bpf_prog_info = opaque {};
pub const struct_bpf_map_info = extern struct {
    type: __u32 = @import("std").mem.zeroes(__u32),
    id: __u32 = @import("std").mem.zeroes(__u32),
    key_size: __u32 = @import("std").mem.zeroes(__u32),
    value_size: __u32 = @import("std").mem.zeroes(__u32),
    max_entries: __u32 = @import("std").mem.zeroes(__u32),
    map_flags: __u32 = @import("std").mem.zeroes(__u32),
    name: [16]u8 = @import("std").mem.zeroes([16]u8),
    ifindex: __u32 = @import("std").mem.zeroes(__u32),
    btf_vmlinux_value_type_id: __u32 = @import("std").mem.zeroes(__u32),
    netns_dev: __u64 = @import("std").mem.zeroes(__u64),
    netns_ino: __u64 = @import("std").mem.zeroes(__u64),
    btf_id: __u32 = @import("std").mem.zeroes(__u32),
    btf_key_type_id: __u32 = @import("std").mem.zeroes(__u32),
    btf_value_type_id: __u32 = @import("std").mem.zeroes(__u32),
    btf_vmlinux_id: __u32 = @import("std").mem.zeroes(__u32),
    map_extra: __u64 = @import("std").mem.zeroes(__u64),
};
pub const struct_bpf_btf_info = extern struct {
    btf: __u64 align(8) = @import("std").mem.zeroes(__u64),
    btf_size: __u32 = @import("std").mem.zeroes(__u32),
    id: __u32 = @import("std").mem.zeroes(__u32),
    name: __u64 align(8) = @import("std").mem.zeroes(__u64),
    name_len: __u32 = @import("std").mem.zeroes(__u32),
    kernel_btf: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_207 = extern struct {
    tp_name: __u64 align(8) = @import("std").mem.zeroes(__u64),
    tp_name_len: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_208 = extern struct {
    attach_type: __u32 = @import("std").mem.zeroes(__u32),
    target_obj_id: __u32 = @import("std").mem.zeroes(__u32),
    target_btf_id: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_209 = extern struct {
    cgroup_id: __u64 = @import("std").mem.zeroes(__u64),
    attach_type: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_212 = extern struct {
    map_id: __u32 = @import("std").mem.zeroes(__u32),
};
const union_unnamed_211 = extern union {
    map: struct_unnamed_212,
};
const struct_unnamed_214 = extern struct {
    cgroup_id: __u64 = @import("std").mem.zeroes(__u64),
    order: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_215 = extern struct {
    tid: __u32 = @import("std").mem.zeroes(__u32),
    pid: __u32 = @import("std").mem.zeroes(__u32),
};
const union_unnamed_213 = extern union {
    cgroup: struct_unnamed_214,
    task: struct_unnamed_215,
};
const struct_unnamed_210 = extern struct {
    target_name: __u64 align(8) = @import("std").mem.zeroes(__u64),
    target_name_len: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_0: union_unnamed_211 = @import("std").mem.zeroes(union_unnamed_211),
    unnamed_1: union_unnamed_213 = @import("std").mem.zeroes(union_unnamed_213),
};
const struct_unnamed_216 = extern struct {
    netns_ino: __u32 = @import("std").mem.zeroes(__u32),
    attach_type: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_217 = extern struct {
    ifindex: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_218 = extern struct {
    map_id: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_219 = extern struct {
    pf: __u32 = @import("std").mem.zeroes(__u32),
    hooknum: __u32 = @import("std").mem.zeroes(__u32),
    priority: __s32 = @import("std").mem.zeroes(__s32),
    flags: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_220 = extern struct {
    addrs: __u64 align(8) = @import("std").mem.zeroes(__u64),
    count: __u32 = @import("std").mem.zeroes(__u32),
    flags: __u32 = @import("std").mem.zeroes(__u32),
    missed: __u64 = @import("std").mem.zeroes(__u64),
    cookies: __u64 align(8) = @import("std").mem.zeroes(__u64),
};
const struct_unnamed_221 = extern struct {
    path: __u64 align(8) = @import("std").mem.zeroes(__u64),
    offsets: __u64 align(8) = @import("std").mem.zeroes(__u64),
    ref_ctr_offsets: __u64 align(8) = @import("std").mem.zeroes(__u64),
    cookies: __u64 align(8) = @import("std").mem.zeroes(__u64),
    path_size: __u32 = @import("std").mem.zeroes(__u32),
    count: __u32 = @import("std").mem.zeroes(__u32),
    flags: __u32 = @import("std").mem.zeroes(__u32),
    pid: __u32 = @import("std").mem.zeroes(__u32),
};
// /usr/include/linux/bpf.h:6691:4: warning: struct demoted to opaque type - has bitfield
const struct_unnamed_222 = opaque {};
const struct_unnamed_223 = extern struct {
    ifindex: __u32 = @import("std").mem.zeroes(__u32),
    attach_type: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_224 = extern struct {
    ifindex: __u32 = @import("std").mem.zeroes(__u32),
    attach_type: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_225 = extern struct {
    map_id: __u32 = @import("std").mem.zeroes(__u32),
    attach_type: __u32 = @import("std").mem.zeroes(__u32),
};
const union_unnamed_206 = extern union {
    raw_tracepoint: struct_unnamed_207,
    tracing: struct_unnamed_208,
    cgroup: struct_unnamed_209,
    iter: struct_unnamed_210,
    netns: struct_unnamed_216,
    xdp: struct_unnamed_217,
    struct_ops: struct_unnamed_218,
    netfilter: struct_unnamed_219,
    kprobe_multi: struct_unnamed_220,
    uprobe_multi: struct_unnamed_221,
    perf_event: struct_unnamed_222,
    tcx: struct_unnamed_223,
    netkit: struct_unnamed_224,
    sockmap: struct_unnamed_225,
};
pub const struct_bpf_link_info = extern struct {
    type: __u32 = @import("std").mem.zeroes(__u32),
    id: __u32 = @import("std").mem.zeroes(__u32),
    prog_id: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_0: union_unnamed_206 = @import("std").mem.zeroes(union_unnamed_206),
};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_226 = opaque {};
pub const struct_bpf_sock_addr = extern struct {
    user_family: __u32 = @import("std").mem.zeroes(__u32),
    user_ip4: __u32 = @import("std").mem.zeroes(__u32),
    user_ip6: [4]__u32 = @import("std").mem.zeroes([4]__u32),
    user_port: __u32 = @import("std").mem.zeroes(__u32),
    family: __u32 = @import("std").mem.zeroes(__u32),
    type: __u32 = @import("std").mem.zeroes(__u32),
    protocol: __u32 = @import("std").mem.zeroes(__u32),
    msg_src_ip4: __u32 = @import("std").mem.zeroes(__u32),
    msg_src_ip6: [4]__u32 = @import("std").mem.zeroes([4]__u32),
    unnamed_0: union_unnamed_226 = @import("std").mem.zeroes(union_unnamed_226),
};
const union_unnamed_227 = extern union {
    args: [4]__u32,
    reply: __u32,
    replylong: [4]__u32,
};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_228 = opaque {};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_229 = opaque {};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_230 = opaque {};
pub const struct_bpf_sock_ops = extern struct {
    op: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_0: union_unnamed_227 = @import("std").mem.zeroes(union_unnamed_227),
    family: __u32 = @import("std").mem.zeroes(__u32),
    remote_ip4: __u32 = @import("std").mem.zeroes(__u32),
    local_ip4: __u32 = @import("std").mem.zeroes(__u32),
    remote_ip6: [4]__u32 = @import("std").mem.zeroes([4]__u32),
    local_ip6: [4]__u32 = @import("std").mem.zeroes([4]__u32),
    remote_port: __u32 = @import("std").mem.zeroes(__u32),
    local_port: __u32 = @import("std").mem.zeroes(__u32),
    is_fullsock: __u32 = @import("std").mem.zeroes(__u32),
    snd_cwnd: __u32 = @import("std").mem.zeroes(__u32),
    srtt_us: __u32 = @import("std").mem.zeroes(__u32),
    bpf_sock_ops_cb_flags: __u32 = @import("std").mem.zeroes(__u32),
    state: __u32 = @import("std").mem.zeroes(__u32),
    rtt_min: __u32 = @import("std").mem.zeroes(__u32),
    snd_ssthresh: __u32 = @import("std").mem.zeroes(__u32),
    rcv_nxt: __u32 = @import("std").mem.zeroes(__u32),
    snd_nxt: __u32 = @import("std").mem.zeroes(__u32),
    snd_una: __u32 = @import("std").mem.zeroes(__u32),
    mss_cache: __u32 = @import("std").mem.zeroes(__u32),
    ecn_flags: __u32 = @import("std").mem.zeroes(__u32),
    rate_delivered: __u32 = @import("std").mem.zeroes(__u32),
    rate_interval_us: __u32 = @import("std").mem.zeroes(__u32),
    packets_out: __u32 = @import("std").mem.zeroes(__u32),
    retrans_out: __u32 = @import("std").mem.zeroes(__u32),
    total_retrans: __u32 = @import("std").mem.zeroes(__u32),
    segs_in: __u32 = @import("std").mem.zeroes(__u32),
    data_segs_in: __u32 = @import("std").mem.zeroes(__u32),
    segs_out: __u32 = @import("std").mem.zeroes(__u32),
    data_segs_out: __u32 = @import("std").mem.zeroes(__u32),
    lost_out: __u32 = @import("std").mem.zeroes(__u32),
    sacked_out: __u32 = @import("std").mem.zeroes(__u32),
    sk_txhash: __u32 = @import("std").mem.zeroes(__u32),
    bytes_received: __u64 = @import("std").mem.zeroes(__u64),
    bytes_acked: __u64 = @import("std").mem.zeroes(__u64),
    unnamed_1: union_unnamed_228 = @import("std").mem.zeroes(union_unnamed_228),
    unnamed_2: union_unnamed_229 = @import("std").mem.zeroes(union_unnamed_229),
    unnamed_3: union_unnamed_230 = @import("std").mem.zeroes(union_unnamed_230),
    skb_len: __u32 = @import("std").mem.zeroes(__u32),
    skb_tcp_flags: __u32 = @import("std").mem.zeroes(__u32),
    skb_hwtstamp: __u64 = @import("std").mem.zeroes(__u64),
};
pub const BPF_SOCK_OPS_RTO_CB_FLAG: c_int = 1;
pub const BPF_SOCK_OPS_RETRANS_CB_FLAG: c_int = 2;
pub const BPF_SOCK_OPS_STATE_CB_FLAG: c_int = 4;
pub const BPF_SOCK_OPS_RTT_CB_FLAG: c_int = 8;
pub const BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG: c_int = 16;
pub const BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG: c_int = 32;
pub const BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG: c_int = 64;
pub const BPF_SOCK_OPS_ALL_CB_FLAGS: c_int = 127;
const enum_unnamed_231 = c_uint;
pub const BPF_SOCK_OPS_VOID: c_int = 0;
pub const BPF_SOCK_OPS_TIMEOUT_INIT: c_int = 1;
pub const BPF_SOCK_OPS_RWND_INIT: c_int = 2;
pub const BPF_SOCK_OPS_TCP_CONNECT_CB: c_int = 3;
pub const BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB: c_int = 4;
pub const BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB: c_int = 5;
pub const BPF_SOCK_OPS_NEEDS_ECN: c_int = 6;
pub const BPF_SOCK_OPS_BASE_RTT: c_int = 7;
pub const BPF_SOCK_OPS_RTO_CB: c_int = 8;
pub const BPF_SOCK_OPS_RETRANS_CB: c_int = 9;
pub const BPF_SOCK_OPS_STATE_CB: c_int = 10;
pub const BPF_SOCK_OPS_TCP_LISTEN_CB: c_int = 11;
pub const BPF_SOCK_OPS_RTT_CB: c_int = 12;
pub const BPF_SOCK_OPS_PARSE_HDR_OPT_CB: c_int = 13;
pub const BPF_SOCK_OPS_HDR_OPT_LEN_CB: c_int = 14;
pub const BPF_SOCK_OPS_WRITE_HDR_OPT_CB: c_int = 15;
const enum_unnamed_232 = c_uint;
pub const BPF_TCP_ESTABLISHED: c_int = 1;
pub const BPF_TCP_SYN_SENT: c_int = 2;
pub const BPF_TCP_SYN_RECV: c_int = 3;
pub const BPF_TCP_FIN_WAIT1: c_int = 4;
pub const BPF_TCP_FIN_WAIT2: c_int = 5;
pub const BPF_TCP_TIME_WAIT: c_int = 6;
pub const BPF_TCP_CLOSE: c_int = 7;
pub const BPF_TCP_CLOSE_WAIT: c_int = 8;
pub const BPF_TCP_LAST_ACK: c_int = 9;
pub const BPF_TCP_LISTEN: c_int = 10;
pub const BPF_TCP_CLOSING: c_int = 11;
pub const BPF_TCP_NEW_SYN_RECV: c_int = 12;
pub const BPF_TCP_BOUND_INACTIVE: c_int = 13;
pub const BPF_TCP_MAX_STATES: c_int = 14;
const enum_unnamed_233 = c_uint;
pub const TCP_BPF_IW: c_int = 1001;
pub const TCP_BPF_SNDCWND_CLAMP: c_int = 1002;
pub const TCP_BPF_DELACK_MAX: c_int = 1003;
pub const TCP_BPF_RTO_MIN: c_int = 1004;
pub const TCP_BPF_SYN: c_int = 1005;
pub const TCP_BPF_SYN_IP: c_int = 1006;
pub const TCP_BPF_SYN_MAC: c_int = 1007;
const enum_unnamed_234 = c_uint;
pub const BPF_LOAD_HDR_OPT_TCP_SYN: c_int = 1;
const enum_unnamed_235 = c_uint;
pub const BPF_WRITE_HDR_TCP_CURRENT_MSS: c_int = 1;
pub const BPF_WRITE_HDR_TCP_SYNACK_COOKIE: c_int = 2;
const enum_unnamed_236 = c_uint;
pub const struct_bpf_perf_event_value = extern struct {
    counter: __u64 = @import("std").mem.zeroes(__u64),
    enabled: __u64 = @import("std").mem.zeroes(__u64),
    running: __u64 = @import("std").mem.zeroes(__u64),
};
pub const BPF_DEVCG_ACC_MKNOD: c_int = 1;
pub const BPF_DEVCG_ACC_READ: c_int = 2;
pub const BPF_DEVCG_ACC_WRITE: c_int = 4;
const enum_unnamed_237 = c_uint;
pub const BPF_DEVCG_DEV_BLOCK: c_int = 1;
pub const BPF_DEVCG_DEV_CHAR: c_int = 2;
const enum_unnamed_238 = c_uint;
pub const struct_bpf_cgroup_dev_ctx = extern struct {
    access_type: __u32 = @import("std").mem.zeroes(__u32),
    major: __u32 = @import("std").mem.zeroes(__u32),
    minor: __u32 = @import("std").mem.zeroes(__u32),
};
pub const struct_bpf_raw_tracepoint_args = extern struct {
    pub fn args(self: anytype) @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), c_ulonglong) {
        const Intermediate = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), u8);
        const ReturnType = @import("std").zig.c_translation.FlexibleArrayType(@TypeOf(self), c_ulonglong);
        return @as(ReturnType, @ptrCast(@alignCast(@as(Intermediate, @ptrCast(self)) + 0)));
    }
};
pub const BPF_FIB_LOOKUP_DIRECT: c_int = 1;
pub const BPF_FIB_LOOKUP_OUTPUT: c_int = 2;
pub const BPF_FIB_LOOKUP_SKIP_NEIGH: c_int = 4;
pub const BPF_FIB_LOOKUP_TBID: c_int = 8;
pub const BPF_FIB_LOOKUP_SRC: c_int = 16;
pub const BPF_FIB_LOOKUP_MARK: c_int = 32;
const enum_unnamed_239 = c_uint;
pub const BPF_FIB_LKUP_RET_SUCCESS: c_int = 0;
pub const BPF_FIB_LKUP_RET_BLACKHOLE: c_int = 1;
pub const BPF_FIB_LKUP_RET_UNREACHABLE: c_int = 2;
pub const BPF_FIB_LKUP_RET_PROHIBIT: c_int = 3;
pub const BPF_FIB_LKUP_RET_NOT_FWDED: c_int = 4;
pub const BPF_FIB_LKUP_RET_FWD_DISABLED: c_int = 5;
pub const BPF_FIB_LKUP_RET_UNSUPP_LWT: c_int = 6;
pub const BPF_FIB_LKUP_RET_NO_NEIGH: c_int = 7;
pub const BPF_FIB_LKUP_RET_FRAG_NEEDED: c_int = 8;
pub const BPF_FIB_LKUP_RET_NO_SRC_ADDR: c_int = 9;
const enum_unnamed_240 = c_uint;
const union_unnamed_241 = extern union {
    tot_len: __u16 align(1),
    mtu_result: __u16 align(1),
};
const union_unnamed_242 = extern union {
    tos: __u8,
    flowinfo: __be32,
    rt_metric: __u32,
};
const union_unnamed_243 = extern union {
    ipv4_src: __be32,
    ipv6_src: [4]__u32,
};
const union_unnamed_244 = extern union {
    ipv4_dst: __be32,
    ipv6_dst: [4]__u32,
};
const struct_unnamed_246 = extern struct {
    h_vlan_proto: __be16 = @import("std").mem.zeroes(__be16),
    h_vlan_TCI: __be16 = @import("std").mem.zeroes(__be16),
};
const union_unnamed_245 = extern union {
    unnamed_0: struct_unnamed_246,
    tbid: __u32,
};
const struct_unnamed_248 = extern struct {
    mark: __u32 = @import("std").mem.zeroes(__u32),
};
const struct_unnamed_249 = extern struct {
    smac: [6]__u8 = @import("std").mem.zeroes([6]__u8),
    dmac: [6]__u8 = @import("std").mem.zeroes([6]__u8),
};
const union_unnamed_247 = extern union {
    unnamed_0: struct_unnamed_248,
    unnamed_1: struct_unnamed_249,
};
pub const struct_bpf_fib_lookup = extern struct {
    family: __u8 = @import("std").mem.zeroes(__u8),
    l4_protocol: __u8 = @import("std").mem.zeroes(__u8),
    sport: __be16 = @import("std").mem.zeroes(__be16),
    dport: __be16 = @import("std").mem.zeroes(__be16),
    unnamed_0: union_unnamed_241 = @import("std").mem.zeroes(union_unnamed_241),
    ifindex: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_1: union_unnamed_242 = @import("std").mem.zeroes(union_unnamed_242),
    unnamed_2: union_unnamed_243 = @import("std").mem.zeroes(union_unnamed_243),
    unnamed_3: union_unnamed_244 = @import("std").mem.zeroes(union_unnamed_244),
    unnamed_4: union_unnamed_245 = @import("std").mem.zeroes(union_unnamed_245),
    unnamed_5: union_unnamed_247 = @import("std").mem.zeroes(union_unnamed_247),
};
const union_unnamed_250 = extern union {
    ipv4_nh: __be32,
    ipv6_nh: [4]__u32,
};
pub const struct_bpf_redir_neigh = extern struct {
    nh_family: __u32 = @import("std").mem.zeroes(__u32),
    unnamed_0: union_unnamed_250 = @import("std").mem.zeroes(union_unnamed_250),
};
pub const BPF_MTU_CHK_SEGS: c_int = 1;
pub const enum_bpf_check_mtu_flags = c_uint;
pub const BPF_MTU_CHK_RET_SUCCESS: c_int = 0;
pub const BPF_MTU_CHK_RET_FRAG_NEEDED: c_int = 1;
pub const BPF_MTU_CHK_RET_SEGS_TOOBIG: c_int = 2;
pub const enum_bpf_check_mtu_ret = c_uint;
pub const BPF_FD_TYPE_RAW_TRACEPOINT: c_int = 0;
pub const BPF_FD_TYPE_TRACEPOINT: c_int = 1;
pub const BPF_FD_TYPE_KPROBE: c_int = 2;
pub const BPF_FD_TYPE_KRETPROBE: c_int = 3;
pub const BPF_FD_TYPE_UPROBE: c_int = 4;
pub const BPF_FD_TYPE_URETPROBE: c_int = 5;
pub const enum_bpf_task_fd_type = c_uint;
pub const BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG: c_int = 1;
pub const BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL: c_int = 2;
pub const BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP: c_int = 4;
const enum_unnamed_251 = c_uint;
pub const struct_bpf_func_info = extern struct {
    insn_off: __u32 = @import("std").mem.zeroes(__u32),
    type_id: __u32 = @import("std").mem.zeroes(__u32),
};
pub const struct_bpf_line_info = extern struct {
    insn_off: __u32 = @import("std").mem.zeroes(__u32),
    file_name_off: __u32 = @import("std").mem.zeroes(__u32),
    line_off: __u32 = @import("std").mem.zeroes(__u32),
    line_col: __u32 = @import("std").mem.zeroes(__u32),
};
pub const struct_bpf_spin_lock = extern struct {
    val: __u32 = @import("std").mem.zeroes(__u32),
};
pub const struct_bpf_timer = extern struct {
    __opaque: [2]__u64 = @import("std").mem.zeroes([2]__u64),
};
pub const struct_bpf_wq = extern struct {
    __opaque: [2]__u64 = @import("std").mem.zeroes([2]__u64),
};
pub const struct_bpf_dynptr = extern struct {
    __opaque: [2]__u64 = @import("std").mem.zeroes([2]__u64),
};
pub const struct_bpf_list_head = extern struct {
    __opaque: [2]__u64 = @import("std").mem.zeroes([2]__u64),
};
pub const struct_bpf_list_node = extern struct {
    __opaque: [3]__u64 = @import("std").mem.zeroes([3]__u64),
};
pub const struct_bpf_rb_root = extern struct {
    __opaque: [2]__u64 = @import("std").mem.zeroes([2]__u64),
};
pub const struct_bpf_rb_node = extern struct {
    __opaque: [4]__u64 = @import("std").mem.zeroes([4]__u64),
};
pub const struct_bpf_refcount = extern struct {
    __opaque: [1]__u32 = @import("std").mem.zeroes([1]__u32),
};
pub const struct_bpf_sysctl = extern struct {
    write: __u32 = @import("std").mem.zeroes(__u32),
    file_pos: __u32 = @import("std").mem.zeroes(__u32),
};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_252 = opaque {};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_253 = opaque {};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_254 = opaque {};
pub const struct_bpf_sockopt = extern struct {
    unnamed_0: union_unnamed_252 = @import("std").mem.zeroes(union_unnamed_252),
    unnamed_1: union_unnamed_253 = @import("std").mem.zeroes(union_unnamed_253),
    unnamed_2: union_unnamed_254 = @import("std").mem.zeroes(union_unnamed_254),
    level: __s32 = @import("std").mem.zeroes(__s32),
    optname: __s32 = @import("std").mem.zeroes(__s32),
    optlen: __s32 = @import("std").mem.zeroes(__s32),
    retval: __s32 = @import("std").mem.zeroes(__s32),
};
pub const struct_bpf_pidns_info = extern struct {
    pid: __u32 = @import("std").mem.zeroes(__u32),
    tgid: __u32 = @import("std").mem.zeroes(__u32),
};
// /usr/include/linux/bpf.h:6207:2: warning: union demoted to opaque type - has bitfield
const union_unnamed_256 = opaque {};
const union_unnamed_255 = extern union {
    unnamed_0: union_unnamed_256,
    cookie: __u64,
};
// /usr/include/linux/bpf.h:7377:2: warning: struct demoted to opaque type - has bitfield
pub const struct_bpf_sk_lookup = opaque {};
pub const struct_btf_ptr = extern struct {
    ptr: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    type_id: __u32 = @import("std").mem.zeroes(__u32),
    flags: __u32 = @import("std").mem.zeroes(__u32),
};
pub const BTF_F_COMPACT: c_int = 1;
pub const BTF_F_NONAME: c_int = 2;
pub const BTF_F_PTR_RAW: c_int = 4;
pub const BTF_F_ZERO: c_int = 8;
const enum_unnamed_257 = c_uint;
pub const BPF_CORE_FIELD_BYTE_OFFSET: c_int = 0;
pub const BPF_CORE_FIELD_BYTE_SIZE: c_int = 1;
pub const BPF_CORE_FIELD_EXISTS: c_int = 2;
pub const BPF_CORE_FIELD_SIGNED: c_int = 3;
pub const BPF_CORE_FIELD_LSHIFT_U64: c_int = 4;
pub const BPF_CORE_FIELD_RSHIFT_U64: c_int = 5;
pub const BPF_CORE_TYPE_ID_LOCAL: c_int = 6;
pub const BPF_CORE_TYPE_ID_TARGET: c_int = 7;
pub const BPF_CORE_TYPE_EXISTS: c_int = 8;
pub const BPF_CORE_TYPE_SIZE: c_int = 9;
pub const BPF_CORE_ENUMVAL_EXISTS: c_int = 10;
pub const BPF_CORE_ENUMVAL_VALUE: c_int = 11;
pub const BPF_CORE_TYPE_MATCHES: c_int = 12;
pub const enum_bpf_core_relo_kind = c_uint;
pub const struct_bpf_core_relo = extern struct {
    insn_off: __u32 = @import("std").mem.zeroes(__u32),
    type_id: __u32 = @import("std").mem.zeroes(__u32),
    access_str_off: __u32 = @import("std").mem.zeroes(__u32),
    kind: enum_bpf_core_relo_kind = @import("std").mem.zeroes(enum_bpf_core_relo_kind),
};
pub const BPF_F_TIMER_ABS: c_int = 1;
pub const BPF_F_TIMER_CPU_PIN: c_int = 2;
const enum_unnamed_258 = c_uint;
pub const struct_bpf_iter_num = extern struct {
    __opaque: [1]__u64 = @import("std").mem.zeroes([1]__u64),
};
pub const ngx_bpf_reloc_t = extern struct {
    name: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    offset: c_int = @import("std").mem.zeroes(c_int),
};
pub const ngx_bpf_program_t = extern struct {
    license: [*c]u8 = @import("std").mem.zeroes([*c]u8),
    type: enum_bpf_prog_type = @import("std").mem.zeroes(enum_bpf_prog_type),
    ins: ?*struct_bpf_insn = @import("std").mem.zeroes(?*struct_bpf_insn),
    nins: usize = @import("std").mem.zeroes(usize),
    relocs: [*c]ngx_bpf_reloc_t = @import("std").mem.zeroes([*c]ngx_bpf_reloc_t),
    nrelocs: usize = @import("std").mem.zeroes(usize),
};
pub extern fn ngx_bpf_program_link(program: [*c]ngx_bpf_program_t, symbol: [*c]const u8, fd: c_int) void;
pub extern fn ngx_bpf_load_program(log: [*c]ngx_log_t, program: [*c]ngx_bpf_program_t) c_int;
pub extern fn ngx_bpf_map_create(log: [*c]ngx_log_t, @"type": enum_bpf_map_type, key_size: c_int, value_size: c_int, max_entries: c_int, map_flags: u32) c_int;
pub extern fn ngx_bpf_map_update(fd: c_int, key: ?*const anyopaque, value: ?*const anyopaque, flags: u64) c_int;
pub extern fn ngx_bpf_map_delete(fd: c_int, key: ?*const anyopaque) c_int;
pub extern fn ngx_bpf_map_lookup(fd: c_int, key: ?*const anyopaque, value: ?*anyopaque) c_int;
pub extern fn ngx_cpuinfo() void;
pub const ngx_http_request_t = struct_ngx_http_request_s;
pub const ngx_http_event_handler_pt = ?*const fn ([*c]ngx_http_request_t) callconv(.c) void;
pub const struct_ngx_http_file_cache_s = extern struct {
    sh: [*c]ngx_http_file_cache_sh_t = @import("std").mem.zeroes([*c]ngx_http_file_cache_sh_t),
    shpool: [*c]ngx_slab_pool_t = @import("std").mem.zeroes([*c]ngx_slab_pool_t),
    path: [*c]ngx_path_t = @import("std").mem.zeroes([*c]ngx_path_t),
    min_free: off_t = @import("std").mem.zeroes(off_t),
    max_size: off_t = @import("std").mem.zeroes(off_t),
    bsize: usize = @import("std").mem.zeroes(usize),
    inactive: time_t = @import("std").mem.zeroes(time_t),
    fail_time: time_t = @import("std").mem.zeroes(time_t),
    files: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    loader_files: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    last: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    loader_sleep: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    loader_threshold: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    manager_files: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    manager_sleep: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    manager_threshold: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    shm_zone: [*c]ngx_shm_zone_t = @import("std").mem.zeroes([*c]ngx_shm_zone_t),
    use_temp_path: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_http_file_cache_t = struct_ngx_http_file_cache_s;
const struct_ngx_http_cache_flags_s = packed struct {
    lock: bool,
    waiting: bool,
    updated: bool,
    updating: bool,
    exists: bool,
    temp_file: bool,
    purged: bool,
    reading: bool,
    secondary: bool,
    update_variant: bool,
    background: bool,
    stale_updating: bool,
    stale_error: bool,
    padding: u19,
};
pub const struct_ngx_http_cache_s = extern struct {
    file: ngx_file_t = @import("std").mem.zeroes(ngx_file_t),
    keys: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    crc32: u32 = @import("std").mem.zeroes(u32),
    key: [16]u_char = @import("std").mem.zeroes([16]u_char),
    main: [16]u_char = @import("std").mem.zeroes([16]u_char),
    uniq: ngx_file_uniq_t = @import("std").mem.zeroes(ngx_file_uniq_t),
    valid_sec: time_t = @import("std").mem.zeroes(time_t),
    updating_sec: time_t = @import("std").mem.zeroes(time_t),
    error_sec: time_t = @import("std").mem.zeroes(time_t),
    last_modified: time_t = @import("std").mem.zeroes(time_t),
    date: time_t = @import("std").mem.zeroes(time_t),
    etag: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    vary: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    variant: [16]u_char = @import("std").mem.zeroes([16]u_char),
    buffer_size: usize = @import("std").mem.zeroes(usize),
    header_start: usize = @import("std").mem.zeroes(usize),
    body_start: usize = @import("std").mem.zeroes(usize),
    length: off_t = @import("std").mem.zeroes(off_t),
    fs_size: off_t = @import("std").mem.zeroes(off_t),
    min_uses: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    @"error": ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    valid_msec: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    vary_tag: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    buf: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    file_cache: [*c]ngx_http_file_cache_t = @import("std").mem.zeroes([*c]ngx_http_file_cache_t),
    node: [*c]ngx_http_file_cache_node_t = @import("std").mem.zeroes([*c]ngx_http_file_cache_node_t),
    lock_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    lock_age: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    lock_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    wait_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    wait_event: ngx_event_t = @import("std").mem.zeroes(ngx_event_t),
    flags: struct_ngx_http_cache_flags_s = @import("std").mem.zeroes(struct_ngx_http_cache_flags_s),
};
pub const ngx_http_cache_t = struct_ngx_http_cache_s;
pub const ngx_http_upstream_handler_pt = ?*const fn ([*c]ngx_http_request_t, [*c]ngx_http_upstream_t) callconv(.c) void;
pub const ngx_event_get_peer_pt = ?*const fn ([*c]ngx_peer_connection_t, ?*anyopaque) callconv(.c) ngx_int_t;
pub const ngx_event_free_peer_pt = ?*const fn ([*c]ngx_peer_connection_t, ?*anyopaque, ngx_uint_t) callconv(.c) void;
pub const ngx_event_notify_peer_pt = ?*const fn ([*c]ngx_peer_connection_t, ?*anyopaque, ngx_uint_t) callconv(.c) void;
pub const ngx_event_set_peer_session_pt = ?*const fn ([*c]ngx_peer_connection_t, ?*anyopaque) callconv(.c) ngx_int_t;
pub const ngx_event_save_peer_session_pt = ?*const fn ([*c]ngx_peer_connection_t, ?*anyopaque) callconv(.c) void;
const struct_ngx_peer_connection_flags_s = packed struct {
    cached: bool,
    transparent: bool,
    so_keepalive: bool,
    down: bool,
    log_error: u2,
    padding: u26,
};
pub const struct_ngx_peer_connection_s = extern struct {
    connection: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    sockaddr: [*c]struct_sockaddr = @import("std").mem.zeroes([*c]struct_sockaddr),
    socklen: socklen_t = @import("std").mem.zeroes(socklen_t),
    name: [*c]ngx_str_t = @import("std").mem.zeroes([*c]ngx_str_t),
    tries: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    start_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    get: ngx_event_get_peer_pt = @import("std").mem.zeroes(ngx_event_get_peer_pt),
    free: ngx_event_free_peer_pt = @import("std").mem.zeroes(ngx_event_free_peer_pt),
    notify: ngx_event_notify_peer_pt = @import("std").mem.zeroes(ngx_event_notify_peer_pt),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    set_session: ngx_event_set_peer_session_pt = @import("std").mem.zeroes(ngx_event_set_peer_session_pt),
    save_session: ngx_event_save_peer_session_pt = @import("std").mem.zeroes(ngx_event_save_peer_session_pt),
    local: [*c]ngx_addr_t = @import("std").mem.zeroes([*c]ngx_addr_t),
    type: c_int = @import("std").mem.zeroes(c_int),
    rcvbuf: c_int = @import("std").mem.zeroes(c_int),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    flags: struct_ngx_peer_connection_flags_s = @import("std").mem.zeroes(struct_ngx_peer_connection_flags_s),
};
pub const ngx_peer_connection_t = struct_ngx_peer_connection_s;
pub const ngx_event_pipe_input_filter_pt = ?*const fn ([*c]ngx_event_pipe_t, [*c]ngx_buf_t) callconv(.c) ngx_int_t;
pub const ngx_event_pipe_output_filter_pt = ?*const fn (?*anyopaque, [*c]ngx_chain_t) callconv(.c) ngx_int_t;
const struct_ngx_event_pipe_flags_s = packed struct {
    read: bool,
    cacheable: bool,
    single_buf: bool,
    free_bufs: bool,
    upstream_done: bool,
    upstream_error: bool,
    upstream_eof: bool,
    upstream_blocked: bool,
    downstream_done: bool,
    downstream_error: bool,
    cyclic_temp_file: bool,
    aio: bool,
    padding: u20,
};
pub const struct_ngx_event_pipe_s = extern struct {
    upstream: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    downstream: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    free_raw_bufs: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    in: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    last_in: [*c][*c]ngx_chain_t = @import("std").mem.zeroes([*c][*c]ngx_chain_t),
    writing: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    out: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    free: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    busy: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    input_filter: ngx_event_pipe_input_filter_pt = @import("std").mem.zeroes(ngx_event_pipe_input_filter_pt),
    input_ctx: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    output_filter: ngx_event_pipe_output_filter_pt = @import("std").mem.zeroes(ngx_event_pipe_output_filter_pt),
    output_ctx: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    flags: struct_ngx_event_pipe_flags_s = @import("std").mem.zeroes(struct_ngx_event_pipe_flags_s),
    allocated: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    bufs: ngx_bufs_t = @import("std").mem.zeroes(ngx_bufs_t),
    tag: ngx_buf_tag_t = @import("std").mem.zeroes(ngx_buf_tag_t),
    busy_size: isize = @import("std").mem.zeroes(isize),
    read_length: off_t = @import("std").mem.zeroes(off_t),
    length: off_t = @import("std").mem.zeroes(off_t),
    max_temp_file_size: off_t = @import("std").mem.zeroes(off_t),
    temp_file_write_size: isize = @import("std").mem.zeroes(isize),
    read_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    send_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    send_lowat: isize = @import("std").mem.zeroes(isize),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    preread_bufs: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    preread_size: usize = @import("std").mem.zeroes(usize),
    buf_to_file: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    limit_rate: usize = @import("std").mem.zeroes(usize),
    start_sec: time_t = @import("std").mem.zeroes(time_t),
    temp_file: [*c]ngx_temp_file_t = @import("std").mem.zeroes([*c]ngx_temp_file_t),
    num: c_int = @import("std").mem.zeroes(c_int),
};
pub const ngx_event_pipe_t = struct_ngx_event_pipe_s;
pub const struct_ngx_http_upstream_srv_conf_s = extern struct {
    peer: ngx_http_upstream_peer_t = @import("std").mem.zeroes(ngx_http_upstream_peer_t),
    srv_conf: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
    servers: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    flags: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    host: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    file_name: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    line: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    port: in_port_t = @import("std").mem.zeroes(in_port_t),
    no_port: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    shm_zone: [*c]ngx_shm_zone_t = @import("std").mem.zeroes([*c]ngx_shm_zone_t),
    resolver: [*c]ngx_resolver_t = @import("std").mem.zeroes([*c]ngx_resolver_t),
    resolver_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
};
pub const ngx_http_upstream_srv_conf_t = struct_ngx_http_upstream_srv_conf_s;
pub const ngx_http_cleanup_pt = ?*const fn (?*anyopaque) callconv(.c) void;
const struct_ngx_http_upstream_flags_s = packed struct {
    store: bool,
    cacheable: bool,
    accel: bool,
    ssl: bool,
    cache_status: u3,
    buffering: bool,
    keepalive: bool,
    upgrade: bool,
    @"error": bool,
    request_sent: bool,
    request_body_sent: bool,
    request_body_blocked: bool,
    header_sent: bool,
    padding: u17,
};
pub const struct_ngx_http_upstream_s = extern struct {
    read_event_handler: ngx_http_upstream_handler_pt = @import("std").mem.zeroes(ngx_http_upstream_handler_pt),
    write_event_handler: ngx_http_upstream_handler_pt = @import("std").mem.zeroes(ngx_http_upstream_handler_pt),
    peer: ngx_peer_connection_t = @import("std").mem.zeroes(ngx_peer_connection_t),
    pipe: [*c]ngx_event_pipe_t = @import("std").mem.zeroes([*c]ngx_event_pipe_t),
    request_bufs: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    output: ngx_output_chain_ctx_t = @import("std").mem.zeroes(ngx_output_chain_ctx_t),
    writer: ngx_chain_writer_ctx_t = @import("std").mem.zeroes(ngx_chain_writer_ctx_t),
    conf: [*c]ngx_http_upstream_conf_t = @import("std").mem.zeroes([*c]ngx_http_upstream_conf_t),
    upstream: [*c]ngx_http_upstream_srv_conf_t = @import("std").mem.zeroes([*c]ngx_http_upstream_srv_conf_t),
    caches: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    headers_in: ngx_http_upstream_headers_in_t = @import("std").mem.zeroes(ngx_http_upstream_headers_in_t),
    resolved: [*c]ngx_http_upstream_resolved_t = @import("std").mem.zeroes([*c]ngx_http_upstream_resolved_t),
    from_client: ngx_buf_t = @import("std").mem.zeroes(ngx_buf_t),
    buffer: ngx_buf_t = @import("std").mem.zeroes(ngx_buf_t),
    length: off_t = @import("std").mem.zeroes(off_t),
    early_hints_length: off_t = @import("std").mem.zeroes(off_t),
    out_bufs: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    busy_bufs: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    free_bufs: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    input_filter_init: ?*const fn (?*anyopaque) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn (?*anyopaque) callconv(.c) ngx_int_t),
    input_filter: ?*const fn (?*anyopaque, isize) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn (?*anyopaque, isize) callconv(.c) ngx_int_t),
    input_filter_ctx: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    create_key: ?*const fn ([*c]ngx_http_request_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_http_request_t) callconv(.c) ngx_int_t),
    create_request: ?*const fn ([*c]ngx_http_request_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_http_request_t) callconv(.c) ngx_int_t),
    reinit_request: ?*const fn ([*c]ngx_http_request_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_http_request_t) callconv(.c) ngx_int_t),
    process_header: ?*const fn ([*c]ngx_http_request_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_http_request_t) callconv(.c) ngx_int_t),
    abort_request: ?*const fn ([*c]ngx_http_request_t) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]ngx_http_request_t) callconv(.c) void),
    finalize_request: ?*const fn ([*c]ngx_http_request_t, ngx_int_t) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]ngx_http_request_t, ngx_int_t) callconv(.c) void),
    rewrite_redirect: ?*const fn ([*c]ngx_http_request_t, [*c]ngx_table_elt_t, usize) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_http_request_t, [*c]ngx_table_elt_t, usize) callconv(.c) ngx_int_t),
    rewrite_cookie: ?*const fn ([*c]ngx_http_request_t, [*c]ngx_table_elt_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_http_request_t, [*c]ngx_table_elt_t) callconv(.c) ngx_int_t),
    start_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    state: [*c]ngx_http_upstream_state_t = @import("std").mem.zeroes([*c]ngx_http_upstream_state_t),
    method: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    schema: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    uri: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    ssl_name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    ssl_alpn_protocol: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    cleanup: [*c]ngx_http_cleanup_pt = @import("std").mem.zeroes([*c]ngx_http_cleanup_pt),
    flags: struct_ngx_http_upstream_flags_s = @import("std").mem.zeroes(struct_ngx_http_upstream_flags_s),
};
pub const ngx_http_upstream_t = struct_ngx_http_upstream_s;
pub const struct_ngx_http_postponed_request_s = extern struct {
    request: [*c]ngx_http_request_t = @import("std").mem.zeroes([*c]ngx_http_request_t),
    out: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    next: [*c]ngx_http_postponed_request_t = @import("std").mem.zeroes([*c]ngx_http_postponed_request_t),
};
pub const ngx_http_postponed_request_t = struct_ngx_http_postponed_request_s;
pub const struct_ngx_http_posted_request_s = extern struct {
    request: [*c]ngx_http_request_t = @import("std").mem.zeroes([*c]ngx_http_request_t),
    next: [*c]ngx_http_posted_request_t = @import("std").mem.zeroes([*c]ngx_http_posted_request_t),
};
pub const ngx_http_posted_request_t = struct_ngx_http_posted_request_s;
pub const ngx_http_handler_pt = ?*const fn ([*c]ngx_http_request_t) callconv(.c) ngx_int_t;
pub const ngx_http_variable_value_t = ngx_variable_value_t;
pub const struct_ngx_http_v2_stream_s = opaque {};
pub const ngx_http_v2_stream_t = struct_ngx_http_v2_stream_s;
pub const struct_ngx_http_v3_parse_s = opaque {};
pub const ngx_http_v3_parse_t = struct_ngx_http_v3_parse_s;
pub const ngx_http_log_handler_pt = ?*const fn ([*c]ngx_http_request_t, [*c]ngx_http_request_t, [*c]u_char, usize) callconv(.c) [*c]u_char;
pub const struct_ngx_http_cleanup_s = extern struct {
    handler: ngx_http_cleanup_pt = @import("std").mem.zeroes(ngx_http_cleanup_pt),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    next: [*c]ngx_http_cleanup_t = @import("std").mem.zeroes([*c]ngx_http_cleanup_t),
};
pub const ngx_http_cleanup_t = struct_ngx_http_cleanup_s;

const struct_ngx_http_request_flag0_s = packed struct {
    count: u16,
    subrequests: u8,
    blocked: u8,
    aio: bool,
    http_state: u4,
    complex_uri: bool,
    quoted_uri: bool,
    plus_in_uri: bool,
    empty_path_in_uri: bool,
    invalid_header: bool,
    add_uri_to_alias: bool,
    valid_location: bool,
    valid_unparsed_uri: bool,
    uri_changed: bool,
    uri_changes: u4,
    request_body_in_single_buf: bool,
    request_body_in_file_only: bool,
    request_body_in_persistent_file: bool,
    request_body_in_clean_file: bool,
    request_body_file_group_access: bool,
    request_body_file_log_level: u3,
    request_body_no_buffering: bool,
    subrequest_in_memory: bool,
    waited: bool,
    cached: bool,
    gzip_tested: bool,
    gzip_ok: bool,
};
const struct_ngx_http_request_flag1_s = packed struct {
    gzip_vary: bool,
    realloc_captures: bool,
    proxy: bool,
    bypass_cache: bool,
    no_cache: bool,
    limit_conn_status: u2,
    limit_req_status: u3,
    limit_rate_set: bool,
    limit_rate_after_set: bool,
    pipeline: bool,
    chunked: bool,
    header_only: bool,
    expect_trailers: bool,
    keepalive: bool,
    lingering_close: bool,
    discard_body: bool,
    reading_body: bool,
    internal: bool,
    error_page: bool,
    filter_finalize: bool,
    post_action: bool,
    request_complete: bool,
    request_output: bool,
    header_sent: bool,
    response_sent: bool,
    expect_tested: bool,
    root_tested: bool,
    done: bool,
    logged: bool,
    terminated: bool,
    buffered: u4,
    main_filter_need_in_memory: bool,
    filter_need_in_memory: bool,
    filter_need_temporary: bool,
    preserve_body: bool,
    allow_ranges: bool,
    subrequest_ranges: bool,
    single_range: bool,
    disable_not_modified: bool,
    stat_reading: bool,
    stat_writing: bool,
    stat_processing: bool,
    background: bool,
    health_check: bool,
    padding: u14,
};
const struct_ngx_http_request_flag2_s = packed struct {
    http_minor: u16,
    http_major: u16,
};
pub const struct_ngx_http_request_s = extern struct {
    signature: u32 = @import("std").mem.zeroes(u32),
    connection: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    ctx: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
    main_conf: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
    srv_conf: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
    loc_conf: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
    read_event_handler: ngx_http_event_handler_pt = @import("std").mem.zeroes(ngx_http_event_handler_pt),
    write_event_handler: ngx_http_event_handler_pt = @import("std").mem.zeroes(ngx_http_event_handler_pt),
    cache: [*c]ngx_http_cache_t = @import("std").mem.zeroes([*c]ngx_http_cache_t),
    upstream: [*c]ngx_http_upstream_t = @import("std").mem.zeroes([*c]ngx_http_upstream_t),
    upstream_states: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    pool: [*c]ngx_pool_t = @import("std").mem.zeroes([*c]ngx_pool_t),
    header_in: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    headers_in: ngx_http_headers_in_t = @import("std").mem.zeroes(ngx_http_headers_in_t),
    headers_out: ngx_http_headers_out_t = @import("std").mem.zeroes(ngx_http_headers_out_t),
    request_body: [*c]ngx_http_request_body_t = @import("std").mem.zeroes([*c]ngx_http_request_body_t),
    lingering_time: time_t = @import("std").mem.zeroes(time_t),
    start_sec: time_t = @import("std").mem.zeroes(time_t),
    start_msec: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    method: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    http_version: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    request_line: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    uri: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    args: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    exten: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    unparsed_uri: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    method_name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    http_protocol: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    schema: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    out: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    main: [*c]ngx_http_request_t = @import("std").mem.zeroes([*c]ngx_http_request_t),
    parent: [*c]ngx_http_request_t = @import("std").mem.zeroes([*c]ngx_http_request_t),
    postponed: [*c]ngx_http_postponed_request_t = @import("std").mem.zeroes([*c]ngx_http_postponed_request_t),
    post_subrequest: [*c]ngx_http_post_subrequest_t = @import("std").mem.zeroes([*c]ngx_http_post_subrequest_t),
    posted_requests: [*c]ngx_http_posted_request_t = @import("std").mem.zeroes([*c]ngx_http_posted_request_t),
    phase_handler: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    content_handler: ?*const fn ([*c]ngx_http_request_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(ngx_http_handler_pt),
    access_code: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    variables: [*c]ngx_http_variable_value_t = @import("std").mem.zeroes([*c]ngx_http_variable_value_t),
    ncaptures: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    captures: [*c]c_int = @import("std").mem.zeroes([*c]c_int),
    captures_data: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    limit_rate: usize = @import("std").mem.zeroes(usize),
    limit_rate_after: usize = @import("std").mem.zeroes(usize),
    header_size: usize = @import("std").mem.zeroes(usize),
    request_length: off_t = @import("std").mem.zeroes(off_t),
    err_status: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    http_connection: [*c]ngx_http_connection_t = @import("std").mem.zeroes([*c]ngx_http_connection_t),
    stream: ?*ngx_http_v2_stream_t = @import("std").mem.zeroes(?*ngx_http_v2_stream_t),
    v3_parse: ?*ngx_http_v3_parse_t = @import("std").mem.zeroes(?*ngx_http_v3_parse_t),
    log_handler: ngx_http_log_handler_pt = @import("std").mem.zeroes(ngx_http_log_handler_pt),
    cleanup: [*c]ngx_http_cleanup_t = @import("std").mem.zeroes([*c]ngx_http_cleanup_t),
    port: in_port_t = @import("std").mem.zeroes(in_port_t),
    flags0: struct_ngx_http_request_flag0_s = @import("std").mem.zeroes(struct_ngx_http_request_flag0_s),
    flags1: struct_ngx_http_request_flag1_s = @import("std").mem.zeroes(struct_ngx_http_request_flag1_s),
    state: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    header_hash: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    lowcase_index: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    lowcase_header: [32]u_char = @import("std").mem.zeroes([32]u_char),
    header_name_start: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    header_name_end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    header_start: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    header_end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    uri_start: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    uri_end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    uri_ext: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    args_start: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    request_start: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    request_end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    method_end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    schema_start: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    schema_end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    host_start: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    host_end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    flags2: struct_ngx_http_request_flag2_s = @import("std").mem.zeroes(struct_ngx_http_request_flag2_s),
};
pub const struct_ngx_http_log_ctx_s = extern struct {
    connection: [*c]ngx_connection_t = @import("std").mem.zeroes([*c]ngx_connection_t),
    request: [*c]ngx_http_request_t = @import("std").mem.zeroes([*c]ngx_http_request_t),
    current_request: [*c]ngx_http_request_t = @import("std").mem.zeroes([*c]ngx_http_request_t),
};
pub const ngx_http_log_ctx_t = struct_ngx_http_log_ctx_s;
pub const struct_ngx_http_chunked_s = extern struct {
    state: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    size: off_t = @import("std").mem.zeroes(off_t),
    length: off_t = @import("std").mem.zeroes(off_t),
};
pub const ngx_http_chunked_t = struct_ngx_http_chunked_s;
pub const struct_ngx_http_v3_session_s = opaque {};
pub const ngx_http_v3_session_t = struct_ngx_http_v3_session_s;
pub const ngx_http_header_handler_pt = ?*const fn ([*c]ngx_http_request_t, [*c]ngx_table_elt_t, ngx_uint_t) callconv(.c) ngx_int_t;
pub const ngx_http_set_variable_pt = ?*const fn ([*c]ngx_http_request_t, [*c]ngx_http_variable_value_t, usize) callconv(.c) void;
pub const ngx_http_get_variable_pt = ?*const fn ([*c]ngx_http_request_t, [*c]ngx_http_variable_value_t, usize) callconv(.c) ngx_int_t;
pub const struct_ngx_http_variable_s = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    set_handler: ngx_http_set_variable_pt = @import("std").mem.zeroes(ngx_http_set_variable_pt),
    get_handler: ngx_http_get_variable_pt = @import("std").mem.zeroes(ngx_http_get_variable_pt),
    data: usize = @import("std").mem.zeroes(usize),
    flags: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    index: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_http_variable_t = struct_ngx_http_variable_s;
pub extern fn ngx_http_add_variable(cf: [*c]ngx_conf_t, name: [*c]ngx_str_t, flags: ngx_uint_t) [*c]ngx_http_variable_t;
pub extern fn ngx_http_get_variable_index(cf: [*c]ngx_conf_t, name: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_http_get_indexed_variable(r: [*c]ngx_http_request_t, index: ngx_uint_t) [*c]ngx_http_variable_value_t;
pub extern fn ngx_http_get_flushed_variable(r: [*c]ngx_http_request_t, index: ngx_uint_t) [*c]ngx_http_variable_value_t;
pub extern fn ngx_http_get_variable(r: [*c]ngx_http_request_t, name: [*c]ngx_str_t, key: ngx_uint_t) [*c]ngx_http_variable_value_t;
pub extern fn ngx_http_variable_unknown_header(r: [*c]ngx_http_request_t, v: [*c]ngx_http_variable_value_t, @"var": [*c]ngx_str_t, part: [*c]ngx_list_part_t, prefix: usize) ngx_int_t;
pub const ngx_http_regex_variable_t = extern struct {
    capture: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    index: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
};
pub const ngx_http_regex_t = extern struct {
    regex: ?*ngx_regex_t = @import("std").mem.zeroes(?*ngx_regex_t),
    ncaptures: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    variables: [*c]ngx_http_regex_variable_t = @import("std").mem.zeroes([*c]ngx_http_regex_variable_t),
    nvariables: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub const ngx_http_map_regex_t = extern struct {
    regex: [*c]ngx_http_regex_t = @import("std").mem.zeroes([*c]ngx_http_regex_t),
    value: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub extern fn ngx_http_regex_compile(cf: [*c]ngx_conf_t, rc: [*c]ngx_regex_compile_t) [*c]ngx_http_regex_t;
pub extern fn ngx_http_regex_exec(r: [*c]ngx_http_request_t, re: [*c]ngx_http_regex_t, s: [*c]ngx_str_t) ngx_int_t;
pub const ngx_http_map_t = extern struct {
    hash: ngx_hash_combined_t = @import("std").mem.zeroes(ngx_hash_combined_t),
    regex: [*c]ngx_http_map_regex_t = @import("std").mem.zeroes([*c]ngx_http_map_regex_t),
    nregex: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub extern fn ngx_http_map_find(r: [*c]ngx_http_request_t, map: [*c]ngx_http_map_t, match: [*c]ngx_str_t) ?*anyopaque;
pub extern fn ngx_http_variables_add_core_vars(cf: [*c]ngx_conf_t) ngx_int_t;
pub extern fn ngx_http_variables_init_vars(cf: [*c]ngx_conf_t) ngx_int_t;
pub extern var ngx_http_variable_null_value: ngx_http_variable_value_t;
pub extern var ngx_http_variable_true_value: ngx_http_variable_value_t;
pub const ngx_http_conf_ctx_t = extern struct {
    main_conf: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
    srv_conf: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
    loc_conf: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
};
pub const ngx_http_module_t = extern struct {
    preconfiguration: ?*const fn ([*c]ngx_conf_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_conf_t) callconv(.c) ngx_int_t),
    postconfiguration: ?*const fn ([*c]ngx_conf_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_conf_t) callconv(.c) ngx_int_t),
    create_main_conf: ?*const fn ([*c]ngx_conf_t) callconv(.c) ?*anyopaque = @import("std").mem.zeroes(?*const fn ([*c]ngx_conf_t) callconv(.c) ?*anyopaque),
    init_main_conf: ?*const fn ([*c]ngx_conf_t, ?*anyopaque) callconv(.c) [*c]u8 = @import("std").mem.zeroes(?*const fn ([*c]ngx_conf_t, ?*anyopaque) callconv(.c) [*c]u8),
    create_srv_conf: ?*const fn ([*c]ngx_conf_t) callconv(.c) ?*anyopaque = @import("std").mem.zeroes(?*const fn ([*c]ngx_conf_t) callconv(.c) ?*anyopaque),
    merge_srv_conf: ?*const fn ([*c]ngx_conf_t, ?*anyopaque, ?*anyopaque) callconv(.c) [*c]u8 = @import("std").mem.zeroes(?*const fn ([*c]ngx_conf_t, ?*anyopaque, ?*anyopaque) callconv(.c) [*c]u8),
    create_loc_conf: ?*const fn ([*c]ngx_conf_t) callconv(.c) ?*anyopaque = @import("std").mem.zeroes(?*const fn ([*c]ngx_conf_t) callconv(.c) ?*anyopaque),
    merge_loc_conf: ?*const fn ([*c]ngx_conf_t, ?*anyopaque, ?*anyopaque) callconv(.c) [*c]u8 = @import("std").mem.zeroes(?*const fn ([*c]ngx_conf_t, ?*anyopaque, ?*anyopaque) callconv(.c) [*c]u8),
};
pub const NGX_HTTP_INITING_REQUEST_STATE: c_int = 0;
pub const NGX_HTTP_READING_REQUEST_STATE: c_int = 1;
pub const NGX_HTTP_PROCESS_REQUEST_STATE: c_int = 2;
pub const NGX_HTTP_CONNECT_UPSTREAM_STATE: c_int = 3;
pub const NGX_HTTP_WRITING_UPSTREAM_STATE: c_int = 4;
pub const NGX_HTTP_READING_UPSTREAM_STATE: c_int = 5;
pub const NGX_HTTP_WRITING_REQUEST_STATE: c_int = 6;
pub const NGX_HTTP_LINGERING_CLOSE_STATE: c_int = 7;
pub const NGX_HTTP_KEEPALIVE_STATE: c_int = 8;
pub const ngx_http_state_e = c_uint;
pub const ngx_http_header_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    offset: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    handler: ngx_http_header_handler_pt = @import("std").mem.zeroes(ngx_http_header_handler_pt),
};
pub const ngx_http_header_out_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    offset: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
const ngx_http_headers_in_flags_t = packed struct {
    connection_type: u2,
    chunked: bool,
    multi: bool,
    multi_linked: bool,
    msie: bool,
    msie6: bool,
    opera: bool,
    gecko: bool,
    chrome: bool,
    safari: bool,
    konqueror: bool,
    padding: u20,
};
pub const ngx_http_headers_in_t = extern struct {
    headers: ngx_list_t = @import("std").mem.zeroes(ngx_list_t),
    host: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    connection: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    if_modified_since: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    if_unmodified_since: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    if_match: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    if_none_match: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    user_agent: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    referer: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    content_length: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    content_range: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    content_type: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    range: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    if_range: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    transfer_encoding: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    te: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    expect: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    upgrade: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    accept_encoding: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    via: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    authorization: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    keep_alive: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    x_forwarded_for: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    cookie: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    user: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    passwd: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    server: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    content_length_n: off_t = @import("std").mem.zeroes(off_t),
    keep_alive_n: time_t = @import("std").mem.zeroes(time_t),
    flags: ngx_http_headers_in_flags_t = @import("std").mem.zeroes(ngx_http_headers_in_flags_t),
};
pub const ngx_http_headers_out_t = extern struct {
    headers: ngx_list_t = @import("std").mem.zeroes(ngx_list_t),
    trailers: ngx_list_t = @import("std").mem.zeroes(ngx_list_t),
    status: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    status_line: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    server: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    date: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    content_length: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    content_encoding: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    location: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    refresh: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    last_modified: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    content_range: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    accept_ranges: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    www_authenticate: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    expires: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    etag: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    cache_control: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    link: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    override_charset: [*c]ngx_str_t = @import("std").mem.zeroes([*c]ngx_str_t),
    content_type_len: usize = @import("std").mem.zeroes(usize),
    content_type: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    charset: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    content_type_lowcase: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    content_type_hash: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    content_length_n: off_t = @import("std").mem.zeroes(off_t),
    content_offset: off_t = @import("std").mem.zeroes(off_t),
    date_time: time_t = @import("std").mem.zeroes(time_t),
    last_modified_time: time_t = @import("std").mem.zeroes(time_t),
};
pub const ngx_http_client_body_handler_pt = ?*const fn ([*c]ngx_http_request_t) callconv(.c) void;
const ngx_http_request_body_flags_t = packed struct {
    filter_need_buffering: bool,
    last_sent: bool,
    last_saved: bool,
    padding: u29,
};
pub const ngx_http_request_body_t = extern struct {
    temp_file: [*c]ngx_temp_file_t = @import("std").mem.zeroes([*c]ngx_temp_file_t),
    bufs: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    buf: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    rest: off_t = @import("std").mem.zeroes(off_t),
    received: off_t = @import("std").mem.zeroes(off_t),
    free: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    busy: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    chunked: [*c]ngx_http_chunked_t = @import("std").mem.zeroes([*c]ngx_http_chunked_t),
    post_handler: ngx_http_client_body_handler_pt = @import("std").mem.zeroes(ngx_http_client_body_handler_pt),
    flags: ngx_http_request_body_flags_t = @import("std").mem.zeroes(ngx_http_request_body_flags_t),
};
const struct_ngx_http_addr_conf_flags_s = packed struct {
    ssl: bool,
    http2: bool,
    quic: bool,
    proxy_protocol: bool,
    padding: u28,
};
pub const struct_ngx_http_addr_conf_s = extern struct {
    default_server: [*c]ngx_http_core_srv_conf_t = @import("std").mem.zeroes([*c]ngx_http_core_srv_conf_t),
    virtual_names: [*c]ngx_http_virtual_names_t = @import("std").mem.zeroes([*c]ngx_http_virtual_names_t),
    flags: struct_ngx_http_addr_conf_flags_s = @import("std").mem.zeroes(struct_ngx_http_addr_conf_flags_s),
};
pub const ngx_http_addr_conf_t = struct_ngx_http_addr_conf_s;
const ngx_http_connection_flags_t = packed struct {
    ssl: bool,
    proxy_protocol: bool,
    padding: u30,
};
pub const ngx_http_connection_t = extern struct {
    addr_conf: [*c]ngx_http_addr_conf_t = @import("std").mem.zeroes([*c]ngx_http_addr_conf_t),
    conf_ctx: [*c]ngx_http_conf_ctx_t = @import("std").mem.zeroes([*c]ngx_http_conf_ctx_t),
    ssl_servername: [*c]ngx_str_t = @import("std").mem.zeroes([*c]ngx_str_t),
    ssl_servername_regex: [*c]ngx_http_regex_t = @import("std").mem.zeroes([*c]ngx_http_regex_t),
    busy: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    nbusy: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    free: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    keepalive_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    flags: ngx_http_connection_flags_t = @import("std").mem.zeroes(ngx_http_connection_flags_t),
};
pub const ngx_http_post_subrequest_pt = ?*const fn ([*c]ngx_http_request_t, ?*anyopaque, ngx_int_t) callconv(.c) ngx_int_t;
pub const ngx_http_post_subrequest_t = extern struct {
    handler: ngx_http_post_subrequest_pt = @import("std").mem.zeroes(ngx_http_post_subrequest_pt),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
pub const ngx_http_ephemeral_t = extern struct {
    terminal_posted_request: ngx_http_posted_request_t = @import("std").mem.zeroes(ngx_http_posted_request_t),
};
pub const ngx_http_headers_in: [*c]ngx_http_header_t = @extern([*c]ngx_http_header_t, .{
    .name = "ngx_http_headers_in",
});
pub const ngx_http_headers_out: [*c]ngx_http_header_out_t = @extern([*c]ngx_http_header_out_t, .{
    .name = "ngx_http_headers_out",
});
const ngx_http_script_engine_flags_t = packed struct {
    flushed: bool,
    skip: bool,
    quote: bool,
    is_args: bool,
    log: bool,
    padding: u27,
};
pub const ngx_http_script_engine_t = extern struct {
    ip: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    pos: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    sp: [*c]ngx_http_variable_value_t = @import("std").mem.zeroes([*c]ngx_http_variable_value_t),
    buf: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    line: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    args: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    flags: ngx_http_script_engine_flags_t = @import("std").mem.zeroes(ngx_http_script_engine_flags_t),
    status: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    request: [*c]ngx_http_request_t = @import("std").mem.zeroes([*c]ngx_http_request_t),
};

const ngx_http_script_compile_flags_t = packed struct {
    compile_args: bool,
    complete_lengths: bool,
    complete_values: bool,
    zero: bool,
    conf_prefix: bool,
    root_prefix: bool,
    dup_capture: bool,
    args: bool,
    padding: u24,
};
pub const ngx_http_script_compile_t = extern struct {
    cf: [*c]ngx_conf_t = @import("std").mem.zeroes([*c]ngx_conf_t),
    source: [*c]ngx_str_t = @import("std").mem.zeroes([*c]ngx_str_t),
    flushes: [*c][*c]ngx_array_t = @import("std").mem.zeroes([*c][*c]ngx_array_t),
    lengths: [*c][*c]ngx_array_t = @import("std").mem.zeroes([*c][*c]ngx_array_t),
    values: [*c][*c]ngx_array_t = @import("std").mem.zeroes([*c][*c]ngx_array_t),
    variables: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    ncaptures: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    captures_mask: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    size: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    main: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    flags: ngx_http_script_compile_flags_t = @import("std").mem.zeroes(ngx_http_script_compile_flags_t),
};
const union_unnamed_259 = extern union {
    size: usize,
};
pub const ngx_http_complex_value_t = extern struct {
    value: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    flushes: [*c]ngx_uint_t = @import("std").mem.zeroes([*c]ngx_uint_t),
    lengths: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    values: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    u: union_unnamed_259 = @import("std").mem.zeroes(union_unnamed_259),
};
const ngx_http_compile_complex_value_flags_t = packed struct {
    zero: bool,
    conf_prefix: bool,
    root_prefix: bool,
    padding: u29,
};
pub const ngx_http_compile_complex_value_t = extern struct {
    cf: [*c]ngx_conf_t = @import("std").mem.zeroes([*c]ngx_conf_t),
    value: [*c]ngx_str_t = @import("std").mem.zeroes([*c]ngx_str_t),
    complex_value: [*c]ngx_http_complex_value_t = @import("std").mem.zeroes([*c]ngx_http_complex_value_t),
    flags: ngx_http_compile_complex_value_flags_t = @import("std").mem.zeroes(ngx_http_compile_complex_value_flags_t),
};
pub const ngx_http_script_code_pt = ?*const fn ([*c]ngx_http_script_engine_t) callconv(.c) void;
pub const ngx_http_script_len_code_pt = ?*const fn ([*c]ngx_http_script_engine_t) callconv(.c) usize;
pub const ngx_http_script_copy_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    len: usize = @import("std").mem.zeroes(usize),
};
pub const ngx_http_script_var_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    index: usize = @import("std").mem.zeroes(usize),
};
pub const ngx_http_script_var_handler_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    handler: ngx_http_set_variable_pt = @import("std").mem.zeroes(ngx_http_set_variable_pt),
    data: usize = @import("std").mem.zeroes(usize),
};
pub const ngx_http_script_copy_capture_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    n: usize = @import("std").mem.zeroes(usize),
};
const ngx_http_script_regex_code_flags_t = packed struct {
    @"test": bool,
    negative_test: bool,
    uri: bool,
    args: bool,
    add_args: bool,
    redirect: bool,
    break_cycle: bool,
    padding: u25,
};
pub const ngx_http_script_regex_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    regex: [*c]ngx_http_regex_t = @import("std").mem.zeroes([*c]ngx_http_regex_t),
    lengths: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    size: usize = @import("std").mem.zeroes(usize),
    status: usize = @import("std").mem.zeroes(usize),
    next: usize = @import("std").mem.zeroes(usize),
    flags: ngx_http_script_regex_code_flags_t = @import("std").mem.zeroes(ngx_http_script_regex_code_flags_t),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
const ngx_http_script_regex_end_code_flags_t = packed struct {
    uri: bool,
    args: bool,
    add_args: bool,
    redirect: bool,
    padding: u28,
};
pub const ngx_http_script_regex_end_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    flags: ngx_http_script_regex_end_code_flags_t = @import("std").mem.zeroes(ngx_http_script_regex_end_code_flags_t),
};
pub const ngx_http_script_full_name_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    conf_prefix: usize = @import("std").mem.zeroes(usize),
};
pub const ngx_http_script_return_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    status: usize = @import("std").mem.zeroes(usize),
    text: ngx_http_complex_value_t = @import("std").mem.zeroes(ngx_http_complex_value_t),
};
pub const ngx_http_script_file_plain: c_int = 0;
pub const ngx_http_script_file_not_plain: c_int = 1;
pub const ngx_http_script_file_dir: c_int = 2;
pub const ngx_http_script_file_not_dir: c_int = 3;
pub const ngx_http_script_file_exists: c_int = 4;
pub const ngx_http_script_file_not_exists: c_int = 5;
pub const ngx_http_script_file_exec: c_int = 6;
pub const ngx_http_script_file_not_exec: c_int = 7;
pub const ngx_http_script_file_op_e = c_uint;
pub const ngx_http_script_file_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    op: usize = @import("std").mem.zeroes(usize),
};
pub const ngx_http_script_if_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    next: usize = @import("std").mem.zeroes(usize),
    loc_conf: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
};
pub const ngx_http_script_complex_value_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    lengths: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
};
pub const ngx_http_script_value_code_t = extern struct {
    code: ngx_http_script_code_pt = @import("std").mem.zeroes(ngx_http_script_code_pt),
    value: usize = @import("std").mem.zeroes(usize),
    text_len: usize = @import("std").mem.zeroes(usize),
    text_data: usize = @import("std").mem.zeroes(usize),
};
pub extern fn ngx_http_script_flush_complex_value(r: [*c]ngx_http_request_t, val: [*c]ngx_http_complex_value_t) void;
pub extern fn ngx_http_complex_value(r: [*c]ngx_http_request_t, val: [*c]ngx_http_complex_value_t, value: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_http_complex_value_size(r: [*c]ngx_http_request_t, val: [*c]ngx_http_complex_value_t, default_value: usize) usize;
pub extern fn ngx_http_compile_complex_value(ccv: [*c]ngx_http_compile_complex_value_t) ngx_int_t;
pub extern fn ngx_http_set_complex_value_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_http_set_complex_value_zero_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_http_set_complex_value_size_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_http_test_predicates(r: [*c]ngx_http_request_t, predicates: [*c]ngx_array_t) ngx_int_t;
pub extern fn ngx_http_test_required_predicates(r: [*c]ngx_http_request_t, predicates: [*c]ngx_array_t) ngx_int_t;
pub extern fn ngx_http_set_predicate_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_http_script_variables_count(value: [*c]ngx_str_t) ngx_uint_t;
pub extern fn ngx_http_script_compile(sc: [*c]ngx_http_script_compile_t) ngx_int_t;
pub extern fn ngx_http_script_run(r: [*c]ngx_http_request_t, value: [*c]ngx_str_t, code_lengths: ?*anyopaque, reserved: usize, code_values: ?*anyopaque) [*c]u_char;
pub extern fn ngx_http_script_flush_no_cacheable_variables(r: [*c]ngx_http_request_t, indices: [*c]ngx_array_t) void;
pub extern fn ngx_http_script_start_code(pool: [*c]ngx_pool_t, codes: [*c][*c]ngx_array_t, size: usize) ?*anyopaque;
pub extern fn ngx_http_script_add_code(codes: [*c]ngx_array_t, size: usize, code: ?*anyopaque) ?*anyopaque;
pub extern fn ngx_http_script_copy_len_code(e: [*c]ngx_http_script_engine_t) usize;
pub extern fn ngx_http_script_copy_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_copy_var_len_code(e: [*c]ngx_http_script_engine_t) usize;
pub extern fn ngx_http_script_copy_var_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_copy_capture_len_code(e: [*c]ngx_http_script_engine_t) usize;
pub extern fn ngx_http_script_copy_capture_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_mark_args_code(e: [*c]ngx_http_script_engine_t) usize;
pub extern fn ngx_http_script_start_args_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_regex_start_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_regex_end_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_return_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_break_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_if_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_equal_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_not_equal_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_file_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_complex_value_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_value_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_set_var_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_var_set_handler_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_var_code(e: [*c]ngx_http_script_engine_t) void;
pub extern fn ngx_http_script_nop_code(e: [*c]ngx_http_script_engine_t) void;
pub const ngx_event_actions_t = extern struct {
    add: ?*const fn ([*c]ngx_event_t, ngx_int_t, ngx_uint_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_event_t, ngx_int_t, ngx_uint_t) callconv(.c) ngx_int_t),
    del: ?*const fn ([*c]ngx_event_t, ngx_int_t, ngx_uint_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_event_t, ngx_int_t, ngx_uint_t) callconv(.c) ngx_int_t),
    enable: ?*const fn ([*c]ngx_event_t, ngx_int_t, ngx_uint_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_event_t, ngx_int_t, ngx_uint_t) callconv(.c) ngx_int_t),
    disable: ?*const fn ([*c]ngx_event_t, ngx_int_t, ngx_uint_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_event_t, ngx_int_t, ngx_uint_t) callconv(.c) ngx_int_t),
    add_conn: ?*const fn ([*c]ngx_connection_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_connection_t) callconv(.c) ngx_int_t),
    del_conn: ?*const fn ([*c]ngx_connection_t, ngx_uint_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_connection_t, ngx_uint_t) callconv(.c) ngx_int_t),
    notify: ?*const fn (ngx_event_handler_pt) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn (ngx_event_handler_pt) callconv(.c) ngx_int_t),
    process_events: ?*const fn ([*c]ngx_cycle_t, ngx_msec_t, ngx_uint_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t, ngx_msec_t, ngx_uint_t) callconv(.c) ngx_int_t),
    init: ?*const fn ([*c]ngx_cycle_t, ngx_msec_t) callconv(.c) ngx_int_t = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t, ngx_msec_t) callconv(.c) ngx_int_t),
    done: ?*const fn ([*c]ngx_cycle_t) callconv(.c) void = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t) callconv(.c) void),
};
pub extern var ngx_event_actions: ngx_event_actions_t;
pub extern var ngx_use_epoll_rdhup: ngx_uint_t;
pub extern var ngx_io: ngx_os_io_t;
pub const ngx_event_conf_t = extern struct {
    connections: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    use: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    multi_accept: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    accept_mutex: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    accept_mutex_delay: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    name: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
};
pub const ngx_event_module_t = extern struct {
    name: [*c]ngx_str_t = @import("std").mem.zeroes([*c]ngx_str_t),
    create_conf: ?*const fn ([*c]ngx_cycle_t) callconv(.c) ?*anyopaque = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t) callconv(.c) ?*anyopaque),
    init_conf: ?*const fn ([*c]ngx_cycle_t, ?*anyopaque) callconv(.c) [*c]u8 = @import("std").mem.zeroes(?*const fn ([*c]ngx_cycle_t, ?*anyopaque) callconv(.c) [*c]u8),
    actions: ngx_event_actions_t = @import("std").mem.zeroes(ngx_event_actions_t),
};
pub extern var ngx_connection_counter: [*c]volatile ngx_atomic_t;
pub extern var ngx_accept_mutex_ptr: [*c]volatile ngx_atomic_t;
pub extern var ngx_accept_mutex: ngx_shmtx_t;
pub extern var ngx_use_accept_mutex: ngx_uint_t;
pub extern var ngx_accept_events: ngx_uint_t;
pub extern var ngx_accept_mutex_held: ngx_uint_t;
pub extern var ngx_accept_mutex_delay: ngx_msec_t;
pub extern var ngx_accept_disabled: ngx_int_t;
pub extern var ngx_use_exclusive_accept: ngx_uint_t;
pub extern var ngx_event_timer_alarm: sig_atomic_t;
pub extern var ngx_event_flags: ngx_uint_t;
pub extern var ngx_events_module: ngx_module_t;
pub extern var ngx_event_core_module: ngx_module_t;
pub extern fn ngx_event_accept(ev: [*c]ngx_event_t) void;
pub extern fn ngx_trylock_accept_mutex(cycle: [*c]ngx_cycle_t) ngx_int_t;
pub extern fn ngx_enable_accept_events(cycle: [*c]ngx_cycle_t) ngx_int_t;
pub extern fn ngx_accept_log_error(log: [*c]ngx_log_t, buf: [*c]u_char, len: usize) [*c]u_char;
pub extern fn ngx_process_events_and_timers(cycle: [*c]ngx_cycle_t) void;
pub extern fn ngx_handle_read_event(rev: [*c]ngx_event_t, flags: ngx_uint_t) ngx_int_t;
pub extern fn ngx_handle_write_event(wev: [*c]ngx_event_t, lowat: usize) ngx_int_t;
pub extern fn ngx_send_lowat(c: [*c]ngx_connection_t, lowat: usize) ngx_int_t;
pub extern fn ngx_event_timer_init(log: [*c]ngx_log_t) ngx_int_t;
pub extern fn ngx_event_find_timer() ngx_msec_t;
pub extern fn ngx_event_expire_timers() void;
pub extern fn ngx_event_no_timers_left() ngx_int_t;
pub extern var ngx_event_timer_rbtree: ngx_rbtree_t;
pub extern fn ngx_event_process_posted(cycle: [*c]ngx_cycle_t, posted: [*c]ngx_queue_t) void;
pub extern fn ngx_event_move_posted_next(cycle: [*c]ngx_cycle_t) void;
pub extern var ngx_posted_accept_events: ngx_queue_t;
pub extern var ngx_posted_next_events: ngx_queue_t;
pub extern var ngx_posted_events: ngx_queue_t;
pub const ngx_addrinfo_t = extern union {
    pkt: struct_in_pktinfo,
    pkt6: struct_in6_pktinfo,
};
pub extern fn ngx_set_srcaddr_cmsg(cmsg: [*c]struct_cmsghdr, local_sockaddr: [*c]struct_sockaddr) usize;
pub extern fn ngx_get_srcaddr_cmsg(cmsg: [*c]struct_cmsghdr, local_sockaddr: [*c]struct_sockaddr) ngx_int_t;
pub extern fn ngx_event_recvmsg(ev: [*c]ngx_event_t) void;
pub extern fn ngx_sendmsg(c: [*c]ngx_connection_t, msg: [*c]struct_msghdr, flags: c_int) isize;
pub extern fn ngx_udp_rbtree_insert_value(temp: [*c]ngx_rbtree_node_t, node: [*c]ngx_rbtree_node_t, sentinel: [*c]ngx_rbtree_node_t) void;
pub extern fn ngx_delete_udp_connection(data: ?*anyopaque) void;
pub extern fn ngx_event_connect_peer(pc: [*c]ngx_peer_connection_t) ngx_int_t;
pub extern fn ngx_event_get_peer(pc: [*c]ngx_peer_connection_t, data: ?*anyopaque) ngx_int_t;
pub extern fn ngx_event_pipe(p: [*c]ngx_event_pipe_t, do_write: ngx_int_t) ngx_int_t;
pub extern fn ngx_event_pipe_copy_input_filter(p: [*c]ngx_event_pipe_t, buf: [*c]ngx_buf_t) ngx_int_t;
pub extern fn ngx_event_pipe_add_free_buf(p: [*c]ngx_event_pipe_t, b: [*c]ngx_buf_t) ngx_int_t;
pub const ngx_http_upstream_state_t = extern struct {
    status: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    response_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    connect_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    header_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    queue_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    response_length: off_t = @import("std").mem.zeroes(off_t),
    bytes_received: off_t = @import("std").mem.zeroes(off_t),
    bytes_sent: off_t = @import("std").mem.zeroes(off_t),
    peer: [*c]ngx_str_t = @import("std").mem.zeroes([*c]ngx_str_t),
};
pub const ngx_http_upstream_main_conf_t = extern struct {
    headers_in_hash: ngx_hash_t = @import("std").mem.zeroes(ngx_hash_t),
    upstreams: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
};
pub const ngx_http_upstream_init_pt = ?*const fn ([*c]ngx_conf_t, [*c]ngx_http_upstream_srv_conf_t) callconv(.c) ngx_int_t;
pub const ngx_http_upstream_init_peer_pt = ?*const fn ([*c]ngx_http_request_t, [*c]ngx_http_upstream_srv_conf_t) callconv(.c) ngx_int_t;
pub const ngx_http_upstream_peer_t = extern struct {
    init_upstream: ngx_http_upstream_init_pt = @import("std").mem.zeroes(ngx_http_upstream_init_pt),
    init: ngx_http_upstream_init_peer_pt = @import("std").mem.zeroes(ngx_http_upstream_init_peer_pt),
    data: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
};
const ngx_http_upstream_server_flags_t = packed struct {
    backup: bool,
    padding: u31,
};
pub const ngx_http_upstream_server_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    addrs: [*c]ngx_addr_t = @import("std").mem.zeroes([*c]ngx_addr_t),
    naddrs: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    weight: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    max_conns: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    max_fails: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    fail_timeout: time_t = @import("std").mem.zeroes(time_t),
    slow_start: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    down: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    flags: ngx_http_upstream_server_flags_t = @import("std").mem.zeroes(ngx_http_upstream_server_flags_t),
    host: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    service: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub const ngx_http_upstream_local_t = extern struct {
    addr: [*c]ngx_addr_t = @import("std").mem.zeroes([*c]ngx_addr_t),
    value: [*c]ngx_http_complex_value_t = @import("std").mem.zeroes([*c]ngx_http_complex_value_t),
    transparent: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
const ngx_http_upstream_conf_flags_t = packed struct {
    cache: i2,
    store: i2,
    intercept_404: bool,
    change_buffering: bool,
    preserve_output: bool,
    padding: u25,
};
pub const ngx_http_upstream_conf_t = extern struct {
    upstream: [*c]ngx_http_upstream_srv_conf_t = @import("std").mem.zeroes([*c]ngx_http_upstream_srv_conf_t),
    connect_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    send_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    read_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    next_upstream_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    send_lowat: usize = @import("std").mem.zeroes(usize),
    buffer_size: usize = @import("std").mem.zeroes(usize),
    limit_rate: [*c]ngx_http_complex_value_t = @import("std").mem.zeroes([*c]ngx_http_complex_value_t),
    busy_buffers_size: usize = @import("std").mem.zeroes(usize),
    max_temp_file_size: usize = @import("std").mem.zeroes(usize),
    temp_file_write_size: usize = @import("std").mem.zeroes(usize),
    busy_buffers_size_conf: usize = @import("std").mem.zeroes(usize),
    max_temp_file_size_conf: usize = @import("std").mem.zeroes(usize),
    temp_file_write_size_conf: usize = @import("std").mem.zeroes(usize),
    bufs: ngx_bufs_t = @import("std").mem.zeroes(ngx_bufs_t),
    ignore_headers: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    next_upstream: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    store_access: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    next_upstream_tries: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    buffering: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    request_buffering: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    pass_request_headers: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    pass_request_body: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    pass_trailers: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    pass_early_hints: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    ignore_client_abort: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    intercept_errors: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    cyclic_temp_file: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    force_ranges: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    temp_path: [*c]ngx_path_t = @import("std").mem.zeroes([*c]ngx_path_t),
    hide_headers_hash: ngx_hash_t = @import("std").mem.zeroes(ngx_hash_t),
    hide_headers: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    pass_headers: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    local: [*c]ngx_http_upstream_local_t = @import("std").mem.zeroes([*c]ngx_http_upstream_local_t),
    socket_keepalive: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    cache_zone: [*c]ngx_shm_zone_t = @import("std").mem.zeroes([*c]ngx_shm_zone_t),
    cache_value: [*c]ngx_http_complex_value_t = @import("std").mem.zeroes([*c]ngx_http_complex_value_t),
    cache_min_uses: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    cache_use_stale: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    cache_methods: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    cache_max_range_offset: off_t = @import("std").mem.zeroes(off_t),
    cache_lock: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    cache_lock_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    cache_lock_age: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    cache_revalidate: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    cache_convert_head: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    cache_background_update: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    cache_valid: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    cache_bypass: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    cache_purge: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    no_cache: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    store_lengths: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    store_values: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    flags: ngx_http_upstream_conf_flags_t = @import("std").mem.zeroes(ngx_http_upstream_conf_flags_t),
    ssl: [*c]ngx_ssl_t = @import("std").mem.zeroes([*c]ngx_ssl_t),
    ssl_session_reuse: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    ssl_name: [*c]ngx_http_complex_value_t = @import("std").mem.zeroes([*c]ngx_http_complex_value_t),
    ssl_server_name: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    ssl_verify: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    ssl_certificate: [*c]ngx_http_complex_value_t = @import("std").mem.zeroes([*c]ngx_http_complex_value_t),
    ssl_certificate_key: [*c]ngx_http_complex_value_t = @import("std").mem.zeroes([*c]ngx_http_complex_value_t),
    ssl_certificate_cache: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    ssl_passwords: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    module: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub const ngx_http_upstream_header_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    handler: ngx_http_header_handler_pt = @import("std").mem.zeroes(ngx_http_header_handler_pt),
    offset: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    copy_handler: ngx_http_header_handler_pt = @import("std").mem.zeroes(ngx_http_header_handler_pt),
    conf: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    redirect: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
const ngx_http_upstream_headers_in_flags_t = packed struct {
    connection_close: bool,
    chunked: bool,
    no_cache: bool,
    expired: bool,
    padding: u28,
};
pub const ngx_http_upstream_headers_in_t = extern struct {
    headers: ngx_list_t = @import("std").mem.zeroes(ngx_list_t),
    trailers: ngx_list_t = @import("std").mem.zeroes(ngx_list_t),
    status_n: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    status_line: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    status: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    date: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    server: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    connection: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    expires: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    etag: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    x_accel_expires: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    x_accel_redirect: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    x_accel_limit_rate: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    content_type: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    content_length: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    last_modified: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    location: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    refresh: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    www_authenticate: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    transfer_encoding: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    vary: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    cache_control: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    set_cookie: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    content_length_n: off_t = @import("std").mem.zeroes(off_t),
    last_modified_time: time_t = @import("std").mem.zeroes(time_t),
    flags: ngx_http_upstream_headers_in_flags_t = @import("std").mem.zeroes(ngx_http_upstream_headers_in_flags_t),
};
pub const ngx_http_upstream_resolved_t = extern struct {
    host: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    port: in_port_t = @import("std").mem.zeroes(in_port_t),
    no_port: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    naddrs: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    addrs: [*c]ngx_resolver_addr_t = @import("std").mem.zeroes([*c]ngx_resolver_addr_t),
    sockaddr: [*c]struct_sockaddr = @import("std").mem.zeroes([*c]struct_sockaddr),
    socklen: socklen_t = @import("std").mem.zeroes(socklen_t),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    ctx: [*c]ngx_resolver_ctx_t = @import("std").mem.zeroes([*c]ngx_resolver_ctx_t),
};
pub const ngx_http_upstream_next_t = extern struct {
    status: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    mask: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_http_upstream_param_t = extern struct {
    key: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    value: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    skip_empty: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub extern fn ngx_http_upstream_create(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_upstream_init(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_upstream_non_buffered_filter_init(data: ?*anyopaque) ngx_int_t;
pub extern fn ngx_http_upstream_non_buffered_filter(data: ?*anyopaque, bytes: isize) ngx_int_t;
pub extern fn ngx_http_upstream_add(cf: [*c]ngx_conf_t, u: [*c]ngx_url_t, flags: ngx_uint_t) [*c]ngx_http_upstream_srv_conf_t;
pub extern fn ngx_http_upstream_bind_set_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_http_upstream_param_set_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_http_upstream_hide_headers_hash(cf: [*c]ngx_conf_t, conf: [*c]ngx_http_upstream_conf_t, prev: [*c]ngx_http_upstream_conf_t, default_hide_headers: [*c]ngx_str_t, hash: [*c]ngx_hash_init_t) ngx_int_t;
pub extern var ngx_http_upstream_module: ngx_module_t;
pub const ngx_http_upstream_cache_method_mask: [*c]ngx_conf_bitmask_t = @extern([*c]ngx_conf_bitmask_t, .{
    .name = "ngx_http_upstream_cache_method_mask",
});
pub const ngx_http_upstream_ignore_headers_masks: [*c]ngx_conf_bitmask_t = @extern([*c]ngx_conf_bitmask_t, .{
    .name = "ngx_http_upstream_ignore_headers_masks",
});
const struct_ngx_http_upstream_rr_peer_flags_s = packed struct {
    zombie: bool,
    padding: u31,
};
pub const struct_ngx_http_upstream_rr_peer_s = extern struct {
    sockaddr: [*c]struct_sockaddr = @import("std").mem.zeroes([*c]struct_sockaddr),
    socklen: socklen_t = @import("std").mem.zeroes(socklen_t),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    server: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    current_weight: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    effective_weight: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    weight: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    conns: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    max_conns: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    fails: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    accessed: time_t = @import("std").mem.zeroes(time_t),
    checked: time_t = @import("std").mem.zeroes(time_t),
    max_fails: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    fail_timeout: time_t = @import("std").mem.zeroes(time_t),
    slow_start: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    start_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    down: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    ssl_session: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    ssl_session_len: c_int = @import("std").mem.zeroes(c_int),
    flags: struct_ngx_http_upstream_rr_peer_flags_s = @import("std").mem.zeroes(struct_ngx_http_upstream_rr_peer_flags_s),
    lock: ngx_atomic_t = @import("std").mem.zeroes(ngx_atomic_t),
    refs: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    host: [*c]ngx_http_upstream_host_t = @import("std").mem.zeroes([*c]ngx_http_upstream_host_t),
    next: [*c]ngx_http_upstream_rr_peer_t = @import("std").mem.zeroes([*c]ngx_http_upstream_rr_peer_t),
};
pub const ngx_http_upstream_rr_peer_t = struct_ngx_http_upstream_rr_peer_s;
pub const ngx_http_upstream_rr_peers_t = struct_ngx_http_upstream_rr_peers_s;
const struct_ngx_http_upstream_rr_peers_flags_s = packed struct {
    single: bool,
    weighted: bool,
    padding: u30,
};
pub const struct_ngx_http_upstream_rr_peers_s = extern struct {
    number: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    shpool: [*c]ngx_slab_pool_t = @import("std").mem.zeroes([*c]ngx_slab_pool_t),
    rwlock: ngx_atomic_t = @import("std").mem.zeroes(ngx_atomic_t),
    config: [*c]ngx_uint_t = @import("std").mem.zeroes([*c]ngx_uint_t),
    resolve: [*c]ngx_http_upstream_rr_peer_t = @import("std").mem.zeroes([*c]ngx_http_upstream_rr_peer_t),
    zone_next: [*c]ngx_http_upstream_rr_peers_t = @import("std").mem.zeroes([*c]ngx_http_upstream_rr_peers_t),
    total_weight: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    tries: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    flags: struct_ngx_http_upstream_rr_peers_flags_s = @import("std").mem.zeroes(struct_ngx_http_upstream_rr_peers_flags_s),
    name: [*c]ngx_str_t = @import("std").mem.zeroes([*c]ngx_str_t),
    next: [*c]ngx_http_upstream_rr_peers_t = @import("std").mem.zeroes([*c]ngx_http_upstream_rr_peers_t),
    peer: [*c]ngx_http_upstream_rr_peer_t = @import("std").mem.zeroes([*c]ngx_http_upstream_rr_peer_t),
};
pub const ngx_http_upstream_host_t = extern struct {
    event: ngx_event_t = @import("std").mem.zeroes(ngx_event_t),
    worker: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    service: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    valid: time_t = @import("std").mem.zeroes(time_t),
    peers: [*c]ngx_http_upstream_rr_peers_t = @import("std").mem.zeroes([*c]ngx_http_upstream_rr_peers_t),
    peer: [*c]ngx_http_upstream_rr_peer_t = @import("std").mem.zeroes([*c]ngx_http_upstream_rr_peer_t),
};
pub const ngx_http_upstream_rr_peer_data_t = extern struct {
    config: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    peers: [*c]ngx_http_upstream_rr_peers_t = @import("std").mem.zeroes([*c]ngx_http_upstream_rr_peers_t),
    current: [*c]ngx_http_upstream_rr_peer_t = @import("std").mem.zeroes([*c]ngx_http_upstream_rr_peer_t),
    tried: [*c]usize = @import("std").mem.zeroes([*c]usize),
    data: usize = @import("std").mem.zeroes(usize),
};
pub extern fn ngx_http_upstream_init_round_robin(cf: [*c]ngx_conf_t, us: [*c]ngx_http_upstream_srv_conf_t) ngx_int_t;
pub extern fn ngx_http_upstream_init_round_robin_peer(r: [*c]ngx_http_request_t, us: [*c]ngx_http_upstream_srv_conf_t) ngx_int_t;
pub extern fn ngx_http_upstream_create_round_robin_peer(r: [*c]ngx_http_request_t, ur: [*c]ngx_http_upstream_resolved_t) ngx_int_t;
pub extern fn ngx_http_upstream_get_round_robin_peer(pc: [*c]ngx_peer_connection_t, data: ?*anyopaque) ngx_int_t;
pub extern fn ngx_http_upstream_free_round_robin_peer(pc: [*c]ngx_peer_connection_t, data: ?*anyopaque, state: ngx_uint_t) void;
pub extern fn ngx_http_upstream_set_round_robin_peer_session(pc: [*c]ngx_peer_connection_t, data: ?*anyopaque) ngx_int_t;
pub extern fn ngx_http_upstream_save_round_robin_peer_session(pc: [*c]ngx_peer_connection_t, data: ?*anyopaque) void;
pub const ngx_http_location_tree_node_t = struct_ngx_http_location_tree_node_s;

const struct_ngx_http_core_loc_conf_flags_s = packed struct {
    noname: bool,
    lmt_excpt: bool,
    named: bool,
    exact_match: bool,
    noregex: bool,
    auto_redirect: bool,
    gzip_disable_msie6: u2,
    gzip_disalbe_degradation: u2,
    padding: u22,
};
pub const struct_ngx_http_core_loc_conf_s = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    escaped_name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    regex: [*c]ngx_http_regex_t = @import("std").mem.zeroes([*c]ngx_http_regex_t),
    flags: struct_ngx_http_core_loc_conf_flags_s = @import("std").mem.zeroes(struct_ngx_http_core_loc_conf_flags_s),
    static_locations: [*c]ngx_http_location_tree_node_t = @import("std").mem.zeroes([*c]ngx_http_location_tree_node_t),
    regex_locations: [*c][*c]ngx_http_core_loc_conf_t = @import("std").mem.zeroes([*c][*c]ngx_http_core_loc_conf_t),
    loc_conf: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
    limit_except: u32 = @import("std").mem.zeroes(u32),
    limit_except_loc_conf: [*c]?*anyopaque = @import("std").mem.zeroes([*c]?*anyopaque),
    handler: ngx_http_handler_pt = @import("std").mem.zeroes(ngx_http_handler_pt),
    alias: usize = @import("std").mem.zeroes(usize),
    root: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    post_action: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    root_lengths: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    root_values: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    types: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    types_hash: ngx_hash_t = @import("std").mem.zeroes(ngx_hash_t),
    default_type: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    client_max_body_size: off_t = @import("std").mem.zeroes(off_t),
    directio: off_t = @import("std").mem.zeroes(off_t),
    directio_alignment: off_t = @import("std").mem.zeroes(off_t),
    client_body_buffer_size: usize = @import("std").mem.zeroes(usize),
    send_lowat: usize = @import("std").mem.zeroes(usize),
    postpone_output: usize = @import("std").mem.zeroes(usize),
    sendfile_max_chunk: usize = @import("std").mem.zeroes(usize),
    read_ahead: usize = @import("std").mem.zeroes(usize),
    subrequest_output_buffer_size: usize = @import("std").mem.zeroes(usize),
    limit_rate: [*c]ngx_http_complex_value_t = @import("std").mem.zeroes([*c]ngx_http_complex_value_t),
    limit_rate_after: [*c]ngx_http_complex_value_t = @import("std").mem.zeroes([*c]ngx_http_complex_value_t),
    client_body_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    send_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    keepalive_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    keepalive_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    keepalive_min_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    lingering_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    lingering_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    resolver_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    auth_delay: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    resolver: [*c]ngx_resolver_t = @import("std").mem.zeroes([*c]ngx_resolver_t),
    keepalive_header: time_t = @import("std").mem.zeroes(time_t),
    keepalive_requests: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    keepalive_disable: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    satisfy: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    lingering_close: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    if_modified_since: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    max_ranges: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    client_body_in_file_only: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    client_body_in_single_buffer: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    internal: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    sendfile: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    aio: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    aio_write: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    tcp_nopush: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    tcp_nodelay: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    reset_timedout_connection: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    absolute_redirect: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    server_name_in_redirect: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    port_in_redirect: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    msie_padding: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    msie_refresh: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    log_not_found: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    log_subrequest: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    recursive_error_pages: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    server_tokens: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    chunked_transfer_encoding: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    etag: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    gzip_vary: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    gzip_http_version: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    gzip_proxied: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    gzip_disable: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    disable_symlinks: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    disable_symlinks_from: [*c]ngx_http_complex_value_t = @import("std").mem.zeroes([*c]ngx_http_complex_value_t),
    early_hints: [*c]ngx_array_t =  @import("std").mem.zeroes([*c]ngx_array_t),
    error_pages: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    client_body_temp_path: [*c]ngx_path_t = @import("std").mem.zeroes([*c]ngx_path_t),
    open_file_cache: [*c]ngx_open_file_cache_t = @import("std").mem.zeroes([*c]ngx_open_file_cache_t),
    open_file_cache_valid: time_t = @import("std").mem.zeroes(time_t),
    open_file_cache_min_uses: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    open_file_cache_errors: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    open_file_cache_events: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    error_log: [*c]ngx_log_t = @import("std").mem.zeroes([*c]ngx_log_t),
    types_hash_max_size: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    types_hash_bucket_size: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    locations: [*c]ngx_queue_t = @import("std").mem.zeroes([*c]ngx_queue_t),
};
pub const ngx_http_core_loc_conf_t = struct_ngx_http_core_loc_conf_s;
pub const struct_ngx_http_location_tree_node_s = extern struct {
    left: [*c]ngx_http_location_tree_node_t = @import("std").mem.zeroes([*c]ngx_http_location_tree_node_t),
    right: [*c]ngx_http_location_tree_node_t = @import("std").mem.zeroes([*c]ngx_http_location_tree_node_t),
    tree: [*c]ngx_http_location_tree_node_t = @import("std").mem.zeroes([*c]ngx_http_location_tree_node_t),
    exact: [*c]ngx_http_core_loc_conf_t = @import("std").mem.zeroes([*c]ngx_http_core_loc_conf_t),
    inclusive: [*c]ngx_http_core_loc_conf_t = @import("std").mem.zeroes([*c]ngx_http_core_loc_conf_t),
    len: u_short = @import("std").mem.zeroes(u_short),
    auto_redirect: u_char = @import("std").mem.zeroes(u_char),
    name: [1]u_char = @import("std").mem.zeroes([1]u_char),
};
const ngx_http_listen_opt_flags_t = packed struct {
    set: bool,
    default_server: bool,
    bind: bool,
    wildcard: bool,
    ssl: bool,
    http2: bool,
    quic: bool,
    ipv6only: bool,
    deferred_accept: bool,
    reuseport: bool,
    so_keepalive: u2,
    proxy_protocol: bool,
    padding: u19,
};
pub const ngx_http_listen_opt_t = extern struct {
    sockaddr: [*c]struct_sockaddr = @import("std").mem.zeroes([*c]struct_sockaddr),
    socklen: socklen_t = @import("std").mem.zeroes(socklen_t),
    addr_text: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    flags: ngx_http_listen_opt_flags_t = @import("std").mem.zeroes(ngx_http_listen_opt_flags_t),
    backlog: c_int = @import("std").mem.zeroes(c_int),
    rcvbuf: c_int = @import("std").mem.zeroes(c_int),
    sndbuf: c_int = @import("std").mem.zeroes(c_int),
    type: c_int = @import("std").mem.zeroes(c_int),
    fastopen: c_int = @import("std").mem.zeroes(c_int),
    tcp_keepidle: c_int = @import("std").mem.zeroes(c_int),
    tcp_keepintvl: c_int = @import("std").mem.zeroes(c_int),
    tcp_keepcnt: c_int = @import("std").mem.zeroes(c_int),
};
pub const NGX_HTTP_POST_READ_PHASE: c_int = 0;
pub const NGX_HTTP_SERVER_REWRITE_PHASE: c_int = 1;
pub const NGX_HTTP_FIND_CONFIG_PHASE: c_int = 2;
pub const NGX_HTTP_REWRITE_PHASE: c_int = 3;
pub const NGX_HTTP_POST_REWRITE_PHASE: c_int = 4;
pub const NGX_HTTP_PREACCESS_PHASE: c_int = 5;
pub const NGX_HTTP_ACCESS_PHASE: c_int = 6;
pub const NGX_HTTP_POST_ACCESS_PHASE: c_int = 7;
pub const NGX_HTTP_PRECONTENT_PHASE: c_int = 8;
pub const NGX_HTTP_CONTENT_PHASE: c_int = 9;
pub const NGX_HTTP_LOG_PHASE: c_int = 10;
pub const ngx_http_phases = c_uint;
pub const ngx_http_phase_handler_t = struct_ngx_http_phase_handler_s;
pub const ngx_http_phase_handler_pt = ?*const fn ([*c]ngx_http_request_t, [*c]ngx_http_phase_handler_t) callconv(.c) ngx_int_t;
pub const struct_ngx_http_phase_handler_s = extern struct {
    checker: ngx_http_phase_handler_pt = @import("std").mem.zeroes(ngx_http_phase_handler_pt),
    handler: ngx_http_handler_pt = @import("std").mem.zeroes(ngx_http_handler_pt),
    next: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_http_phase_engine_t = extern struct {
    handlers: [*c]ngx_http_phase_handler_t = @import("std").mem.zeroes([*c]ngx_http_phase_handler_t),
    server_rewrite_index: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    location_rewrite_index: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_http_phase_t = extern struct {
    handlers: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
};
pub const ngx_http_core_main_conf_t = extern struct {
    servers: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    phase_engine: ngx_http_phase_engine_t = @import("std").mem.zeroes(ngx_http_phase_engine_t),
    headers_in_hash: ngx_hash_t = @import("std").mem.zeroes(ngx_hash_t),
    variables_hash: ngx_hash_t = @import("std").mem.zeroes(ngx_hash_t),
    variables: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    prefix_variables: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    ncaptures: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    server_names_hash_max_size: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    server_names_hash_bucket_size: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    variables_hash_max_size: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    variables_hash_bucket_size: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    variables_keys: [*c]ngx_hash_keys_arrays_t = @import("std").mem.zeroes([*c]ngx_hash_keys_arrays_t),
    ports: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    phases: [11]ngx_http_phase_t = @import("std").mem.zeroes([11]ngx_http_phase_t),
};
const ngx_http_core_srv_conf_flags_t = packed struct {
    listen: bool,
    captures: bool,
    allow_connect: bool,
    padding: u29,
};
pub const ngx_http_core_srv_conf_t = extern struct {
    server_names: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    ctx: [*c]ngx_http_conf_ctx_t = @import("std").mem.zeroes([*c]ngx_http_conf_ctx_t),
    file_name: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    line: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    server_name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    connection_pool_size: usize = @import("std").mem.zeroes(usize),
    request_pool_size: usize = @import("std").mem.zeroes(usize),
    client_header_buffer_size: usize = @import("std").mem.zeroes(usize),
    large_client_header_buffers: ngx_bufs_t = @import("std").mem.zeroes(ngx_bufs_t),
    client_header_timeout: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
    ignore_invalid_headers: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    merge_slashes: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    underscores_in_headers: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    flags: ngx_http_core_srv_conf_flags_t = @import("std").mem.zeroes(ngx_http_core_srv_conf_flags_t),
    named_locations: [*c][*c]ngx_http_core_loc_conf_t = @import("std").mem.zeroes([*c][*c]ngx_http_core_loc_conf_t),
};
pub const ngx_http_server_name_t = extern struct {
    regex: [*c]ngx_http_regex_t = @import("std").mem.zeroes([*c]ngx_http_regex_t),
    server: [*c]ngx_http_core_srv_conf_t = @import("std").mem.zeroes([*c]ngx_http_core_srv_conf_t),
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub const ngx_http_virtual_names_t = extern struct {
    names: ngx_hash_combined_t = @import("std").mem.zeroes(ngx_hash_combined_t),
    nregex: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    regex: [*c]ngx_http_server_name_t = @import("std").mem.zeroes([*c]ngx_http_server_name_t),
};
pub const ngx_http_in_addr_t = extern struct {
    addr: in_addr_t = @import("std").mem.zeroes(in_addr_t),
    conf: ngx_http_addr_conf_t = @import("std").mem.zeroes(ngx_http_addr_conf_t),
};
pub const ngx_http_in6_addr_t = extern struct {
    addr6: struct_in6_addr = @import("std").mem.zeroes(struct_in6_addr),
    conf: ngx_http_addr_conf_t = @import("std").mem.zeroes(ngx_http_addr_conf_t),
};
pub const ngx_http_port_t = extern struct {
    addrs: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    naddrs: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_http_conf_port_t = extern struct {
    family: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    type: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    port: in_port_t = @import("std").mem.zeroes(in_port_t),
    addrs: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
};
const ngx_http_conf_addr_flags_t = packed struct {
    protocols: u3,
    protocols_set: bool,
    protocols_changed: bool,
    padding: u27,
};
pub const ngx_http_conf_addr_t = extern struct {
    opt: ngx_http_listen_opt_t = @import("std").mem.zeroes(ngx_http_listen_opt_t),
    flags: ngx_http_conf_addr_flags_t = @import("std").mem.zeroes(ngx_http_conf_addr_flags_t),
    hash: ngx_hash_t = @import("std").mem.zeroes(ngx_hash_t),
    wc_head: [*c]ngx_hash_wildcard_t = @import("std").mem.zeroes([*c]ngx_hash_wildcard_t),
    wc_tail: [*c]ngx_hash_wildcard_t = @import("std").mem.zeroes([*c]ngx_hash_wildcard_t),
    nregex: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    regex: [*c]ngx_http_server_name_t = @import("std").mem.zeroes([*c]ngx_http_server_name_t),
    default_server: [*c]ngx_http_core_srv_conf_t = @import("std").mem.zeroes([*c]ngx_http_core_srv_conf_t),
    servers: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
};
pub const ngx_http_err_page_t = extern struct {
    status: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    overwrite: ngx_int_t = @import("std").mem.zeroes(ngx_int_t),
    value: ngx_http_complex_value_t = @import("std").mem.zeroes(ngx_http_complex_value_t),
    args: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub const ngx_http_location_queue_t = extern struct {
    queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    exact: [*c]ngx_http_core_loc_conf_t = @import("std").mem.zeroes([*c]ngx_http_core_loc_conf_t),
    inclusive: [*c]ngx_http_core_loc_conf_t = @import("std").mem.zeroes([*c]ngx_http_core_loc_conf_t),
    name: [*c]ngx_str_t = @import("std").mem.zeroes([*c]ngx_str_t),
    file_name: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    line: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    list: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
};
pub extern fn ngx_http_core_run_phases(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_core_generic_phase(r: [*c]ngx_http_request_t, ph: [*c]ngx_http_phase_handler_t) ngx_int_t;
pub extern fn ngx_http_core_rewrite_phase(r: [*c]ngx_http_request_t, ph: [*c]ngx_http_phase_handler_t) ngx_int_t;
pub extern fn ngx_http_core_find_config_phase(r: [*c]ngx_http_request_t, ph: [*c]ngx_http_phase_handler_t) ngx_int_t;
pub extern fn ngx_http_core_post_rewrite_phase(r: [*c]ngx_http_request_t, ph: [*c]ngx_http_phase_handler_t) ngx_int_t;
pub extern fn ngx_http_core_access_phase(r: [*c]ngx_http_request_t, ph: [*c]ngx_http_phase_handler_t) ngx_int_t;
pub extern fn ngx_http_core_post_access_phase(r: [*c]ngx_http_request_t, ph: [*c]ngx_http_phase_handler_t) ngx_int_t;
pub extern fn ngx_http_core_content_phase(r: [*c]ngx_http_request_t, ph: [*c]ngx_http_phase_handler_t) ngx_int_t;
pub extern fn ngx_http_test_content_type(r: [*c]ngx_http_request_t, types_hash: [*c]ngx_hash_t) ?*anyopaque;
pub extern fn ngx_http_set_content_type(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_set_exten(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_set_etag(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_weak_etag(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_send_response(r: [*c]ngx_http_request_t, status: ngx_uint_t, ct: [*c]ngx_str_t, cv: [*c]ngx_http_complex_value_t) ngx_int_t;
pub extern fn ngx_http_map_uri_to_path(r: [*c]ngx_http_request_t, name: [*c]ngx_str_t, root_length: [*c]usize, reserved: usize) [*c]u_char;
pub extern fn ngx_http_auth_basic_user(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_gzip_ok(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_subrequest(r: [*c]ngx_http_request_t, uri: [*c]ngx_str_t, args: [*c]ngx_str_t, psr: [*c][*c]ngx_http_request_t, ps: [*c]ngx_http_post_subrequest_t, flags: ngx_uint_t) ngx_int_t;
pub extern fn ngx_http_internal_redirect(r: [*c]ngx_http_request_t, uri: [*c]ngx_str_t, args: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_http_named_location(r: [*c]ngx_http_request_t, name: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_http_cleanup_add(r: [*c]ngx_http_request_t, size: usize) [*c]ngx_http_cleanup_t;
pub const ngx_http_output_header_filter_pt = ?*const fn ([*c]ngx_http_request_t) callconv(.c) ngx_int_t;
pub const ngx_http_output_body_filter_pt = ?*const fn ([*c]ngx_http_request_t, [*c]ngx_chain_t) callconv(.c) ngx_int_t;
pub const ngx_http_request_body_filter_pt = ?*const fn ([*c]ngx_http_request_t, [*c]ngx_chain_t) callconv(.c) ngx_int_t;
pub extern fn ngx_http_output_filter(r: [*c]ngx_http_request_t, chain: [*c]ngx_chain_t) ngx_int_t;
pub extern fn ngx_http_write_filter(r: [*c]ngx_http_request_t, chain: [*c]ngx_chain_t) ngx_int_t;
pub extern fn ngx_http_request_body_save_filter(r: [*c]ngx_http_request_t, chain: [*c]ngx_chain_t) ngx_int_t;
pub extern fn ngx_http_set_disable_symlinks(r: [*c]ngx_http_request_t, clcf: [*c]ngx_http_core_loc_conf_t, path: [*c]ngx_str_t, of: [*c]ngx_open_file_info_t) ngx_int_t;
pub extern fn ngx_http_get_forwarded_addr(r: [*c]ngx_http_request_t, addr: [*c]ngx_addr_t, headers: [*c]ngx_table_elt_t, value: [*c]ngx_str_t, proxies: [*c]ngx_array_t, recursive: c_int) ngx_int_t;
pub extern fn ngx_http_link_multi_headers(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern var ngx_http_core_module: ngx_module_t;
pub extern var ngx_http_max_module: ngx_uint_t;
pub extern var ngx_http_core_get_method: ngx_str_t;
pub const ngx_http_cache_valid_t = extern struct {
    status: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    valid: time_t = @import("std").mem.zeroes(time_t),
};
const ngx_http_file_cache_node_flags_t = packed struct {
    count: u20,
    uses: u10,
    valid_msec: u10,
    @"error": u10,
    exists: bool,
    updating: bool,
    deleting: bool,
    purged: bool,
    padding: u10,
};
pub const ngx_http_file_cache_node_t = extern struct {
    node: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    key: [8]u_char = @import("std").mem.zeroes([8]u_char),
    flags: ngx_http_file_cache_node_flags_t = @import("std").mem.zeroes(ngx_http_file_cache_node_flags_t),
    uniq: ngx_file_uniq_t = @import("std").mem.zeroes(ngx_file_uniq_t),
    expire: time_t = @import("std").mem.zeroes(time_t),
    valid_sec: time_t = @import("std").mem.zeroes(time_t),
    body_start: usize = @import("std").mem.zeroes(usize),
    fs_size: off_t = @import("std").mem.zeroes(off_t),
    lock_time: ngx_msec_t = @import("std").mem.zeroes(ngx_msec_t),
};
pub const ngx_http_file_cache_header_t = extern struct {
    version: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    valid_sec: time_t = @import("std").mem.zeroes(time_t),
    updating_sec: time_t = @import("std").mem.zeroes(time_t),
    error_sec: time_t = @import("std").mem.zeroes(time_t),
    last_modified: time_t = @import("std").mem.zeroes(time_t),
    date: time_t = @import("std").mem.zeroes(time_t),
    crc32: u32 = @import("std").mem.zeroes(u32),
    valid_msec: u_short = @import("std").mem.zeroes(u_short),
    header_start: u_short = @import("std").mem.zeroes(u_short),
    body_start: u_short = @import("std").mem.zeroes(u_short),
    etag_len: u_char = @import("std").mem.zeroes(u_char),
    etag: [128]u_char = @import("std").mem.zeroes([128]u_char),
    vary_len: u_char = @import("std").mem.zeroes(u_char),
    vary: [128]u_char = @import("std").mem.zeroes([128]u_char),
    variant: [16]u_char = @import("std").mem.zeroes([16]u_char),
};
pub const ngx_http_file_cache_sh_t = extern struct {
    rbtree: ngx_rbtree_t = @import("std").mem.zeroes(ngx_rbtree_t),
    sentinel: ngx_rbtree_node_t = @import("std").mem.zeroes(ngx_rbtree_node_t),
    queue: ngx_queue_t = @import("std").mem.zeroes(ngx_queue_t),
    cold: ngx_atomic_t = @import("std").mem.zeroes(ngx_atomic_t),
    loading: ngx_atomic_t = @import("std").mem.zeroes(ngx_atomic_t),
    size: off_t = @import("std").mem.zeroes(off_t),
    count: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    watermark: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub extern fn ngx_http_file_cache_new(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_file_cache_create(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_file_cache_create_key(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_file_cache_open(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_file_cache_set_header(r: [*c]ngx_http_request_t, buf: [*c]u_char) ngx_int_t;
pub extern fn ngx_http_file_cache_update(r: [*c]ngx_http_request_t, tf: [*c]ngx_temp_file_t) void;
pub extern fn ngx_http_file_cache_update_header(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_cache_send([*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_file_cache_free(c: [*c]ngx_http_cache_t, tf: [*c]ngx_temp_file_t) void;
pub extern fn ngx_http_file_cache_valid(cache_valid: [*c]ngx_array_t, status: ngx_uint_t) time_t;
pub extern fn ngx_http_file_cache_set_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_http_file_cache_valid_set_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub const ngx_http_cache_status: [*c]ngx_str_t = @extern([*c]ngx_str_t, .{
    .name = "ngx_http_cache_status",
});
pub const ngx_http_ssi_main_conf_t = extern struct {
    hash: ngx_hash_t = @import("std").mem.zeroes(ngx_hash_t),
    commands: ngx_hash_keys_arrays_t = @import("std").mem.zeroes(ngx_hash_keys_arrays_t),
};
pub const ngx_http_ssi_ctx_t = extern struct {
    buf: [*c]ngx_buf_t = @import("std").mem.zeroes([*c]ngx_buf_t),
    pos: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    copy_start: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    copy_end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    key: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    command: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    params: ngx_array_t = @import("std").mem.zeroes(ngx_array_t),
    param: [*c]ngx_table_elt_t = @import("std").mem.zeroes([*c]ngx_table_elt_t),
    params_array: [4]ngx_table_elt_t = @import("std").mem.zeroes([4]ngx_table_elt_t),
    in: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    out: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    last_out: [*c][*c]ngx_chain_t = @import("std").mem.zeroes([*c][*c]ngx_chain_t),
    busy: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    free: [*c]ngx_chain_t = @import("std").mem.zeroes([*c]ngx_chain_t),
    state: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    saved_state: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    saved: usize = @import("std").mem.zeroes(usize),
    looked: usize = @import("std").mem.zeroes(usize),
    value_len: usize = @import("std").mem.zeroes(usize),
    variables: [*c]ngx_list_t = @import("std").mem.zeroes([*c]ngx_list_t),
    blocks: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    ncaptures: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    captures: [*c]c_int = @import("std").mem.zeroes([*c]c_int),
    captures_data: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    wait: [*c]ngx_http_request_t = @import("std").mem.zeroes([*c]ngx_http_request_t),
    value_buf: ?*anyopaque = @import("std").mem.zeroes(?*anyopaque),
    timefmt: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    errmsg: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub const ngx_http_ssi_command_pt = ?*const fn ([*c]ngx_http_request_t, [*c]ngx_http_ssi_ctx_t, [*c][*c]ngx_str_t) callconv(.c) ngx_int_t;
pub const ngx_http_ssi_param_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    index: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
};
pub const ngx_http_ssi_command_t = extern struct {
    name: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    handler: ngx_http_ssi_command_pt = @import("std").mem.zeroes(ngx_http_ssi_command_pt),
    params: [*c]ngx_http_ssi_param_t = @import("std").mem.zeroes([*c]ngx_http_ssi_param_t),
};
pub extern var ngx_http_ssi_filter_module: ngx_module_t;
pub const ngx_http_ssl_srv_conf_t = extern struct {
    ssl: ngx_ssl_t = @import("std").mem.zeroes(ngx_ssl_t),
    prefer_server_ciphers: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    early_data: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    reject_handshake: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    protocols: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    verify: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    verify_depth: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    buffer_size: usize = @import("std").mem.zeroes(usize),
    builtin_session_cache: isize = @import("std").mem.zeroes(isize),
    session_timeout: time_t = @import("std").mem.zeroes(time_t),
    certificates: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    certificate_keys: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    certificate_values: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    certificate_key_values: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    dhparam: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    ecdh_curve: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    client_certificate: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    trusted_certificate: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    crl: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    ciphers: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    passwords: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    conf_commands: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    shm_zone: [*c]ngx_shm_zone_t = @import("std").mem.zeroes([*c]ngx_shm_zone_t),
    session_tickets: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    session_ticket_keys: [*c]ngx_array_t = @import("std").mem.zeroes([*c]ngx_array_t),
    ocsp: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    ocsp_responder: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    ocsp_cache_zone: [*c]ngx_shm_zone_t = @import("std").mem.zeroes([*c]ngx_shm_zone_t),
    stapling: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    stapling_verify: ngx_flag_t = @import("std").mem.zeroes(ngx_flag_t),
    stapling_file: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
    stapling_responder: ngx_str_t = @import("std").mem.zeroes(ngx_str_t),
};
pub extern var ngx_http_ssl_module: ngx_module_t;
pub const ngx_http_status_t = extern struct {
    http_version: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    code: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    count: ngx_uint_t = @import("std").mem.zeroes(ngx_uint_t),
    start: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
    end: [*c]u_char = @import("std").mem.zeroes([*c]u_char),
};
pub extern fn ngx_http_add_location(cf: [*c]ngx_conf_t, locations: [*c][*c]ngx_queue_t, clcf: [*c]ngx_http_core_loc_conf_t) ngx_int_t;
pub extern fn ngx_http_add_listen(cf: [*c]ngx_conf_t, cscf: [*c]ngx_http_core_srv_conf_t, lsopt: [*c]ngx_http_listen_opt_t) ngx_int_t;
pub extern fn ngx_http_init_connection(c: [*c]ngx_connection_t) void;
pub extern fn ngx_http_close_connection(c: [*c]ngx_connection_t) void;
pub extern fn ngx_http_ssl_servername(ssl_conn: ?*SSL, ad: [*c]c_int, arg: ?*anyopaque) c_int;
pub extern fn ngx_http_ssl_certificate(ssl_conn: ?*SSL, arg: ?*anyopaque) c_int;
pub extern fn ngx_http_parse_request_line(r: [*c]ngx_http_request_t, b: [*c]ngx_buf_t) ngx_int_t;
pub extern fn ngx_http_parse_uri(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_parse_complex_uri(r: [*c]ngx_http_request_t, merge_slashes: ngx_uint_t) ngx_int_t;
pub extern fn ngx_http_parse_status_line(r: [*c]ngx_http_request_t, b: [*c]ngx_buf_t, status: [*c]ngx_http_status_t) ngx_int_t;
pub extern fn ngx_http_parse_unsafe_uri(r: [*c]ngx_http_request_t, uri: [*c]ngx_str_t, args: [*c]ngx_str_t, flags: [*c]ngx_uint_t) ngx_int_t;
pub extern fn ngx_http_parse_header_line(r: [*c]ngx_http_request_t, b: [*c]ngx_buf_t, allow_underscores: ngx_uint_t) ngx_int_t;
pub extern fn ngx_http_parse_multi_header_lines(r: [*c]ngx_http_request_t, headers: [*c]ngx_table_elt_t, name: [*c]ngx_str_t, value: [*c]ngx_str_t) [*c]ngx_table_elt_t;
pub extern fn ngx_http_parse_set_cookie_lines(r: [*c]ngx_http_request_t, headers: [*c]ngx_table_elt_t, name: [*c]ngx_str_t, value: [*c]ngx_str_t) [*c]ngx_table_elt_t;
pub extern fn ngx_http_arg(r: [*c]ngx_http_request_t, name: [*c]u_char, len: usize, value: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_http_split_args(r: [*c]ngx_http_request_t, uri: [*c]ngx_str_t, args: [*c]ngx_str_t) void;
pub extern fn ngx_http_parse_chunked(r: [*c]ngx_http_request_t, b: [*c]ngx_buf_t, ctx: [*c]ngx_http_chunked_t, keep_trailers: ngx_uint_t) ngx_int_t;
pub extern fn ngx_http_create_request(c: [*c]ngx_connection_t) [*c]ngx_http_request_t;
pub extern fn ngx_http_process_request_uri(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_process_request_header(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_process_request(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_update_location_config(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_handler(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_run_posted_requests(c: [*c]ngx_connection_t) void;
pub extern fn ngx_http_post_request(r: [*c]ngx_http_request_t, pr: [*c]ngx_http_posted_request_t) ngx_int_t;
pub extern fn ngx_http_set_virtual_server(r: [*c]ngx_http_request_t, host: [*c]ngx_str_t) ngx_int_t;
pub extern fn ngx_http_validate_host(host: [*c]ngx_str_t, pool: [*c]ngx_pool_t, alloc: ngx_uint_t) ngx_int_t;
pub extern fn ngx_http_close_request(r: [*c]ngx_http_request_t, rc: ngx_int_t) void;
pub extern fn ngx_http_finalize_request(r: [*c]ngx_http_request_t, rc: ngx_int_t) void;
pub extern fn ngx_http_free_request(r: [*c]ngx_http_request_t, rc: ngx_int_t) void;
pub extern fn ngx_http_empty_handler(wev: [*c]ngx_event_t) void;
pub extern fn ngx_http_request_empty_handler(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_send_special(r: [*c]ngx_http_request_t, flags: ngx_uint_t) ngx_int_t;
pub extern fn ngx_http_read_client_request_body(r: [*c]ngx_http_request_t, post_handler: ngx_http_client_body_handler_pt) ngx_int_t;
pub extern fn ngx_http_read_unbuffered_request_body(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_send_header(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_special_response_handler(r: [*c]ngx_http_request_t, @"error": ngx_int_t) ngx_int_t;
pub extern fn ngx_http_filter_finalize_request(r: [*c]ngx_http_request_t, m: [*c]ngx_module_t, @"error": ngx_int_t) ngx_int_t;
pub extern fn ngx_http_clean_header(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_discard_request_body(r: [*c]ngx_http_request_t) ngx_int_t;
pub extern fn ngx_http_discarded_request_body_handler(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_block_reading(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_test_reading(r: [*c]ngx_http_request_t) void;
pub extern fn ngx_http_types_slot(cf: [*c]ngx_conf_t, cmd: [*c]ngx_command_t, conf: ?*anyopaque) [*c]u8;
pub extern fn ngx_http_merge_types(cf: [*c]ngx_conf_t, keys: [*c][*c]ngx_array_t, types_hash: [*c]ngx_hash_t, prev_keys: [*c][*c]ngx_array_t, prev_types_hash: [*c]ngx_hash_t, default_types: [*c]ngx_str_t) [*c]u8;
pub extern fn ngx_http_set_default_types(cf: [*c]ngx_conf_t, types: [*c][*c]ngx_array_t, default_type: [*c]ngx_str_t) ngx_int_t;
pub extern var ngx_http_module: ngx_module_t;
pub const ngx_http_html_default_types: [*c]ngx_str_t = @extern([*c]ngx_str_t, .{
    .name = "ngx_http_html_default_types",
});
pub extern var ngx_http_top_header_filter: ngx_http_output_header_filter_pt;
pub extern var ngx_http_top_body_filter: ngx_http_output_body_filter_pt;
pub extern var ngx_http_top_request_body_filter: ngx_http_request_body_filter_pt;
pub const __llvm__ = @as(c_int, 1);
pub const __clang__ = @as(c_int, 1);
pub const __clang_major__ = @as(c_int, 18);
pub const __clang_minor__ = @as(c_int, 1);
pub const __clang_patchlevel__ = @as(c_int, 6);
pub const __clang_version__ = "18.1.6 (https://github.com/ziglang/zig-bootstrap 98bc6bf4fc4009888d33941daf6b600d20a42a56)";
pub const __GNUC__ = @as(c_int, 4);
pub const __GNUC_MINOR__ = @as(c_int, 2);
pub const __GNUC_PATCHLEVEL__ = @as(c_int, 1);
pub const __GXX_ABI_VERSION = @as(c_int, 1002);
pub const __ATOMIC_RELAXED = @as(c_int, 0);
pub const __ATOMIC_CONSUME = @as(c_int, 1);
pub const __ATOMIC_ACQUIRE = @as(c_int, 2);
pub const __ATOMIC_RELEASE = @as(c_int, 3);
pub const __ATOMIC_ACQ_REL = @as(c_int, 4);
pub const __ATOMIC_SEQ_CST = @as(c_int, 5);
pub const __MEMORY_SCOPE_SYSTEM = @as(c_int, 0);
pub const __MEMORY_SCOPE_DEVICE = @as(c_int, 1);
pub const __MEMORY_SCOPE_WRKGRP = @as(c_int, 2);
pub const __MEMORY_SCOPE_WVFRNT = @as(c_int, 3);
pub const __MEMORY_SCOPE_SINGLE = @as(c_int, 4);
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = @as(c_int, 0);
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = @as(c_int, 1);
pub const __OPENCL_MEMORY_SCOPE_DEVICE = @as(c_int, 2);
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = @as(c_int, 3);
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = @as(c_int, 4);
pub const __FPCLASS_SNAN = @as(c_int, 0x0001);
pub const __FPCLASS_QNAN = @as(c_int, 0x0002);
pub const __FPCLASS_NEGINF = @as(c_int, 0x0004);
pub const __FPCLASS_NEGNORMAL = @as(c_int, 0x0008);
pub const __FPCLASS_NEGSUBNORMAL = @as(c_int, 0x0010);
pub const __FPCLASS_NEGZERO = @as(c_int, 0x0020);
pub const __FPCLASS_POSZERO = @as(c_int, 0x0040);
pub const __FPCLASS_POSSUBNORMAL = @as(c_int, 0x0080);
pub const __FPCLASS_POSNORMAL = @as(c_int, 0x0100);
pub const __FPCLASS_POSINF = @as(c_int, 0x0200);
pub const __PRAGMA_REDEFINE_EXTNAME = @as(c_int, 1);
pub const __VERSION__ = "Clang 18.1.6 (https://github.com/ziglang/zig-bootstrap 98bc6bf4fc4009888d33941daf6b600d20a42a56)";
pub const __OBJC_BOOL_IS_BOOL = @as(c_int, 0);
pub const __CONSTANT_CFSTRINGS__ = @as(c_int, 1);
pub const __clang_literal_encoding__ = "UTF-8";
pub const __clang_wide_literal_encoding__ = "UTF-32";
pub const __ORDER_LITTLE_ENDIAN__ = @as(c_int, 1234);
pub const __ORDER_BIG_ENDIAN__ = @as(c_int, 4321);
pub const __ORDER_PDP_ENDIAN__ = @as(c_int, 3412);
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const __LITTLE_ENDIAN__ = @as(c_int, 1);
pub const _LP64 = @as(c_int, 1);
pub const __LP64__ = @as(c_int, 1);
pub const __CHAR_BIT__ = @as(c_int, 8);
pub const __BOOL_WIDTH__ = @as(c_int, 8);
pub const __SHRT_WIDTH__ = @as(c_int, 16);
pub const __INT_WIDTH__ = @as(c_int, 32);
pub const __LONG_WIDTH__ = @as(c_int, 64);
pub const __LLONG_WIDTH__ = @as(c_int, 64);
pub const __BITINT_MAXWIDTH__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 8388608, .decimal);
pub const __SCHAR_MAX__ = @as(c_int, 127);
pub const __SHRT_MAX__ = @as(c_int, 32767);
pub const __INT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __LONG_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __LONG_LONG_MAX__ = @as(c_longlong, 9223372036854775807);
pub const __WCHAR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __WCHAR_WIDTH__ = @as(c_int, 32);
pub const __WINT_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __WINT_WIDTH__ = @as(c_int, 32);
pub const __INTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTMAX_WIDTH__ = @as(c_int, 64);
pub const __SIZE_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __SIZE_WIDTH__ = @as(c_int, 64);
pub const __UINTMAX_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTMAX_WIDTH__ = @as(c_int, 64);
pub const __PTRDIFF_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __PTRDIFF_WIDTH__ = @as(c_int, 64);
pub const __INTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INTPTR_WIDTH__ = @as(c_int, 64);
pub const __UINTPTR_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINTPTR_WIDTH__ = @as(c_int, 64);
pub const __SIZEOF_DOUBLE__ = @as(c_int, 8);
pub const __SIZEOF_FLOAT__ = @as(c_int, 4);
pub const __SIZEOF_INT__ = @as(c_int, 4);
pub const __SIZEOF_LONG__ = @as(c_int, 8);
pub const __SIZEOF_LONG_DOUBLE__ = @as(c_int, 16);
pub const __SIZEOF_LONG_LONG__ = @as(c_int, 8);
pub const __SIZEOF_POINTER__ = @as(c_int, 8);
pub const __SIZEOF_SHORT__ = @as(c_int, 2);
pub const __SIZEOF_PTRDIFF_T__ = @as(c_int, 8);
pub const __SIZEOF_SIZE_T__ = @as(c_int, 8);
pub const __SIZEOF_WCHAR_T__ = @as(c_int, 4);
pub const __SIZEOF_WINT_T__ = @as(c_int, 4);
pub const __SIZEOF_INT128__ = @as(c_int, 16);
pub const __INTMAX_TYPE__ = c_long;
pub const __INTMAX_FMTd__ = "ld";
pub const __INTMAX_FMTi__ = "li";
pub const __INTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `L`");
// (no file):95:9
pub const __UINTMAX_TYPE__ = c_ulong;
pub const __UINTMAX_FMTo__ = "lo";
pub const __UINTMAX_FMTu__ = "lu";
pub const __UINTMAX_FMTx__ = "lx";
pub const __UINTMAX_FMTX__ = "lX";
pub const __UINTMAX_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `UL`");
// (no file):101:9
pub const __PTRDIFF_TYPE__ = c_long;
pub const __PTRDIFF_FMTd__ = "ld";
pub const __PTRDIFF_FMTi__ = "li";
pub const __INTPTR_TYPE__ = c_long;
pub const __INTPTR_FMTd__ = "ld";
pub const __INTPTR_FMTi__ = "li";
pub const __SIZE_TYPE__ = c_ulong;
pub const __SIZE_FMTo__ = "lo";
pub const __SIZE_FMTu__ = "lu";
pub const __SIZE_FMTx__ = "lx";
pub const __SIZE_FMTX__ = "lX";
pub const __WCHAR_TYPE__ = c_int;
pub const __WINT_TYPE__ = c_uint;
pub const __SIG_ATOMIC_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __SIG_ATOMIC_WIDTH__ = @as(c_int, 32);
pub const __CHAR16_TYPE__ = c_ushort;
pub const __CHAR32_TYPE__ = c_uint;
pub const __UINTPTR_TYPE__ = c_ulong;
pub const __UINTPTR_FMTo__ = "lo";
pub const __UINTPTR_FMTu__ = "lu";
pub const __UINTPTR_FMTx__ = "lx";
pub const __UINTPTR_FMTX__ = "lX";
pub const __FLT16_DENORM_MIN__ = @as(f16, 5.9604644775390625e-8);
pub const __FLT16_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT16_DIG__ = @as(c_int, 3);
pub const __FLT16_DECIMAL_DIG__ = @as(c_int, 5);
pub const __FLT16_EPSILON__ = @as(f16, 9.765625e-4);
pub const __FLT16_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT16_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT16_MANT_DIG__ = @as(c_int, 11);
pub const __FLT16_MAX_10_EXP__ = @as(c_int, 4);
pub const __FLT16_MAX_EXP__ = @as(c_int, 16);
pub const __FLT16_MAX__ = @as(f16, 6.5504e+4);
pub const __FLT16_MIN_10_EXP__ = -@as(c_int, 4);
pub const __FLT16_MIN_EXP__ = -@as(c_int, 13);
pub const __FLT16_MIN__ = @as(f16, 6.103515625e-5);
pub const __FLT_DENORM_MIN__ = @as(f32, 1.40129846e-45);
pub const __FLT_HAS_DENORM__ = @as(c_int, 1);
pub const __FLT_DIG__ = @as(c_int, 6);
pub const __FLT_DECIMAL_DIG__ = @as(c_int, 9);
pub const __FLT_EPSILON__ = @as(f32, 1.19209290e-7);
pub const __FLT_HAS_INFINITY__ = @as(c_int, 1);
pub const __FLT_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __FLT_MANT_DIG__ = @as(c_int, 24);
pub const __FLT_MAX_10_EXP__ = @as(c_int, 38);
pub const __FLT_MAX_EXP__ = @as(c_int, 128);
pub const __FLT_MAX__ = @as(f32, 3.40282347e+38);
pub const __FLT_MIN_10_EXP__ = -@as(c_int, 37);
pub const __FLT_MIN_EXP__ = -@as(c_int, 125);
pub const __FLT_MIN__ = @as(f32, 1.17549435e-38);
pub const __DBL_DENORM_MIN__ = @as(f64, 4.9406564584124654e-324);
pub const __DBL_HAS_DENORM__ = @as(c_int, 1);
pub const __DBL_DIG__ = @as(c_int, 15);
pub const __DBL_DECIMAL_DIG__ = @as(c_int, 17);
pub const __DBL_EPSILON__ = @as(f64, 2.2204460492503131e-16);
pub const __DBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __DBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __DBL_MANT_DIG__ = @as(c_int, 53);
pub const __DBL_MAX_10_EXP__ = @as(c_int, 308);
pub const __DBL_MAX_EXP__ = @as(c_int, 1024);
pub const __DBL_MAX__ = @as(f64, 1.7976931348623157e+308);
pub const __DBL_MIN_10_EXP__ = -@as(c_int, 307);
pub const __DBL_MIN_EXP__ = -@as(c_int, 1021);
pub const __DBL_MIN__ = @as(f64, 2.2250738585072014e-308);
pub const __LDBL_DENORM_MIN__ = @as(c_longdouble, 3.64519953188247460253e-4951);
pub const __LDBL_HAS_DENORM__ = @as(c_int, 1);
pub const __LDBL_DIG__ = @as(c_int, 18);
pub const __LDBL_DECIMAL_DIG__ = @as(c_int, 21);
pub const __LDBL_EPSILON__ = @as(c_longdouble, 1.08420217248550443401e-19);
pub const __LDBL_HAS_INFINITY__ = @as(c_int, 1);
pub const __LDBL_HAS_QUIET_NAN__ = @as(c_int, 1);
pub const __LDBL_MANT_DIG__ = @as(c_int, 64);
pub const __LDBL_MAX_10_EXP__ = @as(c_int, 4932);
pub const __LDBL_MAX_EXP__ = @as(c_int, 16384);
pub const __LDBL_MAX__ = @as(c_longdouble, 1.18973149535723176502e+4932);
pub const __LDBL_MIN_10_EXP__ = -@as(c_int, 4931);
pub const __LDBL_MIN_EXP__ = -@as(c_int, 16381);
pub const __LDBL_MIN__ = @as(c_longdouble, 3.36210314311209350626e-4932);
pub const __POINTER_WIDTH__ = @as(c_int, 64);
pub const __BIGGEST_ALIGNMENT__ = @as(c_int, 16);
pub const __WINT_UNSIGNED__ = @as(c_int, 1);
pub const __INT8_TYPE__ = i8;
pub const __INT8_FMTd__ = "hhd";
pub const __INT8_FMTi__ = "hhi";
pub const __INT8_C_SUFFIX__ = "";
pub const __INT16_TYPE__ = c_short;
pub const __INT16_FMTd__ = "hd";
pub const __INT16_FMTi__ = "hi";
pub const __INT16_C_SUFFIX__ = "";
pub const __INT32_TYPE__ = c_int;
pub const __INT32_FMTd__ = "d";
pub const __INT32_FMTi__ = "i";
pub const __INT32_C_SUFFIX__ = "";
pub const __INT64_TYPE__ = c_long;
pub const __INT64_FMTd__ = "ld";
pub const __INT64_FMTi__ = "li";
pub const __INT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `L`");
// (no file):198:9
pub const __UINT8_TYPE__ = u8;
pub const __UINT8_FMTo__ = "hho";
pub const __UINT8_FMTu__ = "hhu";
pub const __UINT8_FMTx__ = "hhx";
pub const __UINT8_FMTX__ = "hhX";
pub const __UINT8_C_SUFFIX__ = "";
pub const __UINT8_MAX__ = @as(c_int, 255);
pub const __INT8_MAX__ = @as(c_int, 127);
pub const __UINT16_TYPE__ = c_ushort;
pub const __UINT16_FMTo__ = "ho";
pub const __UINT16_FMTu__ = "hu";
pub const __UINT16_FMTx__ = "hx";
pub const __UINT16_FMTX__ = "hX";
pub const __UINT16_C_SUFFIX__ = "";
pub const __UINT16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __INT16_MAX__ = @as(c_int, 32767);
pub const __UINT32_TYPE__ = c_uint;
pub const __UINT32_FMTo__ = "o";
pub const __UINT32_FMTu__ = "u";
pub const __UINT32_FMTx__ = "x";
pub const __UINT32_FMTX__ = "X";
pub const __UINT32_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `U`");
// (no file):220:9
pub const __UINT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __INT32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __UINT64_TYPE__ = c_ulong;
pub const __UINT64_FMTo__ = "lo";
pub const __UINT64_FMTu__ = "lu";
pub const __UINT64_FMTx__ = "lx";
pub const __UINT64_FMTX__ = "lX";
pub const __UINT64_C_SUFFIX__ = @compileError("unable to translate macro: undefined identifier `UL`");
// (no file):228:9
pub const __UINT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __INT64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST8_TYPE__ = i8;
pub const __INT_LEAST8_MAX__ = @as(c_int, 127);
pub const __INT_LEAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_LEAST8_FMTd__ = "hhd";
pub const __INT_LEAST8_FMTi__ = "hhi";
pub const __UINT_LEAST8_TYPE__ = u8;
pub const __UINT_LEAST8_MAX__ = @as(c_int, 255);
pub const __UINT_LEAST8_FMTo__ = "hho";
pub const __UINT_LEAST8_FMTu__ = "hhu";
pub const __UINT_LEAST8_FMTx__ = "hhx";
pub const __UINT_LEAST8_FMTX__ = "hhX";
pub const __INT_LEAST16_TYPE__ = c_short;
pub const __INT_LEAST16_MAX__ = @as(c_int, 32767);
pub const __INT_LEAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_LEAST16_FMTd__ = "hd";
pub const __INT_LEAST16_FMTi__ = "hi";
pub const __UINT_LEAST16_TYPE__ = c_ushort;
pub const __UINT_LEAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_LEAST16_FMTo__ = "ho";
pub const __UINT_LEAST16_FMTu__ = "hu";
pub const __UINT_LEAST16_FMTx__ = "hx";
pub const __UINT_LEAST16_FMTX__ = "hX";
pub const __INT_LEAST32_TYPE__ = c_int;
pub const __INT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_LEAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_LEAST32_FMTd__ = "d";
pub const __INT_LEAST32_FMTi__ = "i";
pub const __UINT_LEAST32_TYPE__ = c_uint;
pub const __UINT_LEAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_LEAST32_FMTo__ = "o";
pub const __UINT_LEAST32_FMTu__ = "u";
pub const __UINT_LEAST32_FMTx__ = "x";
pub const __UINT_LEAST32_FMTX__ = "X";
pub const __INT_LEAST64_TYPE__ = c_long;
pub const __INT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_LEAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_LEAST64_FMTd__ = "ld";
pub const __INT_LEAST64_FMTi__ = "li";
pub const __UINT_LEAST64_TYPE__ = c_ulong;
pub const __UINT_LEAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_LEAST64_FMTo__ = "lo";
pub const __UINT_LEAST64_FMTu__ = "lu";
pub const __UINT_LEAST64_FMTx__ = "lx";
pub const __UINT_LEAST64_FMTX__ = "lX";
pub const __INT_FAST8_TYPE__ = i8;
pub const __INT_FAST8_MAX__ = @as(c_int, 127);
pub const __INT_FAST8_WIDTH__ = @as(c_int, 8);
pub const __INT_FAST8_FMTd__ = "hhd";
pub const __INT_FAST8_FMTi__ = "hhi";
pub const __UINT_FAST8_TYPE__ = u8;
pub const __UINT_FAST8_MAX__ = @as(c_int, 255);
pub const __UINT_FAST8_FMTo__ = "hho";
pub const __UINT_FAST8_FMTu__ = "hhu";
pub const __UINT_FAST8_FMTx__ = "hhx";
pub const __UINT_FAST8_FMTX__ = "hhX";
pub const __INT_FAST16_TYPE__ = c_short;
pub const __INT_FAST16_MAX__ = @as(c_int, 32767);
pub const __INT_FAST16_WIDTH__ = @as(c_int, 16);
pub const __INT_FAST16_FMTd__ = "hd";
pub const __INT_FAST16_FMTi__ = "hi";
pub const __UINT_FAST16_TYPE__ = c_ushort;
pub const __UINT_FAST16_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const __UINT_FAST16_FMTo__ = "ho";
pub const __UINT_FAST16_FMTu__ = "hu";
pub const __UINT_FAST16_FMTx__ = "hx";
pub const __UINT_FAST16_FMTX__ = "hX";
pub const __INT_FAST32_TYPE__ = c_int;
pub const __INT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const __INT_FAST32_WIDTH__ = @as(c_int, 32);
pub const __INT_FAST32_FMTd__ = "d";
pub const __INT_FAST32_FMTi__ = "i";
pub const __UINT_FAST32_TYPE__ = c_uint;
pub const __UINT_FAST32_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const __UINT_FAST32_FMTo__ = "o";
pub const __UINT_FAST32_FMTu__ = "u";
pub const __UINT_FAST32_FMTx__ = "x";
pub const __UINT_FAST32_FMTX__ = "X";
pub const __INT_FAST64_TYPE__ = c_long;
pub const __INT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const __INT_FAST64_WIDTH__ = @as(c_int, 64);
pub const __INT_FAST64_FMTd__ = "ld";
pub const __INT_FAST64_FMTi__ = "li";
pub const __UINT_FAST64_TYPE__ = c_ulong;
pub const __UINT_FAST64_MAX__ = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const __UINT_FAST64_FMTo__ = "lo";
pub const __UINT_FAST64_FMTu__ = "lu";
pub const __UINT_FAST64_FMTx__ = "lx";
pub const __UINT_FAST64_FMTX__ = "lX";
pub const __USER_LABEL_PREFIX__ = "";
pub const __FINITE_MATH_ONLY__ = @as(c_int, 0);
pub const __GNUC_STDC_INLINE__ = @as(c_int, 1);
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL = @as(c_int, 1);
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_BOOL_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_SHORT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_INT_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_LLONG_LOCK_FREE = @as(c_int, 2);
pub const __GCC_ATOMIC_POINTER_LOCK_FREE = @as(c_int, 2);
pub const __NO_INLINE__ = @as(c_int, 1);
pub const __PIC__ = @as(c_int, 2);
pub const __pic__ = @as(c_int, 2);
pub const __PIE__ = @as(c_int, 2);
pub const __pie__ = @as(c_int, 2);
pub const __FLT_RADIX__ = @as(c_int, 2);
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const __ELF__ = @as(c_int, 1);
pub const __GCC_ASM_FLAG_OUTPUTS__ = @as(c_int, 1);
pub const __code_model_small__ = @as(c_int, 1);
pub const __amd64__ = @as(c_int, 1);
pub const __amd64 = @as(c_int, 1);
pub const __x86_64 = @as(c_int, 1);
pub const __x86_64__ = @as(c_int, 1);
pub const __SEG_GS = @as(c_int, 1);
pub const __SEG_FS = @as(c_int, 1);
pub const __seg_gs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):359:9
pub const __seg_fs = @compileError("unable to translate macro: undefined identifier `address_space`");
// (no file):360:9
pub const __corei7 = @as(c_int, 1);
pub const __corei7__ = @as(c_int, 1);
pub const __tune_corei7__ = @as(c_int, 1);
pub const __REGISTER_PREFIX__ = "";
pub const __NO_MATH_INLINES = @as(c_int, 1);
pub const __LAHF_SAHF__ = @as(c_int, 1);
pub const __POPCNT__ = @as(c_int, 1);
pub const __FXSR__ = @as(c_int, 1);
pub const __CRC32__ = @as(c_int, 1);
pub const __SSE4_2__ = @as(c_int, 1);
pub const __SSE4_1__ = @as(c_int, 1);
pub const __SSSE3__ = @as(c_int, 1);
pub const __SSE3__ = @as(c_int, 1);
pub const __SSE2__ = @as(c_int, 1);
pub const __SSE2_MATH__ = @as(c_int, 1);
pub const __SSE__ = @as(c_int, 1);
pub const __SSE_MATH__ = @as(c_int, 1);
pub const __MMX__ = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = @as(c_int, 1);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = @as(c_int, 1);
pub const __SIZEOF_FLOAT128__ = @as(c_int, 16);
pub const unix = @as(c_int, 1);
pub const __unix = @as(c_int, 1);
pub const __unix__ = @as(c_int, 1);
pub const linux = @as(c_int, 1);
pub const __linux = @as(c_int, 1);
pub const __linux__ = @as(c_int, 1);
pub const __gnu_linux__ = @as(c_int, 1);
pub const __FLOAT128__ = @as(c_int, 1);
pub const __STDC__ = @as(c_int, 1);
pub const __STDC_HOSTED__ = @as(c_int, 1);
pub const __STDC_VERSION__ = @as(c_long, 201710);
pub const __STDC_UTF_16__ = @as(c_int, 1);
pub const __STDC_UTF_32__ = @as(c_int, 1);
pub const _DEBUG = @as(c_int, 1);
pub const __GCC_HAVE_DWARF2_CFI_ASM = @as(c_int, 1);
pub const _NGX_HTTP_H_INCLUDED_ = "";
pub const _NGX_CONFIG_H_INCLUDED_ = "";
pub const NGX_HAVE_UNISTD_H = @as(c_int, 1);
pub const NGX_HAVE_INTTYPES_H = @as(c_int, 1);
pub const NGX_HAVE_LIMITS_H = @as(c_int, 1);
pub const NGX_HAVE_SYS_PARAM_H = @as(c_int, 1);
pub const NGX_HAVE_SYS_MOUNT_H = @as(c_int, 1);
pub const NGX_HAVE_SYS_STATVFS_H = @as(c_int, 1);
pub const NGX_HAVE_CRYPT_H = @as(c_int, 1);
pub const NGX_LINUX = @as(c_int, 1);
pub const NGX_HAVE_SYS_PRCTL_H = @as(c_int, 1);
pub const NGX_HAVE_SYS_VFS_H = @as(c_int, 1);
pub const _NGX_LINUX_CONFIG_H_INCLUDED_ = "";
pub const _GNU_SOURCE = "";
pub const _FILE_OFFSET_BITS = @as(c_int, 64);
pub const _SYS_TYPES_H = @as(c_int, 1);
pub const _FEATURES_H = @as(c_int, 1);
pub const __KERNEL_STRICT_NAMES = "";
pub inline fn __GNUC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    _ = &maj;
    _ = &min;
    return ((__GNUC__ << @as(c_int, 16)) + __GNUC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub inline fn __glibc_clang_prereq(maj: anytype, min: anytype) @TypeOf(((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min)) {
    _ = &maj;
    _ = &min;
    return ((__clang_major__ << @as(c_int, 16)) + __clang_minor__) >= ((maj << @as(c_int, 16)) + min);
}
pub const __GLIBC_USE = @compileError("unable to translate macro: undefined identifier `__GLIBC_USE_`");
// /usr/include/features.h:189:9
pub const _ISOC95_SOURCE = @as(c_int, 1);
pub const _ISOC99_SOURCE = @as(c_int, 1);
pub const _ISOC11_SOURCE = @as(c_int, 1);
pub const _ISOC23_SOURCE = @as(c_int, 1);
pub const _POSIX_SOURCE = @as(c_int, 1);
pub const _POSIX_C_SOURCE = @as(c_long, 200809);
pub const _XOPEN_SOURCE = @as(c_int, 700);
pub const _XOPEN_SOURCE_EXTENDED = @as(c_int, 1);
pub const _LARGEFILE64_SOURCE = @as(c_int, 1);
pub const _DEFAULT_SOURCE = @as(c_int, 1);
pub const _ATFILE_SOURCE = @as(c_int, 1);
pub const _DYNAMIC_STACK_SIZE_SOURCE = @as(c_int, 1);
pub const __GLIBC_USE_ISOC23 = @as(c_int, 1);
pub const __USE_ISOC11 = @as(c_int, 1);
pub const __USE_ISOC99 = @as(c_int, 1);
pub const __USE_ISOC95 = @as(c_int, 1);
pub const __USE_POSIX = @as(c_int, 1);
pub const __USE_POSIX2 = @as(c_int, 1);
pub const __USE_POSIX199309 = @as(c_int, 1);
pub const __USE_POSIX199506 = @as(c_int, 1);
pub const __USE_XOPEN2K = @as(c_int, 1);
pub const __USE_XOPEN2K8 = @as(c_int, 1);
pub const __USE_XOPEN = @as(c_int, 1);
pub const __USE_XOPEN_EXTENDED = @as(c_int, 1);
pub const __USE_UNIX98 = @as(c_int, 1);
pub const _LARGEFILE_SOURCE = @as(c_int, 1);
pub const __USE_XOPEN2K8XSI = @as(c_int, 1);
pub const __USE_XOPEN2KXSI = @as(c_int, 1);
pub const __USE_LARGEFILE = @as(c_int, 1);
pub const __USE_LARGEFILE64 = @as(c_int, 1);
pub const __USE_FILE_OFFSET64 = @as(c_int, 1);
pub const __WORDSIZE = @as(c_int, 64);
pub const __WORDSIZE_TIME64_COMPAT32 = @as(c_int, 1);
pub const __SYSCALL_WORDSIZE = @as(c_int, 64);
pub const __TIMESIZE = __WORDSIZE;
pub const __USE_TIME_BITS64 = @as(c_int, 1);
pub const __USE_MISC = @as(c_int, 1);
pub const __USE_ATFILE = @as(c_int, 1);
pub const __USE_DYNAMIC_STACK_SIZE = @as(c_int, 1);
pub const __USE_GNU = @as(c_int, 1);
pub const __USE_FORTIFY_LEVEL = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_GETS = @as(c_int, 0);
pub const __GLIBC_USE_DEPRECATED_SCANF = @as(c_int, 0);
pub const __GLIBC_USE_C23_STRTOL = @as(c_int, 1);
pub const _STDC_PREDEF_H = @as(c_int, 1);
pub const __STDC_IEC_559__ = @as(c_int, 1);
pub const __STDC_IEC_60559_BFP__ = @as(c_long, 201404);
pub const __STDC_IEC_559_COMPLEX__ = @as(c_int, 1);
pub const __STDC_IEC_60559_COMPLEX__ = @as(c_long, 201404);
pub const __STDC_ISO_10646__ = @as(c_long, 201706);
pub const __GNU_LIBRARY__ = @as(c_int, 6);
pub const __GLIBC__ = @as(c_int, 2);
pub const __GLIBC_MINOR__ = @as(c_int, 40);
pub inline fn __GLIBC_PREREQ(maj: anytype, min: anytype) @TypeOf(((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min)) {
    _ = &maj;
    _ = &min;
    return ((__GLIBC__ << @as(c_int, 16)) + __GLIBC_MINOR__) >= ((maj << @as(c_int, 16)) + min);
}
pub const _SYS_CDEFS_H = @as(c_int, 1);
pub const __glibc_has_attribute = @compileError("unable to translate macro: undefined identifier `__has_attribute`");
// /usr/include/sys/cdefs.h:45:10
pub inline fn __glibc_has_builtin(name: anytype) @TypeOf(__has_builtin(name)) {
    _ = &name;
    return __has_builtin(name);
}
pub const __glibc_has_extension = @compileError("unable to translate macro: undefined identifier `__has_extension`");
// /usr/include/sys/cdefs.h:55:10
pub const __LEAF = "";
pub const __LEAF_ATTR = "";
pub const __THROW = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/sys/cdefs.h:79:11
pub const __THROWNL = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/sys/cdefs.h:80:11
pub const __NTH = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/sys/cdefs.h:81:11
pub const __NTHNL = @compileError("unable to translate macro: undefined identifier `__nothrow__`");
// /usr/include/sys/cdefs.h:82:11
pub const __COLD = @compileError("unable to translate macro: undefined identifier `__cold__`");
// /usr/include/sys/cdefs.h:102:11
pub inline fn __P(args: anytype) @TypeOf(args) {
    _ = &args;
    return args;
}
pub inline fn __PMT(args: anytype) @TypeOf(args) {
    _ = &args;
    return args;
}
pub const __CONCAT = @compileError("unable to translate C expr: unexpected token '##'");
// /usr/include/sys/cdefs.h:131:9
pub const __STRING = @compileError("unable to translate C expr: unexpected token '#'");
// /usr/include/sys/cdefs.h:132:9
pub const __ptr_t = ?*anyopaque;
pub const __BEGIN_DECLS = "";
pub const __END_DECLS = "";
pub const __attribute_overloadable__ = @compileError("unable to translate macro: undefined identifier `__overloadable__`");
// /usr/include/sys/cdefs.h:151:10
pub inline fn __bos(ptr: anytype) @TypeOf(__builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1))) {
    _ = &ptr;
    return __builtin_object_size(ptr, __USE_FORTIFY_LEVEL > @as(c_int, 1));
}
pub inline fn __bos0(ptr: anytype) @TypeOf(__builtin_object_size(ptr, @as(c_int, 0))) {
    _ = &ptr;
    return __builtin_object_size(ptr, @as(c_int, 0));
}
pub inline fn __glibc_objsize0(__o: anytype) @TypeOf(__bos0(__o)) {
    _ = &__o;
    return __bos0(__o);
}
pub inline fn __glibc_objsize(__o: anytype) @TypeOf(__bos(__o)) {
    _ = &__o;
    return __bos(__o);
}
pub const __warnattr = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/sys/cdefs.h:370:10
pub const __errordecl = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/sys/cdefs.h:371:10
pub const __flexarr = @compileError("unable to translate C expr: unexpected token '['");
// /usr/include/sys/cdefs.h:379:10
pub const __glibc_c99_flexarr_available = @as(c_int, 1);
pub const __REDIRECT = @compileError("unable to translate C expr: unexpected token '__asm__'");
// /usr/include/sys/cdefs.h:410:10
pub const __REDIRECT_NTH = @compileError("unable to translate C expr: unexpected token '__asm__'");
// /usr/include/sys/cdefs.h:417:11
pub const __REDIRECT_NTHNL = @compileError("unable to translate C expr: unexpected token '__asm__'");
// /usr/include/sys/cdefs.h:419:11
pub const __ASMNAME = @compileError("unable to translate C expr: unexpected token ','");
// /usr/include/sys/cdefs.h:422:10
pub inline fn __ASMNAME2(prefix: anytype, cname: anytype) @TypeOf(__STRING(prefix) ++ cname) {
    _ = &prefix;
    _ = &cname;
    return __STRING(prefix) ++ cname;
}
pub const __REDIRECT_FORTIFY = __REDIRECT;
pub const __REDIRECT_FORTIFY_NTH = __REDIRECT_NTH;
pub const __attribute_malloc__ = @compileError("unable to translate macro: undefined identifier `__malloc__`");
// /usr/include/sys/cdefs.h:452:10
pub const __attribute_alloc_size__ = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/sys/cdefs.h:463:10
pub const __attribute_alloc_align__ = @compileError("unable to translate macro: undefined identifier `__alloc_align__`");
// /usr/include/sys/cdefs.h:469:10
pub const __attribute_pure__ = @compileError("unable to translate macro: undefined identifier `__pure__`");
// /usr/include/sys/cdefs.h:479:10
pub const __attribute_const__ = @compileError("unable to translate C expr: unexpected token '__attribute__'");
// /usr/include/sys/cdefs.h:486:10
pub const __attribute_maybe_unused__ = @compileError("unable to translate macro: undefined identifier `__unused__`");
// /usr/include/sys/cdefs.h:492:10
pub const __attribute_used__ = @compileError("unable to translate macro: undefined identifier `__used__`");
// /usr/include/sys/cdefs.h:501:10
pub const __attribute_noinline__ = @compileError("unable to translate macro: undefined identifier `__noinline__`");
// /usr/include/sys/cdefs.h:502:10
pub const __attribute_deprecated__ = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// /usr/include/sys/cdefs.h:510:10
pub const __attribute_deprecated_msg__ = @compileError("unable to translate macro: undefined identifier `__deprecated__`");
// /usr/include/sys/cdefs.h:520:10
pub const __attribute_format_arg__ = @compileError("unable to translate macro: undefined identifier `__format_arg__`");
// /usr/include/sys/cdefs.h:533:10
pub const __attribute_format_strfmon__ = @compileError("unable to translate macro: undefined identifier `__format__`");
// /usr/include/sys/cdefs.h:543:10
pub const __attribute_nonnull__ = @compileError("unable to translate macro: undefined identifier `__nonnull__`");
// /usr/include/sys/cdefs.h:555:11
pub inline fn __nonnull(params: anytype) @TypeOf(__attribute_nonnull__(params)) {
    _ = &params;
    return __attribute_nonnull__(params);
}
pub const __returns_nonnull = @compileError("unable to translate macro: undefined identifier `__returns_nonnull__`");
// /usr/include/sys/cdefs.h:568:10
pub const __attribute_warn_unused_result__ = @compileError("unable to translate macro: undefined identifier `__warn_unused_result__`");
// /usr/include/sys/cdefs.h:577:10
pub const __wur = "";
pub const __always_inline = @compileError("unable to translate macro: undefined identifier `__always_inline__`");
// /usr/include/sys/cdefs.h:595:10
pub const __attribute_artificial__ = @compileError("unable to translate macro: undefined identifier `__artificial__`");
// /usr/include/sys/cdefs.h:604:10
pub const __extern_inline = @compileError("unable to translate macro: undefined identifier `__gnu_inline__`");
// /usr/include/sys/cdefs.h:622:11
pub const __extern_always_inline = @compileError("unable to translate macro: undefined identifier `__gnu_inline__`");
// /usr/include/sys/cdefs.h:623:11
pub const __fortify_function = __extern_always_inline ++ __attribute_artificial__;
pub const __restrict_arr = @compileError("unable to translate C expr: unexpected token '__restrict'");
// /usr/include/sys/cdefs.h:666:10
pub inline fn __glibc_unlikely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 0))) {
    _ = &cond;
    return __builtin_expect(cond, @as(c_int, 0));
}
pub inline fn __glibc_likely(cond: anytype) @TypeOf(__builtin_expect(cond, @as(c_int, 1))) {
    _ = &cond;
    return __builtin_expect(cond, @as(c_int, 1));
}
pub const __attribute_nonstring__ = "";
pub const __attribute_copy__ = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/sys/cdefs.h:715:10
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = @as(c_int, 0);
pub inline fn __LDBL_REDIR1(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return name ++ proto;
}
pub inline fn __LDBL_REDIR(name: anytype, proto: anytype) @TypeOf(name ++ proto) {
    _ = &name;
    _ = &proto;
    return name ++ proto;
}
pub inline fn __LDBL_REDIR1_NTH(name: anytype, proto: anytype, alias: anytype) @TypeOf(name ++ proto ++ __THROW) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return name ++ proto ++ __THROW;
}
pub inline fn __LDBL_REDIR_NTH(name: anytype, proto: anytype) @TypeOf(name ++ proto ++ __THROW) {
    _ = &name;
    _ = &proto;
    return name ++ proto ++ __THROW;
}
pub const __LDBL_REDIR2_DECL = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/sys/cdefs.h:792:10
pub const __LDBL_REDIR_DECL = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/sys/cdefs.h:793:10
pub inline fn __REDIRECT_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT(name, proto, alias)) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return __REDIRECT(name, proto, alias);
}
pub inline fn __REDIRECT_NTH_LDBL(name: anytype, proto: anytype, alias: anytype) @TypeOf(__REDIRECT_NTH(name, proto, alias)) {
    _ = &name;
    _ = &proto;
    _ = &alias;
    return __REDIRECT_NTH(name, proto, alias);
}
pub const __glibc_macro_warning1 = @compileError("unable to translate macro: undefined identifier `_Pragma`");
// /usr/include/sys/cdefs.h:807:10
pub const __glibc_macro_warning = @compileError("unable to translate macro: undefined identifier `GCC`");
// /usr/include/sys/cdefs.h:808:10
pub const __HAVE_GENERIC_SELECTION = @as(c_int, 1);
pub const __fortified_attr_access = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/sys/cdefs.h:853:11
pub const __attr_access = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/sys/cdefs.h:854:11
pub const __attr_access_none = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/sys/cdefs.h:855:11
pub const __attr_dealloc = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/sys/cdefs.h:865:10
pub const __attr_dealloc_free = "";
pub const __attribute_returns_twice__ = @compileError("unable to translate macro: undefined identifier `__returns_twice__`");
// /usr/include/sys/cdefs.h:872:10
pub const __attribute_struct_may_alias__ = @compileError("unable to translate macro: undefined identifier `__may_alias__`");
// /usr/include/sys/cdefs.h:881:10
pub const __stub___compat_bdflush = "";
pub const __stub_chflags = "";
pub const __stub_fchflags = "";
pub const __stub_gtty = "";
pub const __stub_revoke = "";
pub const __stub_setlogin = "";
pub const __stub_sigreturn = "";
pub const __stub_stty = "";
pub const _BITS_TYPES_H = @as(c_int, 1);
pub const __S16_TYPE = c_short;
pub const __U16_TYPE = c_ushort;
pub const __S32_TYPE = c_int;
pub const __U32_TYPE = c_uint;
pub const __SLONGWORD_TYPE = c_long;
pub const __ULONGWORD_TYPE = c_ulong;
pub const __SQUAD_TYPE = c_long;
pub const __UQUAD_TYPE = c_ulong;
pub const __SWORD_TYPE = c_long;
pub const __UWORD_TYPE = c_ulong;
pub const __SLONG32_TYPE = c_int;
pub const __ULONG32_TYPE = c_uint;
pub const __S64_TYPE = c_long;
pub const __U64_TYPE = c_ulong;
pub const __STD_TYPE = @compileError("unable to translate C expr: unexpected token 'typedef'");
// /usr/include/bits/types.h:137:10
pub const _BITS_TYPESIZES_H = @as(c_int, 1);
pub const __SYSCALL_SLONG_TYPE = __SLONGWORD_TYPE;
pub const __SYSCALL_ULONG_TYPE = __ULONGWORD_TYPE;
pub const __DEV_T_TYPE = __UQUAD_TYPE;
pub const __UID_T_TYPE = __U32_TYPE;
pub const __GID_T_TYPE = __U32_TYPE;
pub const __INO_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __INO64_T_TYPE = __UQUAD_TYPE;
pub const __MODE_T_TYPE = __U32_TYPE;
pub const __NLINK_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSWORD_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __OFF_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __OFF64_T_TYPE = __SQUAD_TYPE;
pub const __PID_T_TYPE = __S32_TYPE;
pub const __RLIM_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __RLIM64_T_TYPE = __UQUAD_TYPE;
pub const __BLKCNT_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __BLKCNT64_T_TYPE = __SQUAD_TYPE;
pub const __FSBLKCNT_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSBLKCNT64_T_TYPE = __UQUAD_TYPE;
pub const __FSFILCNT_T_TYPE = __SYSCALL_ULONG_TYPE;
pub const __FSFILCNT64_T_TYPE = __UQUAD_TYPE;
pub const __ID_T_TYPE = __U32_TYPE;
pub const __CLOCK_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __TIME_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __USECONDS_T_TYPE = __U32_TYPE;
pub const __SUSECONDS_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __SUSECONDS64_T_TYPE = __SQUAD_TYPE;
pub const __DADDR_T_TYPE = __S32_TYPE;
pub const __KEY_T_TYPE = __S32_TYPE;
pub const __CLOCKID_T_TYPE = __S32_TYPE;
pub const __TIMER_T_TYPE = ?*anyopaque;
pub const __BLKSIZE_T_TYPE = __SYSCALL_SLONG_TYPE;
pub const __FSID_T_TYPE = @compileError("unable to translate macro: undefined identifier `__val`");
// /usr/include/bits/typesizes.h:73:9
pub const __SSIZE_T_TYPE = __SWORD_TYPE;
pub const __CPU_MASK_TYPE = __SYSCALL_ULONG_TYPE;
pub const __OFF_T_MATCHES_OFF64_T = @as(c_int, 1);
pub const __INO_T_MATCHES_INO64_T = @as(c_int, 1);
pub const __RLIM_T_MATCHES_RLIM64_T = @as(c_int, 1);
pub const __STATFS_MATCHES_STATFS64 = @as(c_int, 1);
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = @as(c_int, 1);
pub const __FD_SETSIZE = @as(c_int, 1024);
pub const _BITS_TIME64_H = @as(c_int, 1);
pub const __TIME64_T_TYPE = __TIME_T_TYPE;
pub const __u_char_defined = "";
pub const __ino_t_defined = "";
pub const __ino64_t_defined = "";
pub const __dev_t_defined = "";
pub const __gid_t_defined = "";
pub const __mode_t_defined = "";
pub const __nlink_t_defined = "";
pub const __uid_t_defined = "";
pub const __off_t_defined = "";
pub const __off64_t_defined = "";
pub const __pid_t_defined = "";
pub const __id_t_defined = "";
pub const __ssize_t_defined = "";
pub const __daddr_t_defined = "";
pub const __key_t_defined = "";
pub const __clock_t_defined = @as(c_int, 1);
pub const __clockid_t_defined = @as(c_int, 1);
pub const __time_t_defined = @as(c_int, 1);
pub const __timer_t_defined = @as(c_int, 1);
pub const __useconds_t_defined = "";
pub const __suseconds_t_defined = "";
pub const __need_size_t = "";
pub const _SIZE_T = "";
pub const _BITS_STDINT_INTN_H = @as(c_int, 1);
pub const __BIT_TYPES_DEFINED__ = @as(c_int, 1);
pub const _ENDIAN_H = @as(c_int, 1);
pub const _BITS_ENDIAN_H = @as(c_int, 1);
pub const __LITTLE_ENDIAN = @as(c_int, 1234);
pub const __BIG_ENDIAN = @as(c_int, 4321);
pub const __PDP_ENDIAN = @as(c_int, 3412);
pub const _BITS_ENDIANNESS_H = @as(c_int, 1);
pub const __BYTE_ORDER = __LITTLE_ENDIAN;
pub const __FLOAT_WORD_ORDER = __BYTE_ORDER;
pub inline fn __LONG_LONG_PAIR(HI: anytype, LO: anytype) @TypeOf(HI) {
    _ = &HI;
    _ = &LO;
    return blk: {
        _ = &LO;
        break :blk HI;
    };
}
pub const LITTLE_ENDIAN = __LITTLE_ENDIAN;
pub const BIG_ENDIAN = __BIG_ENDIAN;
pub const PDP_ENDIAN = __PDP_ENDIAN;
pub const BYTE_ORDER = __BYTE_ORDER;
pub const _BITS_BYTESWAP_H = @as(c_int, 1);
pub inline fn __bswap_constant_16(x: anytype) __uint16_t {
    _ = &x;
    return @import("std").zig.c_translation.cast(__uint16_t, ((x >> @as(c_int, 8)) & @as(c_int, 0xff)) | ((x & @as(c_int, 0xff)) << @as(c_int, 8)));
}
pub inline fn __bswap_constant_32(x: anytype) @TypeOf(((((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hex)) >> @as(c_int, 24)) | ((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hex)) >> @as(c_int, 8))) | ((x & @as(c_uint, 0x0000ff00)) << @as(c_int, 8))) | ((x & @as(c_uint, 0x000000ff)) << @as(c_int, 24))) {
    _ = &x;
    return ((((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0xff000000, .hex)) >> @as(c_int, 24)) | ((x & @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00ff0000, .hex)) >> @as(c_int, 8))) | ((x & @as(c_uint, 0x0000ff00)) << @as(c_int, 8))) | ((x & @as(c_uint, 0x000000ff)) << @as(c_int, 24));
}
pub inline fn __bswap_constant_64(x: anytype) @TypeOf(((((((((x & @as(c_ulonglong, 0xff00000000000000)) >> @as(c_int, 56)) | ((x & @as(c_ulonglong, 0x00ff000000000000)) >> @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x0000ff0000000000)) >> @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000ff00000000)) >> @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x00000000ff000000)) << @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x0000000000ff0000)) << @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000000000ff00)) << @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x00000000000000ff)) << @as(c_int, 56))) {
    _ = &x;
    return ((((((((x & @as(c_ulonglong, 0xff00000000000000)) >> @as(c_int, 56)) | ((x & @as(c_ulonglong, 0x00ff000000000000)) >> @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x0000ff0000000000)) >> @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000ff00000000)) >> @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x00000000ff000000)) << @as(c_int, 8))) | ((x & @as(c_ulonglong, 0x0000000000ff0000)) << @as(c_int, 24))) | ((x & @as(c_ulonglong, 0x000000000000ff00)) << @as(c_int, 40))) | ((x & @as(c_ulonglong, 0x00000000000000ff)) << @as(c_int, 56));
}
pub const _BITS_UINTN_IDENTITY_H = @as(c_int, 1);
pub inline fn htobe16(x: anytype) @TypeOf(__bswap_16(x)) {
    _ = &x;
    return __bswap_16(x);
}
pub inline fn htole16(x: anytype) @TypeOf(__uint16_identity(x)) {
    _ = &x;
    return __uint16_identity(x);
}
pub inline fn be16toh(x: anytype) @TypeOf(__bswap_16(x)) {
    _ = &x;
    return __bswap_16(x);
}
pub inline fn le16toh(x: anytype) @TypeOf(__uint16_identity(x)) {
    _ = &x;
    return __uint16_identity(x);
}
pub inline fn htobe32(x: anytype) @TypeOf(__bswap_32(x)) {
    _ = &x;
    return __bswap_32(x);
}
pub inline fn htole32(x: anytype) @TypeOf(__uint32_identity(x)) {
    _ = &x;
    return __uint32_identity(x);
}
pub inline fn be32toh(x: anytype) @TypeOf(__bswap_32(x)) {
    _ = &x;
    return __bswap_32(x);
}
pub inline fn le32toh(x: anytype) @TypeOf(__uint32_identity(x)) {
    _ = &x;
    return __uint32_identity(x);
}
pub inline fn htobe64(x: anytype) @TypeOf(__bswap_64(x)) {
    _ = &x;
    return __bswap_64(x);
}
pub inline fn htole64(x: anytype) @TypeOf(__uint64_identity(x)) {
    _ = &x;
    return __uint64_identity(x);
}
pub inline fn be64toh(x: anytype) @TypeOf(__bswap_64(x)) {
    _ = &x;
    return __bswap_64(x);
}
pub inline fn le64toh(x: anytype) @TypeOf(__uint64_identity(x)) {
    _ = &x;
    return __uint64_identity(x);
}
pub const _SYS_SELECT_H = @as(c_int, 1);
pub const __FD_ZERO = @compileError("unable to translate macro: undefined identifier `__i`");
// /usr/include/bits/select.h:25:9
pub const __FD_SET = @compileError("unable to translate C expr: expected ')' instead got '|='");
// /usr/include/bits/select.h:32:9
pub const __FD_CLR = @compileError("unable to translate C expr: expected ')' instead got '&='");
// /usr/include/bits/select.h:34:9
pub inline fn __FD_ISSET(d: anytype, s: anytype) @TypeOf((__FDS_BITS(s)[@as(usize, @intCast(__FD_ELT(d)))] & __FD_MASK(d)) != @as(c_int, 0)) {
    _ = &d;
    _ = &s;
    return (__FDS_BITS(s)[@as(usize, @intCast(__FD_ELT(d)))] & __FD_MASK(d)) != @as(c_int, 0);
}
pub const __sigset_t_defined = @as(c_int, 1);
pub const ____sigset_t_defined = "";
pub const _SIGSET_NWORDS = @import("std").zig.c_translation.MacroArithmetic.div(@as(c_int, 1024), @as(c_int, 8) * @import("std").zig.c_translation.sizeof(c_ulong));
pub const __timeval_defined = @as(c_int, 1);
pub const _STRUCT_TIMESPEC = @as(c_int, 1);
pub const __NFDBITS = @as(c_int, 8) * @import("std").zig.c_translation.cast(c_int, @import("std").zig.c_translation.sizeof(__fd_mask));
pub inline fn __FD_ELT(d: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(d, __NFDBITS)) {
    _ = &d;
    return @import("std").zig.c_translation.MacroArithmetic.div(d, __NFDBITS);
}
pub inline fn __FD_MASK(d: anytype) __fd_mask {
    _ = &d;
    return @import("std").zig.c_translation.cast(__fd_mask, @as(c_ulong, 1) << @import("std").zig.c_translation.MacroArithmetic.rem(d, __NFDBITS));
}
pub inline fn __FDS_BITS(set: anytype) @TypeOf(set.*.fds_bits) {
    _ = &set;
    return set.*.fds_bits;
}
pub const FD_SETSIZE = __FD_SETSIZE;
pub const NFDBITS = __NFDBITS;
pub inline fn FD_SET(fd: anytype, fdsetp: anytype) @TypeOf(__FD_SET(fd, fdsetp)) {
    _ = &fd;
    _ = &fdsetp;
    return __FD_SET(fd, fdsetp);
}
pub inline fn FD_CLR(fd: anytype, fdsetp: anytype) @TypeOf(__FD_CLR(fd, fdsetp)) {
    _ = &fd;
    _ = &fdsetp;
    return __FD_CLR(fd, fdsetp);
}
pub inline fn FD_ISSET(fd: anytype, fdsetp: anytype) @TypeOf(__FD_ISSET(fd, fdsetp)) {
    _ = &fd;
    _ = &fdsetp;
    return __FD_ISSET(fd, fdsetp);
}
pub inline fn FD_ZERO(fdsetp: anytype) @TypeOf(__FD_ZERO(fdsetp)) {
    _ = &fdsetp;
    return __FD_ZERO(fdsetp);
}
pub const __blksize_t_defined = "";
pub const __blkcnt_t_defined = "";
pub const __fsblkcnt_t_defined = "";
pub const __fsfilcnt_t_defined = "";
pub const _BITS_PTHREADTYPES_COMMON_H = @as(c_int, 1);
pub const _THREAD_SHARED_TYPES_H = @as(c_int, 1);
pub const _BITS_PTHREADTYPES_ARCH_H = @as(c_int, 1);
pub const __SIZEOF_PTHREAD_MUTEX_T = @as(c_int, 40);
pub const __SIZEOF_PTHREAD_ATTR_T = @as(c_int, 56);
pub const __SIZEOF_PTHREAD_RWLOCK_T = @as(c_int, 56);
pub const __SIZEOF_PTHREAD_BARRIER_T = @as(c_int, 32);
pub const __SIZEOF_PTHREAD_MUTEXATTR_T = @as(c_int, 4);
pub const __SIZEOF_PTHREAD_COND_T = @as(c_int, 48);
pub const __SIZEOF_PTHREAD_CONDATTR_T = @as(c_int, 4);
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T = @as(c_int, 8);
pub const __SIZEOF_PTHREAD_BARRIERATTR_T = @as(c_int, 4);
pub const __LOCK_ALIGNMENT = "";
pub const __ONCE_ALIGNMENT = "";
pub const _BITS_ATOMIC_WIDE_COUNTER_H = "";
pub const _THREAD_MUTEX_INTERNAL_H = @as(c_int, 1);
pub const __PTHREAD_MUTEX_HAVE_PREV = @as(c_int, 1);
pub const __PTHREAD_MUTEX_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/bits/struct_mutex.h:56:10
pub const _RWLOCK_INTERNAL_H = "";
pub const __PTHREAD_RWLOCK_ELISION_EXTRA = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/bits/struct_rwlock.h:40:11
pub inline fn __PTHREAD_RWLOCK_INITIALIZER(__flags: anytype) @TypeOf(__flags) {
    _ = &__flags;
    return blk: {
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = @as(c_int, 0);
        _ = &__PTHREAD_RWLOCK_ELISION_EXTRA;
        _ = @as(c_int, 0);
        break :blk __flags;
    };
}
pub const __ONCE_FLAG_INIT = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/bits/thread-shared-types.h:113:9
pub const __have_pthread_attr_t = @as(c_int, 1);
pub const _SYS_TIME_H = @as(c_int, 1);
pub const TIMEVAL_TO_TIMESPEC = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/sys/time.h:38:10
pub const TIMESPEC_TO_TIMEVAL = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/sys/time.h:42:10
pub inline fn timerisset(tvp: anytype) @TypeOf((tvp.*.tv_sec != 0) or (tvp.*.tv_usec != 0)) {
    _ = &tvp;
    return (tvp.*.tv_sec != 0) or (tvp.*.tv_usec != 0);
}
pub const timerclear = @compileError("unable to translate C expr: expected ')' instead got '='");
// /usr/include/sys/time.h:232:10
pub inline fn timercmp(a: anytype, b: anytype, CMP: anytype) @TypeOf(if (a.*.tv_sec == b.*.tv_sec) a.*.tv_usec ++ CMP(b).*.tv_usec else a.*.tv_sec ++ CMP(b).*.tv_sec) {
    _ = &a;
    _ = &b;
    _ = &CMP;
    return if (a.*.tv_sec == b.*.tv_sec) a.*.tv_usec ++ CMP(b).*.tv_usec else a.*.tv_sec ++ CMP(b).*.tv_sec;
}
pub const timeradd = @compileError("unable to translate C expr: unexpected token 'do'");
// /usr/include/sys/time.h:237:10
pub const timersub = @compileError("unable to translate C expr: unexpected token 'do'");
// /usr/include/sys/time.h:247:10
pub const _UNISTD_H = @as(c_int, 1);
pub const _POSIX_VERSION = @as(c_long, 200809);
pub const __POSIX2_THIS_VERSION = @as(c_long, 200809);
pub const _POSIX2_VERSION = __POSIX2_THIS_VERSION;
pub const _POSIX2_C_VERSION = __POSIX2_THIS_VERSION;
pub const _POSIX2_C_BIND = __POSIX2_THIS_VERSION;
pub const _POSIX2_C_DEV = __POSIX2_THIS_VERSION;
pub const _POSIX2_SW_DEV = __POSIX2_THIS_VERSION;
pub const _POSIX2_LOCALEDEF = __POSIX2_THIS_VERSION;
pub const _XOPEN_VERSION = @as(c_int, 700);
pub const _XOPEN_XCU_VERSION = @as(c_int, 4);
pub const _XOPEN_XPG2 = @as(c_int, 1);
pub const _XOPEN_XPG3 = @as(c_int, 1);
pub const _XOPEN_XPG4 = @as(c_int, 1);
pub const _XOPEN_UNIX = @as(c_int, 1);
pub const _XOPEN_ENH_I18N = @as(c_int, 1);
pub const _XOPEN_LEGACY = @as(c_int, 1);
pub const _BITS_POSIX_OPT_H = @as(c_int, 1);
pub const _POSIX_JOB_CONTROL = @as(c_int, 1);
pub const _POSIX_SAVED_IDS = @as(c_int, 1);
pub const _POSIX_PRIORITY_SCHEDULING = @as(c_long, 200809);
pub const _POSIX_SYNCHRONIZED_IO = @as(c_long, 200809);
pub const _POSIX_FSYNC = @as(c_long, 200809);
pub const _POSIX_MAPPED_FILES = @as(c_long, 200809);
pub const _POSIX_MEMLOCK = @as(c_long, 200809);
pub const _POSIX_MEMLOCK_RANGE = @as(c_long, 200809);
pub const _POSIX_MEMORY_PROTECTION = @as(c_long, 200809);
pub const _POSIX_CHOWN_RESTRICTED = @as(c_int, 0);
pub const _POSIX_VDISABLE = '\x00';
pub const _POSIX_NO_TRUNC = @as(c_int, 1);
pub const _XOPEN_REALTIME = @as(c_int, 1);
pub const _XOPEN_REALTIME_THREADS = @as(c_int, 1);
pub const _XOPEN_SHM = @as(c_int, 1);
pub const _POSIX_THREADS = @as(c_long, 200809);
pub const _POSIX_REENTRANT_FUNCTIONS = @as(c_int, 1);
pub const _POSIX_THREAD_SAFE_FUNCTIONS = @as(c_long, 200809);
pub const _POSIX_THREAD_PRIORITY_SCHEDULING = @as(c_long, 200809);
pub const _POSIX_THREAD_ATTR_STACKSIZE = @as(c_long, 200809);
pub const _POSIX_THREAD_ATTR_STACKADDR = @as(c_long, 200809);
pub const _POSIX_THREAD_PRIO_INHERIT = @as(c_long, 200809);
pub const _POSIX_THREAD_PRIO_PROTECT = @as(c_long, 200809);
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT = @as(c_long, 200809);
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT = -@as(c_int, 1);
pub const _POSIX_SEMAPHORES = @as(c_long, 200809);
pub const _POSIX_REALTIME_SIGNALS = @as(c_long, 200809);
pub const _POSIX_ASYNCHRONOUS_IO = @as(c_long, 200809);
pub const _POSIX_ASYNC_IO = @as(c_int, 1);
pub const _LFS_ASYNCHRONOUS_IO = @as(c_int, 1);
pub const _POSIX_PRIORITIZED_IO = @as(c_long, 200809);
pub const _LFS64_ASYNCHRONOUS_IO = @as(c_int, 1);
pub const _LFS_LARGEFILE = @as(c_int, 1);
pub const _LFS64_LARGEFILE = @as(c_int, 1);
pub const _LFS64_STDIO = @as(c_int, 1);
pub const _POSIX_SHARED_MEMORY_OBJECTS = @as(c_long, 200809);
pub const _POSIX_CPUTIME = @as(c_int, 0);
pub const _POSIX_THREAD_CPUTIME = @as(c_int, 0);
pub const _POSIX_REGEXP = @as(c_int, 1);
pub const _POSIX_READER_WRITER_LOCKS = @as(c_long, 200809);
pub const _POSIX_SHELL = @as(c_int, 1);
pub const _POSIX_TIMEOUTS = @as(c_long, 200809);
pub const _POSIX_SPIN_LOCKS = @as(c_long, 200809);
pub const _POSIX_SPAWN = @as(c_long, 200809);
pub const _POSIX_TIMERS = @as(c_long, 200809);
pub const _POSIX_BARRIERS = @as(c_long, 200809);
pub const _POSIX_MESSAGE_PASSING = @as(c_long, 200809);
pub const _POSIX_THREAD_PROCESS_SHARED = @as(c_long, 200809);
pub const _POSIX_MONOTONIC_CLOCK = @as(c_int, 0);
pub const _POSIX_CLOCK_SELECTION = @as(c_long, 200809);
pub const _POSIX_ADVISORY_INFO = @as(c_long, 200809);
pub const _POSIX_IPV6 = @as(c_long, 200809);
pub const _POSIX_RAW_SOCKETS = @as(c_long, 200809);
pub const _POSIX2_CHAR_TERM = @as(c_long, 200809);
pub const _POSIX_SPORADIC_SERVER = -@as(c_int, 1);
pub const _POSIX_THREAD_SPORADIC_SERVER = -@as(c_int, 1);
pub const _POSIX_TRACE = -@as(c_int, 1);
pub const _POSIX_TRACE_EVENT_FILTER = -@as(c_int, 1);
pub const _POSIX_TRACE_INHERIT = -@as(c_int, 1);
pub const _POSIX_TRACE_LOG = -@as(c_int, 1);
pub const _POSIX_TYPED_MEMORY_OBJECTS = -@as(c_int, 1);
pub const _POSIX_V7_LPBIG_OFFBIG = -@as(c_int, 1);
pub const _POSIX_V6_LPBIG_OFFBIG = -@as(c_int, 1);
pub const _XBS5_LPBIG_OFFBIG = -@as(c_int, 1);
pub const _POSIX_V7_LP64_OFF64 = @as(c_int, 1);
pub const _POSIX_V6_LP64_OFF64 = @as(c_int, 1);
pub const _XBS5_LP64_OFF64 = @as(c_int, 1);
pub const __ILP32_OFF32_CFLAGS = "-m32";
pub const __ILP32_OFF32_LDFLAGS = "-m32";
pub const __ILP32_OFFBIG_CFLAGS = "-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64";
pub const __ILP32_OFFBIG_LDFLAGS = "-m32";
pub const __LP64_OFF64_CFLAGS = "-m64";
pub const __LP64_OFF64_LDFLAGS = "-m64";
pub const STDIN_FILENO = @as(c_int, 0);
pub const STDOUT_FILENO = @as(c_int, 1);
pub const STDERR_FILENO = @as(c_int, 2);
pub const __need_NULL = "";
pub const NULL = @import("std").zig.c_translation.cast(?*anyopaque, @as(c_int, 0));
pub const __intptr_t_defined = "";
pub const __socklen_t_defined = "";
pub const R_OK = @as(c_int, 4);
pub const W_OK = @as(c_int, 2);
pub const X_OK = @as(c_int, 1);
pub const F_OK = @as(c_int, 0);
pub const SEEK_SET = @as(c_int, 0);
pub const SEEK_CUR = @as(c_int, 1);
pub const SEEK_END = @as(c_int, 2);
pub const SEEK_DATA = @as(c_int, 3);
pub const SEEK_HOLE = @as(c_int, 4);
pub const L_SET = SEEK_SET;
pub const L_INCR = SEEK_CUR;
pub const L_XTND = SEEK_END;
pub const _SC_PAGE_SIZE = _SC_PAGESIZE;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = _CS_V6_WIDTH_RESTRICTED_ENVS;
pub const _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS = _CS_V5_WIDTH_RESTRICTED_ENVS;
pub const _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS = _CS_V7_WIDTH_RESTRICTED_ENVS;
pub const _GETOPT_POSIX_H = @as(c_int, 1);
pub const _GETOPT_CORE_H = @as(c_int, 1);
pub const F_ULOCK = @as(c_int, 0);
pub const F_LOCK = @as(c_int, 1);
pub const F_TLOCK = @as(c_int, 2);
pub const F_TEST = @as(c_int, 3);
pub const TEMP_FAILURE_RETRY = @compileError("unable to translate macro: undefined identifier `__result`");
// /usr/include/unistd.h:1134:10
pub const _LINUX_CLOSE_RANGE_H = "";
pub const CLOSE_RANGE_UNSHARE = @as(c_uint, 1) << @as(c_int, 1);
pub const CLOSE_RANGE_CLOEXEC = @as(c_uint, 1) << @as(c_int, 2);
pub const __STDARG_H = "";
pub const __need___va_list = "";
pub const __need_va_list = "";
pub const __need_va_arg = "";
pub const __need___va_copy = "";
pub const __need_va_copy = "";
pub const __GNUC_VA_LIST = "";
pub const _VA_LIST = "";
pub const va_start = @compileError("unable to translate macro: undefined identifier `__builtin_va_start`");
// /home/kaiwu/.local/share/zig-linux-x86_64-0.13.0/lib/include/__stdarg_va_arg.h:17:9
pub const va_end = @compileError("unable to translate macro: undefined identifier `__builtin_va_end`");
// /home/kaiwu/.local/share/zig-linux-x86_64-0.13.0/lib/include/__stdarg_va_arg.h:19:9
pub const va_arg = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// /home/kaiwu/.local/share/zig-linux-x86_64-0.13.0/lib/include/__stdarg_va_arg.h:20:9
pub const __va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`");
// /home/kaiwu/.local/share/zig-linux-x86_64-0.13.0/lib/include/__stdarg___va_copy.h:11:9
pub const va_copy = @compileError("unable to translate macro: undefined identifier `__builtin_va_copy`");
// /home/kaiwu/.local/share/zig-linux-x86_64-0.13.0/lib/include/__stdarg_va_copy.h:11:9
pub const __STDDEF_H = "";
pub const __need_ptrdiff_t = "";
pub const __need_wchar_t = "";
pub const __need_max_align_t = "";
pub const __need_offsetof = "";
pub const _PTRDIFF_T = "";
pub const _WCHAR_T = "";
pub const __CLANG_MAX_ALIGN_T_DEFINED = "";
pub const offsetof = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// /home/kaiwu/.local/share/zig-linux-x86_64-0.13.0/lib/include/__stddef_offsetof.h:16:9
pub const _STDIO_H = @as(c_int, 1);
pub const __GLIBC_INTERNAL_STARTING_HEADER_IMPLEMENTATION = "";
pub const __GLIBC_USE_LIB_EXT2 = @as(c_int, 1);
pub const __GLIBC_USE_IEC_60559_BFP_EXT = @as(c_int, 1);
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23 = @as(c_int, 1);
pub const __GLIBC_USE_IEC_60559_EXT = @as(c_int, 1);
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT = @as(c_int, 1);
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23 = @as(c_int, 1);
pub const __GLIBC_USE_IEC_60559_TYPES_EXT = @as(c_int, 1);
pub const _____fpos_t_defined = @as(c_int, 1);
pub const ____mbstate_t_defined = @as(c_int, 1);
pub const _____fpos64_t_defined = @as(c_int, 1);
pub const ____FILE_defined = @as(c_int, 1);
pub const __FILE_defined = @as(c_int, 1);
pub const __struct_FILE_defined = @as(c_int, 1);
pub const __getc_unlocked_body = @compileError("TODO postfix inc/dec expr");
// /usr/include/bits/types/struct_FILE.h:102:9
pub const __putc_unlocked_body = @compileError("TODO postfix inc/dec expr");
// /usr/include/bits/types/struct_FILE.h:106:9
pub const _IO_EOF_SEEN = @as(c_int, 0x0010);
pub inline fn __feof_unlocked_body(_fp: anytype) @TypeOf((_fp.*._flags & _IO_EOF_SEEN) != @as(c_int, 0)) {
    _ = &_fp;
    return (_fp.*._flags & _IO_EOF_SEEN) != @as(c_int, 0);
}
pub const _IO_ERR_SEEN = @as(c_int, 0x0020);
pub inline fn __ferror_unlocked_body(_fp: anytype) @TypeOf((_fp.*._flags & _IO_ERR_SEEN) != @as(c_int, 0)) {
    _ = &_fp;
    return (_fp.*._flags & _IO_ERR_SEEN) != @as(c_int, 0);
}
pub const _IO_USER_LOCK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const __cookie_io_functions_t_defined = @as(c_int, 1);
pub const _VA_LIST_DEFINED = "";
pub const _IOFBF = @as(c_int, 0);
pub const _IOLBF = @as(c_int, 1);
pub const _IONBF = @as(c_int, 2);
pub const BUFSIZ = @as(c_int, 8192);
pub const EOF = -@as(c_int, 1);
pub const P_tmpdir = "/tmp";
pub const L_tmpnam = @as(c_int, 20);
pub const TMP_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 238328, .decimal);
pub const _BITS_STDIO_LIM_H = @as(c_int, 1);
pub const FILENAME_MAX = @as(c_int, 4096);
pub const L_ctermid = @as(c_int, 9);
pub const L_cuserid = @as(c_int, 9);
pub const FOPEN_MAX = @as(c_int, 16);
pub const _PRINTF_NAN_LEN_MAX = @as(c_int, 4);
pub const RENAME_NOREPLACE = @as(c_int, 1) << @as(c_int, 0);
pub const RENAME_EXCHANGE = @as(c_int, 1) << @as(c_int, 1);
pub const RENAME_WHITEOUT = @as(c_int, 1) << @as(c_int, 2);
pub const __attr_dealloc_fclose = __attr_dealloc(fclose, @as(c_int, 1));
pub const _BITS_FLOATN_H = "";
pub const __HAVE_FLOAT128 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT128 = @as(c_int, 0);
pub const __HAVE_FLOAT64X = @as(c_int, 1);
pub const __HAVE_FLOAT64X_LONG_DOUBLE = @as(c_int, 1);
pub const _BITS_FLOATN_COMMON_H = "";
pub const __HAVE_FLOAT16 = @as(c_int, 0);
pub const __HAVE_FLOAT32 = @as(c_int, 1);
pub const __HAVE_FLOAT64 = @as(c_int, 1);
pub const __HAVE_FLOAT32X = @as(c_int, 1);
pub const __HAVE_FLOAT128X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT16 = __HAVE_FLOAT16;
pub const __HAVE_DISTINCT_FLOAT32 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT64 = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT32X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT64X = @as(c_int, 0);
pub const __HAVE_DISTINCT_FLOAT128X = __HAVE_FLOAT128X;
pub const __HAVE_FLOAT128_UNLIKE_LDBL = (__HAVE_DISTINCT_FLOAT128 != 0) and (__LDBL_MANT_DIG__ != @as(c_int, 113));
pub const __HAVE_FLOATN_NOT_TYPEDEF = @as(c_int, 0);
pub const __f32 = @import("std").zig.c_translation.Macros.F_SUFFIX;
pub inline fn __f64(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub inline fn __f32x(x: anytype) @TypeOf(x) {
    _ = &x;
    return x;
}
pub const __f64x = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const __CFLOAT32 = @compileError("unable to translate: TODO _Complex");
// /usr/include/bits/floatn-common.h:149:12
pub const __CFLOAT64 = @compileError("unable to translate: TODO _Complex");
// /usr/include/bits/floatn-common.h:160:13
pub const __CFLOAT32X = @compileError("unable to translate: TODO _Complex");
// /usr/include/bits/floatn-common.h:169:12
pub const __CFLOAT64X = @compileError("unable to translate: TODO _Complex");
// /usr/include/bits/floatn-common.h:178:13
pub inline fn __builtin_huge_valf32() @TypeOf(__builtin_huge_valf()) {
    return __builtin_huge_valf();
}
pub inline fn __builtin_inff32() @TypeOf(__builtin_inff()) {
    return __builtin_inff();
}
pub inline fn __builtin_nanf32(x: anytype) @TypeOf(__builtin_nanf(x)) {
    _ = &x;
    return __builtin_nanf(x);
}
pub const __builtin_nansf32 = @compileError("unable to translate macro: undefined identifier `__builtin_nansf`");
// /usr/include/bits/floatn-common.h:221:12
pub const __builtin_huge_valf64 = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`");
// /usr/include/bits/floatn-common.h:255:13
pub const __builtin_inff64 = @compileError("unable to translate macro: undefined identifier `__builtin_inf`");
// /usr/include/bits/floatn-common.h:256:13
pub const __builtin_nanf64 = @compileError("unable to translate macro: undefined identifier `__builtin_nan`");
// /usr/include/bits/floatn-common.h:257:13
pub const __builtin_nansf64 = @compileError("unable to translate macro: undefined identifier `__builtin_nans`");
// /usr/include/bits/floatn-common.h:258:13
pub const __builtin_huge_valf32x = @compileError("unable to translate macro: undefined identifier `__builtin_huge_val`");
// /usr/include/bits/floatn-common.h:272:12
pub const __builtin_inff32x = @compileError("unable to translate macro: undefined identifier `__builtin_inf`");
// /usr/include/bits/floatn-common.h:273:12
pub const __builtin_nanf32x = @compileError("unable to translate macro: undefined identifier `__builtin_nan`");
// /usr/include/bits/floatn-common.h:274:12
pub const __builtin_nansf32x = @compileError("unable to translate macro: undefined identifier `__builtin_nans`");
// /usr/include/bits/floatn-common.h:275:12
pub const __builtin_huge_valf64x = @compileError("unable to translate macro: undefined identifier `__builtin_huge_vall`");
// /usr/include/bits/floatn-common.h:289:13
pub const __builtin_inff64x = @compileError("unable to translate macro: undefined identifier `__builtin_infl`");
// /usr/include/bits/floatn-common.h:290:13
pub const __builtin_nanf64x = @compileError("unable to translate macro: undefined identifier `__builtin_nanl`");
// /usr/include/bits/floatn-common.h:291:13
pub const __builtin_nansf64x = @compileError("unable to translate macro: undefined identifier `__builtin_nansl`");
// /usr/include/bits/floatn-common.h:292:13
pub const _STDLIB_H = @as(c_int, 1);
pub const WNOHANG = @as(c_int, 1);
pub const WUNTRACED = @as(c_int, 2);
pub const WSTOPPED = @as(c_int, 2);
pub const WEXITED = @as(c_int, 4);
pub const WCONTINUED = @as(c_int, 8);
pub const WNOWAIT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x01000000, .hex);
pub const __WNOTHREAD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hex);
pub const __WALL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hex);
pub const __WCLONE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
pub inline fn __WEXITSTATUS(status: anytype) @TypeOf((status & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff00, .hex)) >> @as(c_int, 8)) {
    _ = &status;
    return (status & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff00, .hex)) >> @as(c_int, 8);
}
pub inline fn __WTERMSIG(status: anytype) @TypeOf(status & @as(c_int, 0x7f)) {
    _ = &status;
    return status & @as(c_int, 0x7f);
}
pub inline fn __WSTOPSIG(status: anytype) @TypeOf(__WEXITSTATUS(status)) {
    _ = &status;
    return __WEXITSTATUS(status);
}
pub inline fn __WIFEXITED(status: anytype) @TypeOf(__WTERMSIG(status) == @as(c_int, 0)) {
    _ = &status;
    return __WTERMSIG(status) == @as(c_int, 0);
}
pub inline fn __WIFSIGNALED(status: anytype) @TypeOf((@import("std").zig.c_translation.cast(i8, (status & @as(c_int, 0x7f)) + @as(c_int, 1)) >> @as(c_int, 1)) > @as(c_int, 0)) {
    _ = &status;
    return (@import("std").zig.c_translation.cast(i8, (status & @as(c_int, 0x7f)) + @as(c_int, 1)) >> @as(c_int, 1)) > @as(c_int, 0);
}
pub inline fn __WIFSTOPPED(status: anytype) @TypeOf((status & @as(c_int, 0xff)) == @as(c_int, 0x7f)) {
    _ = &status;
    return (status & @as(c_int, 0xff)) == @as(c_int, 0x7f);
}
pub inline fn __WIFCONTINUED(status: anytype) @TypeOf(status == __W_CONTINUED) {
    _ = &status;
    return status == __W_CONTINUED;
}
pub inline fn __WCOREDUMP(status: anytype) @TypeOf(status & __WCOREFLAG) {
    _ = &status;
    return status & __WCOREFLAG;
}
pub inline fn __W_EXITCODE(ret: anytype, sig: anytype) @TypeOf((ret << @as(c_int, 8)) | sig) {
    _ = &ret;
    _ = &sig;
    return (ret << @as(c_int, 8)) | sig;
}
pub inline fn __W_STOPCODE(sig: anytype) @TypeOf((sig << @as(c_int, 8)) | @as(c_int, 0x7f)) {
    _ = &sig;
    return (sig << @as(c_int, 8)) | @as(c_int, 0x7f);
}
pub const __W_CONTINUED = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hex);
pub const __WCOREFLAG = @as(c_int, 0x80);
pub inline fn WEXITSTATUS(status: anytype) @TypeOf(__WEXITSTATUS(status)) {
    _ = &status;
    return __WEXITSTATUS(status);
}
pub inline fn WTERMSIG(status: anytype) @TypeOf(__WTERMSIG(status)) {
    _ = &status;
    return __WTERMSIG(status);
}
pub inline fn WSTOPSIG(status: anytype) @TypeOf(__WSTOPSIG(status)) {
    _ = &status;
    return __WSTOPSIG(status);
}
pub inline fn WIFEXITED(status: anytype) @TypeOf(__WIFEXITED(status)) {
    _ = &status;
    return __WIFEXITED(status);
}
pub inline fn WIFSIGNALED(status: anytype) @TypeOf(__WIFSIGNALED(status)) {
    _ = &status;
    return __WIFSIGNALED(status);
}
pub inline fn WIFSTOPPED(status: anytype) @TypeOf(__WIFSTOPPED(status)) {
    _ = &status;
    return __WIFSTOPPED(status);
}
pub inline fn WIFCONTINUED(status: anytype) @TypeOf(__WIFCONTINUED(status)) {
    _ = &status;
    return __WIFCONTINUED(status);
}
pub const __ldiv_t_defined = @as(c_int, 1);
pub const __lldiv_t_defined = @as(c_int, 1);
pub const RAND_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const EXIT_FAILURE = @as(c_int, 1);
pub const EXIT_SUCCESS = @as(c_int, 0);
pub const MB_CUR_MAX = __ctype_get_mb_cur_max();
pub const _BITS_TYPES_LOCALE_T_H = @as(c_int, 1);
pub const _BITS_TYPES___LOCALE_T_H = @as(c_int, 1);
pub const _ALLOCA_H = @as(c_int, 1);
pub const __COMPAR_FN_T = "";
pub const _CTYPE_H = @as(c_int, 1);
pub inline fn _ISbit(bit: anytype) @TypeOf(if (bit < @as(c_int, 8)) (@as(c_int, 1) << bit) << @as(c_int, 8) else (@as(c_int, 1) << bit) >> @as(c_int, 8)) {
    _ = &bit;
    return if (bit < @as(c_int, 8)) (@as(c_int, 1) << bit) << @as(c_int, 8) else (@as(c_int, 1) << bit) >> @as(c_int, 8);
}
pub inline fn __isctype(c: anytype, @"type": anytype) @TypeOf(__ctype_b_loc().*[@as(usize, @intCast(@import("std").zig.c_translation.cast(c_int, c)))] & @import("std").zig.c_translation.cast(c_ushort, @"type")) {
    _ = &c;
    _ = &@"type";
    return __ctype_b_loc().*[@as(usize, @intCast(@import("std").zig.c_translation.cast(c_int, c)))] & @import("std").zig.c_translation.cast(c_ushort, @"type");
}
pub inline fn __isascii(c: anytype) @TypeOf((c & ~@as(c_int, 0x7f)) == @as(c_int, 0)) {
    _ = &c;
    return (c & ~@as(c_int, 0x7f)) == @as(c_int, 0);
}
pub inline fn __toascii(c: anytype) @TypeOf(c & @as(c_int, 0x7f)) {
    _ = &c;
    return c & @as(c_int, 0x7f);
}
pub const __exctype = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/ctype.h:102:9
pub const __tobody = @compileError("unable to translate macro: undefined identifier `__res`");
// /usr/include/ctype.h:155:9
pub inline fn __isctype_l(c: anytype, @"type": anytype, locale: anytype) @TypeOf(locale.*.__ctype_b[@as(usize, @intCast(@import("std").zig.c_translation.cast(c_int, c)))] & @import("std").zig.c_translation.cast(c_ushort, @"type")) {
    _ = &c;
    _ = &@"type";
    _ = &locale;
    return locale.*.__ctype_b[@as(usize, @intCast(@import("std").zig.c_translation.cast(c_int, c)))] & @import("std").zig.c_translation.cast(c_ushort, @"type");
}
pub const __exctype_l = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/ctype.h:244:10
pub inline fn __isalnum_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISalnum, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISalnum, l);
}
pub inline fn __isalpha_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISalpha, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISalpha, l);
}
pub inline fn __iscntrl_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _IScntrl, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _IScntrl, l);
}
pub inline fn __isdigit_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISdigit, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISdigit, l);
}
pub inline fn __islower_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISlower, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISlower, l);
}
pub inline fn __isgraph_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISgraph, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISgraph, l);
}
pub inline fn __isprint_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISprint, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISprint, l);
}
pub inline fn __ispunct_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISpunct, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISpunct, l);
}
pub inline fn __isspace_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISspace, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISspace, l);
}
pub inline fn __isupper_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISupper, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISupper, l);
}
pub inline fn __isxdigit_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISxdigit, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISxdigit, l);
}
pub inline fn __isblank_l(c: anytype, l: anytype) @TypeOf(__isctype_l(c, _ISblank, l)) {
    _ = &c;
    _ = &l;
    return __isctype_l(c, _ISblank, l);
}
pub inline fn __isascii_l(c: anytype, l: anytype) @TypeOf(__isascii(c)) {
    _ = &c;
    _ = &l;
    return blk_1: {
        _ = &l;
        break :blk_1 __isascii(c);
    };
}
pub inline fn __toascii_l(c: anytype, l: anytype) @TypeOf(__toascii(c)) {
    _ = &c;
    _ = &l;
    return blk_1: {
        _ = &l;
        break :blk_1 __toascii(c);
    };
}
pub inline fn isascii_l(c: anytype, l: anytype) @TypeOf(__isascii_l(c, l)) {
    _ = &c;
    _ = &l;
    return __isascii_l(c, l);
}
pub inline fn toascii_l(c: anytype, l: anytype) @TypeOf(__toascii_l(c, l)) {
    _ = &c;
    _ = &l;
    return __toascii_l(c, l);
}
pub const _ERRNO_H = @as(c_int, 1);
pub const _BITS_ERRNO_H = @as(c_int, 1);
pub const _ASM_GENERIC_ERRNO_H = "";
pub const _ASM_GENERIC_ERRNO_BASE_H = "";
pub const EPERM = @as(c_int, 1);
pub const ENOENT = @as(c_int, 2);
pub const ESRCH = @as(c_int, 3);
pub const EINTR = @as(c_int, 4);
pub const EIO = @as(c_int, 5);
pub const ENXIO = @as(c_int, 6);
pub const E2BIG = @as(c_int, 7);
pub const ENOEXEC = @as(c_int, 8);
pub const EBADF = @as(c_int, 9);
pub const ECHILD = @as(c_int, 10);
pub const EAGAIN = @as(c_int, 11);
pub const ENOMEM = @as(c_int, 12);
pub const EACCES = @as(c_int, 13);
pub const EFAULT = @as(c_int, 14);
pub const ENOTBLK = @as(c_int, 15);
pub const EBUSY = @as(c_int, 16);
pub const EEXIST = @as(c_int, 17);
pub const EXDEV = @as(c_int, 18);
pub const ENODEV = @as(c_int, 19);
pub const ENOTDIR = @as(c_int, 20);
pub const EISDIR = @as(c_int, 21);
pub const EINVAL = @as(c_int, 22);
pub const ENFILE = @as(c_int, 23);
pub const EMFILE = @as(c_int, 24);
pub const ENOTTY = @as(c_int, 25);
pub const ETXTBSY = @as(c_int, 26);
pub const EFBIG = @as(c_int, 27);
pub const ENOSPC = @as(c_int, 28);
pub const ESPIPE = @as(c_int, 29);
pub const EROFS = @as(c_int, 30);
pub const EMLINK = @as(c_int, 31);
pub const EPIPE = @as(c_int, 32);
pub const EDOM = @as(c_int, 33);
pub const ERANGE = @as(c_int, 34);
pub const EDEADLK = @as(c_int, 35);
pub const ENAMETOOLONG = @as(c_int, 36);
pub const ENOLCK = @as(c_int, 37);
pub const ENOSYS = @as(c_int, 38);
pub const ENOTEMPTY = @as(c_int, 39);
pub const ELOOP = @as(c_int, 40);
pub const EWOULDBLOCK = EAGAIN;
pub const ENOMSG = @as(c_int, 42);
pub const EIDRM = @as(c_int, 43);
pub const ECHRNG = @as(c_int, 44);
pub const EL2NSYNC = @as(c_int, 45);
pub const EL3HLT = @as(c_int, 46);
pub const EL3RST = @as(c_int, 47);
pub const ELNRNG = @as(c_int, 48);
pub const EUNATCH = @as(c_int, 49);
pub const ENOCSI = @as(c_int, 50);
pub const EL2HLT = @as(c_int, 51);
pub const EBADE = @as(c_int, 52);
pub const EBADR = @as(c_int, 53);
pub const EXFULL = @as(c_int, 54);
pub const ENOANO = @as(c_int, 55);
pub const EBADRQC = @as(c_int, 56);
pub const EBADSLT = @as(c_int, 57);
pub const EDEADLOCK = EDEADLK;
pub const EBFONT = @as(c_int, 59);
pub const ENOSTR = @as(c_int, 60);
pub const ENODATA = @as(c_int, 61);
pub const ETIME = @as(c_int, 62);
pub const ENOSR = @as(c_int, 63);
pub const ENONET = @as(c_int, 64);
pub const ENOPKG = @as(c_int, 65);
pub const EREMOTE = @as(c_int, 66);
pub const ENOLINK = @as(c_int, 67);
pub const EADV = @as(c_int, 68);
pub const ESRMNT = @as(c_int, 69);
pub const ECOMM = @as(c_int, 70);
pub const EPROTO = @as(c_int, 71);
pub const EMULTIHOP = @as(c_int, 72);
pub const EDOTDOT = @as(c_int, 73);
pub const EBADMSG = @as(c_int, 74);
pub const EOVERFLOW = @as(c_int, 75);
pub const ENOTUNIQ = @as(c_int, 76);
pub const EBADFD = @as(c_int, 77);
pub const EREMCHG = @as(c_int, 78);
pub const ELIBACC = @as(c_int, 79);
pub const ELIBBAD = @as(c_int, 80);
pub const ELIBSCN = @as(c_int, 81);
pub const ELIBMAX = @as(c_int, 82);
pub const ELIBEXEC = @as(c_int, 83);
pub const EILSEQ = @as(c_int, 84);
pub const ERESTART = @as(c_int, 85);
pub const ESTRPIPE = @as(c_int, 86);
pub const EUSERS = @as(c_int, 87);
pub const ENOTSOCK = @as(c_int, 88);
pub const EDESTADDRREQ = @as(c_int, 89);
pub const EMSGSIZE = @as(c_int, 90);
pub const EPROTOTYPE = @as(c_int, 91);
pub const ENOPROTOOPT = @as(c_int, 92);
pub const EPROTONOSUPPORT = @as(c_int, 93);
pub const ESOCKTNOSUPPORT = @as(c_int, 94);
pub const EOPNOTSUPP = @as(c_int, 95);
pub const EPFNOSUPPORT = @as(c_int, 96);
pub const EAFNOSUPPORT = @as(c_int, 97);
pub const EADDRINUSE = @as(c_int, 98);
pub const EADDRNOTAVAIL = @as(c_int, 99);
pub const ENETDOWN = @as(c_int, 100);
pub const ENETUNREACH = @as(c_int, 101);
pub const ENETRESET = @as(c_int, 102);
pub const ECONNABORTED = @as(c_int, 103);
pub const ECONNRESET = @as(c_int, 104);
pub const ENOBUFS = @as(c_int, 105);
pub const EISCONN = @as(c_int, 106);
pub const ENOTCONN = @as(c_int, 107);
pub const ESHUTDOWN = @as(c_int, 108);
pub const ETOOMANYREFS = @as(c_int, 109);
pub const ETIMEDOUT = @as(c_int, 110);
pub const ECONNREFUSED = @as(c_int, 111);
pub const EHOSTDOWN = @as(c_int, 112);
pub const EHOSTUNREACH = @as(c_int, 113);
pub const EALREADY = @as(c_int, 114);
pub const EINPROGRESS = @as(c_int, 115);
pub const ESTALE = @as(c_int, 116);
pub const EUCLEAN = @as(c_int, 117);
pub const ENOTNAM = @as(c_int, 118);
pub const ENAVAIL = @as(c_int, 119);
pub const EISNAM = @as(c_int, 120);
pub const EREMOTEIO = @as(c_int, 121);
pub const EDQUOT = @as(c_int, 122);
pub const ENOMEDIUM = @as(c_int, 123);
pub const EMEDIUMTYPE = @as(c_int, 124);
pub const ECANCELED = @as(c_int, 125);
pub const ENOKEY = @as(c_int, 126);
pub const EKEYEXPIRED = @as(c_int, 127);
pub const EKEYREVOKED = @as(c_int, 128);
pub const EKEYREJECTED = @as(c_int, 129);
pub const EOWNERDEAD = @as(c_int, 130);
pub const ENOTRECOVERABLE = @as(c_int, 131);
pub const ERFKILL = @as(c_int, 132);
pub const EHWPOISON = @as(c_int, 133);
pub const ENOTSUP = EOPNOTSUPP;
pub const errno = __errno_location().*;
pub const __error_t_defined = @as(c_int, 1);
pub const _STRING_H = @as(c_int, 1);
pub const strdupa = @compileError("unable to translate macro: undefined identifier `__old`");
// /usr/include/string.h:201:10
pub const strndupa = @compileError("unable to translate macro: undefined identifier `__old`");
// /usr/include/string.h:211:10
pub const _STRINGS_H = @as(c_int, 1);
pub const _SIGNAL_H = "";
pub const _BITS_SIGNUM_GENERIC_H = @as(c_int, 1);
pub const SIG_ERR = @import("std").zig.c_translation.cast(__sighandler_t, -@as(c_int, 1));
pub const SIG_DFL = @import("std").zig.c_translation.cast(__sighandler_t, @as(c_int, 0));
pub const SIG_IGN = @import("std").zig.c_translation.cast(__sighandler_t, @as(c_int, 1));
pub const SIG_HOLD = @import("std").zig.c_translation.cast(__sighandler_t, @as(c_int, 2));
pub const SIGINT = @as(c_int, 2);
pub const SIGILL = @as(c_int, 4);
pub const SIGABRT = @as(c_int, 6);
pub const SIGFPE = @as(c_int, 8);
pub const SIGSEGV = @as(c_int, 11);
pub const SIGTERM = @as(c_int, 15);
pub const SIGHUP = @as(c_int, 1);
pub const SIGQUIT = @as(c_int, 3);
pub const SIGTRAP = @as(c_int, 5);
pub const SIGKILL = @as(c_int, 9);
pub const SIGPIPE = @as(c_int, 13);
pub const SIGALRM = @as(c_int, 14);
pub const SIGIO = SIGPOLL;
pub const SIGIOT = SIGABRT;
pub const SIGCLD = SIGCHLD;
pub const _BITS_SIGNUM_ARCH_H = @as(c_int, 1);
pub const SIGSTKFLT = @as(c_int, 16);
pub const SIGPWR = @as(c_int, 30);
pub const SIGBUS = @as(c_int, 7);
pub const SIGSYS = @as(c_int, 31);
pub const SIGURG = @as(c_int, 23);
pub const SIGSTOP = @as(c_int, 19);
pub const SIGTSTP = @as(c_int, 20);
pub const SIGCONT = @as(c_int, 18);
pub const SIGCHLD = @as(c_int, 17);
pub const SIGTTIN = @as(c_int, 21);
pub const SIGTTOU = @as(c_int, 22);
pub const SIGPOLL = @as(c_int, 29);
pub const SIGXFSZ = @as(c_int, 25);
pub const SIGXCPU = @as(c_int, 24);
pub const SIGVTALRM = @as(c_int, 26);
pub const SIGPROF = @as(c_int, 27);
pub const SIGUSR1 = @as(c_int, 10);
pub const SIGUSR2 = @as(c_int, 12);
pub const SIGWINCH = @as(c_int, 28);
pub const __SIGRTMIN = @as(c_int, 32);
pub const __SIGRTMAX = @as(c_int, 64);
pub const _NSIG = __SIGRTMAX + @as(c_int, 1);
pub const __sig_atomic_t_defined = @as(c_int, 1);
pub const __siginfo_t_defined = @as(c_int, 1);
pub const ____sigval_t_defined = "";
pub const __SI_MAX_SIZE = @as(c_int, 128);
pub const __SI_PAD_SIZE = @import("std").zig.c_translation.MacroArithmetic.div(__SI_MAX_SIZE, @import("std").zig.c_translation.sizeof(c_int)) - @as(c_int, 4);
pub const _BITS_SIGINFO_ARCH_H = @as(c_int, 1);
pub const __SI_ALIGNMENT = "";
pub const __SI_BAND_TYPE = c_long;
pub const __SI_CLOCK_T = __clock_t;
pub const __SI_ERRNO_THEN_CODE = @as(c_int, 1);
pub const __SI_HAVE_SIGSYS = @as(c_int, 1);
pub const __SI_SIGFAULT_ADDL = "";
pub const si_pid = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:128:9
pub const si_uid = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:129:9
pub const si_timerid = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:130:9
pub const si_overrun = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:131:9
pub const si_status = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:132:9
pub const si_utime = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:133:9
pub const si_stime = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:134:9
pub const si_value = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:135:9
pub const si_int = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:136:9
pub const si_ptr = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:137:9
pub const si_addr = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:138:9
pub const si_addr_lsb = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:139:9
pub const si_lower = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:140:9
pub const si_upper = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:141:9
pub const si_pkey = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:142:9
pub const si_band = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:143:9
pub const si_fd = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:144:9
pub const si_call_addr = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:146:10
pub const si_syscall = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:147:10
pub const si_arch = @compileError("unable to translate macro: undefined identifier `_sifields`");
// /usr/include/bits/types/siginfo_t.h:148:10
pub const _BITS_SIGINFO_CONSTS_H = @as(c_int, 1);
pub const __SI_ASYNCIO_AFTER_SIGIO = @as(c_int, 1);
pub const _BITS_SIGINFO_CONSTS_ARCH_H = @as(c_int, 1);
pub const __sigval_t_defined = "";
pub const __sigevent_t_defined = @as(c_int, 1);
pub const __SIGEV_MAX_SIZE = @as(c_int, 64);
pub const __SIGEV_PAD_SIZE = @import("std").zig.c_translation.MacroArithmetic.div(__SIGEV_MAX_SIZE, @import("std").zig.c_translation.sizeof(c_int)) - @as(c_int, 4);
pub const sigev_notify_function = @compileError("unable to translate macro: undefined identifier `_sigev_un`");
// /usr/include/bits/types/sigevent_t.h:45:9
pub const sigev_notify_attributes = @compileError("unable to translate macro: undefined identifier `_sigev_un`");
// /usr/include/bits/types/sigevent_t.h:46:9
pub const _BITS_SIGEVENT_CONSTS_H = @as(c_int, 1);
pub inline fn sigmask(sig: anytype) @TypeOf(__glibc_macro_warning("sigmask is deprecated")(@import("std").zig.c_translation.cast(c_int, @as(c_uint, 1) << (sig - @as(c_int, 1))))) {
    _ = &sig;
    return __glibc_macro_warning("sigmask is deprecated")(@import("std").zig.c_translation.cast(c_int, @as(c_uint, 1) << (sig - @as(c_int, 1))));
}
pub const NSIG = _NSIG;
pub const _BITS_SIGACTION_H = @as(c_int, 1);
pub const sa_handler = @compileError("unable to translate macro: undefined identifier `__sigaction_handler`");
// /usr/include/bits/sigaction.h:39:10
pub const sa_sigaction = @compileError("unable to translate macro: undefined identifier `__sigaction_handler`");
// /usr/include/bits/sigaction.h:40:10
pub const SA_NOCLDSTOP = @as(c_int, 1);
pub const SA_NOCLDWAIT = @as(c_int, 2);
pub const SA_SIGINFO = @as(c_int, 4);
pub const SA_ONSTACK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000000, .hex);
pub const SA_RESTART = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000000, .hex);
pub const SA_NODEFER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hex);
pub const SA_RESETHAND = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
pub const SA_INTERRUPT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hex);
pub const SA_NOMASK = SA_NODEFER;
pub const SA_ONESHOT = SA_RESETHAND;
pub const SA_STACK = SA_ONSTACK;
pub const SIG_BLOCK = @as(c_int, 0);
pub const SIG_UNBLOCK = @as(c_int, 1);
pub const SIG_SETMASK = @as(c_int, 2);
pub const _BITS_SIGCONTEXT_H = @as(c_int, 1);
pub const FP_XSTATE_MAGIC1 = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x46505853, .hex);
pub const FP_XSTATE_MAGIC2 = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x46505845, .hex);
pub const FP_XSTATE_MAGIC2_SIZE = @import("std").zig.c_translation.sizeof(FP_XSTATE_MAGIC2);
pub const __stack_t_defined = @as(c_int, 1);
pub const _SYS_UCONTEXT_H = @as(c_int, 1);
pub inline fn __ctx(fld: anytype) @TypeOf(fld) {
    _ = &fld;
    return fld;
}
pub const __NGREG = @as(c_int, 23);
pub const NGREG = __NGREG;
pub const _BITS_SIGSTACK_H = @as(c_int, 1);
pub const MINSIGSTKSZ = @as(c_int, 2048);
pub const SIGSTKSZ = @as(c_int, 8192);
pub const _BITS_SS_FLAGS_H = @as(c_int, 1);
pub const __sigstack_defined = @as(c_int, 1);
pub const _BITS_SIGTHREAD_H = @as(c_int, 1);
pub const SIGRTMIN = __libc_current_sigrtmin();
pub const SIGRTMAX = __libc_current_sigrtmax();
pub const _PWD_H = @as(c_int, 1);
pub const NSS_BUFLEN_PASSWD = @as(c_int, 1024);
pub const _GRP_H = @as(c_int, 1);
pub const NSS_BUFLEN_GROUP = @as(c_int, 1024);
pub const _DIRENT_H = @as(c_int, 1);
pub const d_fileno = @compileError("unable to translate macro: undefined identifier `d_ino`");
// /usr/include/bits/dirent.h:47:9
pub const _DIRENT_HAVE_D_RECLEN = "";
pub const _DIRENT_HAVE_D_OFF = "";
pub const _DIRENT_HAVE_D_TYPE = "";
pub const _DIRENT_MATCHES_DIRENT64 = @as(c_int, 1);
pub inline fn _D_EXACT_NAMLEN(d: anytype) @TypeOf(strlen(d.*.d_name)) {
    _ = &d;
    return strlen(d.*.d_name);
}
pub inline fn _D_ALLOC_NAMLEN(d: anytype) @TypeOf((@import("std").zig.c_translation.cast([*c]u8, d) + d.*.d_reclen) - (&d.*.d_name[@as(usize, @intCast(@as(c_int, 0)))])) {
    _ = &d;
    return (@import("std").zig.c_translation.cast([*c]u8, d) + d.*.d_reclen) - (&d.*.d_name[@as(usize, @intCast(@as(c_int, 0)))]);
}
pub inline fn IFTODT(mode: anytype) @TypeOf((mode & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o170000, .octal)) >> @as(c_int, 12)) {
    _ = &mode;
    return (mode & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o170000, .octal)) >> @as(c_int, 12);
}
pub inline fn DTTOIF(dirtype: anytype) @TypeOf(dirtype << @as(c_int, 12)) {
    _ = &dirtype;
    return dirtype << @as(c_int, 12);
}
pub const _BITS_POSIX1_LIM_H = @as(c_int, 1);
pub const _POSIX_AIO_LISTIO_MAX = @as(c_int, 2);
pub const _POSIX_AIO_MAX = @as(c_int, 1);
pub const _POSIX_ARG_MAX = @as(c_int, 4096);
pub const _POSIX_CHILD_MAX = @as(c_int, 25);
pub const _POSIX_DELAYTIMER_MAX = @as(c_int, 32);
pub const _POSIX_HOST_NAME_MAX = @as(c_int, 255);
pub const _POSIX_LINK_MAX = @as(c_int, 8);
pub const _POSIX_LOGIN_NAME_MAX = @as(c_int, 9);
pub const _POSIX_MAX_CANON = @as(c_int, 255);
pub const _POSIX_MAX_INPUT = @as(c_int, 255);
pub const _POSIX_MQ_OPEN_MAX = @as(c_int, 8);
pub const _POSIX_MQ_PRIO_MAX = @as(c_int, 32);
pub const _POSIX_NAME_MAX = @as(c_int, 14);
pub const _POSIX_NGROUPS_MAX = @as(c_int, 8);
pub const _POSIX_OPEN_MAX = @as(c_int, 20);
pub const _POSIX_FD_SETSIZE = _POSIX_OPEN_MAX;
pub const _POSIX_PATH_MAX = @as(c_int, 256);
pub const _POSIX_PIPE_BUF = @as(c_int, 512);
pub const _POSIX_RE_DUP_MAX = @as(c_int, 255);
pub const _POSIX_RTSIG_MAX = @as(c_int, 8);
pub const _POSIX_SEM_NSEMS_MAX = @as(c_int, 256);
pub const _POSIX_SEM_VALUE_MAX = @as(c_int, 32767);
pub const _POSIX_SIGQUEUE_MAX = @as(c_int, 32);
pub const _POSIX_SSIZE_MAX = @as(c_int, 32767);
pub const _POSIX_STREAM_MAX = @as(c_int, 8);
pub const _POSIX_SYMLINK_MAX = @as(c_int, 255);
pub const _POSIX_SYMLOOP_MAX = @as(c_int, 8);
pub const _POSIX_TIMER_MAX = @as(c_int, 32);
pub const _POSIX_TTY_NAME_MAX = @as(c_int, 9);
pub const _POSIX_TZNAME_MAX = @as(c_int, 6);
pub const _POSIX_QLIMIT = @as(c_int, 1);
pub const _POSIX_HIWAT = _POSIX_PIPE_BUF;
pub const _POSIX_UIO_MAXIOV = @as(c_int, 16);
pub const _POSIX_CLOCKRES_MIN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 20000000, .decimal);
pub const __undef_NR_OPEN = "";
pub const __undef_LINK_MAX = "";
pub const __undef_OPEN_MAX = "";
pub const __undef_ARG_MAX = "";
pub const _LINUX_LIMITS_H = "";
pub const NR_OPEN = @as(c_int, 1024);
pub const NGROUPS_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const ARG_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 131072, .decimal);
pub const LINK_MAX = @as(c_int, 127);
pub const MAX_CANON = @as(c_int, 255);
pub const MAX_INPUT = @as(c_int, 255);
pub const NAME_MAX = @as(c_int, 255);
pub const PATH_MAX = @as(c_int, 4096);
pub const PIPE_BUF = @as(c_int, 4096);
pub const XATTR_NAME_MAX = @as(c_int, 255);
pub const XATTR_SIZE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const XATTR_LIST_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub const RTSIG_MAX = @as(c_int, 32);
pub const _POSIX_THREAD_KEYS_MAX = @as(c_int, 128);
pub const PTHREAD_KEYS_MAX = @as(c_int, 1024);
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS = @as(c_int, 4);
pub const PTHREAD_DESTRUCTOR_ITERATIONS = _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
pub const _POSIX_THREAD_THREADS_MAX = @as(c_int, 64);
pub const AIO_PRIO_DELTA_MAX = @as(c_int, 20);
pub const __SC_THREAD_STACK_MIN_VALUE = @as(c_int, 75);
pub const PTHREAD_STACK_MIN = __sysconf(__SC_THREAD_STACK_MIN_VALUE);
pub const DELAYTIMER_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const TTY_NAME_MAX = @as(c_int, 32);
pub const LOGIN_NAME_MAX = @as(c_int, 256);
pub const HOST_NAME_MAX = @as(c_int, 64);
pub const MQ_PRIO_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const SEM_VALUE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const SSIZE_MAX = LONG_MAX;
pub const MAXNAMLEN = NAME_MAX;
pub const _GLOB_H = @as(c_int, 1);
pub const GLOB_ERR = @as(c_int, 1) << @as(c_int, 0);
pub const GLOB_MARK = @as(c_int, 1) << @as(c_int, 1);
pub const GLOB_NOSORT = @as(c_int, 1) << @as(c_int, 2);
pub const GLOB_DOOFFS = @as(c_int, 1) << @as(c_int, 3);
pub const GLOB_NOCHECK = @as(c_int, 1) << @as(c_int, 4);
pub const GLOB_APPEND = @as(c_int, 1) << @as(c_int, 5);
pub const GLOB_NOESCAPE = @as(c_int, 1) << @as(c_int, 6);
pub const GLOB_PERIOD = @as(c_int, 1) << @as(c_int, 7);
pub const GLOB_MAGCHAR = @as(c_int, 1) << @as(c_int, 8);
pub const GLOB_ALTDIRFUNC = @as(c_int, 1) << @as(c_int, 9);
pub const GLOB_BRACE = @as(c_int, 1) << @as(c_int, 10);
pub const GLOB_NOMAGIC = @as(c_int, 1) << @as(c_int, 11);
pub const GLOB_TILDE = @as(c_int, 1) << @as(c_int, 12);
pub const GLOB_ONLYDIR = @as(c_int, 1) << @as(c_int, 13);
pub const GLOB_TILDE_CHECK = @as(c_int, 1) << @as(c_int, 14);
pub const __GLOB_FLAGS = ((((((((((((GLOB_ERR | GLOB_MARK) | GLOB_NOSORT) | GLOB_DOOFFS) | GLOB_NOESCAPE) | GLOB_NOCHECK) | GLOB_APPEND) | GLOB_PERIOD) | GLOB_ALTDIRFUNC) | GLOB_BRACE) | GLOB_NOMAGIC) | GLOB_TILDE) | GLOB_ONLYDIR) | GLOB_TILDE_CHECK;
pub const GLOB_NOSPACE = @as(c_int, 1);
pub const GLOB_ABORTED = @as(c_int, 2);
pub const GLOB_NOMATCH = @as(c_int, 3);
pub const GLOB_NOSYS = @as(c_int, 4);
pub const GLOB_ABEND = GLOB_ABORTED;
pub const _SYS_STATFS_H = @as(c_int, 1);
pub const _STATFS_F_NAMELEN = "";
pub const _STATFS_F_FRSIZE = "";
pub const _STATFS_F_FLAGS = "";
pub const _SYS_UIO_H = @as(c_int, 1);
pub const __iovec_defined = @as(c_int, 1);
pub const _BITS_UIO_LIM_H = @as(c_int, 1);
pub const __IOV_MAX = @as(c_int, 1024);
pub const UIO_MAXIOV = __IOV_MAX;
pub const _BITS_UIO_EXT_H = @as(c_int, 1);
pub const RWF_HIPRI = @as(c_int, 0x00000001);
pub const RWF_DSYNC = @as(c_int, 0x00000002);
pub const RWF_SYNC = @as(c_int, 0x00000004);
pub const RWF_NOWAIT = @as(c_int, 0x00000008);
pub const RWF_APPEND = @as(c_int, 0x00000010);
pub const RWF_NOAPPEND = @as(c_int, 0x00000020);
pub const _SYS_STAT_H = @as(c_int, 1);
pub const _BITS_STAT_H = @as(c_int, 1);
pub const _BITS_STRUCT_STAT_H = @as(c_int, 1);
pub const st_atime = @compileError("unable to translate macro: undefined identifier `st_atim`");
// /usr/include/bits/struct_stat.h:77:11
pub const st_mtime = @compileError("unable to translate macro: undefined identifier `st_mtim`");
// /usr/include/bits/struct_stat.h:78:11
pub const st_ctime = @compileError("unable to translate macro: undefined identifier `st_ctim`");
// /usr/include/bits/struct_stat.h:79:11
pub const _STATBUF_ST_BLKSIZE = "";
pub const _STATBUF_ST_RDEV = "";
pub const _STATBUF_ST_NSEC = "";
pub const __S_IFMT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o170000, .octal);
pub const __S_IFDIR = @as(c_int, 0o040000);
pub const __S_IFCHR = @as(c_int, 0o020000);
pub const __S_IFBLK = @as(c_int, 0o060000);
pub const __S_IFREG = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o100000, .octal);
pub const __S_IFIFO = @as(c_int, 0o010000);
pub const __S_IFLNK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o120000, .octal);
pub const __S_IFSOCK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o140000, .octal);
pub inline fn __S_TYPEISMQ(buf: anytype) @TypeOf(buf.*.st_mode - buf.*.st_mode) {
    _ = &buf;
    return buf.*.st_mode - buf.*.st_mode;
}
pub inline fn __S_TYPEISSEM(buf: anytype) @TypeOf(buf.*.st_mode - buf.*.st_mode) {
    _ = &buf;
    return buf.*.st_mode - buf.*.st_mode;
}
pub inline fn __S_TYPEISSHM(buf: anytype) @TypeOf(buf.*.st_mode - buf.*.st_mode) {
    _ = &buf;
    return buf.*.st_mode - buf.*.st_mode;
}
pub const __S_ISUID = @as(c_int, 0o4000);
pub const __S_ISGID = @as(c_int, 0o2000);
pub const __S_ISVTX = @as(c_int, 0o1000);
pub const __S_IREAD = @as(c_int, 0o400);
pub const __S_IWRITE = @as(c_int, 0o200);
pub const __S_IEXEC = @as(c_int, 0o100);
pub const UTIME_NOW = (@as(c_long, 1) << @as(c_int, 30)) - @as(c_long, 1);
pub const UTIME_OMIT = (@as(c_long, 1) << @as(c_int, 30)) - @as(c_long, 2);
pub const S_IFMT = __S_IFMT;
pub const S_IFDIR = __S_IFDIR;
pub const S_IFCHR = __S_IFCHR;
pub const S_IFBLK = __S_IFBLK;
pub const S_IFREG = __S_IFREG;
pub const S_IFIFO = __S_IFIFO;
pub const S_IFLNK = __S_IFLNK;
pub const S_IFSOCK = __S_IFSOCK;
pub inline fn __S_ISTYPE(mode: anytype, mask: anytype) @TypeOf((mode & __S_IFMT) == mask) {
    _ = &mode;
    _ = &mask;
    return (mode & __S_IFMT) == mask;
}
pub inline fn S_ISDIR(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFDIR)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFDIR);
}
pub inline fn S_ISCHR(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFCHR)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFCHR);
}
pub inline fn S_ISBLK(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFBLK)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFBLK);
}
pub inline fn S_ISREG(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFREG)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFREG);
}
pub inline fn S_ISFIFO(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFIFO)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFIFO);
}
pub inline fn S_ISLNK(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFLNK)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFLNK);
}
pub inline fn S_ISSOCK(mode: anytype) @TypeOf(__S_ISTYPE(mode, __S_IFSOCK)) {
    _ = &mode;
    return __S_ISTYPE(mode, __S_IFSOCK);
}
pub inline fn S_TYPEISMQ(buf: anytype) @TypeOf(__S_TYPEISMQ(buf)) {
    _ = &buf;
    return __S_TYPEISMQ(buf);
}
pub inline fn S_TYPEISSEM(buf: anytype) @TypeOf(__S_TYPEISSEM(buf)) {
    _ = &buf;
    return __S_TYPEISSEM(buf);
}
pub inline fn S_TYPEISSHM(buf: anytype) @TypeOf(__S_TYPEISSHM(buf)) {
    _ = &buf;
    return __S_TYPEISSHM(buf);
}
pub const S_ISUID = __S_ISUID;
pub const S_ISGID = __S_ISGID;
pub const S_ISVTX = __S_ISVTX;
pub const S_IRUSR = __S_IREAD;
pub const S_IWUSR = __S_IWRITE;
pub const S_IXUSR = __S_IEXEC;
pub const S_IRWXU = (__S_IREAD | __S_IWRITE) | __S_IEXEC;
pub const S_IREAD = S_IRUSR;
pub const S_IWRITE = S_IWUSR;
pub const S_IEXEC = S_IXUSR;
pub const S_IRGRP = S_IRUSR >> @as(c_int, 3);
pub const S_IWGRP = S_IWUSR >> @as(c_int, 3);
pub const S_IXGRP = S_IXUSR >> @as(c_int, 3);
pub const S_IRWXG = S_IRWXU >> @as(c_int, 3);
pub const S_IROTH = S_IRGRP >> @as(c_int, 3);
pub const S_IWOTH = S_IWGRP >> @as(c_int, 3);
pub const S_IXOTH = S_IXGRP >> @as(c_int, 3);
pub const S_IRWXO = S_IRWXG >> @as(c_int, 3);
pub const ACCESSPERMS = (S_IRWXU | S_IRWXG) | S_IRWXO;
pub const ALLPERMS = ((((S_ISUID | S_ISGID) | S_ISVTX) | S_IRWXU) | S_IRWXG) | S_IRWXO;
pub const DEFFILEMODE = ((((S_IRUSR | S_IWUSR) | S_IRGRP) | S_IWGRP) | S_IROTH) | S_IWOTH;
pub const S_BLKSIZE = @as(c_int, 512);
pub const _LINUX_STAT_H = "";
pub const _LINUX_TYPES_H = "";
pub const _ASM_GENERIC_TYPES_H = "";
pub const _ASM_GENERIC_INT_LL64_H = "";
pub const __ASM_X86_BITSPERLONG_H = "";
pub const __BITS_PER_LONG = @as(c_int, 64);
pub const __ASM_GENERIC_BITS_PER_LONG = "";
pub const __BITS_PER_LONG_LONG = @as(c_int, 64);
pub const _LINUX_POSIX_TYPES_H = "";
pub const _LINUX_STDDEF_H = "";
pub const __struct_group = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /usr/include/linux/stddef.h:26:9
pub const __DECLARE_FLEX_ARRAY = @compileError("unable to translate macro: undefined identifier `__empty_`");
// /usr/include/linux/stddef.h:47:9
pub const __counted_by = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/linux/stddef.h:55:9
pub const __counted_by_le = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/linux/stddef.h:59:9
pub const __counted_by_be = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/linux/stddef.h:63:9
pub const _ASM_X86_POSIX_TYPES_64_H = "";
pub const __ASM_GENERIC_POSIX_TYPES_H = "";
pub const __bitwise = "";
pub const __bitwise__ = "";
pub const __aligned_u64 = @compileError("unable to translate macro: undefined identifier `aligned`");
// /usr/include/linux/types.h:50:9
pub const __aligned_be64 = @compileError("unable to translate macro: undefined identifier `aligned`");
// /usr/include/linux/types.h:51:9
pub const __aligned_le64 = @compileError("unable to translate macro: undefined identifier `aligned`");
// /usr/include/linux/types.h:52:9
pub const STATX_TYPE = @as(c_uint, 0x00000001);
pub const STATX_MODE = @as(c_uint, 0x00000002);
pub const STATX_NLINK = @as(c_uint, 0x00000004);
pub const STATX_UID = @as(c_uint, 0x00000008);
pub const STATX_GID = @as(c_uint, 0x00000010);
pub const STATX_ATIME = @as(c_uint, 0x00000020);
pub const STATX_MTIME = @as(c_uint, 0x00000040);
pub const STATX_CTIME = @as(c_uint, 0x00000080);
pub const STATX_INO = @as(c_uint, 0x00000100);
pub const STATX_SIZE = @as(c_uint, 0x00000200);
pub const STATX_BLOCKS = @as(c_uint, 0x00000400);
pub const STATX_BASIC_STATS = @as(c_uint, 0x000007ff);
pub const STATX_BTIME = @as(c_uint, 0x00000800);
pub const STATX_MNT_ID = @as(c_uint, 0x00001000);
pub const STATX_DIOALIGN = @as(c_uint, 0x00002000);
pub const STATX_MNT_ID_UNIQUE = @as(c_uint, 0x00004000);
pub const STATX_SUBVOL = @as(c_uint, 0x00008000);
pub const STATX__RESERVED = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x80000000, .hex);
pub const STATX_ALL = @as(c_uint, 0x00000fff);
pub const STATX_ATTR_COMPRESSED = @as(c_int, 0x00000004);
pub const STATX_ATTR_IMMUTABLE = @as(c_int, 0x00000010);
pub const STATX_ATTR_APPEND = @as(c_int, 0x00000020);
pub const STATX_ATTR_NODUMP = @as(c_int, 0x00000040);
pub const STATX_ATTR_ENCRYPTED = @as(c_int, 0x00000800);
pub const STATX_ATTR_AUTOMOUNT = @as(c_int, 0x00001000);
pub const STATX_ATTR_MOUNT_ROOT = @as(c_int, 0x00002000);
pub const STATX_ATTR_VERITY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00100000, .hex);
pub const STATX_ATTR_DAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00200000, .hex);
pub const __statx_timestamp_defined = @as(c_int, 1);
pub const __statx_defined = @as(c_int, 1);
pub const _FCNTL_H = @as(c_int, 1);
pub const __O_LARGEFILE = @as(c_int, 0);
pub const F_GETLK64 = @as(c_int, 5);
pub const F_SETLK64 = @as(c_int, 6);
pub const F_SETLKW64 = @as(c_int, 7);
pub const O_ACCMODE = @as(c_int, 0o003);
pub const O_RDONLY = @as(c_int, 0o0);
pub const O_WRONLY = @as(c_int, 0o1);
pub const O_RDWR = @as(c_int, 0o2);
pub const O_CREAT = @as(c_int, 0o100);
pub const O_EXCL = @as(c_int, 0o200);
pub const O_NOCTTY = @as(c_int, 0o400);
pub const O_TRUNC = @as(c_int, 0o1000);
pub const O_APPEND = @as(c_int, 0o2000);
pub const O_NONBLOCK = @as(c_int, 0o4000);
pub const O_NDELAY = O_NONBLOCK;
pub const O_SYNC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o4010000, .octal);
pub const O_FSYNC = O_SYNC;
pub const O_ASYNC = @as(c_int, 0o20000);
pub const __O_DIRECTORY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o200000, .octal);
pub const __O_NOFOLLOW = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o400000, .octal);
pub const __O_CLOEXEC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o2000000, .octal);
pub const __O_DIRECT = @as(c_int, 0o40000);
pub const __O_NOATIME = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o1000000, .octal);
pub const __O_PATH = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o10000000, .octal);
pub const __O_DSYNC = @as(c_int, 0o10000);
pub const __O_TMPFILE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0o20000000, .octal) | __O_DIRECTORY;
pub const F_GETLK = F_GETLK64;
pub const F_SETLK = F_SETLK64;
pub const F_SETLKW = F_SETLKW64;
pub const F_OFD_GETLK = @as(c_int, 36);
pub const F_OFD_SETLK = @as(c_int, 37);
pub const F_OFD_SETLKW = @as(c_int, 38);
pub const O_LARGEFILE = __O_LARGEFILE;
pub const O_DIRECTORY = __O_DIRECTORY;
pub const O_NOFOLLOW = __O_NOFOLLOW;
pub const O_CLOEXEC = __O_CLOEXEC;
pub const O_DIRECT = __O_DIRECT;
pub const O_NOATIME = __O_NOATIME;
pub const O_PATH = __O_PATH;
pub const O_TMPFILE = __O_TMPFILE;
pub const O_DSYNC = __O_DSYNC;
pub const O_RSYNC = O_SYNC;
pub const F_DUPFD = @as(c_int, 0);
pub const F_GETFD = @as(c_int, 1);
pub const F_SETFD = @as(c_int, 2);
pub const F_GETFL = @as(c_int, 3);
pub const F_SETFL = @as(c_int, 4);
pub const __F_SETOWN = @as(c_int, 8);
pub const __F_GETOWN = @as(c_int, 9);
pub const F_SETOWN = __F_SETOWN;
pub const F_GETOWN = __F_GETOWN;
pub const __F_SETSIG = @as(c_int, 10);
pub const __F_GETSIG = @as(c_int, 11);
pub const __F_SETOWN_EX = @as(c_int, 15);
pub const __F_GETOWN_EX = @as(c_int, 16);
pub const F_SETSIG = __F_SETSIG;
pub const F_GETSIG = __F_GETSIG;
pub const F_SETOWN_EX = __F_SETOWN_EX;
pub const F_GETOWN_EX = __F_GETOWN_EX;
pub const F_SETLEASE = @as(c_int, 1024);
pub const F_GETLEASE = @as(c_int, 1025);
pub const F_NOTIFY = @as(c_int, 1026);
pub const F_SETPIPE_SZ = @as(c_int, 1031);
pub const F_GETPIPE_SZ = @as(c_int, 1032);
pub const F_ADD_SEALS = @as(c_int, 1033);
pub const F_GET_SEALS = @as(c_int, 1034);
pub const F_GET_RW_HINT = @as(c_int, 1035);
pub const F_SET_RW_HINT = @as(c_int, 1036);
pub const F_GET_FILE_RW_HINT = @as(c_int, 1037);
pub const F_SET_FILE_RW_HINT = @as(c_int, 1038);
pub const F_DUPFD_CLOEXEC = @as(c_int, 1030);
pub const FD_CLOEXEC = @as(c_int, 1);
pub const F_RDLCK = @as(c_int, 0);
pub const F_WRLCK = @as(c_int, 1);
pub const F_UNLCK = @as(c_int, 2);
pub const F_EXLCK = @as(c_int, 4);
pub const F_SHLCK = @as(c_int, 8);
pub const LOCK_SH = @as(c_int, 1);
pub const LOCK_EX = @as(c_int, 2);
pub const LOCK_NB = @as(c_int, 4);
pub const LOCK_UN = @as(c_int, 8);
pub const LOCK_MAND = @as(c_int, 32);
pub const LOCK_READ = @as(c_int, 64);
pub const LOCK_WRITE = @as(c_int, 128);
pub const LOCK_RW = @as(c_int, 192);
pub const DN_ACCESS = @as(c_int, 0x00000001);
pub const DN_MODIFY = @as(c_int, 0x00000002);
pub const DN_CREATE = @as(c_int, 0x00000004);
pub const DN_DELETE = @as(c_int, 0x00000008);
pub const DN_RENAME = @as(c_int, 0x00000010);
pub const DN_ATTRIB = @as(c_int, 0x00000020);
pub const DN_MULTISHOT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
pub const F_SEAL_SEAL = @as(c_int, 0x0001);
pub const F_SEAL_SHRINK = @as(c_int, 0x0002);
pub const F_SEAL_GROW = @as(c_int, 0x0004);
pub const F_SEAL_WRITE = @as(c_int, 0x0008);
pub const F_SEAL_FUTURE_WRITE = @as(c_int, 0x0010);
pub const F_SEAL_EXEC = @as(c_int, 0x0020);
pub const RWH_WRITE_LIFE_NOT_SET = @as(c_int, 0);
pub const RWF_WRITE_LIFE_NOT_SET = RWH_WRITE_LIFE_NOT_SET;
pub const RWH_WRITE_LIFE_NONE = @as(c_int, 1);
pub const RWH_WRITE_LIFE_SHORT = @as(c_int, 2);
pub const RWH_WRITE_LIFE_MEDIUM = @as(c_int, 3);
pub const RWH_WRITE_LIFE_LONG = @as(c_int, 4);
pub const RWH_WRITE_LIFE_EXTREME = @as(c_int, 5);
pub const FAPPEND = O_APPEND;
pub const FFSYNC = O_FSYNC;
pub const FASYNC = O_ASYNC;
pub const FNONBLOCK = O_NONBLOCK;
pub const FNDELAY = O_NDELAY;
pub const __POSIX_FADV_DONTNEED = @as(c_int, 4);
pub const __POSIX_FADV_NOREUSE = @as(c_int, 5);
pub const POSIX_FADV_NORMAL = @as(c_int, 0);
pub const POSIX_FADV_RANDOM = @as(c_int, 1);
pub const POSIX_FADV_SEQUENTIAL = @as(c_int, 2);
pub const POSIX_FADV_WILLNEED = @as(c_int, 3);
pub const POSIX_FADV_DONTNEED = __POSIX_FADV_DONTNEED;
pub const POSIX_FADV_NOREUSE = __POSIX_FADV_NOREUSE;
pub const SYNC_FILE_RANGE_WAIT_BEFORE = @as(c_int, 1);
pub const SYNC_FILE_RANGE_WRITE = @as(c_int, 2);
pub const SYNC_FILE_RANGE_WAIT_AFTER = @as(c_int, 4);
pub const SYNC_FILE_RANGE_WRITE_AND_WAIT = (SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_BEFORE) | SYNC_FILE_RANGE_WAIT_AFTER;
pub const SPLICE_F_MOVE = @as(c_int, 1);
pub const SPLICE_F_NONBLOCK = @as(c_int, 2);
pub const SPLICE_F_MORE = @as(c_int, 4);
pub const SPLICE_F_GIFT = @as(c_int, 8);
pub const _FALLOC_H_ = "";
pub const FALLOC_FL_KEEP_SIZE = @as(c_int, 0x01);
pub const FALLOC_FL_PUNCH_HOLE = @as(c_int, 0x02);
pub const FALLOC_FL_NO_HIDE_STALE = @as(c_int, 0x04);
pub const FALLOC_FL_COLLAPSE_RANGE = @as(c_int, 0x08);
pub const FALLOC_FL_ZERO_RANGE = @as(c_int, 0x10);
pub const FALLOC_FL_INSERT_RANGE = @as(c_int, 0x20);
pub const FALLOC_FL_UNSHARE_RANGE = @as(c_int, 0x40);
pub const MAX_HANDLE_SZ = @as(c_int, 128);
pub const AT_HANDLE_FID = AT_REMOVEDIR;
pub inline fn __OPEN_NEEDS_MODE(oflag: anytype) @TypeOf(((oflag & O_CREAT) != @as(c_int, 0)) or ((oflag & __O_TMPFILE) == __O_TMPFILE)) {
    _ = &oflag;
    return ((oflag & O_CREAT) != @as(c_int, 0)) or ((oflag & __O_TMPFILE) == __O_TMPFILE);
}
pub const AT_FDCWD = -@as(c_int, 100);
pub const AT_SYMLINK_NOFOLLOW = @as(c_int, 0x100);
pub const AT_REMOVEDIR = @as(c_int, 0x200);
pub const AT_SYMLINK_FOLLOW = @as(c_int, 0x400);
pub const AT_NO_AUTOMOUNT = @as(c_int, 0x800);
pub const AT_EMPTY_PATH = @as(c_int, 0x1000);
pub const AT_STATX_SYNC_TYPE = @as(c_int, 0x6000);
pub const AT_STATX_SYNC_AS_STAT = @as(c_int, 0x0000);
pub const AT_STATX_FORCE_SYNC = @as(c_int, 0x2000);
pub const AT_STATX_DONT_SYNC = @as(c_int, 0x4000);
pub const AT_RECURSIVE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const AT_EACCESS = @as(c_int, 0x200);
pub const _SYS_WAIT_H = @as(c_int, 1);
pub const WCOREFLAG = __WCOREFLAG;
pub inline fn WCOREDUMP(status: anytype) @TypeOf(__WCOREDUMP(status)) {
    _ = &status;
    return __WCOREDUMP(status);
}
pub inline fn W_EXITCODE(ret: anytype, sig: anytype) @TypeOf(__W_EXITCODE(ret, sig)) {
    _ = &ret;
    _ = &sig;
    return __W_EXITCODE(ret, sig);
}
pub inline fn W_STOPCODE(sig: anytype) @TypeOf(__W_STOPCODE(sig)) {
    _ = &sig;
    return __W_STOPCODE(sig);
}
pub const __idtype_t_defined = "";
pub const WAIT_ANY = -@as(c_int, 1);
pub const WAIT_MYPGRP = @as(c_int, 0);
pub const _SYS_MMAN_H = @as(c_int, 1);
pub const MAP_32BIT = @as(c_int, 0x40);
pub const MAP_ABOVE4G = @as(c_int, 0x80);
pub const SHADOW_STACK_SET_TOKEN = @as(c_int, 0x1);
pub const MAP_GROWSDOWN = @as(c_int, 0x00100);
pub const MAP_DENYWRITE = @as(c_int, 0x00800);
pub const MAP_EXECUTABLE = @as(c_int, 0x01000);
pub const MAP_LOCKED = @as(c_int, 0x02000);
pub const MAP_NORESERVE = @as(c_int, 0x04000);
pub const MAP_POPULATE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000, .hex);
pub const MAP_NONBLOCK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const MAP_STACK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000, .hex);
pub const MAP_HUGETLB = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000, .hex);
pub const MAP_SYNC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000, .hex);
pub const MAP_FIXED_NOREPLACE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100000, .hex);
pub const PROT_READ = @as(c_int, 0x1);
pub const PROT_WRITE = @as(c_int, 0x2);
pub const PROT_EXEC = @as(c_int, 0x4);
pub const PROT_NONE = @as(c_int, 0x0);
pub const PROT_GROWSDOWN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x01000000, .hex);
pub const PROT_GROWSUP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x02000000, .hex);
pub const MAP_SHARED = @as(c_int, 0x01);
pub const MAP_PRIVATE = @as(c_int, 0x02);
pub const MAP_SHARED_VALIDATE = @as(c_int, 0x03);
pub const MAP_TYPE = @as(c_int, 0x0f);
pub const MAP_FIXED = @as(c_int, 0x10);
pub const MAP_FILE = @as(c_int, 0);
pub const MAP_ANONYMOUS = @as(c_int, 0x20);
pub const MAP_ANON = MAP_ANONYMOUS;
pub const MAP_HUGE_SHIFT = @as(c_int, 26);
pub const MAP_HUGE_MASK = @as(c_int, 0x3f);
pub const MAP_HUGE_16KB = @as(c_int, 14) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_64KB = @as(c_int, 16) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_512KB = @as(c_int, 19) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_1MB = @as(c_int, 20) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_2MB = @as(c_int, 21) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_8MB = @as(c_int, 23) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_16MB = @as(c_int, 24) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_32MB = @as(c_int, 25) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_256MB = @as(c_int, 28) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_512MB = @as(c_int, 29) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_1GB = @as(c_int, 30) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_2GB = @as(c_int, 31) << MAP_HUGE_SHIFT;
pub const MAP_HUGE_16GB = @as(c_uint, 34) << MAP_HUGE_SHIFT;
pub const MS_ASYNC = @as(c_int, 1);
pub const MS_SYNC = @as(c_int, 4);
pub const MS_INVALIDATE = @as(c_int, 2);
pub const MADV_NORMAL = @as(c_int, 0);
pub const MADV_RANDOM = @as(c_int, 1);
pub const MADV_SEQUENTIAL = @as(c_int, 2);
pub const MADV_WILLNEED = @as(c_int, 3);
pub const MADV_DONTNEED = @as(c_int, 4);
pub const MADV_FREE = @as(c_int, 8);
pub const MADV_REMOVE = @as(c_int, 9);
pub const MADV_DONTFORK = @as(c_int, 10);
pub const MADV_DOFORK = @as(c_int, 11);
pub const MADV_MERGEABLE = @as(c_int, 12);
pub const MADV_UNMERGEABLE = @as(c_int, 13);
pub const MADV_HUGEPAGE = @as(c_int, 14);
pub const MADV_NOHUGEPAGE = @as(c_int, 15);
pub const MADV_DONTDUMP = @as(c_int, 16);
pub const MADV_DODUMP = @as(c_int, 17);
pub const MADV_WIPEONFORK = @as(c_int, 18);
pub const MADV_KEEPONFORK = @as(c_int, 19);
pub const MADV_COLD = @as(c_int, 20);
pub const MADV_PAGEOUT = @as(c_int, 21);
pub const MADV_POPULATE_READ = @as(c_int, 22);
pub const MADV_POPULATE_WRITE = @as(c_int, 23);
pub const MADV_DONTNEED_LOCKED = @as(c_int, 24);
pub const MADV_COLLAPSE = @as(c_int, 25);
pub const MADV_HWPOISON = @as(c_int, 100);
pub const POSIX_MADV_NORMAL = @as(c_int, 0);
pub const POSIX_MADV_RANDOM = @as(c_int, 1);
pub const POSIX_MADV_SEQUENTIAL = @as(c_int, 2);
pub const POSIX_MADV_WILLNEED = @as(c_int, 3);
pub const POSIX_MADV_DONTNEED = @as(c_int, 4);
pub const MCL_CURRENT = @as(c_int, 1);
pub const MCL_FUTURE = @as(c_int, 2);
pub const MCL_ONFAULT = @as(c_int, 4);
pub const MREMAP_MAYMOVE = @as(c_int, 1);
pub const MREMAP_FIXED = @as(c_int, 2);
pub const MREMAP_DONTUNMAP = @as(c_int, 4);
pub const MFD_CLOEXEC = @as(c_uint, 1);
pub const MFD_ALLOW_SEALING = @as(c_uint, 2);
pub const MFD_HUGETLB = @as(c_uint, 4);
pub const MFD_NOEXEC_SEAL = @as(c_uint, 8);
pub const MFD_EXEC = @as(c_uint, 0x10);
pub const MLOCK_ONFAULT = @as(c_uint, 1);
pub const PKEY_DISABLE_ACCESS = @as(c_int, 0x1);
pub const PKEY_DISABLE_WRITE = @as(c_int, 0x2);
pub const MAP_FAILED = @import("std").zig.c_translation.cast(?*anyopaque, -@as(c_int, 1));
pub const _SYS_RESOURCE_H = @as(c_int, 1);
pub const RLIMIT_RSS = __RLIMIT_RSS;
pub const RLIMIT_OFILE = __RLIMIT_OFILE;
pub const RLIMIT_NPROC = __RLIMIT_NPROC;
pub const RLIMIT_MEMLOCK = __RLIMIT_MEMLOCK;
pub const RLIMIT_LOCKS = __RLIMIT_LOCKS;
pub const RLIMIT_SIGPENDING = __RLIMIT_SIGPENDING;
pub const RLIMIT_MSGQUEUE = __RLIMIT_MSGQUEUE;
pub const RLIMIT_NICE = __RLIMIT_NICE;
pub const RLIMIT_RTPRIO = __RLIMIT_RTPRIO;
pub const RLIMIT_RTTIME = __RLIMIT_RTTIME;
pub const RLIMIT_NLIMITS = __RLIMIT_NLIMITS;
pub const RLIM_NLIMITS = __RLIM_NLIMITS;
pub const RLIM_INFINITY = @as(c_ulonglong, 0xffffffffffffffff);
pub const RLIM64_INFINITY = @as(c_ulonglong, 0xffffffffffffffff);
pub const RLIM_SAVED_MAX = RLIM_INFINITY;
pub const RLIM_SAVED_CUR = RLIM_INFINITY;
pub const RUSAGE_LWP = RUSAGE_THREAD;
pub const __rusage_defined = @as(c_int, 1);
pub const PRIO_MIN = -@as(c_int, 20);
pub const PRIO_MAX = @as(c_int, 20);
pub const _SCHED_H = @as(c_int, 1);
pub const _BITS_SCHED_H = @as(c_int, 1);
pub const SCHED_OTHER = @as(c_int, 0);
pub const SCHED_FIFO = @as(c_int, 1);
pub const SCHED_RR = @as(c_int, 2);
pub const SCHED_BATCH = @as(c_int, 3);
pub const SCHED_ISO = @as(c_int, 4);
pub const SCHED_IDLE = @as(c_int, 5);
pub const SCHED_DEADLINE = @as(c_int, 6);
pub const SCHED_RESET_ON_FORK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hex);
pub const CSIGNAL = @as(c_int, 0x000000ff);
pub const CLONE_VM = @as(c_int, 0x00000100);
pub const CLONE_FS = @as(c_int, 0x00000200);
pub const CLONE_FILES = @as(c_int, 0x00000400);
pub const CLONE_SIGHAND = @as(c_int, 0x00000800);
pub const CLONE_PIDFD = @as(c_int, 0x00001000);
pub const CLONE_PTRACE = @as(c_int, 0x00002000);
pub const CLONE_VFORK = @as(c_int, 0x00004000);
pub const CLONE_PARENT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00008000, .hex);
pub const CLONE_THREAD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00010000, .hex);
pub const CLONE_NEWNS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00020000, .hex);
pub const CLONE_SYSVSEM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00040000, .hex);
pub const CLONE_SETTLS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00080000, .hex);
pub const CLONE_PARENT_SETTID = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00100000, .hex);
pub const CLONE_CHILD_CLEARTID = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00200000, .hex);
pub const CLONE_DETACHED = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00400000, .hex);
pub const CLONE_UNTRACED = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00800000, .hex);
pub const CLONE_CHILD_SETTID = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x01000000, .hex);
pub const CLONE_NEWCGROUP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x02000000, .hex);
pub const CLONE_NEWUTS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x04000000, .hex);
pub const CLONE_NEWIPC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000000, .hex);
pub const CLONE_NEWUSER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000000, .hex);
pub const CLONE_NEWPID = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hex);
pub const CLONE_NEWNET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hex);
pub const CLONE_IO = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
pub const CLONE_NEWTIME = @as(c_int, 0x00000080);
pub const _BITS_TYPES_STRUCT_SCHED_PARAM = @as(c_int, 1);
pub const _BITS_CPU_SET_H = @as(c_int, 1);
pub const __CPU_SETSIZE = @as(c_int, 1024);
pub const __NCPUBITS = @as(c_int, 8) * @import("std").zig.c_translation.sizeof(__cpu_mask);
pub inline fn __CPUELT(cpu: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(cpu, __NCPUBITS)) {
    _ = &cpu;
    return @import("std").zig.c_translation.MacroArithmetic.div(cpu, __NCPUBITS);
}
pub inline fn __CPUMASK(cpu: anytype) @TypeOf(@import("std").zig.c_translation.cast(__cpu_mask, @as(c_int, 1)) << @import("std").zig.c_translation.MacroArithmetic.rem(cpu, __NCPUBITS)) {
    _ = &cpu;
    return @import("std").zig.c_translation.cast(__cpu_mask, @as(c_int, 1)) << @import("std").zig.c_translation.MacroArithmetic.rem(cpu, __NCPUBITS);
}
pub const __CPU_ZERO_S = @compileError("unable to translate C expr: unexpected token 'do'");
// /usr/include/bits/cpu-set.h:46:10
pub const __CPU_SET_S = @compileError("unable to translate macro: undefined identifier `__cpu`");
// /usr/include/bits/cpu-set.h:58:9
pub const __CPU_CLR_S = @compileError("unable to translate macro: undefined identifier `__cpu`");
// /usr/include/bits/cpu-set.h:65:9
pub const __CPU_ISSET_S = @compileError("unable to translate macro: undefined identifier `__cpu`");
// /usr/include/bits/cpu-set.h:72:9
pub inline fn __CPU_COUNT_S(setsize: anytype, cpusetp: anytype) @TypeOf(__sched_cpucount(setsize, cpusetp)) {
    _ = &setsize;
    _ = &cpusetp;
    return __sched_cpucount(setsize, cpusetp);
}
pub const __CPU_EQUAL_S = @compileError("unable to translate macro: undefined identifier `__builtin_memcmp`");
// /usr/include/bits/cpu-set.h:84:10
pub const __CPU_OP_S = @compileError("unable to translate macro: undefined identifier `__dest`");
// /usr/include/bits/cpu-set.h:99:9
pub inline fn __CPU_ALLOC_SIZE(count: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div((count + __NCPUBITS) - @as(c_int, 1), __NCPUBITS) * @import("std").zig.c_translation.sizeof(__cpu_mask)) {
    _ = &count;
    return @import("std").zig.c_translation.MacroArithmetic.div((count + __NCPUBITS) - @as(c_int, 1), __NCPUBITS) * @import("std").zig.c_translation.sizeof(__cpu_mask);
}
pub inline fn __CPU_ALLOC(count: anytype) @TypeOf(__sched_cpualloc(count)) {
    _ = &count;
    return __sched_cpualloc(count);
}
pub inline fn __CPU_FREE(cpuset: anytype) @TypeOf(__sched_cpufree(cpuset)) {
    _ = &cpuset;
    return __sched_cpufree(cpuset);
}
pub const __sched_priority = @compileError("unable to translate macro: undefined identifier `sched_priority`");
// /usr/include/sched.h:48:9
pub const CPU_SETSIZE = __CPU_SETSIZE;
pub inline fn CPU_SET(cpu: anytype, cpusetp: anytype) @TypeOf(__CPU_SET_S(cpu, @import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp)) {
    _ = &cpu;
    _ = &cpusetp;
    return __CPU_SET_S(cpu, @import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp);
}
pub inline fn CPU_CLR(cpu: anytype, cpusetp: anytype) @TypeOf(__CPU_CLR_S(cpu, @import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp)) {
    _ = &cpu;
    _ = &cpusetp;
    return __CPU_CLR_S(cpu, @import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp);
}
pub inline fn CPU_ISSET(cpu: anytype, cpusetp: anytype) @TypeOf(__CPU_ISSET_S(cpu, @import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp)) {
    _ = &cpu;
    _ = &cpusetp;
    return __CPU_ISSET_S(cpu, @import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp);
}
pub inline fn CPU_ZERO(cpusetp: anytype) @TypeOf(__CPU_ZERO_S(@import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp)) {
    _ = &cpusetp;
    return __CPU_ZERO_S(@import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp);
}
pub inline fn CPU_COUNT(cpusetp: anytype) @TypeOf(__CPU_COUNT_S(@import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp)) {
    _ = &cpusetp;
    return __CPU_COUNT_S(@import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp);
}
pub inline fn CPU_SET_S(cpu: anytype, setsize: anytype, cpusetp: anytype) @TypeOf(__CPU_SET_S(cpu, setsize, cpusetp)) {
    _ = &cpu;
    _ = &setsize;
    _ = &cpusetp;
    return __CPU_SET_S(cpu, setsize, cpusetp);
}
pub inline fn CPU_CLR_S(cpu: anytype, setsize: anytype, cpusetp: anytype) @TypeOf(__CPU_CLR_S(cpu, setsize, cpusetp)) {
    _ = &cpu;
    _ = &setsize;
    _ = &cpusetp;
    return __CPU_CLR_S(cpu, setsize, cpusetp);
}
pub inline fn CPU_ISSET_S(cpu: anytype, setsize: anytype, cpusetp: anytype) @TypeOf(__CPU_ISSET_S(cpu, setsize, cpusetp)) {
    _ = &cpu;
    _ = &setsize;
    _ = &cpusetp;
    return __CPU_ISSET_S(cpu, setsize, cpusetp);
}
pub inline fn CPU_ZERO_S(setsize: anytype, cpusetp: anytype) @TypeOf(__CPU_ZERO_S(setsize, cpusetp)) {
    _ = &setsize;
    _ = &cpusetp;
    return __CPU_ZERO_S(setsize, cpusetp);
}
pub inline fn CPU_COUNT_S(setsize: anytype, cpusetp: anytype) @TypeOf(__CPU_COUNT_S(setsize, cpusetp)) {
    _ = &setsize;
    _ = &cpusetp;
    return __CPU_COUNT_S(setsize, cpusetp);
}
pub inline fn CPU_EQUAL(cpusetp1: anytype, cpusetp2: anytype) @TypeOf(__CPU_EQUAL_S(@import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp1, cpusetp2)) {
    _ = &cpusetp1;
    _ = &cpusetp2;
    return __CPU_EQUAL_S(@import("std").zig.c_translation.sizeof(cpu_set_t), cpusetp1, cpusetp2);
}
pub inline fn CPU_EQUAL_S(setsize: anytype, cpusetp1: anytype, cpusetp2: anytype) @TypeOf(__CPU_EQUAL_S(setsize, cpusetp1, cpusetp2)) {
    _ = &setsize;
    _ = &cpusetp1;
    _ = &cpusetp2;
    return __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2);
}
pub const CPU_AND = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/sched.h:111:10
pub const CPU_OR = @compileError("unable to translate C expr: unexpected token '|'");
// /usr/include/sched.h:113:10
pub const CPU_XOR = @compileError("unable to translate C expr: unexpected token '^'");
// /usr/include/sched.h:115:10
pub const CPU_AND_S = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/sched.h:117:10
pub const CPU_OR_S = @compileError("unable to translate C expr: unexpected token '|'");
// /usr/include/sched.h:119:10
pub const CPU_XOR_S = @compileError("unable to translate C expr: unexpected token '^'");
// /usr/include/sched.h:121:10
pub inline fn CPU_ALLOC_SIZE(count: anytype) @TypeOf(__CPU_ALLOC_SIZE(count)) {
    _ = &count;
    return __CPU_ALLOC_SIZE(count);
}
pub inline fn CPU_ALLOC(count: anytype) @TypeOf(__CPU_ALLOC(count)) {
    _ = &count;
    return __CPU_ALLOC(count);
}
pub inline fn CPU_FREE(cpuset: anytype) @TypeOf(__CPU_FREE(cpuset)) {
    _ = &cpuset;
    return __CPU_FREE(cpuset);
}
pub const _SYS_SOCKET_H = @as(c_int, 1);
pub const __BITS_SOCKET_H = "";
pub const PF_UNSPEC = @as(c_int, 0);
pub const PF_LOCAL = @as(c_int, 1);
pub const PF_UNIX = PF_LOCAL;
pub const PF_FILE = PF_LOCAL;
pub const PF_INET = @as(c_int, 2);
pub const PF_AX25 = @as(c_int, 3);
pub const PF_IPX = @as(c_int, 4);
pub const PF_APPLETALK = @as(c_int, 5);
pub const PF_NETROM = @as(c_int, 6);
pub const PF_BRIDGE = @as(c_int, 7);
pub const PF_ATMPVC = @as(c_int, 8);
pub const PF_X25 = @as(c_int, 9);
pub const PF_INET6 = @as(c_int, 10);
pub const PF_ROSE = @as(c_int, 11);
pub const PF_DECnet = @as(c_int, 12);
pub const PF_NETBEUI = @as(c_int, 13);
pub const PF_SECURITY = @as(c_int, 14);
pub const PF_KEY = @as(c_int, 15);
pub const PF_NETLINK = @as(c_int, 16);
pub const PF_ROUTE = PF_NETLINK;
pub const PF_PACKET = @as(c_int, 17);
pub const PF_ASH = @as(c_int, 18);
pub const PF_ECONET = @as(c_int, 19);
pub const PF_ATMSVC = @as(c_int, 20);
pub const PF_RDS = @as(c_int, 21);
pub const PF_SNA = @as(c_int, 22);
pub const PF_IRDA = @as(c_int, 23);
pub const PF_PPPOX = @as(c_int, 24);
pub const PF_WANPIPE = @as(c_int, 25);
pub const PF_LLC = @as(c_int, 26);
pub const PF_IB = @as(c_int, 27);
pub const PF_MPLS = @as(c_int, 28);
pub const PF_CAN = @as(c_int, 29);
pub const PF_TIPC = @as(c_int, 30);
pub const PF_BLUETOOTH = @as(c_int, 31);
pub const PF_IUCV = @as(c_int, 32);
pub const PF_RXRPC = @as(c_int, 33);
pub const PF_ISDN = @as(c_int, 34);
pub const PF_PHONET = @as(c_int, 35);
pub const PF_IEEE802154 = @as(c_int, 36);
pub const PF_CAIF = @as(c_int, 37);
pub const PF_ALG = @as(c_int, 38);
pub const PF_NFC = @as(c_int, 39);
pub const PF_VSOCK = @as(c_int, 40);
pub const PF_KCM = @as(c_int, 41);
pub const PF_QIPCRTR = @as(c_int, 42);
pub const PF_SMC = @as(c_int, 43);
pub const PF_XDP = @as(c_int, 44);
pub const PF_MCTP = @as(c_int, 45);
pub const PF_MAX = @as(c_int, 46);
pub const AF_UNSPEC = PF_UNSPEC;
pub const AF_LOCAL = PF_LOCAL;
pub const AF_UNIX = PF_UNIX;
pub const AF_FILE = PF_FILE;
pub const AF_INET = PF_INET;
pub const AF_AX25 = PF_AX25;
pub const AF_IPX = PF_IPX;
pub const AF_APPLETALK = PF_APPLETALK;
pub const AF_NETROM = PF_NETROM;
pub const AF_BRIDGE = PF_BRIDGE;
pub const AF_ATMPVC = PF_ATMPVC;
pub const AF_X25 = PF_X25;
pub const AF_INET6 = PF_INET6;
pub const AF_ROSE = PF_ROSE;
pub const AF_DECnet = PF_DECnet;
pub const AF_NETBEUI = PF_NETBEUI;
pub const AF_SECURITY = PF_SECURITY;
pub const AF_KEY = PF_KEY;
pub const AF_NETLINK = PF_NETLINK;
pub const AF_ROUTE = PF_ROUTE;
pub const AF_PACKET = PF_PACKET;
pub const AF_ASH = PF_ASH;
pub const AF_ECONET = PF_ECONET;
pub const AF_ATMSVC = PF_ATMSVC;
pub const AF_RDS = PF_RDS;
pub const AF_SNA = PF_SNA;
pub const AF_IRDA = PF_IRDA;
pub const AF_PPPOX = PF_PPPOX;
pub const AF_WANPIPE = PF_WANPIPE;
pub const AF_LLC = PF_LLC;
pub const AF_IB = PF_IB;
pub const AF_MPLS = PF_MPLS;
pub const AF_CAN = PF_CAN;
pub const AF_TIPC = PF_TIPC;
pub const AF_BLUETOOTH = PF_BLUETOOTH;
pub const AF_IUCV = PF_IUCV;
pub const AF_RXRPC = PF_RXRPC;
pub const AF_ISDN = PF_ISDN;
pub const AF_PHONET = PF_PHONET;
pub const AF_IEEE802154 = PF_IEEE802154;
pub const AF_CAIF = PF_CAIF;
pub const AF_ALG = PF_ALG;
pub const AF_NFC = PF_NFC;
pub const AF_VSOCK = PF_VSOCK;
pub const AF_KCM = PF_KCM;
pub const AF_QIPCRTR = PF_QIPCRTR;
pub const AF_SMC = PF_SMC;
pub const AF_XDP = PF_XDP;
pub const AF_MCTP = PF_MCTP;
pub const AF_MAX = PF_MAX;
pub const SOL_RAW = @as(c_int, 255);
pub const SOL_DECNET = @as(c_int, 261);
pub const SOL_X25 = @as(c_int, 262);
pub const SOL_PACKET = @as(c_int, 263);
pub const SOL_ATM = @as(c_int, 264);
pub const SOL_AAL = @as(c_int, 265);
pub const SOL_IRDA = @as(c_int, 266);
pub const SOL_NETBEUI = @as(c_int, 267);
pub const SOL_LLC = @as(c_int, 268);
pub const SOL_DCCP = @as(c_int, 269);
pub const SOL_NETLINK = @as(c_int, 270);
pub const SOL_TIPC = @as(c_int, 271);
pub const SOL_RXRPC = @as(c_int, 272);
pub const SOL_PPPOL2TP = @as(c_int, 273);
pub const SOL_BLUETOOTH = @as(c_int, 274);
pub const SOL_PNPIPE = @as(c_int, 275);
pub const SOL_RDS = @as(c_int, 276);
pub const SOL_IUCV = @as(c_int, 277);
pub const SOL_CAIF = @as(c_int, 278);
pub const SOL_ALG = @as(c_int, 279);
pub const SOL_NFC = @as(c_int, 280);
pub const SOL_KCM = @as(c_int, 281);
pub const SOL_TLS = @as(c_int, 282);
pub const SOL_XDP = @as(c_int, 283);
pub const SOL_MPTCP = @as(c_int, 284);
pub const SOL_MCTP = @as(c_int, 285);
pub const SOL_SMC = @as(c_int, 286);
pub const SOL_VSOCK = @as(c_int, 287);
pub const SOMAXCONN = @as(c_int, 4096);
pub const _BITS_SOCKADDR_H = @as(c_int, 1);
pub const __SOCKADDR_COMMON = @compileError("unable to translate macro: undefined identifier `family`");
// /usr/include/bits/sockaddr.h:34:9
pub const __SOCKADDR_COMMON_SIZE = @import("std").zig.c_translation.sizeof(c_ushort);
pub const _SS_SIZE = @as(c_int, 128);
pub const __ss_aligntype = c_ulong;
pub const _SS_PADSIZE = (_SS_SIZE - __SOCKADDR_COMMON_SIZE) - @import("std").zig.c_translation.sizeof(__ss_aligntype);
pub inline fn CMSG_DATA(cmsg: anytype) @TypeOf(cmsg.*.__cmsg_data) {
    _ = &cmsg;
    return cmsg.*.__cmsg_data;
}
pub inline fn CMSG_NXTHDR(mhdr: anytype, cmsg: anytype) @TypeOf(__cmsg_nxthdr(mhdr, cmsg)) {
    _ = &mhdr;
    _ = &cmsg;
    return __cmsg_nxthdr(mhdr, cmsg);
}
pub inline fn CMSG_FIRSTHDR(mhdr: anytype) @TypeOf(if (@import("std").zig.c_translation.cast(usize, mhdr.*.msg_controllen) >= @import("std").zig.c_translation.sizeof(struct_cmsghdr)) @import("std").zig.c_translation.cast([*c]struct_cmsghdr, mhdr.*.msg_control) else @import("std").zig.c_translation.cast([*c]struct_cmsghdr, @as(c_int, 0))) {
    _ = &mhdr;
    return if (@import("std").zig.c_translation.cast(usize, mhdr.*.msg_controllen) >= @import("std").zig.c_translation.sizeof(struct_cmsghdr)) @import("std").zig.c_translation.cast([*c]struct_cmsghdr, mhdr.*.msg_control) else @import("std").zig.c_translation.cast([*c]struct_cmsghdr, @as(c_int, 0));
}
pub inline fn CMSG_ALIGN(len: anytype) @TypeOf(((len + @import("std").zig.c_translation.sizeof(usize)) - @as(c_int, 1)) & @import("std").zig.c_translation.cast(usize, ~(@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)))) {
    _ = &len;
    return ((len + @import("std").zig.c_translation.sizeof(usize)) - @as(c_int, 1)) & @import("std").zig.c_translation.cast(usize, ~(@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)));
}
pub inline fn CMSG_SPACE(len: anytype) @TypeOf(CMSG_ALIGN(len) + CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr))) {
    _ = &len;
    return CMSG_ALIGN(len) + CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr));
}
pub inline fn CMSG_LEN(len: anytype) @TypeOf(CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr)) + len) {
    _ = &len;
    return CMSG_ALIGN(@import("std").zig.c_translation.sizeof(struct_cmsghdr)) + len;
}
pub inline fn __CMSG_PADDING(len: anytype) @TypeOf((@import("std").zig.c_translation.sizeof(usize) - (len & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)))) & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1))) {
    _ = &len;
    return (@import("std").zig.c_translation.sizeof(usize) - (len & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1)))) & (@import("std").zig.c_translation.sizeof(usize) - @as(c_int, 1));
}
pub const __ASM_GENERIC_SOCKET_H = "";
pub const __ASM_GENERIC_SOCKIOS_H = "";
pub const FIOSETOWN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8901, .hex);
pub const SIOCSPGRP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8902, .hex);
pub const FIOGETOWN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8903, .hex);
pub const SIOCGPGRP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8904, .hex);
pub const SIOCATMARK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8905, .hex);
pub const SIOCGSTAMP_OLD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8906, .hex);
pub const SIOCGSTAMPNS_OLD = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8907, .hex);
pub const SOL_SOCKET = @as(c_int, 1);
pub const SO_DEBUG = @as(c_int, 1);
pub const SO_REUSEADDR = @as(c_int, 2);
pub const SO_TYPE = @as(c_int, 3);
pub const SO_ERROR = @as(c_int, 4);
pub const SO_DONTROUTE = @as(c_int, 5);
pub const SO_BROADCAST = @as(c_int, 6);
pub const SO_SNDBUF = @as(c_int, 7);
pub const SO_RCVBUF = @as(c_int, 8);
pub const SO_SNDBUFFORCE = @as(c_int, 32);
pub const SO_RCVBUFFORCE = @as(c_int, 33);
pub const SO_KEEPALIVE = @as(c_int, 9);
pub const SO_OOBINLINE = @as(c_int, 10);
pub const SO_NO_CHECK = @as(c_int, 11);
pub const SO_PRIORITY = @as(c_int, 12);
pub const SO_LINGER = @as(c_int, 13);
pub const SO_BSDCOMPAT = @as(c_int, 14);
pub const SO_REUSEPORT = @as(c_int, 15);
pub const SO_PASSCRED = @as(c_int, 16);
pub const SO_PEERCRED = @as(c_int, 17);
pub const SO_RCVLOWAT = @as(c_int, 18);
pub const SO_SNDLOWAT = @as(c_int, 19);
pub const SO_RCVTIMEO_OLD = @as(c_int, 20);
pub const SO_SNDTIMEO_OLD = @as(c_int, 21);
pub const SO_SECURITY_AUTHENTICATION = @as(c_int, 22);
pub const SO_SECURITY_ENCRYPTION_TRANSPORT = @as(c_int, 23);
pub const SO_SECURITY_ENCRYPTION_NETWORK = @as(c_int, 24);
pub const SO_BINDTODEVICE = @as(c_int, 25);
pub const SO_ATTACH_FILTER = @as(c_int, 26);
pub const SO_DETACH_FILTER = @as(c_int, 27);
pub const SO_GET_FILTER = SO_ATTACH_FILTER;
pub const SO_PEERNAME = @as(c_int, 28);
pub const SO_ACCEPTCONN = @as(c_int, 30);
pub const SO_PEERSEC = @as(c_int, 31);
pub const SO_PASSSEC = @as(c_int, 34);
pub const SO_MARK = @as(c_int, 36);
pub const SO_PROTOCOL = @as(c_int, 38);
pub const SO_DOMAIN = @as(c_int, 39);
pub const SO_RXQ_OVFL = @as(c_int, 40);
pub const SO_WIFI_STATUS = @as(c_int, 41);
pub const SCM_WIFI_STATUS = SO_WIFI_STATUS;
pub const SO_PEEK_OFF = @as(c_int, 42);
pub const SO_NOFCS = @as(c_int, 43);
pub const SO_LOCK_FILTER = @as(c_int, 44);
pub const SO_SELECT_ERR_QUEUE = @as(c_int, 45);
pub const SO_BUSY_POLL = @as(c_int, 46);
pub const SO_MAX_PACING_RATE = @as(c_int, 47);
pub const SO_BPF_EXTENSIONS = @as(c_int, 48);
pub const SO_INCOMING_CPU = @as(c_int, 49);
pub const SO_ATTACH_BPF = @as(c_int, 50);
pub const SO_DETACH_BPF = SO_DETACH_FILTER;
pub const SO_ATTACH_REUSEPORT_CBPF = @as(c_int, 51);
pub const SO_ATTACH_REUSEPORT_EBPF = @as(c_int, 52);
pub const SO_CNX_ADVICE = @as(c_int, 53);
pub const SCM_TIMESTAMPING_OPT_STATS = @as(c_int, 54);
pub const SO_MEMINFO = @as(c_int, 55);
pub const SO_INCOMING_NAPI_ID = @as(c_int, 56);
pub const SO_COOKIE = @as(c_int, 57);
pub const SCM_TIMESTAMPING_PKTINFO = @as(c_int, 58);
pub const SO_PEERGROUPS = @as(c_int, 59);
pub const SO_ZEROCOPY = @as(c_int, 60);
pub const SO_TXTIME = @as(c_int, 61);
pub const SCM_TXTIME = SO_TXTIME;
pub const SO_BINDTOIFINDEX = @as(c_int, 62);
pub const SO_TIMESTAMP_OLD = @as(c_int, 29);
pub const SO_TIMESTAMPNS_OLD = @as(c_int, 35);
pub const SO_TIMESTAMPING_OLD = @as(c_int, 37);
pub const SO_TIMESTAMP_NEW = @as(c_int, 63);
pub const SO_TIMESTAMPNS_NEW = @as(c_int, 64);
pub const SO_TIMESTAMPING_NEW = @as(c_int, 65);
pub const SO_RCVTIMEO_NEW = @as(c_int, 66);
pub const SO_SNDTIMEO_NEW = @as(c_int, 67);
pub const SO_DETACH_REUSEPORT_BPF = @as(c_int, 68);
pub const SO_PREFER_BUSY_POLL = @as(c_int, 69);
pub const SO_BUSY_POLL_BUDGET = @as(c_int, 70);
pub const SO_NETNS_COOKIE = @as(c_int, 71);
pub const SO_BUF_LOCK = @as(c_int, 72);
pub const SO_RESERVE_MEM = @as(c_int, 73);
pub const SO_TXREHASH = @as(c_int, 74);
pub const SO_RCVMARK = @as(c_int, 75);
pub const SO_PASSPIDFD = @as(c_int, 76);
pub const SO_PEERPIDFD = @as(c_int, 77);
pub const SO_TIMESTAMP = SO_TIMESTAMP_OLD;
pub const SO_TIMESTAMPNS = SO_TIMESTAMPNS_OLD;
pub const SO_TIMESTAMPING = SO_TIMESTAMPING_OLD;
pub const SO_RCVTIMEO = SO_RCVTIMEO_OLD;
pub const SO_SNDTIMEO = SO_SNDTIMEO_OLD;
pub const SCM_TIMESTAMP = SO_TIMESTAMP;
pub const SCM_TIMESTAMPNS = SO_TIMESTAMPNS;
pub const SCM_TIMESTAMPING = SO_TIMESTAMPING;
pub const __osockaddr_defined = @as(c_int, 1);
pub const __SOCKADDR_ALLTYPES = @compileError("unable to translate macro: undefined identifier `sockaddr_at`");
// /usr/include/sys/socket.h:63:10
pub const __SOCKADDR_ONETYPE = @compileError("unable to translate macro: untranslatable usage of arg `type`");
// /usr/include/sys/socket.h:78:10
pub const _NETINET_IN_H = @as(c_int, 1);
pub const _BITS_STDINT_UINTN_H = @as(c_int, 1);
pub const __USE_KERNEL_IPV6_DEFS = @as(c_int, 0);
pub const IP_OPTIONS = @as(c_int, 4);
pub const IP_HDRINCL = @as(c_int, 3);
pub const IP_TOS = @as(c_int, 1);
pub const IP_TTL = @as(c_int, 2);
pub const IP_RECVOPTS = @as(c_int, 6);
pub const IP_RECVRETOPTS = IP_RETOPTS;
pub const IP_RETOPTS = @as(c_int, 7);
pub const IP_MULTICAST_IF = @as(c_int, 32);
pub const IP_MULTICAST_TTL = @as(c_int, 33);
pub const IP_MULTICAST_LOOP = @as(c_int, 34);
pub const IP_ADD_MEMBERSHIP = @as(c_int, 35);
pub const IP_DROP_MEMBERSHIP = @as(c_int, 36);
pub const IP_UNBLOCK_SOURCE = @as(c_int, 37);
pub const IP_BLOCK_SOURCE = @as(c_int, 38);
pub const IP_ADD_SOURCE_MEMBERSHIP = @as(c_int, 39);
pub const IP_DROP_SOURCE_MEMBERSHIP = @as(c_int, 40);
pub const IP_MSFILTER = @as(c_int, 41);
pub const MCAST_JOIN_GROUP = @as(c_int, 42);
pub const MCAST_BLOCK_SOURCE = @as(c_int, 43);
pub const MCAST_UNBLOCK_SOURCE = @as(c_int, 44);
pub const MCAST_LEAVE_GROUP = @as(c_int, 45);
pub const MCAST_JOIN_SOURCE_GROUP = @as(c_int, 46);
pub const MCAST_LEAVE_SOURCE_GROUP = @as(c_int, 47);
pub const MCAST_MSFILTER = @as(c_int, 48);
pub const IP_MULTICAST_ALL = @as(c_int, 49);
pub const IP_UNICAST_IF = @as(c_int, 50);
pub const MCAST_EXCLUDE = @as(c_int, 0);
pub const MCAST_INCLUDE = @as(c_int, 1);
pub const IP_ROUTER_ALERT = @as(c_int, 5);
pub const IP_PKTINFO = @as(c_int, 8);
pub const IP_PKTOPTIONS = @as(c_int, 9);
pub const IP_PMTUDISC = @as(c_int, 10);
pub const IP_MTU_DISCOVER = @as(c_int, 10);
pub const IP_RECVERR = @as(c_int, 11);
pub const IP_RECVTTL = @as(c_int, 12);
pub const IP_RECVTOS = @as(c_int, 13);
pub const IP_MTU = @as(c_int, 14);
pub const IP_FREEBIND = @as(c_int, 15);
pub const IP_IPSEC_POLICY = @as(c_int, 16);
pub const IP_XFRM_POLICY = @as(c_int, 17);
pub const IP_PASSSEC = @as(c_int, 18);
pub const IP_TRANSPARENT = @as(c_int, 19);
pub const IP_ORIGDSTADDR = @as(c_int, 20);
pub const IP_RECVORIGDSTADDR = IP_ORIGDSTADDR;
pub const IP_MINTTL = @as(c_int, 21);
pub const IP_NODEFRAG = @as(c_int, 22);
pub const IP_CHECKSUM = @as(c_int, 23);
pub const IP_BIND_ADDRESS_NO_PORT = @as(c_int, 24);
pub const IP_RECVFRAGSIZE = @as(c_int, 25);
pub const IP_RECVERR_RFC4884 = @as(c_int, 26);
pub const IP_PMTUDISC_DONT = @as(c_int, 0);
pub const IP_PMTUDISC_WANT = @as(c_int, 1);
pub const IP_PMTUDISC_DO = @as(c_int, 2);
pub const IP_PMTUDISC_PROBE = @as(c_int, 3);
pub const IP_PMTUDISC_INTERFACE = @as(c_int, 4);
pub const IP_PMTUDISC_OMIT = @as(c_int, 5);
pub const IP_LOCAL_PORT_RANGE = @as(c_int, 51);
pub const IP_PROTOCOL = @as(c_int, 52);
pub const SOL_IP = @as(c_int, 0);
pub const IP_DEFAULT_MULTICAST_TTL = @as(c_int, 1);
pub const IP_DEFAULT_MULTICAST_LOOP = @as(c_int, 1);
pub const IP_MAX_MEMBERSHIPS = @as(c_int, 20);
pub const IPV6_ADDRFORM = @as(c_int, 1);
pub const IPV6_2292PKTINFO = @as(c_int, 2);
pub const IPV6_2292HOPOPTS = @as(c_int, 3);
pub const IPV6_2292DSTOPTS = @as(c_int, 4);
pub const IPV6_2292RTHDR = @as(c_int, 5);
pub const IPV6_2292PKTOPTIONS = @as(c_int, 6);
pub const IPV6_CHECKSUM = @as(c_int, 7);
pub const IPV6_2292HOPLIMIT = @as(c_int, 8);
pub const SCM_SRCRT = @compileError("unable to translate macro: undefined identifier `IPV6_RXSRCRT`");
// /usr/include/bits/in.h:172:9
pub const IPV6_NEXTHOP = @as(c_int, 9);
pub const IPV6_AUTHHDR = @as(c_int, 10);
pub const IPV6_UNICAST_HOPS = @as(c_int, 16);
pub const IPV6_MULTICAST_IF = @as(c_int, 17);
pub const IPV6_MULTICAST_HOPS = @as(c_int, 18);
pub const IPV6_MULTICAST_LOOP = @as(c_int, 19);
pub const IPV6_JOIN_GROUP = @as(c_int, 20);
pub const IPV6_LEAVE_GROUP = @as(c_int, 21);
pub const IPV6_ROUTER_ALERT = @as(c_int, 22);
pub const IPV6_MTU_DISCOVER = @as(c_int, 23);
pub const IPV6_MTU = @as(c_int, 24);
pub const IPV6_RECVERR = @as(c_int, 25);
pub const IPV6_V6ONLY = @as(c_int, 26);
pub const IPV6_JOIN_ANYCAST = @as(c_int, 27);
pub const IPV6_LEAVE_ANYCAST = @as(c_int, 28);
pub const IPV6_MULTICAST_ALL = @as(c_int, 29);
pub const IPV6_ROUTER_ALERT_ISOLATE = @as(c_int, 30);
pub const IPV6_RECVERR_RFC4884 = @as(c_int, 31);
pub const IPV6_IPSEC_POLICY = @as(c_int, 34);
pub const IPV6_XFRM_POLICY = @as(c_int, 35);
pub const IPV6_HDRINCL = @as(c_int, 36);
pub const IPV6_RECVPKTINFO = @as(c_int, 49);
pub const IPV6_PKTINFO = @as(c_int, 50);
pub const IPV6_RECVHOPLIMIT = @as(c_int, 51);
pub const IPV6_HOPLIMIT = @as(c_int, 52);
pub const IPV6_RECVHOPOPTS = @as(c_int, 53);
pub const IPV6_HOPOPTS = @as(c_int, 54);
pub const IPV6_RTHDRDSTOPTS = @as(c_int, 55);
pub const IPV6_RECVRTHDR = @as(c_int, 56);
pub const IPV6_RTHDR = @as(c_int, 57);
pub const IPV6_RECVDSTOPTS = @as(c_int, 58);
pub const IPV6_DSTOPTS = @as(c_int, 59);
pub const IPV6_RECVPATHMTU = @as(c_int, 60);
pub const IPV6_PATHMTU = @as(c_int, 61);
pub const IPV6_DONTFRAG = @as(c_int, 62);
pub const IPV6_RECVTCLASS = @as(c_int, 66);
pub const IPV6_TCLASS = @as(c_int, 67);
pub const IPV6_AUTOFLOWLABEL = @as(c_int, 70);
pub const IPV6_ADDR_PREFERENCES = @as(c_int, 72);
pub const IPV6_MINHOPCOUNT = @as(c_int, 73);
pub const IPV6_ORIGDSTADDR = @as(c_int, 74);
pub const IPV6_RECVORIGDSTADDR = IPV6_ORIGDSTADDR;
pub const IPV6_TRANSPARENT = @as(c_int, 75);
pub const IPV6_UNICAST_IF = @as(c_int, 76);
pub const IPV6_RECVFRAGSIZE = @as(c_int, 77);
pub const IPV6_FREEBIND = @as(c_int, 78);
pub const IPV6_ADD_MEMBERSHIP = IPV6_JOIN_GROUP;
pub const IPV6_DROP_MEMBERSHIP = IPV6_LEAVE_GROUP;
pub const IPV6_RXHOPOPTS = IPV6_HOPOPTS;
pub const IPV6_RXDSTOPTS = IPV6_DSTOPTS;
pub const IPV6_PMTUDISC_DONT = @as(c_int, 0);
pub const IPV6_PMTUDISC_WANT = @as(c_int, 1);
pub const IPV6_PMTUDISC_DO = @as(c_int, 2);
pub const IPV6_PMTUDISC_PROBE = @as(c_int, 3);
pub const IPV6_PMTUDISC_INTERFACE = @as(c_int, 4);
pub const IPV6_PMTUDISC_OMIT = @as(c_int, 5);
pub const SOL_IPV6 = @as(c_int, 41);
pub const SOL_ICMPV6 = @as(c_int, 58);
pub const IPV6_RTHDR_LOOSE = @as(c_int, 0);
pub const IPV6_RTHDR_STRICT = @as(c_int, 1);
pub const IPV6_RTHDR_TYPE_0 = @as(c_int, 0);
pub inline fn IN_CLASSA(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex)) == @as(c_int, 0)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex)) == @as(c_int, 0);
}
pub const IN_CLASSA_NET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff000000, .hex);
pub const IN_CLASSA_NSHIFT = @as(c_int, 24);
pub const IN_CLASSA_HOST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex) & ~IN_CLASSA_NET;
pub const IN_CLASSA_MAX = @as(c_int, 128);
pub inline fn IN_CLASSB(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
}
pub const IN_CLASSB_NET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff0000, .hex);
pub const IN_CLASSB_NSHIFT = @as(c_int, 16);
pub const IN_CLASSB_HOST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex) & ~IN_CLASSB_NET;
pub const IN_CLASSB_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65536, .decimal);
pub inline fn IN_CLASSC(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hex)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000000, .hex);
}
pub const IN_CLASSC_NET = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffff00, .hex);
pub const IN_CLASSC_NSHIFT = @as(c_int, 8);
pub const IN_CLASSC_HOST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex) & ~IN_CLASSC_NET;
pub inline fn IN_CLASSD(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex);
}
pub inline fn IN_MULTICAST(a: anytype) @TypeOf(IN_CLASSD(a)) {
    _ = &a;
    return IN_CLASSD(a);
}
pub inline fn IN_EXPERIMENTAL(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex);
}
pub inline fn IN_BADCLASS(a: anytype) @TypeOf((@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex)) {
    _ = &a;
    return (@import("std").zig.c_translation.cast(in_addr_t, a) & @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex)) == @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xf0000000, .hex);
}
pub const INADDR_ANY = @import("std").zig.c_translation.cast(in_addr_t, @as(c_int, 0x00000000));
pub const INADDR_BROADCAST = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex));
pub const INADDR_NONE = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex));
pub const INADDR_DUMMY = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xc0000008, .hex));
pub const IN_LOOPBACKNET = @as(c_int, 127);
pub const INADDR_LOOPBACK = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7f000001, .hex));
pub const INADDR_UNSPEC_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000000, .hex));
pub const INADDR_ALLHOSTS_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000001, .hex));
pub const INADDR_ALLRTRS_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe0000002, .hex));
pub const INADDR_ALLSNOOPERS_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe000006a, .hex));
pub const INADDR_MAX_LOCAL_GROUP = @import("std").zig.c_translation.cast(in_addr_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xe00000ff, .hex));
pub const s6_addr = @compileError("unable to translate macro: undefined identifier `__in6_u`");
// /usr/include/netinet/in.h:229:9
pub const s6_addr16 = @compileError("unable to translate macro: undefined identifier `__in6_u`");
// /usr/include/netinet/in.h:231:10
pub const s6_addr32 = @compileError("unable to translate macro: undefined identifier `__in6_u`");
// /usr/include/netinet/in.h:232:10
pub const IN6ADDR_ANY_INIT = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/netinet/in.h:239:9
pub const IN6ADDR_LOOPBACK_INIT = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/netinet/in.h:240:9
pub const INET_ADDRSTRLEN = @as(c_int, 16);
pub const INET6_ADDRSTRLEN = @as(c_int, 46);
pub inline fn IP_MSFILTER_SIZE(numsrc: anytype) @TypeOf((@import("std").zig.c_translation.sizeof(struct_ip_msfilter) - @import("std").zig.c_translation.sizeof(struct_in_addr)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_in_addr))) {
    _ = &numsrc;
    return (@import("std").zig.c_translation.sizeof(struct_ip_msfilter) - @import("std").zig.c_translation.sizeof(struct_in_addr)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_in_addr));
}
pub inline fn GROUP_FILTER_SIZE(numsrc: anytype) @TypeOf((@import("std").zig.c_translation.sizeof(struct_group_filter) - @import("std").zig.c_translation.sizeof(struct_sockaddr_storage)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_sockaddr_storage))) {
    _ = &numsrc;
    return (@import("std").zig.c_translation.sizeof(struct_group_filter) - @import("std").zig.c_translation.sizeof(struct_sockaddr_storage)) + (numsrc * @import("std").zig.c_translation.sizeof(struct_sockaddr_storage));
}
pub const IN6_IS_ADDR_UNSPECIFIED = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:435:10
pub const IN6_IS_ADDR_LOOPBACK = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:443:10
pub const IN6_IS_ADDR_LINKLOCAL = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:451:10
pub const IN6_IS_ADDR_SITELOCAL = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:456:10
pub const IN6_IS_ADDR_V4MAPPED = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:461:10
pub const IN6_IS_ADDR_V4COMPAT = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:468:10
pub const IN6_ARE_ADDR_EQUAL = @compileError("unable to translate macro: undefined identifier `__a`");
// /usr/include/netinet/in.h:476:10
pub const IN6_IS_ADDR_MULTICAST = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:523:9
pub const IN6_IS_ADDR_MC_NODELOCAL = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:535:9
pub const IN6_IS_ADDR_MC_LINKLOCAL = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:539:9
pub const IN6_IS_ADDR_MC_SITELOCAL = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:543:9
pub const IN6_IS_ADDR_MC_ORGLOCAL = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:547:9
pub const IN6_IS_ADDR_MC_GLOBAL = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/netinet/in.h:551:9
pub const _NETINET_TCP_H = @as(c_int, 1);
pub const TCP_NODELAY = @as(c_int, 1);
pub const TCP_MAXSEG = @as(c_int, 2);
pub const TCP_CORK = @as(c_int, 3);
pub const TCP_KEEPIDLE = @as(c_int, 4);
pub const TCP_KEEPINTVL = @as(c_int, 5);
pub const TCP_KEEPCNT = @as(c_int, 6);
pub const TCP_SYNCNT = @as(c_int, 7);
pub const TCP_LINGER2 = @as(c_int, 8);
pub const TCP_DEFER_ACCEPT = @as(c_int, 9);
pub const TCP_WINDOW_CLAMP = @as(c_int, 10);
pub const TCP_INFO = @as(c_int, 11);
pub const TCP_QUICKACK = @as(c_int, 12);
pub const TCP_CONGESTION = @as(c_int, 13);
pub const TCP_MD5SIG = @as(c_int, 14);
pub const TCP_COOKIE_TRANSACTIONS = @as(c_int, 15);
pub const TCP_THIN_LINEAR_TIMEOUTS = @as(c_int, 16);
pub const TCP_THIN_DUPACK = @as(c_int, 17);
pub const TCP_USER_TIMEOUT = @as(c_int, 18);
pub const TCP_REPAIR = @as(c_int, 19);
pub const TCP_REPAIR_QUEUE = @as(c_int, 20);
pub const TCP_QUEUE_SEQ = @as(c_int, 21);
pub const TCP_REPAIR_OPTIONS = @as(c_int, 22);
pub const TCP_FASTOPEN = @as(c_int, 23);
pub const TCP_TIMESTAMP = @as(c_int, 24);
pub const TCP_NOTSENT_LOWAT = @as(c_int, 25);
pub const TCP_CC_INFO = @as(c_int, 26);
pub const TCP_SAVE_SYN = @as(c_int, 27);
pub const TCP_SAVED_SYN = @as(c_int, 28);
pub const TCP_REPAIR_WINDOW = @as(c_int, 29);
pub const TCP_FASTOPEN_CONNECT = @as(c_int, 30);
pub const TCP_ULP = @as(c_int, 31);
pub const TCP_MD5SIG_EXT = @as(c_int, 32);
pub const TCP_FASTOPEN_KEY = @as(c_int, 33);
pub const TCP_FASTOPEN_NO_COOKIE = @as(c_int, 34);
pub const TCP_ZEROCOPY_RECEIVE = @as(c_int, 35);
pub const TCP_INQ = @as(c_int, 36);
pub const TCP_CM_INQ = TCP_INQ;
pub const TCP_TX_DELAY = @as(c_int, 37);
pub const TCP_REPAIR_ON = @as(c_int, 1);
pub const TCP_REPAIR_OFF = @as(c_int, 0);
pub const TCP_REPAIR_OFF_NO_WP = -@as(c_int, 1);
pub const _STDINT_H = @as(c_int, 1);
pub const _BITS_WCHAR_H = @as(c_int, 1);
pub const __WCHAR_MAX = __WCHAR_MAX__;
pub const __WCHAR_MIN = -__WCHAR_MAX - @as(c_int, 1);
pub const _BITS_STDINT_LEAST_H = @as(c_int, 1);
pub const __INT64_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const __UINT64_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const INT8_MIN = -@as(c_int, 128);
pub const INT16_MIN = -@as(c_int, 32767) - @as(c_int, 1);
pub const INT32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT8_MAX = @as(c_int, 127);
pub const INT16_MAX = @as(c_int, 32767);
pub const INT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT8_MAX = @as(c_int, 255);
pub const UINT16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const UINT64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INT_LEAST8_MIN = -@as(c_int, 128);
pub const INT_LEAST16_MIN = -@as(c_int, 32767) - @as(c_int, 1);
pub const INT_LEAST32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const INT_LEAST64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT_LEAST8_MAX = @as(c_int, 127);
pub const INT_LEAST16_MAX = @as(c_int, 32767);
pub const INT_LEAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const INT_LEAST64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT_LEAST8_MAX = @as(c_int, 255);
pub const UINT_LEAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const UINT_LEAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub const UINT_LEAST64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INT_FAST8_MIN = -@as(c_int, 128);
pub const INT_FAST16_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INT_FAST32_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INT_FAST64_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INT_FAST8_MAX = @as(c_int, 127);
pub const INT_FAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const INT_FAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const INT_FAST64_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINT_FAST8_MAX = @as(c_int, 255);
pub const UINT_FAST16_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const UINT_FAST32_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const UINT_FAST64_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const INTPTR_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const INTPTR_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const UINTPTR_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const INTMAX_MIN = -__INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal)) - @as(c_int, 1);
pub const INTMAX_MAX = __INT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal));
pub const UINTMAX_MAX = __UINT64_C(@import("std").zig.c_translation.promoteIntLiteral(c_int, 18446744073709551615, .decimal));
pub const PTRDIFF_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal) - @as(c_int, 1);
pub const PTRDIFF_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_long, 9223372036854775807, .decimal);
pub const SIG_ATOMIC_MIN = -@import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal) - @as(c_int, 1);
pub const SIG_ATOMIC_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 2147483647, .decimal);
pub const SIZE_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_ulong, 18446744073709551615, .decimal);
pub const WCHAR_MIN = __WCHAR_MIN;
pub const WCHAR_MAX = __WCHAR_MAX;
pub const WINT_MIN = @as(c_uint, 0);
pub const WINT_MAX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 4294967295, .decimal);
pub inline fn INT8_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub inline fn INT16_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub inline fn INT32_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub const INT64_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub inline fn UINT8_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub inline fn UINT16_C(c: anytype) @TypeOf(c) {
    _ = &c;
    return c;
}
pub const UINT32_C = @import("std").zig.c_translation.Macros.U_SUFFIX;
pub const UINT64_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const INTMAX_C = @import("std").zig.c_translation.Macros.L_SUFFIX;
pub const UINTMAX_C = @import("std").zig.c_translation.Macros.UL_SUFFIX;
pub const INT8_WIDTH = @as(c_int, 8);
pub const UINT8_WIDTH = @as(c_int, 8);
pub const INT16_WIDTH = @as(c_int, 16);
pub const UINT16_WIDTH = @as(c_int, 16);
pub const INT32_WIDTH = @as(c_int, 32);
pub const UINT32_WIDTH = @as(c_int, 32);
pub const INT64_WIDTH = @as(c_int, 64);
pub const UINT64_WIDTH = @as(c_int, 64);
pub const INT_LEAST8_WIDTH = @as(c_int, 8);
pub const UINT_LEAST8_WIDTH = @as(c_int, 8);
pub const INT_LEAST16_WIDTH = @as(c_int, 16);
pub const UINT_LEAST16_WIDTH = @as(c_int, 16);
pub const INT_LEAST32_WIDTH = @as(c_int, 32);
pub const UINT_LEAST32_WIDTH = @as(c_int, 32);
pub const INT_LEAST64_WIDTH = @as(c_int, 64);
pub const UINT_LEAST64_WIDTH = @as(c_int, 64);
pub const INT_FAST8_WIDTH = @as(c_int, 8);
pub const UINT_FAST8_WIDTH = @as(c_int, 8);
pub const INT_FAST16_WIDTH = __WORDSIZE;
pub const UINT_FAST16_WIDTH = __WORDSIZE;
pub const INT_FAST32_WIDTH = __WORDSIZE;
pub const UINT_FAST32_WIDTH = __WORDSIZE;
pub const INT_FAST64_WIDTH = @as(c_int, 64);
pub const UINT_FAST64_WIDTH = @as(c_int, 64);
pub const INTPTR_WIDTH = __WORDSIZE;
pub const UINTPTR_WIDTH = __WORDSIZE;
pub const INTMAX_WIDTH = @as(c_int, 64);
pub const UINTMAX_WIDTH = @as(c_int, 64);
pub const PTRDIFF_WIDTH = __WORDSIZE;
pub const SIG_ATOMIC_WIDTH = @as(c_int, 32);
pub const SIZE_WIDTH = __WORDSIZE;
pub const WCHAR_WIDTH = @as(c_int, 32);
pub const WINT_WIDTH = @as(c_int, 32);
pub const TH_FIN = @as(c_int, 0x01);
pub const TH_SYN = @as(c_int, 0x02);
pub const TH_RST = @as(c_int, 0x04);
pub const TH_PUSH = @as(c_int, 0x08);
pub const TH_ACK = @as(c_int, 0x10);
pub const TH_URG = @as(c_int, 0x20);
pub const TCPOPT_EOL = @as(c_int, 0);
pub const TCPOPT_NOP = @as(c_int, 1);
pub const TCPOPT_MAXSEG = @as(c_int, 2);
pub const TCPOLEN_MAXSEG = @as(c_int, 4);
pub const TCPOPT_WINDOW = @as(c_int, 3);
pub const TCPOLEN_WINDOW = @as(c_int, 3);
pub const TCPOPT_SACK_PERMITTED = @as(c_int, 4);
pub const TCPOLEN_SACK_PERMITTED = @as(c_int, 2);
pub const TCPOPT_SACK = @as(c_int, 5);
pub const TCPOPT_TIMESTAMP = @as(c_int, 8);
pub const TCPOLEN_TIMESTAMP = @as(c_int, 10);
pub const TCPOLEN_TSTAMP_APPA = TCPOLEN_TIMESTAMP + @as(c_int, 2);
pub const TCPOPT_TSTAMP_HDR = (((TCPOPT_NOP << @as(c_int, 24)) | (TCPOPT_NOP << @as(c_int, 16))) | (TCPOPT_TIMESTAMP << @as(c_int, 8))) | TCPOLEN_TIMESTAMP;
pub const TCP_MSS = @as(c_int, 512);
pub const TCP_MAXWIN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 65535, .decimal);
pub const TCP_MAX_WINSHIFT = @as(c_int, 14);
pub const SOL_TCP = @as(c_int, 6);
pub const TCPI_OPT_TIMESTAMPS = @as(c_int, 1);
pub const TCPI_OPT_SACK = @as(c_int, 2);
pub const TCPI_OPT_WSCALE = @as(c_int, 4);
pub const TCPI_OPT_ECN = @as(c_int, 8);
pub const TCPI_OPT_ECN_SEEN = @as(c_int, 16);
pub const TCPI_OPT_SYN_DATA = @as(c_int, 32);
pub const TCP_MD5SIG_MAXKEYLEN = @as(c_int, 80);
pub const TCP_MD5SIG_FLAG_PREFIX = @as(c_int, 1);
pub const TCP_MD5SIG_FLAG_IFINDEX = @as(c_int, 2);
pub const TCP_COOKIE_MIN = @as(c_int, 8);
pub const TCP_COOKIE_MAX = @as(c_int, 16);
pub const TCP_COOKIE_PAIR_SIZE = @as(c_int, 2) * TCP_COOKIE_MAX;
pub const TCP_COOKIE_IN_ALWAYS = @as(c_int, 1) << @as(c_int, 0);
pub const TCP_COOKIE_OUT_NEVER = @as(c_int, 1) << @as(c_int, 1);
pub const TCP_S_DATA_IN = @as(c_int, 1) << @as(c_int, 2);
pub const TCP_S_DATA_OUT = @as(c_int, 1) << @as(c_int, 3);
pub const TCP_MSS_DEFAULT = @as(c_uint, 536);
pub const TCP_MSS_DESIRED = @as(c_uint, 1220);
pub const _ARPA_INET_H = @as(c_int, 1);
pub const _NETDB_H = @as(c_int, 1);
pub const _RPC_NETDB_H = @as(c_int, 1);
pub const _PATH_HEQUIV = "/etc/hosts.equiv";
pub const _PATH_HOSTS = "/etc/hosts";
pub const _PATH_NETWORKS = "/etc/networks";
pub const _PATH_NSSWITCH_CONF = "/etc/nsswitch.conf";
pub const _PATH_PROTOCOLS = "/etc/protocols";
pub const _PATH_SERVICES = "/etc/services";
pub const h_errno = __h_errno_location().*;
pub const HOST_NOT_FOUND = @as(c_int, 1);
pub const TRY_AGAIN = @as(c_int, 2);
pub const NO_RECOVERY = @as(c_int, 3);
pub const NO_DATA = @as(c_int, 4);
pub const NETDB_INTERNAL = -@as(c_int, 1);
pub const NETDB_SUCCESS = @as(c_int, 0);
pub const NO_ADDRESS = NO_DATA;
pub const SCOPE_DELIMITER = '%';
pub const h_addr = @compileError("unable to translate macro: undefined identifier `h_addr_list`");
// /usr/include/netdb.h:106:10
pub const GAI_WAIT = @as(c_int, 0);
pub const GAI_NOWAIT = @as(c_int, 1);
pub const AI_PASSIVE = @as(c_int, 0x0001);
pub const AI_CANONNAME = @as(c_int, 0x0002);
pub const AI_NUMERICHOST = @as(c_int, 0x0004);
pub const AI_V4MAPPED = @as(c_int, 0x0008);
pub const AI_ALL = @as(c_int, 0x0010);
pub const AI_ADDRCONFIG = @as(c_int, 0x0020);
pub const AI_IDN = @as(c_int, 0x0040);
pub const AI_CANONIDN = @as(c_int, 0x0080);
pub const AI_IDN_ALLOW_UNASSIGNED = @compileError("unable to translate C expr: unexpected token 'A number'");
// /usr/include/netdb.h:608:11
pub const AI_IDN_USE_STD3_ASCII_RULES = @compileError("unable to translate C expr: unexpected token 'A number'");
// /usr/include/netdb.h:610:11
pub const AI_NUMERICSERV = @as(c_int, 0x0400);
pub const EAI_BADFLAGS = -@as(c_int, 1);
pub const EAI_NONAME = -@as(c_int, 2);
pub const EAI_AGAIN = -@as(c_int, 3);
pub const EAI_FAIL = -@as(c_int, 4);
pub const EAI_FAMILY = -@as(c_int, 6);
pub const EAI_SOCKTYPE = -@as(c_int, 7);
pub const EAI_SERVICE = -@as(c_int, 8);
pub const EAI_MEMORY = -@as(c_int, 10);
pub const EAI_SYSTEM = -@as(c_int, 11);
pub const EAI_OVERFLOW = -@as(c_int, 12);
pub const EAI_NODATA = -@as(c_int, 5);
pub const EAI_ADDRFAMILY = -@as(c_int, 9);
pub const EAI_INPROGRESS = -@as(c_int, 100);
pub const EAI_CANCELED = -@as(c_int, 101);
pub const EAI_NOTCANCELED = -@as(c_int, 102);
pub const EAI_ALLDONE = -@as(c_int, 103);
pub const EAI_INTR = -@as(c_int, 104);
pub const EAI_IDN_ENCODE = -@as(c_int, 105);
pub const NI_MAXHOST = @as(c_int, 1025);
pub const NI_MAXSERV = @as(c_int, 32);
pub const NI_NUMERICHOST = @as(c_int, 1);
pub const NI_NUMERICSERV = @as(c_int, 2);
pub const NI_NOFQDN = @as(c_int, 4);
pub const NI_NAMEREQD = @as(c_int, 8);
pub const NI_DGRAM = @as(c_int, 16);
pub const NI_IDN = @as(c_int, 32);
pub const NI_IDN_ALLOW_UNASSIGNED = @compileError("unable to translate C expr: unexpected token 'A number'");
// /usr/include/netdb.h:649:11
pub const NI_IDN_USE_STD3_ASCII_RULES = @compileError("unable to translate C expr: unexpected token 'A number'");
// /usr/include/netdb.h:651:11
pub const _SYS_UN_H = @as(c_int, 1);
pub const SUN_LEN = @compileError("unable to translate macro: undefined identifier `sun_path`");
// /usr/include/sys/un.h:41:10
pub const _TIME_H = @as(c_int, 1);
pub const _BITS_TIME_H = @as(c_int, 1);
pub const CLOCKS_PER_SEC = @import("std").zig.c_translation.cast(__clock_t, @import("std").zig.c_translation.promoteIntLiteral(c_int, 1000000, .decimal));
pub const CLOCK_REALTIME = @as(c_int, 0);
pub const CLOCK_MONOTONIC = @as(c_int, 1);
pub const CLOCK_PROCESS_CPUTIME_ID = @as(c_int, 2);
pub const CLOCK_THREAD_CPUTIME_ID = @as(c_int, 3);
pub const CLOCK_MONOTONIC_RAW = @as(c_int, 4);
pub const CLOCK_REALTIME_COARSE = @as(c_int, 5);
pub const CLOCK_MONOTONIC_COARSE = @as(c_int, 6);
pub const CLOCK_BOOTTIME = @as(c_int, 7);
pub const CLOCK_REALTIME_ALARM = @as(c_int, 8);
pub const CLOCK_BOOTTIME_ALARM = @as(c_int, 9);
pub const CLOCK_TAI = @as(c_int, 11);
pub const TIMER_ABSTIME = @as(c_int, 1);
pub const _BITS_TIMEX_H = @as(c_int, 1);
pub const ADJ_OFFSET = @as(c_int, 0x0001);
pub const ADJ_FREQUENCY = @as(c_int, 0x0002);
pub const ADJ_MAXERROR = @as(c_int, 0x0004);
pub const ADJ_ESTERROR = @as(c_int, 0x0008);
pub const ADJ_STATUS = @as(c_int, 0x0010);
pub const ADJ_TIMECONST = @as(c_int, 0x0020);
pub const ADJ_TAI = @as(c_int, 0x0080);
pub const ADJ_SETOFFSET = @as(c_int, 0x0100);
pub const ADJ_MICRO = @as(c_int, 0x1000);
pub const ADJ_NANO = @as(c_int, 0x2000);
pub const ADJ_TICK = @as(c_int, 0x4000);
pub const ADJ_OFFSET_SINGLESHOT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8001, .hex);
pub const ADJ_OFFSET_SS_READ = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xa001, .hex);
pub const MOD_OFFSET = ADJ_OFFSET;
pub const MOD_FREQUENCY = ADJ_FREQUENCY;
pub const MOD_MAXERROR = ADJ_MAXERROR;
pub const MOD_ESTERROR = ADJ_ESTERROR;
pub const MOD_STATUS = ADJ_STATUS;
pub const MOD_TIMECONST = ADJ_TIMECONST;
pub const MOD_CLKB = ADJ_TICK;
pub const MOD_CLKA = ADJ_OFFSET_SINGLESHOT;
pub const MOD_TAI = ADJ_TAI;
pub const MOD_MICRO = ADJ_MICRO;
pub const MOD_NANO = ADJ_NANO;
pub const STA_PLL = @as(c_int, 0x0001);
pub const STA_PPSFREQ = @as(c_int, 0x0002);
pub const STA_PPSTIME = @as(c_int, 0x0004);
pub const STA_FLL = @as(c_int, 0x0008);
pub const STA_INS = @as(c_int, 0x0010);
pub const STA_DEL = @as(c_int, 0x0020);
pub const STA_UNSYNC = @as(c_int, 0x0040);
pub const STA_FREQHOLD = @as(c_int, 0x0080);
pub const STA_PPSSIGNAL = @as(c_int, 0x0100);
pub const STA_PPSJITTER = @as(c_int, 0x0200);
pub const STA_PPSWANDER = @as(c_int, 0x0400);
pub const STA_PPSERROR = @as(c_int, 0x0800);
pub const STA_CLOCKERR = @as(c_int, 0x1000);
pub const STA_NANO = @as(c_int, 0x2000);
pub const STA_MODE = @as(c_int, 0x4000);
pub const STA_CLK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const STA_RONLY = ((((((STA_PPSSIGNAL | STA_PPSJITTER) | STA_PPSWANDER) | STA_PPSERROR) | STA_CLOCKERR) | STA_NANO) | STA_MODE) | STA_CLK;
pub const __struct_tm_defined = @as(c_int, 1);
pub const __itimerspec_defined = @as(c_int, 1);
pub const TIME_UTC = @as(c_int, 1);
pub inline fn __isleap(year: anytype) @TypeOf((@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 4)) == @as(c_int, 0)) and ((@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 100)) != @as(c_int, 0)) or (@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 400)) == @as(c_int, 0)))) {
    _ = &year;
    return (@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 4)) == @as(c_int, 0)) and ((@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 100)) != @as(c_int, 0)) or (@import("std").zig.c_translation.MacroArithmetic.rem(year, @as(c_int, 400)) == @as(c_int, 0)));
}
pub const _MALLOC_H = @as(c_int, 1);
pub const __MALLOC_HOOK_VOLATILE = @compileError("unable to translate C expr: unexpected token 'volatile'");
// /usr/include/malloc.h:31:10
pub const __MALLOC_DEPRECATED = __attribute_deprecated__;
pub const M_MXFAST = @as(c_int, 1);
pub const M_NLBLKS = @as(c_int, 2);
pub const M_GRAIN = @as(c_int, 3);
pub const M_KEEP = @as(c_int, 4);
pub const M_TRIM_THRESHOLD = -@as(c_int, 1);
pub const M_TOP_PAD = -@as(c_int, 2);
pub const M_MMAP_THRESHOLD = -@as(c_int, 3);
pub const M_MMAP_MAX = -@as(c_int, 4);
pub const M_CHECK_ACTION = -@as(c_int, 5);
pub const M_PERTURB = -@as(c_int, 6);
pub const M_ARENA_TEST = -@as(c_int, 7);
pub const M_ARENA_MAX = -@as(c_int, 8);
pub const _LIBC_LIMITS_H_ = @as(c_int, 1);
pub const MB_LEN_MAX = @as(c_int, 16);
pub const __CLANG_LIMITS_H = "";
pub const _GCC_LIMITS_H_ = "";
pub const SCHAR_MAX = __SCHAR_MAX__;
pub const SHRT_MAX = __SHRT_MAX__;
pub const INT_MAX = __INT_MAX__;
pub const LONG_MAX = __LONG_MAX__;
pub const SCHAR_MIN = -__SCHAR_MAX__ - @as(c_int, 1);
pub const SHRT_MIN = -__SHRT_MAX__ - @as(c_int, 1);
pub const INT_MIN = -__INT_MAX__ - @as(c_int, 1);
pub const LONG_MIN = -__LONG_MAX__ - @as(c_long, 1);
pub const UCHAR_MAX = (__SCHAR_MAX__ * @as(c_int, 2)) + @as(c_int, 1);
pub const USHRT_MAX = (__SHRT_MAX__ * @as(c_int, 2)) + @as(c_int, 1);
pub const UINT_MAX = (__INT_MAX__ * @as(c_uint, 2)) + @as(c_uint, 1);
pub const ULONG_MAX = (__LONG_MAX__ * @as(c_ulong, 2)) + @as(c_ulong, 1);
pub const CHAR_BIT = __CHAR_BIT__;
pub const CHAR_MIN = SCHAR_MIN;
pub const CHAR_MAX = __SCHAR_MAX__;
pub const LLONG_MAX = __LONG_LONG_MAX__;
pub const LLONG_MIN = -__LONG_LONG_MAX__ - @as(c_longlong, 1);
pub const ULLONG_MAX = (__LONG_LONG_MAX__ * @as(c_ulonglong, 2)) + @as(c_ulonglong, 1);
pub const LONG_LONG_MAX = __LONG_LONG_MAX__;
pub const LONG_LONG_MIN = -__LONG_LONG_MAX__ - @as(c_longlong, 1);
pub const ULONG_LONG_MAX = (__LONG_LONG_MAX__ * @as(c_ulonglong, 2)) + @as(c_ulonglong, 1);
pub const CHAR_WIDTH = @as(c_int, 8);
pub const SCHAR_WIDTH = @as(c_int, 8);
pub const UCHAR_WIDTH = @as(c_int, 8);
pub const SHRT_WIDTH = @as(c_int, 16);
pub const USHRT_WIDTH = @as(c_int, 16);
pub const INT_WIDTH = @as(c_int, 32);
pub const UINT_WIDTH = @as(c_int, 32);
pub const LONG_WIDTH = __WORDSIZE;
pub const ULONG_WIDTH = __WORDSIZE;
pub const LLONG_WIDTH = @as(c_int, 64);
pub const ULLONG_WIDTH = @as(c_int, 64);
pub const BOOL_MAX = @as(c_int, 1);
pub const BOOL_WIDTH = @as(c_int, 1);
pub const _BITS_POSIX2_LIM_H = @as(c_int, 1);
pub const _POSIX2_BC_BASE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_DIM_MAX = @as(c_int, 2048);
pub const _POSIX2_BC_SCALE_MAX = @as(c_int, 99);
pub const _POSIX2_BC_STRING_MAX = @as(c_int, 1000);
pub const _POSIX2_COLL_WEIGHTS_MAX = @as(c_int, 2);
pub const _POSIX2_EXPR_NEST_MAX = @as(c_int, 32);
pub const _POSIX2_LINE_MAX = @as(c_int, 2048);
pub const _POSIX2_RE_DUP_MAX = @as(c_int, 255);
pub const _POSIX2_CHARCLASS_NAME_MAX = @as(c_int, 14);
pub const BC_BASE_MAX = _POSIX2_BC_BASE_MAX;
pub const BC_DIM_MAX = _POSIX2_BC_DIM_MAX;
pub const BC_SCALE_MAX = _POSIX2_BC_SCALE_MAX;
pub const BC_STRING_MAX = _POSIX2_BC_STRING_MAX;
pub const COLL_WEIGHTS_MAX = @as(c_int, 255);
pub const EXPR_NEST_MAX = _POSIX2_EXPR_NEST_MAX;
pub const LINE_MAX = _POSIX2_LINE_MAX;
pub const CHARCLASS_NAME_MAX = @as(c_int, 2048);
pub const RE_DUP_MAX = @as(c_int, 0x7fff);
pub const _XOPEN_LIM_H = @as(c_int, 1);
pub const _XOPEN_IOV_MAX = _POSIX_UIO_MAXIOV;
pub const IOV_MAX = __IOV_MAX;
pub const NL_ARGMAX = _POSIX_ARG_MAX;
pub const NL_LANGMAX = _POSIX2_LINE_MAX;
pub const NL_MSGMAX = INT_MAX;
pub const NL_NMAX = INT_MAX;
pub const NL_SETMAX = INT_MAX;
pub const NL_TEXTMAX = INT_MAX;
pub const NZERO = @as(c_int, 20);
pub const WORD_BIT = @as(c_int, 32);
pub const LONG_BIT = @as(c_int, 64);
pub const _SYS_IOCTL_H = @as(c_int, 1);
pub const __ASM_GENERIC_IOCTLS_H = "";
pub const _LINUX_IOCTL_H = "";
pub const _ASM_GENERIC_IOCTL_H = "";
pub const _IOC_NRBITS = @as(c_int, 8);
pub const _IOC_TYPEBITS = @as(c_int, 8);
pub const _IOC_SIZEBITS = @as(c_int, 14);
pub const _IOC_DIRBITS = @as(c_int, 2);
pub const _IOC_NRMASK = (@as(c_int, 1) << _IOC_NRBITS) - @as(c_int, 1);
pub const _IOC_TYPEMASK = (@as(c_int, 1) << _IOC_TYPEBITS) - @as(c_int, 1);
pub const _IOC_SIZEMASK = (@as(c_int, 1) << _IOC_SIZEBITS) - @as(c_int, 1);
pub const _IOC_DIRMASK = (@as(c_int, 1) << _IOC_DIRBITS) - @as(c_int, 1);
pub const _IOC_NRSHIFT = @as(c_int, 0);
pub const _IOC_TYPESHIFT = _IOC_NRSHIFT + _IOC_NRBITS;
pub const _IOC_SIZESHIFT = _IOC_TYPESHIFT + _IOC_TYPEBITS;
pub const _IOC_DIRSHIFT = _IOC_SIZESHIFT + _IOC_SIZEBITS;
pub const _IOC_NONE = @as(c_uint, 0);
pub const _IOC_WRITE = @as(c_uint, 1);
pub const _IOC_READ = @as(c_uint, 2);
pub inline fn _IOC(dir: anytype, @"type": anytype, nr: anytype, size: anytype) @TypeOf((((dir << _IOC_DIRSHIFT) | (@"type" << _IOC_TYPESHIFT)) | (nr << _IOC_NRSHIFT)) | (size << _IOC_SIZESHIFT)) {
    _ = &dir;
    _ = &@"type";
    _ = &nr;
    _ = &size;
    return (((dir << _IOC_DIRSHIFT) | (@"type" << _IOC_TYPESHIFT)) | (nr << _IOC_NRSHIFT)) | (size << _IOC_SIZESHIFT);
}
pub inline fn _IOC_TYPECHECK(t: anytype) @TypeOf(@import("std").zig.c_translation.sizeof(t)) {
    _ = &t;
    return @import("std").zig.c_translation.sizeof(t);
}
pub inline fn _IO(@"type": anytype, nr: anytype) @TypeOf(_IOC(_IOC_NONE, @"type", nr, @as(c_int, 0))) {
    _ = &@"type";
    _ = &nr;
    return _IOC(_IOC_NONE, @"type", nr, @as(c_int, 0));
}
pub inline fn _IOR(@"type": anytype, nr: anytype, size: anytype) @TypeOf(_IOC(_IOC_READ, @"type", nr, _IOC_TYPECHECK(size))) {
    _ = &@"type";
    _ = &nr;
    _ = &size;
    return _IOC(_IOC_READ, @"type", nr, _IOC_TYPECHECK(size));
}
pub inline fn _IOW(@"type": anytype, nr: anytype, size: anytype) @TypeOf(_IOC(_IOC_WRITE, @"type", nr, _IOC_TYPECHECK(size))) {
    _ = &@"type";
    _ = &nr;
    _ = &size;
    return _IOC(_IOC_WRITE, @"type", nr, _IOC_TYPECHECK(size));
}
pub inline fn _IOWR(@"type": anytype, nr: anytype, size: anytype) @TypeOf(_IOC(_IOC_READ | _IOC_WRITE, @"type", nr, _IOC_TYPECHECK(size))) {
    _ = &@"type";
    _ = &nr;
    _ = &size;
    return _IOC(_IOC_READ | _IOC_WRITE, @"type", nr, _IOC_TYPECHECK(size));
}
pub inline fn _IOR_BAD(@"type": anytype, nr: anytype, size: anytype) @TypeOf(_IOC(_IOC_READ, @"type", nr, @import("std").zig.c_translation.sizeof(size))) {
    _ = &@"type";
    _ = &nr;
    _ = &size;
    return _IOC(_IOC_READ, @"type", nr, @import("std").zig.c_translation.sizeof(size));
}
pub inline fn _IOW_BAD(@"type": anytype, nr: anytype, size: anytype) @TypeOf(_IOC(_IOC_WRITE, @"type", nr, @import("std").zig.c_translation.sizeof(size))) {
    _ = &@"type";
    _ = &nr;
    _ = &size;
    return _IOC(_IOC_WRITE, @"type", nr, @import("std").zig.c_translation.sizeof(size));
}
pub inline fn _IOWR_BAD(@"type": anytype, nr: anytype, size: anytype) @TypeOf(_IOC(_IOC_READ | _IOC_WRITE, @"type", nr, @import("std").zig.c_translation.sizeof(size))) {
    _ = &@"type";
    _ = &nr;
    _ = &size;
    return _IOC(_IOC_READ | _IOC_WRITE, @"type", nr, @import("std").zig.c_translation.sizeof(size));
}
pub inline fn _IOC_DIR(nr: anytype) @TypeOf((nr >> _IOC_DIRSHIFT) & _IOC_DIRMASK) {
    _ = &nr;
    return (nr >> _IOC_DIRSHIFT) & _IOC_DIRMASK;
}
pub inline fn _IOC_TYPE(nr: anytype) @TypeOf((nr >> _IOC_TYPESHIFT) & _IOC_TYPEMASK) {
    _ = &nr;
    return (nr >> _IOC_TYPESHIFT) & _IOC_TYPEMASK;
}
pub inline fn _IOC_NR(nr: anytype) @TypeOf((nr >> _IOC_NRSHIFT) & _IOC_NRMASK) {
    _ = &nr;
    return (nr >> _IOC_NRSHIFT) & _IOC_NRMASK;
}
pub inline fn _IOC_SIZE(nr: anytype) @TypeOf((nr >> _IOC_SIZESHIFT) & _IOC_SIZEMASK) {
    _ = &nr;
    return (nr >> _IOC_SIZESHIFT) & _IOC_SIZEMASK;
}
pub const IOC_IN = _IOC_WRITE << _IOC_DIRSHIFT;
pub const IOC_OUT = _IOC_READ << _IOC_DIRSHIFT;
pub const IOC_INOUT = (_IOC_WRITE | _IOC_READ) << _IOC_DIRSHIFT;
pub const IOCSIZE_MASK = _IOC_SIZEMASK << _IOC_SIZESHIFT;
pub const IOCSIZE_SHIFT = _IOC_SIZESHIFT;
pub const TCGETS = @as(c_int, 0x5401);
pub const TCSETS = @as(c_int, 0x5402);
pub const TCSETSW = @as(c_int, 0x5403);
pub const TCSETSF = @as(c_int, 0x5404);
pub const TCGETA = @as(c_int, 0x5405);
pub const TCSETA = @as(c_int, 0x5406);
pub const TCSETAW = @as(c_int, 0x5407);
pub const TCSETAF = @as(c_int, 0x5408);
pub const TCSBRK = @as(c_int, 0x5409);
pub const TCXONC = @as(c_int, 0x540A);
pub const TCFLSH = @as(c_int, 0x540B);
pub const TIOCEXCL = @as(c_int, 0x540C);
pub const TIOCNXCL = @as(c_int, 0x540D);
pub const TIOCSCTTY = @as(c_int, 0x540E);
pub const TIOCGPGRP = @as(c_int, 0x540F);
pub const TIOCSPGRP = @as(c_int, 0x5410);
pub const TIOCOUTQ = @as(c_int, 0x5411);
pub const TIOCSTI = @as(c_int, 0x5412);
pub const TIOCGWINSZ = @as(c_int, 0x5413);
pub const TIOCSWINSZ = @as(c_int, 0x5414);
pub const TIOCMGET = @as(c_int, 0x5415);
pub const TIOCMBIS = @as(c_int, 0x5416);
pub const TIOCMBIC = @as(c_int, 0x5417);
pub const TIOCMSET = @as(c_int, 0x5418);
pub const TIOCGSOFTCAR = @as(c_int, 0x5419);
pub const TIOCSSOFTCAR = @as(c_int, 0x541A);
pub const FIONREAD = @as(c_int, 0x541B);
pub const TIOCINQ = FIONREAD;
pub const TIOCLINUX = @as(c_int, 0x541C);
pub const TIOCCONS = @as(c_int, 0x541D);
pub const TIOCGSERIAL = @as(c_int, 0x541E);
pub const TIOCSSERIAL = @as(c_int, 0x541F);
pub const TIOCPKT = @as(c_int, 0x5420);
pub const FIONBIO = @as(c_int, 0x5421);
pub const TIOCNOTTY = @as(c_int, 0x5422);
pub const TIOCSETD = @as(c_int, 0x5423);
pub const TIOCGETD = @as(c_int, 0x5424);
pub const TCSBRKP = @as(c_int, 0x5425);
pub const TIOCSBRK = @as(c_int, 0x5427);
pub const TIOCCBRK = @as(c_int, 0x5428);
pub const TIOCGSID = @as(c_int, 0x5429);
pub const TCGETS2 = @compileError("unable to translate macro: undefined identifier `termios2`");
// /usr/include/asm-generic/ioctls.h:61:9
pub const TCSETS2 = @compileError("unable to translate macro: undefined identifier `termios2`");
// /usr/include/asm-generic/ioctls.h:62:9
pub const TCSETSW2 = @compileError("unable to translate macro: undefined identifier `termios2`");
// /usr/include/asm-generic/ioctls.h:63:9
pub const TCSETSF2 = @compileError("unable to translate macro: undefined identifier `termios2`");
// /usr/include/asm-generic/ioctls.h:64:9
pub const TIOCGRS485 = @as(c_int, 0x542E);
pub const TIOCSRS485 = @as(c_int, 0x542F);
pub const TIOCGPTN = _IOR('T', @as(c_int, 0x30), c_uint);
pub const TIOCSPTLCK = _IOW('T', @as(c_int, 0x31), c_int);
pub const TIOCGDEV = _IOR('T', @as(c_int, 0x32), c_uint);
pub const TCGETX = @as(c_int, 0x5432);
pub const TCSETX = @as(c_int, 0x5433);
pub const TCSETXF = @as(c_int, 0x5434);
pub const TCSETXW = @as(c_int, 0x5435);
pub const TIOCSIG = _IOW('T', @as(c_int, 0x36), c_int);
pub const TIOCVHANGUP = @as(c_int, 0x5437);
pub const TIOCGPKT = _IOR('T', @as(c_int, 0x38), c_int);
pub const TIOCGPTLCK = _IOR('T', @as(c_int, 0x39), c_int);
pub const TIOCGEXCL = _IOR('T', @as(c_int, 0x40), c_int);
pub const TIOCGPTPEER = _IO('T', @as(c_int, 0x41));
pub const TIOCGISO7816 = @compileError("unable to translate macro: undefined identifier `serial_iso7816`");
// /usr/include/asm-generic/ioctls.h:82:9
pub const TIOCSISO7816 = @compileError("unable to translate macro: undefined identifier `serial_iso7816`");
// /usr/include/asm-generic/ioctls.h:83:9
pub const FIONCLEX = @as(c_int, 0x5450);
pub const FIOCLEX = @as(c_int, 0x5451);
pub const FIOASYNC = @as(c_int, 0x5452);
pub const TIOCSERCONFIG = @as(c_int, 0x5453);
pub const TIOCSERGWILD = @as(c_int, 0x5454);
pub const TIOCSERSWILD = @as(c_int, 0x5455);
pub const TIOCGLCKTRMIOS = @as(c_int, 0x5456);
pub const TIOCSLCKTRMIOS = @as(c_int, 0x5457);
pub const TIOCSERGSTRUCT = @as(c_int, 0x5458);
pub const TIOCSERGETLSR = @as(c_int, 0x5459);
pub const TIOCSERGETMULTI = @as(c_int, 0x545A);
pub const TIOCSERSETMULTI = @as(c_int, 0x545B);
pub const TIOCMIWAIT = @as(c_int, 0x545C);
pub const TIOCGICOUNT = @as(c_int, 0x545D);
pub const FIOQSIZE = @as(c_int, 0x5460);
pub const TIOCPKT_DATA = @as(c_int, 0);
pub const TIOCPKT_FLUSHREAD = @as(c_int, 1);
pub const TIOCPKT_FLUSHWRITE = @as(c_int, 2);
pub const TIOCPKT_STOP = @as(c_int, 4);
pub const TIOCPKT_START = @as(c_int, 8);
pub const TIOCPKT_NOSTOP = @as(c_int, 16);
pub const TIOCPKT_DOSTOP = @as(c_int, 32);
pub const TIOCPKT_IOCTL = @as(c_int, 64);
pub const TIOCSER_TEMT = @as(c_int, 0x01);
pub const SIOCADDRT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x890B, .hex);
pub const SIOCDELRT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x890C, .hex);
pub const SIOCRTMSG = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x890D, .hex);
pub const SIOCGIFNAME = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8910, .hex);
pub const SIOCSIFLINK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8911, .hex);
pub const SIOCGIFCONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8912, .hex);
pub const SIOCGIFFLAGS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8913, .hex);
pub const SIOCSIFFLAGS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8914, .hex);
pub const SIOCGIFADDR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8915, .hex);
pub const SIOCSIFADDR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8916, .hex);
pub const SIOCGIFDSTADDR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8917, .hex);
pub const SIOCSIFDSTADDR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8918, .hex);
pub const SIOCGIFBRDADDR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8919, .hex);
pub const SIOCSIFBRDADDR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x891a, .hex);
pub const SIOCGIFNETMASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x891b, .hex);
pub const SIOCSIFNETMASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x891c, .hex);
pub const SIOCGIFMETRIC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x891d, .hex);
pub const SIOCSIFMETRIC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x891e, .hex);
pub const SIOCGIFMEM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x891f, .hex);
pub const SIOCSIFMEM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8920, .hex);
pub const SIOCGIFMTU = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8921, .hex);
pub const SIOCSIFMTU = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8922, .hex);
pub const SIOCSIFNAME = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8923, .hex);
pub const SIOCSIFHWADDR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8924, .hex);
pub const SIOCGIFENCAP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8925, .hex);
pub const SIOCSIFENCAP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8926, .hex);
pub const SIOCGIFHWADDR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8927, .hex);
pub const SIOCGIFSLAVE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8929, .hex);
pub const SIOCSIFSLAVE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8930, .hex);
pub const SIOCADDMULTI = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8931, .hex);
pub const SIOCDELMULTI = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8932, .hex);
pub const SIOCGIFINDEX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8933, .hex);
pub const SIOGIFINDEX = SIOCGIFINDEX;
pub const SIOCSIFPFLAGS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8934, .hex);
pub const SIOCGIFPFLAGS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8935, .hex);
pub const SIOCDIFADDR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8936, .hex);
pub const SIOCSIFHWBROADCAST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8937, .hex);
pub const SIOCGIFCOUNT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8938, .hex);
pub const SIOCGIFBR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8940, .hex);
pub const SIOCSIFBR = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8941, .hex);
pub const SIOCGIFTXQLEN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8942, .hex);
pub const SIOCSIFTXQLEN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8943, .hex);
pub const SIOCDARP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8953, .hex);
pub const SIOCGARP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8954, .hex);
pub const SIOCSARP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8955, .hex);
pub const SIOCDRARP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8960, .hex);
pub const SIOCGRARP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8961, .hex);
pub const SIOCSRARP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8962, .hex);
pub const SIOCGIFMAP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8970, .hex);
pub const SIOCSIFMAP = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8971, .hex);
pub const SIOCADDDLCI = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8980, .hex);
pub const SIOCDELDLCI = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8981, .hex);
pub const SIOCDEVPRIVATE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x89F0, .hex);
pub const SIOCPROTOPRIVATE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x89E0, .hex);
pub const NCC = @as(c_int, 8);
pub const TIOCM_LE = @as(c_int, 0x001);
pub const TIOCM_DTR = @as(c_int, 0x002);
pub const TIOCM_RTS = @as(c_int, 0x004);
pub const TIOCM_ST = @as(c_int, 0x008);
pub const TIOCM_SR = @as(c_int, 0x010);
pub const TIOCM_CTS = @as(c_int, 0x020);
pub const TIOCM_CAR = @as(c_int, 0x040);
pub const TIOCM_RNG = @as(c_int, 0x080);
pub const TIOCM_DSR = @as(c_int, 0x100);
pub const TIOCM_CD = TIOCM_CAR;
pub const TIOCM_RI = TIOCM_RNG;
pub const N_TTY = @as(c_int, 0);
pub const N_SLIP = @as(c_int, 1);
pub const N_MOUSE = @as(c_int, 2);
pub const N_PPP = @as(c_int, 3);
pub const N_STRIP = @as(c_int, 4);
pub const N_AX25 = @as(c_int, 5);
pub const N_X25 = @as(c_int, 6);
pub const N_6PACK = @as(c_int, 7);
pub const N_MASC = @as(c_int, 8);
pub const N_R3964 = @as(c_int, 9);
pub const N_PROFIBUS_FDL = @as(c_int, 10);
pub const N_IRDA = @as(c_int, 11);
pub const N_SMSBLOCK = @as(c_int, 12);
pub const N_HDLC = @as(c_int, 13);
pub const N_SYNC_PPP = @as(c_int, 14);
pub const N_HCI = @as(c_int, 15);
pub const _SYS_TTYDEFAULTS_H_ = "";
pub const TTYDEF_IFLAG = @compileError("unable to translate macro: undefined identifier `BRKINT`");
// /usr/include/sys/ttydefaults.h:46:9
pub const TTYDEF_OFLAG = @compileError("unable to translate macro: undefined identifier `OPOST`");
// /usr/include/sys/ttydefaults.h:47:9
pub const TTYDEF_LFLAG = @compileError("unable to translate macro: undefined identifier `ECHO`");
// /usr/include/sys/ttydefaults.h:48:9
pub const TTYDEF_CFLAG = @compileError("unable to translate macro: undefined identifier `CREAD`");
// /usr/include/sys/ttydefaults.h:49:9
pub const TTYDEF_SPEED = @compileError("unable to translate macro: undefined identifier `B9600`");
// /usr/include/sys/ttydefaults.h:50:9
pub inline fn CTRL(x: anytype) @TypeOf(x & @as(c_int, 0o37)) {
    _ = &x;
    return x & @as(c_int, 0o37);
}
pub const CEOF = CTRL('d');
pub const CEOL = _POSIX_VDISABLE;
pub const CERASE = @as(c_int, 0o177);
pub const CINTR = CTRL('c');
pub const CSTATUS = _POSIX_VDISABLE;
pub const CKILL = CTRL('u');
pub const CMIN = @as(c_int, 1);
pub const CQUIT = @as(c_int, 0o34);
pub const CSUSP = CTRL('z');
pub const CTIME = @as(c_int, 0);
pub const CDSUSP = CTRL('y');
pub const CSTART = CTRL('q');
pub const CSTOP = CTRL('s');
pub const CLNEXT = CTRL('v');
pub const CDISCARD = CTRL('o');
pub const CWERASE = CTRL('w');
pub const CREPRINT = CTRL('r');
pub const CEOT = CEOF;
pub const CBRK = CEOL;
pub const CRPRNT = CREPRINT;
pub const CFLUSH = CDISCARD;
pub const _CRYPT_H = @as(c_int, 1);
pub const CRYPT_OUTPUT_SIZE = @as(c_int, 384);
pub const CRYPT_MAX_PASSPHRASE_SIZE = @as(c_int, 512);
pub const CRYPT_GENSALT_OUTPUT_SIZE = @as(c_int, 192);
pub const CRYPT_DATA_RESERVED_SIZE = @as(c_int, 767);
pub const CRYPT_DATA_INTERNAL_SIZE = @as(c_int, 30720);
pub const CRYPT_SALT_OK = @as(c_int, 0);
pub const CRYPT_SALT_INVALID = @as(c_int, 1);
pub const CRYPT_SALT_METHOD_DISABLED = @as(c_int, 2);
pub const CRYPT_SALT_METHOD_LEGACY = @as(c_int, 3);
pub const CRYPT_SALT_TOO_CHEAP = @as(c_int, 4);
pub const CRYPT_GENSALT_IMPLEMENTS_DEFAULT_PREFIX = @as(c_int, 1);
pub const CRYPT_GENSALT_IMPLEMENTS_AUTO_ENTROPY = @as(c_int, 1);
pub const CRYPT_CHECKSALT_AVAILABLE = @as(c_int, 1);
pub const CRYPT_PREFERRED_METHOD_AVAILABLE = @as(c_int, 1);
pub const XCRYPT_VERSION_MAJOR = @as(c_int, 4);
pub const XCRYPT_VERSION_MINOR = @as(c_int, 4);
pub const XCRYPT_VERSION_NUM = (XCRYPT_VERSION_MAJOR << @as(c_int, 16)) | XCRYPT_VERSION_MINOR;
pub const XCRYPT_VERSION_STR = "4.4.37";
pub const _SYS_UTSNAME_H = @as(c_int, 1);
pub const _UTSNAME_LENGTH = @as(c_int, 65);
pub const _UTSNAME_DOMAIN_LENGTH = _UTSNAME_LENGTH;
pub const _UTSNAME_SYSNAME_LENGTH = _UTSNAME_LENGTH;
pub const _UTSNAME_NODENAME_LENGTH = _UTSNAME_LENGTH;
pub const _UTSNAME_RELEASE_LENGTH = _UTSNAME_LENGTH;
pub const _UTSNAME_VERSION_LENGTH = _UTSNAME_LENGTH;
pub const _UTSNAME_MACHINE_LENGTH = _UTSNAME_LENGTH;
pub const SYS_NMLN = _UTSNAME_LENGTH;
pub const _DLFCN_H = @as(c_int, 1);
pub const RTLD_LAZY = @as(c_int, 0x00001);
pub const RTLD_NOW = @as(c_int, 0x00002);
pub const RTLD_BINDING_MASK = @as(c_int, 0x3);
pub const RTLD_NOLOAD = @as(c_int, 0x00004);
pub const RTLD_DEEPBIND = @as(c_int, 0x00008);
pub const RTLD_GLOBAL = @as(c_int, 0x00100);
pub const RTLD_LOCAL = @as(c_int, 0);
pub const RTLD_NODELETE = @as(c_int, 0x01000);
pub inline fn DL_CALL_FCT(fctp: anytype, args: anytype) @TypeOf(fctp.* ++ args) {
    _ = &fctp;
    _ = &args;
    return blk_1: {
        _ = _dl_mcount_wrapper_check(@import("std").zig.c_translation.cast(?*anyopaque, fctp));
        break :blk_1 fctp.* ++ args;
    };
}
pub const DLFO_STRUCT_HAS_EH_DBASE = @as(c_int, 0);
pub const DLFO_STRUCT_HAS_EH_COUNT = @as(c_int, 0);
pub const DLFO_EH_SEGMENT_TYPE = @compileError("unable to translate macro: undefined identifier `PT_GNU_EH_FRAME`");
// /usr/include/bits/dl_find_object.h:29:9
pub const LM_ID_BASE = @as(c_int, 0);
pub const LM_ID_NEWLM = -@as(c_int, 1);
pub const RTLD_NEXT = @import("std").zig.c_translation.cast(?*anyopaque, -@as(c_long, 1));
pub const RTLD_DEFAULT = @import("std").zig.c_translation.cast(?*anyopaque, @as(c_int, 0));
pub const NGX_CONFIGURE = " --with-http_ssl_module";
pub const NGX_COMPILER = "gcc 14.2.1 20240910 (GCC) ";
pub const NGX_HAVE_GCC_ATOMIC = @as(c_int, 1);
pub const NGX_HAVE_C99_VARIADIC_MACROS = @as(c_int, 1);
pub const NGX_HAVE_GCC_VARIADIC_MACROS = @as(c_int, 1);
pub const NGX_HAVE_GCC_BSWAP64 = @as(c_int, 1);
pub const NGX_HAVE_EPOLL = @as(c_int, 1);
pub const NGX_HAVE_CLEAR_EVENT = @as(c_int, 1);
pub const NGX_HAVE_EPOLLRDHUP = @as(c_int, 1);
pub const NGX_HAVE_EPOLLEXCLUSIVE = @as(c_int, 1);
pub const NGX_HAVE_EVENTFD = @as(c_int, 1);
pub const NGX_HAVE_SYS_EVENTFD_H = @as(c_int, 1);
pub const NGX_HAVE_O_PATH = @as(c_int, 1);
pub const NGX_HAVE_SENDFILE = @as(c_int, 1);
pub const NGX_HAVE_SENDFILE64 = @as(c_int, 1);
pub const NGX_HAVE_PR_SET_DUMPABLE = @as(c_int, 1);
pub const NGX_HAVE_PR_SET_KEEPCAPS = @as(c_int, 1);
pub const NGX_HAVE_CAPABILITIES = @as(c_int, 1);
pub const NGX_HAVE_GNU_CRYPT_R = @as(c_int, 1);
pub const NGX_HAVE_BPF = @as(c_int, 1);
pub const NGX_HAVE_SO_COOKIE = @as(c_int, 1);
pub const NGX_HAVE_UDP_SEGMENT = @as(c_int, 1);
pub const NGX_HAVE_NONALIGNED = @as(c_int, 1);
pub const NGX_CPU_CACHE_LINE = @as(c_int, 64);
pub const NGX_KQUEUE_UDATA_T = @compileError("unable to translate C expr: unexpected token ''");
// objs/ngx_auto_config.h:118:9
pub const NGX_HAVE_POSIX_FADVISE = @as(c_int, 1);
pub const NGX_HAVE_O_DIRECT = @as(c_int, 1);
pub const NGX_HAVE_ALIGNED_DIRECTIO = @as(c_int, 1);
pub const NGX_HAVE_STATFS = @as(c_int, 1);
pub const NGX_HAVE_STATVFS = @as(c_int, 1);
pub const NGX_HAVE_DLOPEN = @as(c_int, 1);
pub const NGX_HAVE_SCHED_YIELD = @as(c_int, 1);
pub const NGX_HAVE_SCHED_SETAFFINITY = @as(c_int, 1);
pub const NGX_HAVE_REUSEPORT = @as(c_int, 1);
pub const NGX_HAVE_TRANSPARENT_PROXY = @as(c_int, 1);
pub const NGX_HAVE_IP_BIND_ADDRESS_NO_PORT = @as(c_int, 1);
pub const NGX_HAVE_IP_PKTINFO = @as(c_int, 1);
pub const NGX_HAVE_IPV6_RECVPKTINFO = @as(c_int, 1);
pub const NGX_HAVE_IP_MTU_DISCOVER = @as(c_int, 1);
pub const NGX_HAVE_IPV6_MTU_DISCOVER = @as(c_int, 1);
pub const NGX_HAVE_IPV6_DONTFRAG = @as(c_int, 1);
pub const NGX_HAVE_DEFERRED_ACCEPT = @as(c_int, 1);
pub const NGX_HAVE_KEEPALIVE_TUNABLE = @as(c_int, 1);
pub const NGX_HAVE_TCP_FASTOPEN = @as(c_int, 1);
pub const NGX_HAVE_TCP_INFO = @as(c_int, 1);
pub const NGX_HAVE_ACCEPT4 = @as(c_int, 1);
pub const NGX_HAVE_UNIX_DOMAIN = @as(c_int, 1);
pub const NGX_PTR_SIZE = @as(c_int, 8);
pub const NGX_SIG_ATOMIC_T_SIZE = @as(c_int, 4);
pub const NGX_HAVE_LITTLE_ENDIAN = @as(c_int, 1);
pub const NGX_MAX_SIZE_T_VALUE = @as(c_longlong, 9223372036854775807);
pub const NGX_SIZE_T_LEN = @compileError("unable to translate C expr: unexpected token 'a string literal'");
// objs/ngx_auto_config.h:252:9
pub const NGX_MAX_OFF_T_VALUE = @as(c_longlong, 9223372036854775807);
pub const NGX_OFF_T_LEN = @compileError("unable to translate C expr: unexpected token 'a string literal'");
// objs/ngx_auto_config.h:262:9
pub const NGX_TIME_T_SIZE = @as(c_int, 8);
pub const NGX_TIME_T_LEN = @compileError("unable to translate C expr: unexpected token 'a string literal'");
// objs/ngx_auto_config.h:272:9
pub const NGX_MAX_TIME_T_VALUE = @as(c_longlong, 9223372036854775807);
pub const NGX_HAVE_INET6 = @as(c_int, 1);
pub const NGX_HAVE_PREAD = @as(c_int, 1);
pub const NGX_HAVE_PWRITE = @as(c_int, 1);
pub const NGX_HAVE_PWRITEV = @as(c_int, 1);
pub const NGX_HAVE_STRERRORDESC_NP = @as(c_int, 1);
pub const NGX_HAVE_LOCALTIME_R = @as(c_int, 1);
pub const NGX_HAVE_CLOCK_MONOTONIC = @as(c_int, 1);
pub const NGX_HAVE_POSIX_MEMALIGN = @as(c_int, 1);
pub const NGX_HAVE_MEMALIGN = @as(c_int, 1);
pub const NGX_HAVE_MAP_ANON = @as(c_int, 1);
pub const NGX_HAVE_MAP_DEVZERO = @as(c_int, 1);
pub const NGX_HAVE_SYSVSHM = @as(c_int, 1);
pub const NGX_HAVE_POSIX_SEM = @as(c_int, 1);
pub const NGX_HAVE_MSGHDR_MSG_CONTROL = @as(c_int, 1);
pub const NGX_HAVE_FIONBIO = @as(c_int, 1);
pub const NGX_HAVE_FIONREAD = @as(c_int, 1);
pub const NGX_HAVE_GMTOFF = @as(c_int, 1);
pub const NGX_HAVE_D_TYPE = @as(c_int, 1);
pub const NGX_HAVE_SC_NPROCESSORS_ONLN = @as(c_int, 1);
pub const NGX_HAVE_LEVEL1_DCACHE_LINESIZE = @as(c_int, 1);
pub const NGX_HAVE_OPENAT = @as(c_int, 1);
pub const NGX_HAVE_GETADDRINFO = @as(c_int, 1);
pub const NGX_HTTP_CACHE = @as(c_int, 1);
pub const NGX_HTTP_GZIP = @as(c_int, 1);
pub const NGX_HTTP_SSI = @as(c_int, 1);
pub const NGX_CRYPT = @as(c_int, 1);
pub const NGX_HTTP_X_FORWARDED_FOR = @as(c_int, 1);
pub const NGX_HTTP_SSL = @as(c_int, 1);
pub const NGX_HTTP_UPSTREAM_ZONE = @as(c_int, 1);
pub const NGX_PCRE2 = @as(c_int, 1);
pub const NGX_PCRE = @as(c_int, 1);
pub const NGX_OPENSSL = @as(c_int, 1);
pub const NGX_SSL = @as(c_int, 1);
pub const NGX_ZLIB = @as(c_int, 1);
pub const NGX_PREFIX = "/usr/local/nginx/";
pub const NGX_CONF_PREFIX = "conf/";
pub const NGX_SBIN_PATH = "sbin/nginx";
pub const NGX_CONF_PATH = "conf/nginx.conf";
pub const NGX_PID_PATH = "logs/nginx.pid";
pub const NGX_LOCK_PATH = "logs/nginx.lock";
pub const NGX_ERROR_LOG_PATH = "logs/error.log";
pub const NGX_HTTP_LOG_PATH = "logs/access.log";
pub const NGX_HTTP_CLIENT_TEMP_PATH = "client_body_temp";
pub const NGX_HTTP_PROXY_TEMP_PATH = "proxy_temp";
pub const NGX_HTTP_FASTCGI_TEMP_PATH = "fastcgi_temp";
pub const NGX_HTTP_UWSGI_TEMP_PATH = "uwsgi_temp";
pub const NGX_HTTP_SCGI_TEMP_PATH = "scgi_temp";
pub const NGX_SUPPRESS_WARN = @as(c_int, 1);
pub const NGX_SMP = @as(c_int, 1);
pub const NGX_USER = "nobody";
pub const NGX_GROUP = "nobody";
pub const _SEMAPHORE_H = @as(c_int, 1);
pub const __SIZEOF_SEM_T = @as(c_int, 32);
pub const SEM_FAILED = @import("std").zig.c_translation.cast([*c]sem_t, @as(c_int, 0));
pub const _SYS_PRCTL_H = @as(c_int, 1);
pub const _LINUX_PRCTL_H = "";
pub const PR_SET_PDEATHSIG = @as(c_int, 1);
pub const PR_GET_PDEATHSIG = @as(c_int, 2);
pub const PR_GET_DUMPABLE = @as(c_int, 3);
pub const PR_SET_DUMPABLE = @as(c_int, 4);
pub const PR_GET_UNALIGN = @as(c_int, 5);
pub const PR_SET_UNALIGN = @as(c_int, 6);
pub const PR_UNALIGN_NOPRINT = @as(c_int, 1);
pub const PR_UNALIGN_SIGBUS = @as(c_int, 2);
pub const PR_GET_KEEPCAPS = @as(c_int, 7);
pub const PR_SET_KEEPCAPS = @as(c_int, 8);
pub const PR_GET_FPEMU = @as(c_int, 9);
pub const PR_SET_FPEMU = @as(c_int, 10);
pub const PR_FPEMU_NOPRINT = @as(c_int, 1);
pub const PR_FPEMU_SIGFPE = @as(c_int, 2);
pub const PR_GET_FPEXC = @as(c_int, 11);
pub const PR_SET_FPEXC = @as(c_int, 12);
pub const PR_FP_EXC_SW_ENABLE = @as(c_int, 0x80);
pub const PR_FP_EXC_DIV = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x010000, .hex);
pub const PR_FP_EXC_OVF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x020000, .hex);
pub const PR_FP_EXC_UND = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x040000, .hex);
pub const PR_FP_EXC_RES = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x080000, .hex);
pub const PR_FP_EXC_INV = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100000, .hex);
pub const PR_FP_EXC_DISABLED = @as(c_int, 0);
pub const PR_FP_EXC_NONRECOV = @as(c_int, 1);
pub const PR_FP_EXC_ASYNC = @as(c_int, 2);
pub const PR_FP_EXC_PRECISE = @as(c_int, 3);
pub const PR_GET_TIMING = @as(c_int, 13);
pub const PR_SET_TIMING = @as(c_int, 14);
pub const PR_TIMING_STATISTICAL = @as(c_int, 0);
pub const PR_TIMING_TIMESTAMP = @as(c_int, 1);
pub const PR_SET_NAME = @as(c_int, 15);
pub const PR_GET_NAME = @as(c_int, 16);
pub const PR_GET_ENDIAN = @as(c_int, 19);
pub const PR_SET_ENDIAN = @as(c_int, 20);
pub const PR_ENDIAN_BIG = @as(c_int, 0);
pub const PR_ENDIAN_LITTLE = @as(c_int, 1);
pub const PR_ENDIAN_PPC_LITTLE = @as(c_int, 2);
pub const PR_GET_SECCOMP = @as(c_int, 21);
pub const PR_SET_SECCOMP = @as(c_int, 22);
pub const PR_CAPBSET_READ = @as(c_int, 23);
pub const PR_CAPBSET_DROP = @as(c_int, 24);
pub const PR_GET_TSC = @as(c_int, 25);
pub const PR_SET_TSC = @as(c_int, 26);
pub const PR_TSC_ENABLE = @as(c_int, 1);
pub const PR_TSC_SIGSEGV = @as(c_int, 2);
pub const PR_GET_SECUREBITS = @as(c_int, 27);
pub const PR_SET_SECUREBITS = @as(c_int, 28);
pub const PR_SET_TIMERSLACK = @as(c_int, 29);
pub const PR_GET_TIMERSLACK = @as(c_int, 30);
pub const PR_TASK_PERF_EVENTS_DISABLE = @as(c_int, 31);
pub const PR_TASK_PERF_EVENTS_ENABLE = @as(c_int, 32);
pub const PR_MCE_KILL = @as(c_int, 33);
pub const PR_MCE_KILL_CLEAR = @as(c_int, 0);
pub const PR_MCE_KILL_SET = @as(c_int, 1);
pub const PR_MCE_KILL_LATE = @as(c_int, 0);
pub const PR_MCE_KILL_EARLY = @as(c_int, 1);
pub const PR_MCE_KILL_DEFAULT = @as(c_int, 2);
pub const PR_MCE_KILL_GET = @as(c_int, 34);
pub const PR_SET_MM = @as(c_int, 35);
pub const PR_SET_MM_START_CODE = @as(c_int, 1);
pub const PR_SET_MM_END_CODE = @as(c_int, 2);
pub const PR_SET_MM_START_DATA = @as(c_int, 3);
pub const PR_SET_MM_END_DATA = @as(c_int, 4);
pub const PR_SET_MM_START_STACK = @as(c_int, 5);
pub const PR_SET_MM_START_BRK = @as(c_int, 6);
pub const PR_SET_MM_BRK = @as(c_int, 7);
pub const PR_SET_MM_ARG_START = @as(c_int, 8);
pub const PR_SET_MM_ARG_END = @as(c_int, 9);
pub const PR_SET_MM_ENV_START = @as(c_int, 10);
pub const PR_SET_MM_ENV_END = @as(c_int, 11);
pub const PR_SET_MM_AUXV = @as(c_int, 12);
pub const PR_SET_MM_EXE_FILE = @as(c_int, 13);
pub const PR_SET_MM_MAP = @as(c_int, 14);
pub const PR_SET_MM_MAP_SIZE = @as(c_int, 15);
pub const PR_SET_PTRACER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x59616d61, .hex);
pub const PR_SET_PTRACER_ANY = @import("std").zig.c_translation.cast(c_ulong, -@as(c_int, 1));
pub const PR_SET_CHILD_SUBREAPER = @as(c_int, 36);
pub const PR_GET_CHILD_SUBREAPER = @as(c_int, 37);
pub const PR_SET_NO_NEW_PRIVS = @as(c_int, 38);
pub const PR_GET_NO_NEW_PRIVS = @as(c_int, 39);
pub const PR_GET_TID_ADDRESS = @as(c_int, 40);
pub const PR_SET_THP_DISABLE = @as(c_int, 41);
pub const PR_GET_THP_DISABLE = @as(c_int, 42);
pub const PR_MPX_ENABLE_MANAGEMENT = @as(c_int, 43);
pub const PR_MPX_DISABLE_MANAGEMENT = @as(c_int, 44);
pub const PR_SET_FP_MODE = @as(c_int, 45);
pub const PR_GET_FP_MODE = @as(c_int, 46);
pub const PR_FP_MODE_FR = @as(c_int, 1) << @as(c_int, 0);
pub const PR_FP_MODE_FRE = @as(c_int, 1) << @as(c_int, 1);
pub const PR_CAP_AMBIENT = @as(c_int, 47);
pub const PR_CAP_AMBIENT_IS_SET = @as(c_int, 1);
pub const PR_CAP_AMBIENT_RAISE = @as(c_int, 2);
pub const PR_CAP_AMBIENT_LOWER = @as(c_int, 3);
pub const PR_CAP_AMBIENT_CLEAR_ALL = @as(c_int, 4);
pub const PR_SVE_SET_VL = @as(c_int, 50);
pub const PR_SVE_SET_VL_ONEXEC = @as(c_int, 1) << @as(c_int, 18);
pub const PR_SVE_GET_VL = @as(c_int, 51);
pub const PR_SVE_VL_LEN_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hex);
pub const PR_SVE_VL_INHERIT = @as(c_int, 1) << @as(c_int, 17);
pub const PR_GET_SPECULATION_CTRL = @as(c_int, 52);
pub const PR_SET_SPECULATION_CTRL = @as(c_int, 53);
pub const PR_SPEC_STORE_BYPASS = @as(c_int, 0);
pub const PR_SPEC_INDIRECT_BRANCH = @as(c_int, 1);
pub const PR_SPEC_L1D_FLUSH = @as(c_int, 2);
pub const PR_SPEC_NOT_AFFECTED = @as(c_int, 0);
pub const PR_SPEC_PRCTL = @as(c_ulong, 1) << @as(c_int, 0);
pub const PR_SPEC_ENABLE = @as(c_ulong, 1) << @as(c_int, 1);
pub const PR_SPEC_DISABLE = @as(c_ulong, 1) << @as(c_int, 2);
pub const PR_SPEC_FORCE_DISABLE = @as(c_ulong, 1) << @as(c_int, 3);
pub const PR_SPEC_DISABLE_NOEXEC = @as(c_ulong, 1) << @as(c_int, 4);
pub const PR_PAC_RESET_KEYS = @as(c_int, 54);
pub const PR_PAC_APIAKEY = @as(c_ulong, 1) << @as(c_int, 0);
pub const PR_PAC_APIBKEY = @as(c_ulong, 1) << @as(c_int, 1);
pub const PR_PAC_APDAKEY = @as(c_ulong, 1) << @as(c_int, 2);
pub const PR_PAC_APDBKEY = @as(c_ulong, 1) << @as(c_int, 3);
pub const PR_PAC_APGAKEY = @as(c_ulong, 1) << @as(c_int, 4);
pub const PR_SET_TAGGED_ADDR_CTRL = @as(c_int, 55);
pub const PR_GET_TAGGED_ADDR_CTRL = @as(c_int, 56);
pub const PR_TAGGED_ADDR_ENABLE = @as(c_ulong, 1) << @as(c_int, 0);
pub const PR_MTE_TCF_NONE = @as(c_ulong, 0);
pub const PR_MTE_TCF_SYNC = @as(c_ulong, 1) << @as(c_int, 1);
pub const PR_MTE_TCF_ASYNC = @as(c_ulong, 1) << @as(c_int, 2);
pub const PR_MTE_TCF_MASK = PR_MTE_TCF_SYNC | PR_MTE_TCF_ASYNC;
pub const PR_MTE_TAG_SHIFT = @as(c_int, 3);
pub const PR_MTE_TAG_MASK = @as(c_ulong, 0xffff) << PR_MTE_TAG_SHIFT;
pub const PR_MTE_TCF_SHIFT = @as(c_int, 1);
pub const PR_SET_IO_FLUSHER = @as(c_int, 57);
pub const PR_GET_IO_FLUSHER = @as(c_int, 58);
pub const PR_SET_SYSCALL_USER_DISPATCH = @as(c_int, 59);
pub const PR_SYS_DISPATCH_OFF = @as(c_int, 0);
pub const PR_SYS_DISPATCH_ON = @as(c_int, 1);
pub const SYSCALL_DISPATCH_FILTER_ALLOW = @as(c_int, 0);
pub const SYSCALL_DISPATCH_FILTER_BLOCK = @as(c_int, 1);
pub const PR_PAC_SET_ENABLED_KEYS = @as(c_int, 60);
pub const PR_PAC_GET_ENABLED_KEYS = @as(c_int, 61);
pub const PR_SCHED_CORE = @as(c_int, 62);
pub const PR_SCHED_CORE_GET = @as(c_int, 0);
pub const PR_SCHED_CORE_CREATE = @as(c_int, 1);
pub const PR_SCHED_CORE_SHARE_TO = @as(c_int, 2);
pub const PR_SCHED_CORE_SHARE_FROM = @as(c_int, 3);
pub const PR_SCHED_CORE_MAX = @as(c_int, 4);
pub const PR_SCHED_CORE_SCOPE_THREAD = @as(c_int, 0);
pub const PR_SCHED_CORE_SCOPE_THREAD_GROUP = @as(c_int, 1);
pub const PR_SCHED_CORE_SCOPE_PROCESS_GROUP = @as(c_int, 2);
pub const PR_SME_SET_VL = @as(c_int, 63);
pub const PR_SME_SET_VL_ONEXEC = @as(c_int, 1) << @as(c_int, 18);
pub const PR_SME_GET_VL = @as(c_int, 64);
pub const PR_SME_VL_LEN_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hex);
pub const PR_SME_VL_INHERIT = @as(c_int, 1) << @as(c_int, 17);
pub const PR_SET_MDWE = @as(c_int, 65);
pub const PR_MDWE_REFUSE_EXEC_GAIN = @as(c_ulong, 1) << @as(c_int, 0);
pub const PR_MDWE_NO_INHERIT = @as(c_ulong, 1) << @as(c_int, 1);
pub const PR_GET_MDWE = @as(c_int, 66);
pub const PR_SET_VMA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x53564d41, .hex);
pub const PR_SET_VMA_ANON_NAME = @as(c_int, 0);
pub const PR_GET_AUXV = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x41555856, .hex);
pub const PR_SET_MEMORY_MERGE = @as(c_int, 67);
pub const PR_GET_MEMORY_MERGE = @as(c_int, 68);
pub const PR_RISCV_V_SET_CONTROL = @as(c_int, 69);
pub const PR_RISCV_V_GET_CONTROL = @as(c_int, 70);
pub const PR_RISCV_V_VSTATE_CTRL_DEFAULT = @as(c_int, 0);
pub const PR_RISCV_V_VSTATE_CTRL_OFF = @as(c_int, 1);
pub const PR_RISCV_V_VSTATE_CTRL_ON = @as(c_int, 2);
pub const PR_RISCV_V_VSTATE_CTRL_INHERIT = @as(c_int, 1) << @as(c_int, 4);
pub const PR_RISCV_V_VSTATE_CTRL_CUR_MASK = @as(c_int, 0x3);
pub const PR_RISCV_V_VSTATE_CTRL_NEXT_MASK = @as(c_int, 0xc);
pub const PR_RISCV_V_VSTATE_CTRL_MASK = @as(c_int, 0x1f);
pub const PR_RISCV_SET_ICACHE_FLUSH_CTX = @as(c_int, 71);
pub const PR_RISCV_CTX_SW_FENCEI_ON = @as(c_int, 0);
pub const PR_RISCV_CTX_SW_FENCEI_OFF = @as(c_int, 1);
pub const PR_RISCV_SCOPE_PER_PROCESS = @as(c_int, 0);
pub const PR_RISCV_SCOPE_PER_THREAD = @as(c_int, 1);
pub const PR_PPC_GET_DEXCR = @as(c_int, 72);
pub const PR_PPC_SET_DEXCR = @as(c_int, 73);
pub const PR_PPC_DEXCR_SBHE = @as(c_int, 0);
pub const PR_PPC_DEXCR_IBRTPD = @as(c_int, 1);
pub const PR_PPC_DEXCR_SRAPD = @as(c_int, 2);
pub const PR_PPC_DEXCR_NPHIE = @as(c_int, 3);
pub const PR_PPC_DEXCR_CTRL_EDITABLE = @as(c_int, 0x1);
pub const PR_PPC_DEXCR_CTRL_SET = @as(c_int, 0x2);
pub const PR_PPC_DEXCR_CTRL_CLEAR = @as(c_int, 0x4);
pub const PR_PPC_DEXCR_CTRL_SET_ONEXEC = @as(c_int, 0x8);
pub const PR_PPC_DEXCR_CTRL_CLEAR_ONEXEC = @as(c_int, 0x10);
pub const PR_PPC_DEXCR_CTRL_MASK = @as(c_int, 0x1f);
pub const _SYS_SENDFILE_H = @as(c_int, 1);
pub const _SYS_EPOLL_H = @as(c_int, 1);
pub const __EPOLL_PACKED = @compileError("unable to translate macro: undefined identifier `__packed__`");
// /usr/include/bits/epoll.h:29:9
pub const EPOLL_CTL_ADD = @as(c_int, 1);
pub const EPOLL_CTL_DEL = @as(c_int, 2);
pub const EPOLL_CTL_MOD = @as(c_int, 3);
pub const EPOLL_IOC_TYPE = @as(c_int, 0x8A);
pub const EPIOCSPARAMS = _IOW(EPOLL_IOC_TYPE, @as(c_int, 0x01), struct_epoll_params);
pub const EPIOCGPARAMS = _IOR(EPOLL_IOC_TYPE, @as(c_int, 0x02), struct_epoll_params);
pub const _SYS_EVENTFD_H = @as(c_int, 1);
pub const _SYSCALL_H = @as(c_int, 1);
pub const _ASM_X86_UNISTD_H = "";
pub const __X32_SYSCALL_BIT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hex);
pub const _ASM_UNISTD_64_H = "";
pub const __NR_read = @as(c_int, 0);
pub const __NR_write = @as(c_int, 1);
pub const __NR_open = @as(c_int, 2);
pub const __NR_close = @as(c_int, 3);
pub const __NR_stat = @as(c_int, 4);
pub const __NR_fstat = @as(c_int, 5);
pub const __NR_lstat = @as(c_int, 6);
pub const __NR_poll = @as(c_int, 7);
pub const __NR_lseek = @as(c_int, 8);
pub const __NR_mmap = @as(c_int, 9);
pub const __NR_mprotect = @as(c_int, 10);
pub const __NR_munmap = @as(c_int, 11);
pub const __NR_brk = @as(c_int, 12);
pub const __NR_rt_sigaction = @as(c_int, 13);
pub const __NR_rt_sigprocmask = @as(c_int, 14);
pub const __NR_rt_sigreturn = @as(c_int, 15);
pub const __NR_ioctl = @as(c_int, 16);
pub const __NR_pread64 = @as(c_int, 17);
pub const __NR_pwrite64 = @as(c_int, 18);
pub const __NR_readv = @as(c_int, 19);
pub const __NR_writev = @as(c_int, 20);
pub const __NR_access = @as(c_int, 21);
pub const __NR_pipe = @as(c_int, 22);
pub const __NR_select = @as(c_int, 23);
pub const __NR_sched_yield = @as(c_int, 24);
pub const __NR_mremap = @as(c_int, 25);
pub const __NR_msync = @as(c_int, 26);
pub const __NR_mincore = @as(c_int, 27);
pub const __NR_madvise = @as(c_int, 28);
pub const __NR_shmget = @as(c_int, 29);
pub const __NR_shmat = @as(c_int, 30);
pub const __NR_shmctl = @as(c_int, 31);
pub const __NR_dup = @as(c_int, 32);
pub const __NR_dup2 = @as(c_int, 33);
pub const __NR_pause = @as(c_int, 34);
pub const __NR_nanosleep = @as(c_int, 35);
pub const __NR_getitimer = @as(c_int, 36);
pub const __NR_alarm = @as(c_int, 37);
pub const __NR_setitimer = @as(c_int, 38);
pub const __NR_getpid = @as(c_int, 39);
pub const __NR_sendfile = @as(c_int, 40);
pub const __NR_socket = @as(c_int, 41);
pub const __NR_connect = @as(c_int, 42);
pub const __NR_accept = @as(c_int, 43);
pub const __NR_sendto = @as(c_int, 44);
pub const __NR_recvfrom = @as(c_int, 45);
pub const __NR_sendmsg = @as(c_int, 46);
pub const __NR_recvmsg = @as(c_int, 47);
pub const __NR_shutdown = @as(c_int, 48);
pub const __NR_bind = @as(c_int, 49);
pub const __NR_listen = @as(c_int, 50);
pub const __NR_getsockname = @as(c_int, 51);
pub const __NR_getpeername = @as(c_int, 52);
pub const __NR_socketpair = @as(c_int, 53);
pub const __NR_setsockopt = @as(c_int, 54);
pub const __NR_getsockopt = @as(c_int, 55);
pub const __NR_clone = @as(c_int, 56);
pub const __NR_fork = @as(c_int, 57);
pub const __NR_vfork = @as(c_int, 58);
pub const __NR_execve = @as(c_int, 59);
pub const __NR_exit = @as(c_int, 60);
pub const __NR_wait4 = @as(c_int, 61);
pub const __NR_kill = @as(c_int, 62);
pub const __NR_uname = @as(c_int, 63);
pub const __NR_semget = @as(c_int, 64);
pub const __NR_semop = @as(c_int, 65);
pub const __NR_semctl = @as(c_int, 66);
pub const __NR_shmdt = @as(c_int, 67);
pub const __NR_msgget = @as(c_int, 68);
pub const __NR_msgsnd = @as(c_int, 69);
pub const __NR_msgrcv = @as(c_int, 70);
pub const __NR_msgctl = @as(c_int, 71);
pub const __NR_fcntl = @as(c_int, 72);
pub const __NR_flock = @as(c_int, 73);
pub const __NR_fsync = @as(c_int, 74);
pub const __NR_fdatasync = @as(c_int, 75);
pub const __NR_truncate = @as(c_int, 76);
pub const __NR_ftruncate = @as(c_int, 77);
pub const __NR_getdents = @as(c_int, 78);
pub const __NR_getcwd = @as(c_int, 79);
pub const __NR_chdir = @as(c_int, 80);
pub const __NR_fchdir = @as(c_int, 81);
pub const __NR_rename = @as(c_int, 82);
pub const __NR_mkdir = @as(c_int, 83);
pub const __NR_rmdir = @as(c_int, 84);
pub const __NR_creat = @as(c_int, 85);
pub const __NR_link = @as(c_int, 86);
pub const __NR_unlink = @as(c_int, 87);
pub const __NR_symlink = @as(c_int, 88);
pub const __NR_readlink = @as(c_int, 89);
pub const __NR_chmod = @as(c_int, 90);
pub const __NR_fchmod = @as(c_int, 91);
pub const __NR_chown = @as(c_int, 92);
pub const __NR_fchown = @as(c_int, 93);
pub const __NR_lchown = @as(c_int, 94);
pub const __NR_umask = @as(c_int, 95);
pub const __NR_gettimeofday = @as(c_int, 96);
pub const __NR_getrlimit = @as(c_int, 97);
pub const __NR_getrusage = @as(c_int, 98);
pub const __NR_sysinfo = @as(c_int, 99);
pub const __NR_times = @as(c_int, 100);
pub const __NR_ptrace = @as(c_int, 101);
pub const __NR_getuid = @as(c_int, 102);
pub const __NR_syslog = @as(c_int, 103);
pub const __NR_getgid = @as(c_int, 104);
pub const __NR_setuid = @as(c_int, 105);
pub const __NR_setgid = @as(c_int, 106);
pub const __NR_geteuid = @as(c_int, 107);
pub const __NR_getegid = @as(c_int, 108);
pub const __NR_setpgid = @as(c_int, 109);
pub const __NR_getppid = @as(c_int, 110);
pub const __NR_getpgrp = @as(c_int, 111);
pub const __NR_setsid = @as(c_int, 112);
pub const __NR_setreuid = @as(c_int, 113);
pub const __NR_setregid = @as(c_int, 114);
pub const __NR_getgroups = @as(c_int, 115);
pub const __NR_setgroups = @as(c_int, 116);
pub const __NR_setresuid = @as(c_int, 117);
pub const __NR_getresuid = @as(c_int, 118);
pub const __NR_setresgid = @as(c_int, 119);
pub const __NR_getresgid = @as(c_int, 120);
pub const __NR_getpgid = @as(c_int, 121);
pub const __NR_setfsuid = @as(c_int, 122);
pub const __NR_setfsgid = @as(c_int, 123);
pub const __NR_getsid = @as(c_int, 124);
pub const __NR_capget = @as(c_int, 125);
pub const __NR_capset = @as(c_int, 126);
pub const __NR_rt_sigpending = @as(c_int, 127);
pub const __NR_rt_sigtimedwait = @as(c_int, 128);
pub const __NR_rt_sigqueueinfo = @as(c_int, 129);
pub const __NR_rt_sigsuspend = @as(c_int, 130);
pub const __NR_sigaltstack = @as(c_int, 131);
pub const __NR_utime = @as(c_int, 132);
pub const __NR_mknod = @as(c_int, 133);
pub const __NR_uselib = @as(c_int, 134);
pub const __NR_personality = @as(c_int, 135);
pub const __NR_ustat = @as(c_int, 136);
pub const __NR_statfs = @as(c_int, 137);
pub const __NR_fstatfs = @as(c_int, 138);
pub const __NR_sysfs = @as(c_int, 139);
pub const __NR_getpriority = @as(c_int, 140);
pub const __NR_setpriority = @as(c_int, 141);
pub const __NR_sched_setparam = @as(c_int, 142);
pub const __NR_sched_getparam = @as(c_int, 143);
pub const __NR_sched_setscheduler = @as(c_int, 144);
pub const __NR_sched_getscheduler = @as(c_int, 145);
pub const __NR_sched_get_priority_max = @as(c_int, 146);
pub const __NR_sched_get_priority_min = @as(c_int, 147);
pub const __NR_sched_rr_get_interval = @as(c_int, 148);
pub const __NR_mlock = @as(c_int, 149);
pub const __NR_munlock = @as(c_int, 150);
pub const __NR_mlockall = @as(c_int, 151);
pub const __NR_munlockall = @as(c_int, 152);
pub const __NR_vhangup = @as(c_int, 153);
pub const __NR_modify_ldt = @as(c_int, 154);
pub const __NR_pivot_root = @as(c_int, 155);
pub const __NR__sysctl = @as(c_int, 156);
pub const __NR_prctl = @as(c_int, 157);
pub const __NR_arch_prctl = @as(c_int, 158);
pub const __NR_adjtimex = @as(c_int, 159);
pub const __NR_setrlimit = @as(c_int, 160);
pub const __NR_chroot = @as(c_int, 161);
pub const __NR_sync = @as(c_int, 162);
pub const __NR_acct = @as(c_int, 163);
pub const __NR_settimeofday = @as(c_int, 164);
pub const __NR_mount = @as(c_int, 165);
pub const __NR_umount2 = @as(c_int, 166);
pub const __NR_swapon = @as(c_int, 167);
pub const __NR_swapoff = @as(c_int, 168);
pub const __NR_reboot = @as(c_int, 169);
pub const __NR_sethostname = @as(c_int, 170);
pub const __NR_setdomainname = @as(c_int, 171);
pub const __NR_iopl = @as(c_int, 172);
pub const __NR_ioperm = @as(c_int, 173);
pub const __NR_create_module = @as(c_int, 174);
pub const __NR_init_module = @as(c_int, 175);
pub const __NR_delete_module = @as(c_int, 176);
pub const __NR_get_kernel_syms = @as(c_int, 177);
pub const __NR_query_module = @as(c_int, 178);
pub const __NR_quotactl = @as(c_int, 179);
pub const __NR_nfsservctl = @as(c_int, 180);
pub const __NR_getpmsg = @as(c_int, 181);
pub const __NR_putpmsg = @as(c_int, 182);
pub const __NR_afs_syscall = @as(c_int, 183);
pub const __NR_tuxcall = @as(c_int, 184);
pub const __NR_security = @as(c_int, 185);
pub const __NR_gettid = @as(c_int, 186);
pub const __NR_readahead = @as(c_int, 187);
pub const __NR_setxattr = @as(c_int, 188);
pub const __NR_lsetxattr = @as(c_int, 189);
pub const __NR_fsetxattr = @as(c_int, 190);
pub const __NR_getxattr = @as(c_int, 191);
pub const __NR_lgetxattr = @as(c_int, 192);
pub const __NR_fgetxattr = @as(c_int, 193);
pub const __NR_listxattr = @as(c_int, 194);
pub const __NR_llistxattr = @as(c_int, 195);
pub const __NR_flistxattr = @as(c_int, 196);
pub const __NR_removexattr = @as(c_int, 197);
pub const __NR_lremovexattr = @as(c_int, 198);
pub const __NR_fremovexattr = @as(c_int, 199);
pub const __NR_tkill = @as(c_int, 200);
pub const __NR_time = @as(c_int, 201);
pub const __NR_futex = @as(c_int, 202);
pub const __NR_sched_setaffinity = @as(c_int, 203);
pub const __NR_sched_getaffinity = @as(c_int, 204);
pub const __NR_set_thread_area = @as(c_int, 205);
pub const __NR_io_setup = @as(c_int, 206);
pub const __NR_io_destroy = @as(c_int, 207);
pub const __NR_io_getevents = @as(c_int, 208);
pub const __NR_io_submit = @as(c_int, 209);
pub const __NR_io_cancel = @as(c_int, 210);
pub const __NR_get_thread_area = @as(c_int, 211);
pub const __NR_lookup_dcookie = @as(c_int, 212);
pub const __NR_epoll_create = @as(c_int, 213);
pub const __NR_epoll_ctl_old = @as(c_int, 214);
pub const __NR_epoll_wait_old = @as(c_int, 215);
pub const __NR_remap_file_pages = @as(c_int, 216);
pub const __NR_getdents64 = @as(c_int, 217);
pub const __NR_set_tid_address = @as(c_int, 218);
pub const __NR_restart_syscall = @as(c_int, 219);
pub const __NR_semtimedop = @as(c_int, 220);
pub const __NR_fadvise64 = @as(c_int, 221);
pub const __NR_timer_create = @as(c_int, 222);
pub const __NR_timer_settime = @as(c_int, 223);
pub const __NR_timer_gettime = @as(c_int, 224);
pub const __NR_timer_getoverrun = @as(c_int, 225);
pub const __NR_timer_delete = @as(c_int, 226);
pub const __NR_clock_settime = @as(c_int, 227);
pub const __NR_clock_gettime = @as(c_int, 228);
pub const __NR_clock_getres = @as(c_int, 229);
pub const __NR_clock_nanosleep = @as(c_int, 230);
pub const __NR_exit_group = @as(c_int, 231);
pub const __NR_epoll_wait = @as(c_int, 232);
pub const __NR_epoll_ctl = @as(c_int, 233);
pub const __NR_tgkill = @as(c_int, 234);
pub const __NR_utimes = @as(c_int, 235);
pub const __NR_vserver = @as(c_int, 236);
pub const __NR_mbind = @as(c_int, 237);
pub const __NR_set_mempolicy = @as(c_int, 238);
pub const __NR_get_mempolicy = @as(c_int, 239);
pub const __NR_mq_open = @as(c_int, 240);
pub const __NR_mq_unlink = @as(c_int, 241);
pub const __NR_mq_timedsend = @as(c_int, 242);
pub const __NR_mq_timedreceive = @as(c_int, 243);
pub const __NR_mq_notify = @as(c_int, 244);
pub const __NR_mq_getsetattr = @as(c_int, 245);
pub const __NR_kexec_load = @as(c_int, 246);
pub const __NR_waitid = @as(c_int, 247);
pub const __NR_add_key = @as(c_int, 248);
pub const __NR_request_key = @as(c_int, 249);
pub const __NR_keyctl = @as(c_int, 250);
pub const __NR_ioprio_set = @as(c_int, 251);
pub const __NR_ioprio_get = @as(c_int, 252);
pub const __NR_inotify_init = @as(c_int, 253);
pub const __NR_inotify_add_watch = @as(c_int, 254);
pub const __NR_inotify_rm_watch = @as(c_int, 255);
pub const __NR_migrate_pages = @as(c_int, 256);
pub const __NR_openat = @as(c_int, 257);
pub const __NR_mkdirat = @as(c_int, 258);
pub const __NR_mknodat = @as(c_int, 259);
pub const __NR_fchownat = @as(c_int, 260);
pub const __NR_futimesat = @as(c_int, 261);
pub const __NR_newfstatat = @as(c_int, 262);
pub const __NR_unlinkat = @as(c_int, 263);
pub const __NR_renameat = @as(c_int, 264);
pub const __NR_linkat = @as(c_int, 265);
pub const __NR_symlinkat = @as(c_int, 266);
pub const __NR_readlinkat = @as(c_int, 267);
pub const __NR_fchmodat = @as(c_int, 268);
pub const __NR_faccessat = @as(c_int, 269);
pub const __NR_pselect6 = @as(c_int, 270);
pub const __NR_ppoll = @as(c_int, 271);
pub const __NR_unshare = @as(c_int, 272);
pub const __NR_set_robust_list = @as(c_int, 273);
pub const __NR_get_robust_list = @as(c_int, 274);
pub const __NR_splice = @as(c_int, 275);
pub const __NR_tee = @as(c_int, 276);
pub const __NR_sync_file_range = @as(c_int, 277);
pub const __NR_vmsplice = @as(c_int, 278);
pub const __NR_move_pages = @as(c_int, 279);
pub const __NR_utimensat = @as(c_int, 280);
pub const __NR_epoll_pwait = @as(c_int, 281);
pub const __NR_signalfd = @as(c_int, 282);
pub const __NR_timerfd_create = @as(c_int, 283);
pub const __NR_eventfd = @as(c_int, 284);
pub const __NR_fallocate = @as(c_int, 285);
pub const __NR_timerfd_settime = @as(c_int, 286);
pub const __NR_timerfd_gettime = @as(c_int, 287);
pub const __NR_accept4 = @as(c_int, 288);
pub const __NR_signalfd4 = @as(c_int, 289);
pub const __NR_eventfd2 = @as(c_int, 290);
pub const __NR_epoll_create1 = @as(c_int, 291);
pub const __NR_dup3 = @as(c_int, 292);
pub const __NR_pipe2 = @as(c_int, 293);
pub const __NR_inotify_init1 = @as(c_int, 294);
pub const __NR_preadv = @as(c_int, 295);
pub const __NR_pwritev = @as(c_int, 296);
pub const __NR_rt_tgsigqueueinfo = @as(c_int, 297);
pub const __NR_perf_event_open = @as(c_int, 298);
pub const __NR_recvmmsg = @as(c_int, 299);
pub const __NR_fanotify_init = @as(c_int, 300);
pub const __NR_fanotify_mark = @as(c_int, 301);
pub const __NR_prlimit64 = @as(c_int, 302);
pub const __NR_name_to_handle_at = @as(c_int, 303);
pub const __NR_open_by_handle_at = @as(c_int, 304);
pub const __NR_clock_adjtime = @as(c_int, 305);
pub const __NR_syncfs = @as(c_int, 306);
pub const __NR_sendmmsg = @as(c_int, 307);
pub const __NR_setns = @as(c_int, 308);
pub const __NR_getcpu = @as(c_int, 309);
pub const __NR_process_vm_readv = @as(c_int, 310);
pub const __NR_process_vm_writev = @as(c_int, 311);
pub const __NR_kcmp = @as(c_int, 312);
pub const __NR_finit_module = @as(c_int, 313);
pub const __NR_sched_setattr = @as(c_int, 314);
pub const __NR_sched_getattr = @as(c_int, 315);
pub const __NR_renameat2 = @as(c_int, 316);
pub const __NR_seccomp = @as(c_int, 317);
pub const __NR_getrandom = @as(c_int, 318);
pub const __NR_memfd_create = @as(c_int, 319);
pub const __NR_kexec_file_load = @as(c_int, 320);
pub const __NR_bpf = @as(c_int, 321);
pub const __NR_execveat = @as(c_int, 322);
pub const __NR_userfaultfd = @as(c_int, 323);
pub const __NR_membarrier = @as(c_int, 324);
pub const __NR_mlock2 = @as(c_int, 325);
pub const __NR_copy_file_range = @as(c_int, 326);
pub const __NR_preadv2 = @as(c_int, 327);
pub const __NR_pwritev2 = @as(c_int, 328);
pub const __NR_pkey_mprotect = @as(c_int, 329);
pub const __NR_pkey_alloc = @as(c_int, 330);
pub const __NR_pkey_free = @as(c_int, 331);
pub const __NR_statx = @as(c_int, 332);
pub const __NR_io_pgetevents = @as(c_int, 333);
pub const __NR_rseq = @as(c_int, 334);
pub const __NR_pidfd_send_signal = @as(c_int, 424);
pub const __NR_io_uring_setup = @as(c_int, 425);
pub const __NR_io_uring_enter = @as(c_int, 426);
pub const __NR_io_uring_register = @as(c_int, 427);
pub const __NR_open_tree = @as(c_int, 428);
pub const __NR_move_mount = @as(c_int, 429);
pub const __NR_fsopen = @as(c_int, 430);
pub const __NR_fsconfig = @as(c_int, 431);
pub const __NR_fsmount = @as(c_int, 432);
pub const __NR_fspick = @as(c_int, 433);
pub const __NR_pidfd_open = @as(c_int, 434);
pub const __NR_clone3 = @as(c_int, 435);
pub const __NR_close_range = @as(c_int, 436);
pub const __NR_openat2 = @as(c_int, 437);
pub const __NR_pidfd_getfd = @as(c_int, 438);
pub const __NR_faccessat2 = @as(c_int, 439);
pub const __NR_process_madvise = @as(c_int, 440);
pub const __NR_epoll_pwait2 = @as(c_int, 441);
pub const __NR_mount_setattr = @as(c_int, 442);
pub const __NR_quotactl_fd = @as(c_int, 443);
pub const __NR_landlock_create_ruleset = @as(c_int, 444);
pub const __NR_landlock_add_rule = @as(c_int, 445);
pub const __NR_landlock_restrict_self = @as(c_int, 446);
pub const __NR_memfd_secret = @as(c_int, 447);
pub const __NR_process_mrelease = @as(c_int, 448);
pub const __NR_futex_waitv = @as(c_int, 449);
pub const __NR_set_mempolicy_home_node = @as(c_int, 450);
pub const __NR_cachestat = @as(c_int, 451);
pub const __NR_fchmodat2 = @as(c_int, 452);
pub const __NR_map_shadow_stack = @as(c_int, 453);
pub const __NR_futex_wake = @as(c_int, 454);
pub const __NR_futex_wait = @as(c_int, 455);
pub const __NR_futex_requeue = @as(c_int, 456);
pub const __NR_statmount = @as(c_int, 457);
pub const __NR_listmount = @as(c_int, 458);
pub const __NR_lsm_get_self_attr = @as(c_int, 459);
pub const __NR_lsm_set_self_attr = @as(c_int, 460);
pub const __NR_lsm_list_modules = @as(c_int, 461);
pub const __NR_mseal = @as(c_int, 462);
pub const __GLIBC_LINUX_VERSION_CODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 395520, .decimal);
pub const SYS__sysctl = __NR__sysctl;
pub const SYS_accept = __NR_accept;
pub const SYS_accept4 = __NR_accept4;
pub const SYS_access = __NR_access;
pub const SYS_acct = __NR_acct;
pub const SYS_add_key = __NR_add_key;
pub const SYS_adjtimex = __NR_adjtimex;
pub const SYS_afs_syscall = __NR_afs_syscall;
pub const SYS_alarm = __NR_alarm;
pub const SYS_arch_prctl = __NR_arch_prctl;
pub const SYS_bind = __NR_bind;
pub const SYS_bpf = __NR_bpf;
pub const SYS_brk = __NR_brk;
pub const SYS_cachestat = __NR_cachestat;
pub const SYS_capget = __NR_capget;
pub const SYS_capset = __NR_capset;
pub const SYS_chdir = __NR_chdir;
pub const SYS_chmod = __NR_chmod;
pub const SYS_chown = __NR_chown;
pub const SYS_chroot = __NR_chroot;
pub const SYS_clock_adjtime = __NR_clock_adjtime;
pub const SYS_clock_getres = __NR_clock_getres;
pub const SYS_clock_gettime = __NR_clock_gettime;
pub const SYS_clock_nanosleep = __NR_clock_nanosleep;
pub const SYS_clock_settime = __NR_clock_settime;
pub const SYS_clone = __NR_clone;
pub const SYS_clone3 = __NR_clone3;
pub const SYS_close = __NR_close;
pub const SYS_close_range = __NR_close_range;
pub const SYS_connect = __NR_connect;
pub const SYS_copy_file_range = __NR_copy_file_range;
pub const SYS_creat = __NR_creat;
pub const SYS_create_module = __NR_create_module;
pub const SYS_delete_module = __NR_delete_module;
pub const SYS_dup = __NR_dup;
pub const SYS_dup2 = __NR_dup2;
pub const SYS_dup3 = __NR_dup3;
pub const SYS_epoll_create = __NR_epoll_create;
pub const SYS_epoll_create1 = __NR_epoll_create1;
pub const SYS_epoll_ctl = __NR_epoll_ctl;
pub const SYS_epoll_ctl_old = __NR_epoll_ctl_old;
pub const SYS_epoll_pwait = __NR_epoll_pwait;
pub const SYS_epoll_pwait2 = __NR_epoll_pwait2;
pub const SYS_epoll_wait = __NR_epoll_wait;
pub const SYS_epoll_wait_old = __NR_epoll_wait_old;
pub const SYS_eventfd = __NR_eventfd;
pub const SYS_eventfd2 = __NR_eventfd2;
pub const SYS_execve = __NR_execve;
pub const SYS_execveat = __NR_execveat;
pub const SYS_exit = __NR_exit;
pub const SYS_exit_group = __NR_exit_group;
pub const SYS_faccessat = __NR_faccessat;
pub const SYS_faccessat2 = __NR_faccessat2;
pub const SYS_fadvise64 = __NR_fadvise64;
pub const SYS_fallocate = __NR_fallocate;
pub const SYS_fanotify_init = __NR_fanotify_init;
pub const SYS_fanotify_mark = __NR_fanotify_mark;
pub const SYS_fchdir = __NR_fchdir;
pub const SYS_fchmod = __NR_fchmod;
pub const SYS_fchmodat = __NR_fchmodat;
pub const SYS_fchmodat2 = __NR_fchmodat2;
pub const SYS_fchown = __NR_fchown;
pub const SYS_fchownat = __NR_fchownat;
pub const SYS_fcntl = __NR_fcntl;
pub const SYS_fdatasync = __NR_fdatasync;
pub const SYS_fgetxattr = __NR_fgetxattr;
pub const SYS_finit_module = __NR_finit_module;
pub const SYS_flistxattr = __NR_flistxattr;
pub const SYS_flock = __NR_flock;
pub const SYS_fork = __NR_fork;
pub const SYS_fremovexattr = __NR_fremovexattr;
pub const SYS_fsconfig = __NR_fsconfig;
pub const SYS_fsetxattr = __NR_fsetxattr;
pub const SYS_fsmount = __NR_fsmount;
pub const SYS_fsopen = __NR_fsopen;
pub const SYS_fspick = __NR_fspick;
pub const SYS_fstat = __NR_fstat;
pub const SYS_fstatfs = __NR_fstatfs;
pub const SYS_fsync = __NR_fsync;
pub const SYS_ftruncate = __NR_ftruncate;
pub const SYS_futex = __NR_futex;
pub const SYS_futex_requeue = __NR_futex_requeue;
pub const SYS_futex_wait = __NR_futex_wait;
pub const SYS_futex_waitv = __NR_futex_waitv;
pub const SYS_futex_wake = __NR_futex_wake;
pub const SYS_futimesat = __NR_futimesat;
pub const SYS_get_kernel_syms = __NR_get_kernel_syms;
pub const SYS_get_mempolicy = __NR_get_mempolicy;
pub const SYS_get_robust_list = __NR_get_robust_list;
pub const SYS_get_thread_area = __NR_get_thread_area;
pub const SYS_getcpu = __NR_getcpu;
pub const SYS_getcwd = __NR_getcwd;
pub const SYS_getdents = __NR_getdents;
pub const SYS_getdents64 = __NR_getdents64;
pub const SYS_getegid = __NR_getegid;
pub const SYS_geteuid = __NR_geteuid;
pub const SYS_getgid = __NR_getgid;
pub const SYS_getgroups = __NR_getgroups;
pub const SYS_getitimer = __NR_getitimer;
pub const SYS_getpeername = __NR_getpeername;
pub const SYS_getpgid = __NR_getpgid;
pub const SYS_getpgrp = __NR_getpgrp;
pub const SYS_getpid = __NR_getpid;
pub const SYS_getpmsg = __NR_getpmsg;
pub const SYS_getppid = __NR_getppid;
pub const SYS_getpriority = __NR_getpriority;
pub const SYS_getrandom = __NR_getrandom;
pub const SYS_getresgid = __NR_getresgid;
pub const SYS_getresuid = __NR_getresuid;
pub const SYS_getrlimit = __NR_getrlimit;
pub const SYS_getrusage = __NR_getrusage;
pub const SYS_getsid = __NR_getsid;
pub const SYS_getsockname = __NR_getsockname;
pub const SYS_getsockopt = __NR_getsockopt;
pub const SYS_gettid = __NR_gettid;
pub const SYS_gettimeofday = __NR_gettimeofday;
pub const SYS_getuid = __NR_getuid;
pub const SYS_getxattr = __NR_getxattr;
pub const SYS_init_module = __NR_init_module;
pub const SYS_inotify_add_watch = __NR_inotify_add_watch;
pub const SYS_inotify_init = __NR_inotify_init;
pub const SYS_inotify_init1 = __NR_inotify_init1;
pub const SYS_inotify_rm_watch = __NR_inotify_rm_watch;
pub const SYS_io_cancel = __NR_io_cancel;
pub const SYS_io_destroy = __NR_io_destroy;
pub const SYS_io_getevents = __NR_io_getevents;
pub const SYS_io_pgetevents = __NR_io_pgetevents;
pub const SYS_io_setup = __NR_io_setup;
pub const SYS_io_submit = __NR_io_submit;
pub const SYS_io_uring_enter = __NR_io_uring_enter;
pub const SYS_io_uring_register = __NR_io_uring_register;
pub const SYS_io_uring_setup = __NR_io_uring_setup;
pub const SYS_ioctl = __NR_ioctl;
pub const SYS_ioperm = __NR_ioperm;
pub const SYS_iopl = __NR_iopl;
pub const SYS_ioprio_get = __NR_ioprio_get;
pub const SYS_ioprio_set = __NR_ioprio_set;
pub const SYS_kcmp = __NR_kcmp;
pub const SYS_kexec_file_load = __NR_kexec_file_load;
pub const SYS_kexec_load = __NR_kexec_load;
pub const SYS_keyctl = __NR_keyctl;
pub const SYS_kill = __NR_kill;
pub const SYS_landlock_add_rule = __NR_landlock_add_rule;
pub const SYS_landlock_create_ruleset = __NR_landlock_create_ruleset;
pub const SYS_landlock_restrict_self = __NR_landlock_restrict_self;
pub const SYS_lchown = __NR_lchown;
pub const SYS_lgetxattr = __NR_lgetxattr;
pub const SYS_link = __NR_link;
pub const SYS_linkat = __NR_linkat;
pub const SYS_listen = __NR_listen;
pub const SYS_listmount = __NR_listmount;
pub const SYS_listxattr = __NR_listxattr;
pub const SYS_llistxattr = __NR_llistxattr;
pub const SYS_lookup_dcookie = __NR_lookup_dcookie;
pub const SYS_lremovexattr = __NR_lremovexattr;
pub const SYS_lseek = __NR_lseek;
pub const SYS_lsetxattr = __NR_lsetxattr;
pub const SYS_lsm_get_self_attr = __NR_lsm_get_self_attr;
pub const SYS_lsm_list_modules = __NR_lsm_list_modules;
pub const SYS_lsm_set_self_attr = __NR_lsm_set_self_attr;
pub const SYS_lstat = __NR_lstat;
pub const SYS_madvise = __NR_madvise;
pub const SYS_map_shadow_stack = __NR_map_shadow_stack;
pub const SYS_mbind = __NR_mbind;
pub const SYS_membarrier = __NR_membarrier;
pub const SYS_memfd_create = __NR_memfd_create;
pub const SYS_memfd_secret = __NR_memfd_secret;
pub const SYS_migrate_pages = __NR_migrate_pages;
pub const SYS_mincore = __NR_mincore;
pub const SYS_mkdir = __NR_mkdir;
pub const SYS_mkdirat = __NR_mkdirat;
pub const SYS_mknod = __NR_mknod;
pub const SYS_mknodat = __NR_mknodat;
pub const SYS_mlock = __NR_mlock;
pub const SYS_mlock2 = __NR_mlock2;
pub const SYS_mlockall = __NR_mlockall;
pub const SYS_mmap = __NR_mmap;
pub const SYS_modify_ldt = __NR_modify_ldt;
pub const SYS_mount = __NR_mount;
pub const SYS_mount_setattr = __NR_mount_setattr;
pub const SYS_move_mount = __NR_move_mount;
pub const SYS_move_pages = __NR_move_pages;
pub const SYS_mprotect = __NR_mprotect;
pub const SYS_mq_getsetattr = __NR_mq_getsetattr;
pub const SYS_mq_notify = __NR_mq_notify;
pub const SYS_mq_open = __NR_mq_open;
pub const SYS_mq_timedreceive = __NR_mq_timedreceive;
pub const SYS_mq_timedsend = __NR_mq_timedsend;
pub const SYS_mq_unlink = __NR_mq_unlink;
pub const SYS_mremap = __NR_mremap;
pub const SYS_msgctl = __NR_msgctl;
pub const SYS_msgget = __NR_msgget;
pub const SYS_msgrcv = __NR_msgrcv;
pub const SYS_msgsnd = __NR_msgsnd;
pub const SYS_msync = __NR_msync;
pub const SYS_munlock = __NR_munlock;
pub const SYS_munlockall = __NR_munlockall;
pub const SYS_munmap = __NR_munmap;
pub const SYS_name_to_handle_at = __NR_name_to_handle_at;
pub const SYS_nanosleep = __NR_nanosleep;
pub const SYS_newfstatat = __NR_newfstatat;
pub const SYS_nfsservctl = __NR_nfsservctl;
pub const SYS_open = __NR_open;
pub const SYS_open_by_handle_at = __NR_open_by_handle_at;
pub const SYS_open_tree = __NR_open_tree;
pub const SYS_openat = __NR_openat;
pub const SYS_openat2 = __NR_openat2;
pub const SYS_pause = __NR_pause;
pub const SYS_perf_event_open = __NR_perf_event_open;
pub const SYS_personality = __NR_personality;
pub const SYS_pidfd_getfd = __NR_pidfd_getfd;
pub const SYS_pidfd_open = __NR_pidfd_open;
pub const SYS_pidfd_send_signal = __NR_pidfd_send_signal;
pub const SYS_pipe = __NR_pipe;
pub const SYS_pipe2 = __NR_pipe2;
pub const SYS_pivot_root = __NR_pivot_root;
pub const SYS_pkey_alloc = __NR_pkey_alloc;
pub const SYS_pkey_free = __NR_pkey_free;
pub const SYS_pkey_mprotect = __NR_pkey_mprotect;
pub const SYS_poll = __NR_poll;
pub const SYS_ppoll = __NR_ppoll;
pub const SYS_prctl = __NR_prctl;
pub const SYS_pread64 = __NR_pread64;
pub const SYS_preadv = __NR_preadv;
pub const SYS_preadv2 = __NR_preadv2;
pub const SYS_prlimit64 = __NR_prlimit64;
pub const SYS_process_madvise = __NR_process_madvise;
pub const SYS_process_mrelease = __NR_process_mrelease;
pub const SYS_process_vm_readv = __NR_process_vm_readv;
pub const SYS_process_vm_writev = __NR_process_vm_writev;
pub const SYS_pselect6 = __NR_pselect6;
pub const SYS_ptrace = __NR_ptrace;
pub const SYS_putpmsg = __NR_putpmsg;
pub const SYS_pwrite64 = __NR_pwrite64;
pub const SYS_pwritev = __NR_pwritev;
pub const SYS_pwritev2 = __NR_pwritev2;
pub const SYS_query_module = __NR_query_module;
pub const SYS_quotactl = __NR_quotactl;
pub const SYS_quotactl_fd = __NR_quotactl_fd;
pub const SYS_read = __NR_read;
pub const SYS_readahead = __NR_readahead;
pub const SYS_readlink = __NR_readlink;
pub const SYS_readlinkat = __NR_readlinkat;
pub const SYS_readv = __NR_readv;
pub const SYS_reboot = __NR_reboot;
pub const SYS_recvfrom = __NR_recvfrom;
pub const SYS_recvmmsg = __NR_recvmmsg;
pub const SYS_recvmsg = __NR_recvmsg;
pub const SYS_remap_file_pages = __NR_remap_file_pages;
pub const SYS_removexattr = __NR_removexattr;
pub const SYS_rename = __NR_rename;
pub const SYS_renameat = __NR_renameat;
pub const SYS_renameat2 = __NR_renameat2;
pub const SYS_request_key = __NR_request_key;
pub const SYS_restart_syscall = __NR_restart_syscall;
pub const SYS_rmdir = __NR_rmdir;
pub const SYS_rseq = __NR_rseq;
pub const SYS_rt_sigaction = __NR_rt_sigaction;
pub const SYS_rt_sigpending = __NR_rt_sigpending;
pub const SYS_rt_sigprocmask = __NR_rt_sigprocmask;
pub const SYS_rt_sigqueueinfo = __NR_rt_sigqueueinfo;
pub const SYS_rt_sigreturn = __NR_rt_sigreturn;
pub const SYS_rt_sigsuspend = __NR_rt_sigsuspend;
pub const SYS_rt_sigtimedwait = __NR_rt_sigtimedwait;
pub const SYS_rt_tgsigqueueinfo = __NR_rt_tgsigqueueinfo;
pub const SYS_sched_get_priority_max = __NR_sched_get_priority_max;
pub const SYS_sched_get_priority_min = __NR_sched_get_priority_min;
pub const SYS_sched_getaffinity = __NR_sched_getaffinity;
pub const SYS_sched_getattr = __NR_sched_getattr;
pub const SYS_sched_getparam = __NR_sched_getparam;
pub const SYS_sched_getscheduler = __NR_sched_getscheduler;
pub const SYS_sched_rr_get_interval = __NR_sched_rr_get_interval;
pub const SYS_sched_setaffinity = __NR_sched_setaffinity;
pub const SYS_sched_setattr = __NR_sched_setattr;
pub const SYS_sched_setparam = __NR_sched_setparam;
pub const SYS_sched_setscheduler = __NR_sched_setscheduler;
pub const SYS_sched_yield = __NR_sched_yield;
pub const SYS_seccomp = __NR_seccomp;
pub const SYS_security = __NR_security;
pub const SYS_select = __NR_select;
pub const SYS_semctl = __NR_semctl;
pub const SYS_semget = __NR_semget;
pub const SYS_semop = __NR_semop;
pub const SYS_semtimedop = __NR_semtimedop;
pub const SYS_sendfile = __NR_sendfile;
pub const SYS_sendmmsg = __NR_sendmmsg;
pub const SYS_sendmsg = __NR_sendmsg;
pub const SYS_sendto = __NR_sendto;
pub const SYS_set_mempolicy = __NR_set_mempolicy;
pub const SYS_set_mempolicy_home_node = __NR_set_mempolicy_home_node;
pub const SYS_set_robust_list = __NR_set_robust_list;
pub const SYS_set_thread_area = __NR_set_thread_area;
pub const SYS_set_tid_address = __NR_set_tid_address;
pub const SYS_setdomainname = __NR_setdomainname;
pub const SYS_setfsgid = __NR_setfsgid;
pub const SYS_setfsuid = __NR_setfsuid;
pub const SYS_setgid = __NR_setgid;
pub const SYS_setgroups = __NR_setgroups;
pub const SYS_sethostname = __NR_sethostname;
pub const SYS_setitimer = __NR_setitimer;
pub const SYS_setns = __NR_setns;
pub const SYS_setpgid = __NR_setpgid;
pub const SYS_setpriority = __NR_setpriority;
pub const SYS_setregid = __NR_setregid;
pub const SYS_setresgid = __NR_setresgid;
pub const SYS_setresuid = __NR_setresuid;
pub const SYS_setreuid = __NR_setreuid;
pub const SYS_setrlimit = __NR_setrlimit;
pub const SYS_setsid = __NR_setsid;
pub const SYS_setsockopt = __NR_setsockopt;
pub const SYS_settimeofday = __NR_settimeofday;
pub const SYS_setuid = __NR_setuid;
pub const SYS_setxattr = __NR_setxattr;
pub const SYS_shmat = __NR_shmat;
pub const SYS_shmctl = __NR_shmctl;
pub const SYS_shmdt = __NR_shmdt;
pub const SYS_shmget = __NR_shmget;
pub const SYS_shutdown = __NR_shutdown;
pub const SYS_sigaltstack = __NR_sigaltstack;
pub const SYS_signalfd = __NR_signalfd;
pub const SYS_signalfd4 = __NR_signalfd4;
pub const SYS_socket = __NR_socket;
pub const SYS_socketpair = __NR_socketpair;
pub const SYS_splice = __NR_splice;
pub const SYS_stat = __NR_stat;
pub const SYS_statfs = __NR_statfs;
pub const SYS_statmount = __NR_statmount;
pub const SYS_statx = __NR_statx;
pub const SYS_swapoff = __NR_swapoff;
pub const SYS_swapon = __NR_swapon;
pub const SYS_symlink = __NR_symlink;
pub const SYS_symlinkat = __NR_symlinkat;
pub const SYS_sync = __NR_sync;
pub const SYS_sync_file_range = __NR_sync_file_range;
pub const SYS_syncfs = __NR_syncfs;
pub const SYS_sysfs = __NR_sysfs;
pub const SYS_sysinfo = __NR_sysinfo;
pub const SYS_syslog = __NR_syslog;
pub const SYS_tee = __NR_tee;
pub const SYS_tgkill = __NR_tgkill;
pub const SYS_time = __NR_time;
pub const SYS_timer_create = __NR_timer_create;
pub const SYS_timer_delete = __NR_timer_delete;
pub const SYS_timer_getoverrun = __NR_timer_getoverrun;
pub const SYS_timer_gettime = __NR_timer_gettime;
pub const SYS_timer_settime = __NR_timer_settime;
pub const SYS_timerfd_create = __NR_timerfd_create;
pub const SYS_timerfd_gettime = __NR_timerfd_gettime;
pub const SYS_timerfd_settime = __NR_timerfd_settime;
pub const SYS_times = __NR_times;
pub const SYS_tkill = __NR_tkill;
pub const SYS_truncate = __NR_truncate;
pub const SYS_tuxcall = __NR_tuxcall;
pub const SYS_umask = __NR_umask;
pub const SYS_umount2 = __NR_umount2;
pub const SYS_uname = __NR_uname;
pub const SYS_unlink = __NR_unlink;
pub const SYS_unlinkat = __NR_unlinkat;
pub const SYS_unshare = __NR_unshare;
pub const SYS_uselib = __NR_uselib;
pub const SYS_userfaultfd = __NR_userfaultfd;
pub const SYS_ustat = __NR_ustat;
pub const SYS_utime = __NR_utime;
pub const SYS_utimensat = __NR_utimensat;
pub const SYS_utimes = __NR_utimes;
pub const SYS_vfork = __NR_vfork;
pub const SYS_vhangup = __NR_vhangup;
pub const SYS_vmsplice = __NR_vmsplice;
pub const SYS_vserver = __NR_vserver;
pub const SYS_wait4 = __NR_wait4;
pub const SYS_waitid = __NR_waitid;
pub const SYS_write = __NR_write;
pub const SYS_writev = __NR_writev;
pub const _LINUX_CAPABILITY_H = "";
pub const _LINUX_CAPABILITY_VERSION_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x19980330, .hex);
pub const _LINUX_CAPABILITY_U32S_1 = @as(c_int, 1);
pub const _LINUX_CAPABILITY_VERSION_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20071026, .hex);
pub const _LINUX_CAPABILITY_U32S_2 = @as(c_int, 2);
pub const _LINUX_CAPABILITY_VERSION_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20080522, .hex);
pub const _LINUX_CAPABILITY_U32S_3 = @as(c_int, 2);
pub const VFS_CAP_REVISION_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFF000000, .hex);
pub const VFS_CAP_REVISION_SHIFT = @as(c_int, 24);
pub const VFS_CAP_FLAGS_MASK = ~VFS_CAP_REVISION_MASK;
pub const VFS_CAP_FLAGS_EFFECTIVE = @as(c_int, 0x000001);
pub const VFS_CAP_REVISION_1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x01000000, .hex);
pub const VFS_CAP_U32_1 = @as(c_int, 1);
pub const XATTR_CAPS_SZ_1 = @import("std").zig.c_translation.sizeof(__le32) * (@as(c_int, 1) + (@as(c_int, 2) * VFS_CAP_U32_1));
pub const VFS_CAP_REVISION_2 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x02000000, .hex);
pub const VFS_CAP_U32_2 = @as(c_int, 2);
pub const XATTR_CAPS_SZ_2 = @import("std").zig.c_translation.sizeof(__le32) * (@as(c_int, 1) + (@as(c_int, 2) * VFS_CAP_U32_2));
pub const VFS_CAP_REVISION_3 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000000, .hex);
pub const VFS_CAP_U32_3 = @as(c_int, 2);
pub const XATTR_CAPS_SZ_3 = @import("std").zig.c_translation.sizeof(__le32) * (@as(c_int, 2) + (@as(c_int, 2) * VFS_CAP_U32_3));
pub const XATTR_CAPS_SZ = XATTR_CAPS_SZ_3;
pub const VFS_CAP_U32 = VFS_CAP_U32_3;
pub const VFS_CAP_REVISION = VFS_CAP_REVISION_3;
pub const _LINUX_CAPABILITY_VERSION = _LINUX_CAPABILITY_VERSION_1;
pub const _LINUX_CAPABILITY_U32S = _LINUX_CAPABILITY_U32S_1;
pub const CAP_CHOWN = @as(c_int, 0);
pub const CAP_DAC_OVERRIDE = @as(c_int, 1);
pub const CAP_DAC_READ_SEARCH = @as(c_int, 2);
pub const CAP_FOWNER = @as(c_int, 3);
pub const CAP_FSETID = @as(c_int, 4);
pub const CAP_KILL = @as(c_int, 5);
pub const CAP_SETGID = @as(c_int, 6);
pub const CAP_SETUID = @as(c_int, 7);
pub const CAP_SETPCAP = @as(c_int, 8);
pub const CAP_LINUX_IMMUTABLE = @as(c_int, 9);
pub const CAP_NET_BIND_SERVICE = @as(c_int, 10);
pub const CAP_NET_BROADCAST = @as(c_int, 11);
pub const CAP_NET_ADMIN = @as(c_int, 12);
pub const CAP_NET_RAW = @as(c_int, 13);
pub const CAP_IPC_LOCK = @as(c_int, 14);
pub const CAP_IPC_OWNER = @as(c_int, 15);
pub const CAP_SYS_MODULE = @as(c_int, 16);
pub const CAP_SYS_RAWIO = @as(c_int, 17);
pub const CAP_SYS_CHROOT = @as(c_int, 18);
pub const CAP_SYS_PTRACE = @as(c_int, 19);
pub const CAP_SYS_PACCT = @as(c_int, 20);
pub const CAP_SYS_ADMIN = @as(c_int, 21);
pub const CAP_SYS_BOOT = @as(c_int, 22);
pub const CAP_SYS_NICE = @as(c_int, 23);
pub const CAP_SYS_RESOURCE = @as(c_int, 24);
pub const CAP_SYS_TIME = @as(c_int, 25);
pub const CAP_SYS_TTY_CONFIG = @as(c_int, 26);
pub const CAP_MKNOD = @as(c_int, 27);
pub const CAP_LEASE = @as(c_int, 28);
pub const CAP_AUDIT_WRITE = @as(c_int, 29);
pub const CAP_AUDIT_CONTROL = @as(c_int, 30);
pub const CAP_SETFCAP = @as(c_int, 31);
pub const CAP_MAC_OVERRIDE = @as(c_int, 32);
pub const CAP_MAC_ADMIN = @as(c_int, 33);
pub const CAP_SYSLOG = @as(c_int, 34);
pub const CAP_WAKE_ALARM = @as(c_int, 35);
pub const CAP_BLOCK_SUSPEND = @as(c_int, 36);
pub const CAP_AUDIT_READ = @as(c_int, 37);
pub const CAP_PERFMON = @as(c_int, 38);
pub const CAP_BPF = @as(c_int, 39);
pub const CAP_CHECKPOINT_RESTORE = @as(c_int, 40);
pub const CAP_LAST_CAP = CAP_CHECKPOINT_RESTORE;
pub inline fn cap_valid(x: anytype) @TypeOf((x >= @as(c_int, 0)) and (x <= CAP_LAST_CAP)) {
    _ = &x;
    return (x >= @as(c_int, 0)) and (x <= CAP_LAST_CAP);
}
pub inline fn CAP_TO_INDEX(x: anytype) @TypeOf(x >> @as(c_int, 5)) {
    _ = &x;
    return x >> @as(c_int, 5);
}
pub inline fn CAP_TO_MASK(x: anytype) @TypeOf(@as(c_uint, 1) << (x & @as(c_int, 31))) {
    _ = &x;
    return @as(c_uint, 1) << (x & @as(c_int, 31));
}
pub const __NETINET_UDP_H = @as(c_int, 1);
pub const UDP_CORK = @as(c_int, 1);
pub const UDP_ENCAP = @as(c_int, 100);
pub const UDP_NO_CHECK6_TX = @as(c_int, 101);
pub const UDP_NO_CHECK6_RX = @as(c_int, 102);
pub const UDP_SEGMENT = @as(c_int, 103);
pub const UDP_GRO = @as(c_int, 104);
pub const UDP_ENCAP_ESPINUDP_NON_IKE = @as(c_int, 1);
pub const UDP_ENCAP_ESPINUDP = @as(c_int, 2);
pub const UDP_ENCAP_L2TPINUDP = @as(c_int, 3);
pub const UDP_ENCAP_GTP0 = @as(c_int, 4);
pub const UDP_ENCAP_GTP1U = @as(c_int, 5);
pub const SOL_UDP = @as(c_int, 17);
pub const NGX_LISTEN_BACKLOG = @as(c_int, 511);
pub const NGX_HAVE_SO_SNDLOWAT = @as(c_int, 0);
pub const NGX_HAVE_INHERITED_NONBLOCK = @as(c_int, 0);
pub const NGX_HAVE_OS_SPECIFIC_INIT = @as(c_int, 1);
pub const ngx_debug_init = @compileError("unable to translate C expr: unexpected token ''");
// src/os/unix/ngx_linux_config.h:126:9
pub const ngx_signal_helper = @compileError("unable to translate macro: undefined identifier `SIG`");
// src/core/ngx_config.h:54:9
pub inline fn ngx_signal_value(n: anytype) @TypeOf(ngx_signal_helper(n)) {
    _ = &n;
    return ngx_signal_helper(n);
}
pub const ngx_random = random;
pub const NGX_SHUTDOWN_SIGNAL = @compileError("unable to translate macro: undefined identifier `QUIT`");
// src/core/ngx_config.h:60:9
pub const NGX_TERMINATE_SIGNAL = @compileError("unable to translate macro: undefined identifier `TERM`");
// src/core/ngx_config.h:61:9
pub const NGX_NOACCEPT_SIGNAL = @compileError("unable to translate macro: undefined identifier `WINCH`");
// src/core/ngx_config.h:62:9
pub const NGX_RECONFIGURE_SIGNAL = @compileError("unable to translate macro: undefined identifier `HUP`");
// src/core/ngx_config.h:63:9
pub const NGX_REOPEN_SIGNAL = @compileError("unable to translate macro: undefined identifier `USR1`");
// src/core/ngx_config.h:69:9
pub const NGX_CHANGEBIN_SIGNAL = @compileError("unable to translate macro: undefined identifier `USR2`");
// src/core/ngx_config.h:70:9
pub const ngx_cdecl = "";
pub const ngx_libc_cdecl = "";
pub const NGX_INT32_LEN = @compileError("unable to translate C expr: unexpected token 'a string literal'");
// src/core/ngx_config.h:83:9
pub const NGX_INT64_LEN = @compileError("unable to translate C expr: unexpected token 'a string literal'");
// src/core/ngx_config.h:84:9
pub const NGX_INT_T_LEN = NGX_INT64_LEN;
pub const NGX_MAX_INT_T_VALUE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 9223372036854775807, .decimal);
pub const NGX_ALIGNMENT = @import("std").zig.c_translation.sizeof(c_ulong);
pub inline fn ngx_align(d: anytype, a: anytype) @TypeOf((d + (a - @as(c_int, 1))) & ~(a - @as(c_int, 1))) {
    _ = &d;
    _ = &a;
    return (d + (a - @as(c_int, 1))) & ~(a - @as(c_int, 1));
}
pub inline fn ngx_align_ptr(p: anytype, a: anytype) [*c]u_char {
    _ = &p;
    _ = &a;
    return @import("std").zig.c_translation.cast([*c]u_char, (@import("std").zig.c_translation.cast(usize, p) + (@import("std").zig.c_translation.cast(usize, a) - @as(c_int, 1))) & ~(@import("std").zig.c_translation.cast(usize, a) - @as(c_int, 1)));
}
pub const ngx_abort = abort;
pub const NGX_INVALID_ARRAY_INDEX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
pub const ngx_inline = @compileError("unable to translate C expr: unexpected token 'inline'");
// src/core/ngx_config.h:114:9
pub const NGX_MAXHOSTNAMELEN = @as(c_int, 256);
pub const NGX_MAX_UINT32_VALUE = @import("std").zig.c_translation.cast(u32, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffffffff, .hex));
pub const NGX_MAX_INT32_VALUE = @import("std").zig.c_translation.cast(u32, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7fffffff, .hex));
pub const NGX_COMPAT_BEGIN = @compileError("unable to translate C expr: unexpected token ''");
// src/core/ngx_config.h:139:9
pub const NGX_COMPAT_END = "";
pub const _NGX_CORE_H_INCLUDED_ = "";
pub const NGX_OK = @as(c_int, 0);
pub const NGX_ERROR = -@as(c_int, 1);
pub const NGX_AGAIN = -@as(c_int, 2);
pub const NGX_BUSY = -@as(c_int, 3);
pub const NGX_DONE = -@as(c_int, 4);
pub const NGX_DECLINED = -@as(c_int, 5);
pub const NGX_ABORT = -@as(c_int, 6);
pub const _NGX_ERRNO_H_INCLUDED_ = "";
pub const NGX_EPERM = EPERM;
pub const NGX_ENOENT = ENOENT;
pub const NGX_ENOPATH = ENOENT;
pub const NGX_ESRCH = ESRCH;
pub const NGX_EINTR = EINTR;
pub const NGX_ECHILD = ECHILD;
pub const NGX_ENOMEM = ENOMEM;
pub const NGX_EACCES = EACCES;
pub const NGX_EBUSY = EBUSY;
pub const NGX_EEXIST = EEXIST;
pub const NGX_EEXIST_FILE = EEXIST;
pub const NGX_EXDEV = EXDEV;
pub const NGX_ENOTDIR = ENOTDIR;
pub const NGX_EISDIR = EISDIR;
pub const NGX_EINVAL = EINVAL;
pub const NGX_ENFILE = ENFILE;
pub const NGX_EMFILE = EMFILE;
pub const NGX_ENOSPC = ENOSPC;
pub const NGX_EPIPE = EPIPE;
pub const NGX_EINPROGRESS = EINPROGRESS;
pub const NGX_ENOPROTOOPT = ENOPROTOOPT;
pub const NGX_EOPNOTSUPP = EOPNOTSUPP;
pub const NGX_EADDRINUSE = EADDRINUSE;
pub const NGX_ECONNABORTED = ECONNABORTED;
pub const NGX_ECONNRESET = ECONNRESET;
pub const NGX_ENOTCONN = ENOTCONN;
pub const NGX_ETIMEDOUT = ETIMEDOUT;
pub const NGX_ECONNREFUSED = ECONNREFUSED;
pub const NGX_ENAMETOOLONG = ENAMETOOLONG;
pub const NGX_ENETDOWN = ENETDOWN;
pub const NGX_ENETUNREACH = ENETUNREACH;
pub const NGX_EHOSTDOWN = EHOSTDOWN;
pub const NGX_EHOSTUNREACH = EHOSTUNREACH;
pub const NGX_ENOSYS = ENOSYS;
pub const NGX_ECANCELED = ECANCELED;
pub const NGX_EILSEQ = EILSEQ;
pub const NGX_ENOMOREFILES = @as(c_int, 0);
pub const NGX_ELOOP = ELOOP;
pub const NGX_EBADF = EBADF;
pub const NGX_EMSGSIZE = EMSGSIZE;
pub const NGX_EMLINK = EMLINK;
pub const NGX_EAGAIN = EAGAIN;
pub const ngx_errno = errno;
pub const ngx_socket_errno = errno;
pub const ngx_set_errno = @compileError("unable to translate C expr: unexpected token '='");
// src/os/unix/ngx_errno.h:72:9
pub const ngx_set_socket_errno = @compileError("unable to translate C expr: unexpected token '='");
// src/os/unix/ngx_errno.h:73:9
pub const _NGX_ATOMIC_H_INCLUDED_ = "";
pub const NGX_HAVE_ATOMIC_OPS = @as(c_int, 1);
pub const NGX_ATOMIC_T_LEN = @compileError("unable to translate C expr: unexpected token 'a string literal'");
// src/os/unix/ngx_atomic.h:51:9
pub const ngx_atomic_cmp_set = @compileError("unable to translate macro: undefined identifier `__sync_bool_compare_and_swap`");
// src/os/unix/ngx_atomic.h:59:9
pub const ngx_atomic_fetch_add = @compileError("unable to translate macro: undefined identifier `__sync_fetch_and_add`");
// src/os/unix/ngx_atomic.h:62:9
pub const ngx_memory_barrier = @compileError("unable to translate macro: undefined identifier `__sync_synchronize`");
// src/os/unix/ngx_atomic.h:65:9
pub const ngx_cpu_pause = @compileError("unable to translate C expr: unexpected token '__asm__'");
// src/os/unix/ngx_atomic.h:68:9
pub inline fn ngx_trylock(lock: anytype) @TypeOf((lock.* == @as(c_int, 0)) and (ngx_atomic_cmp_set(lock, @as(c_int, 0), @as(c_int, 1)) != 0)) {
    _ = &lock;
    return (lock.* == @as(c_int, 0)) and (ngx_atomic_cmp_set(lock, @as(c_int, 0), @as(c_int, 1)) != 0);
}
pub const ngx_unlock = @compileError("unable to translate C expr: unexpected token '='");
// src/os/unix/ngx_atomic.h:310:9
pub const _NGX_THREAD_H_INCLUDED_ = "";
pub const ngx_log_tid = @as(c_int, 0);
pub const NGX_TID_T_FMT = "%d";
pub const _NGX_RBTREE_H_INCLUDED_ = "";
pub const ngx_rbtree_init = @compileError("unable to translate C expr: unexpected token ';'");
// src/core/ngx_rbtree.h:44:9
pub const ngx_rbtree_data = @compileError("unable to translate C expr: unexpected token ')'");
// src/core/ngx_rbtree.h:50:9
pub const ngx_rbt_red = @compileError("unable to translate C expr: expected ')' instead got '='");
// src/core/ngx_rbtree.h:64:9
pub const ngx_rbt_black = @compileError("unable to translate C expr: expected ')' instead got '='");
// src/core/ngx_rbtree.h:65:9
pub inline fn ngx_rbt_is_red(node: anytype) @TypeOf(node.*.color) {
    _ = &node;
    return node.*.color;
}
pub inline fn ngx_rbt_is_black(node: anytype) @TypeOf(!(ngx_rbt_is_red(node) != 0)) {
    _ = &node;
    return !(ngx_rbt_is_red(node) != 0);
}
pub const ngx_rbt_copy_color = @compileError("unable to translate C expr: expected ')' instead got '='");
// src/core/ngx_rbtree.h:68:9
pub inline fn ngx_rbtree_sentinel_init(node: anytype) @TypeOf(ngx_rbt_black(node)) {
    _ = &node;
    return ngx_rbt_black(node);
}
pub const _NGX_TIME_H_INCLUDED_ = "";
pub const ngx_tm_sec = @compileError("unable to translate macro: undefined identifier `tm_sec`");
// src/os/unix/ngx_time.h:21:9
pub const ngx_tm_min = @compileError("unable to translate macro: undefined identifier `tm_min`");
// src/os/unix/ngx_time.h:22:9
pub const ngx_tm_hour = @compileError("unable to translate macro: undefined identifier `tm_hour`");
// src/os/unix/ngx_time.h:23:9
pub const ngx_tm_mday = @compileError("unable to translate macro: undefined identifier `tm_mday`");
// src/os/unix/ngx_time.h:24:9
pub const ngx_tm_mon = @compileError("unable to translate macro: undefined identifier `tm_mon`");
// src/os/unix/ngx_time.h:25:9
pub const ngx_tm_year = @compileError("unable to translate macro: undefined identifier `tm_year`");
// src/os/unix/ngx_time.h:26:9
pub const ngx_tm_wday = @compileError("unable to translate macro: undefined identifier `tm_wday`");
// src/os/unix/ngx_time.h:27:9
pub const ngx_tm_isdst = @compileError("unable to translate macro: undefined identifier `tm_isdst`");
// src/os/unix/ngx_time.h:28:9
pub const ngx_tm_sec_t = c_int;
pub const ngx_tm_min_t = c_int;
pub const ngx_tm_hour_t = c_int;
pub const ngx_tm_mday_t = c_int;
pub const ngx_tm_mon_t = c_int;
pub const ngx_tm_year_t = c_int;
pub const ngx_tm_wday_t = c_int;
pub const ngx_tm_gmtoff = @compileError("unable to translate macro: undefined identifier `tm_gmtoff`");
// src/os/unix/ngx_time.h:40:9
pub const ngx_tm_zone = @compileError("unable to translate macro: undefined identifier `tm_zone`");
// src/os/unix/ngx_time.h:41:9
pub inline fn ngx_timezone(isdst: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(-(if (isdst) timezone + @as(c_int, 3600) else timezone), @as(c_int, 60))) {
    _ = &isdst;
    return @import("std").zig.c_translation.MacroArithmetic.div(-(if (isdst) timezone + @as(c_int, 3600) else timezone), @as(c_int, 60));
}
pub const ngx_gettimeofday = @compileError("unable to translate C expr: unexpected token ';'");
// src/os/unix/ngx_time.h:61:9
pub inline fn ngx_msleep(ms: anytype) anyopaque {
    _ = &ms;
    return @import("std").zig.c_translation.cast(anyopaque, usleep(ms * @as(c_int, 1000)));
}
pub inline fn ngx_sleep(s: anytype) anyopaque {
    _ = &s;
    return @import("std").zig.c_translation.cast(anyopaque, sleep(s));
}
pub const _NGX_SOCKET_H_INCLUDED_ = "";
pub const NGX_WRITE_SHUTDOWN = SHUT_WR;
pub const NGX_READ_SHUTDOWN = SHUT_RD;
pub const NGX_RDWR_SHUTDOWN = SHUT_RDWR;
pub const ngx_socket = socket;
pub const ngx_socket_n = "socket()";
pub const ngx_nonblocking_n = "ioctl(FIONBIO)";
pub const ngx_blocking_n = "ioctl(!FIONBIO)";
pub inline fn ngx_socket_nread(s: anytype, n: anytype) @TypeOf(ioctl(s, FIONREAD, n)) {
    _ = &s;
    _ = &n;
    return ioctl(s, FIONREAD, n);
}
pub const ngx_socket_nread_n = "ioctl(FIONREAD)";
pub const ngx_tcp_nopush_n = "setsockopt(TCP_CORK)";
pub const ngx_tcp_push_n = "setsockopt(!TCP_CORK)";
pub const ngx_shutdown_socket = shutdown;
pub const ngx_shutdown_socket_n = "shutdown()";
pub const ngx_close_socket = close;
pub const ngx_close_socket_n = "close() socket";
pub const _NGX_STRING_H_INCLUDED_ = "";
pub const ngx_string = @compileError("unable to translate C expr: unexpected token '{'");
// src/core/ngx_string.h:40:9
pub const ngx_null_string = @compileError("unable to translate C expr: unexpected token '{'");
// src/core/ngx_string.h:41:9
pub const ngx_str_set = @compileError("unable to translate C expr: unexpected token '='");
// src/core/ngx_string.h:42:9
pub const ngx_str_null = @compileError("unable to translate C expr: unexpected token '='");
// src/core/ngx_string.h:44:9
pub inline fn ngx_tolower(c: anytype) u_char {
    _ = &c;
    return @import("std").zig.c_translation.cast(u_char, if ((c >= 'A') and (c <= 'Z')) c | @as(c_int, 0x20) else c);
}
pub inline fn ngx_toupper(c: anytype) u_char {
    _ = &c;
    return @import("std").zig.c_translation.cast(u_char, if ((c >= 'a') and (c <= 'z')) c & ~@as(c_int, 0x20) else c);
}
pub const ngx_strncmp = @compileError("unable to translate C expr: unexpected token 'const'");
// src/core/ngx_string.h:53:9
pub const ngx_strcmp = @compileError("unable to translate C expr: unexpected token 'const'");
// src/core/ngx_string.h:57:9
pub const ngx_strstr = @compileError("unable to translate C expr: unexpected token 'const'");
// src/core/ngx_string.h:60:9
pub const ngx_strlen = @compileError("unable to translate C expr: unexpected token 'const'");
// src/core/ngx_string.h:61:9
pub const ngx_strchr = @compileError("unable to translate C expr: unexpected token 'const'");
// src/core/ngx_string.h:65:9
pub inline fn ngx_memzero(buf: anytype, n: anytype) anyopaque {
    _ = &buf;
    _ = &n;
    return @import("std").zig.c_translation.cast(anyopaque, memset(buf, @as(c_int, 0), n));
}
pub inline fn ngx_memset(buf: anytype, c: anytype, n: anytype) anyopaque {
    _ = &buf;
    _ = &c;
    _ = &n;
    return @import("std").zig.c_translation.cast(anyopaque, memset(buf, c, n));
}
pub inline fn ngx_memcpy(dst: anytype, src: anytype, n: anytype) anyopaque {
    _ = &dst;
    _ = &src;
    _ = &n;
    return @import("std").zig.c_translation.cast(anyopaque, memcpy(dst, src, n));
}
pub inline fn ngx_cpymem(dst: anytype, src: anytype, n: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]u_char, memcpy(dst, src, n)) + n) {
    _ = &dst;
    _ = &src;
    _ = &n;
    return @import("std").zig.c_translation.cast([*c]u_char, memcpy(dst, src, n)) + n;
}
pub const ngx_copy = ngx_cpymem;
pub inline fn ngx_memmove(dst: anytype, src: anytype, n: anytype) anyopaque {
    _ = &dst;
    _ = &src;
    _ = &n;
    return @import("std").zig.c_translation.cast(anyopaque, memmove(dst, src, n));
}
pub inline fn ngx_movemem(dst: anytype, src: anytype, n: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]u_char, memmove(dst, src, n)) + n) {
    _ = &dst;
    _ = &src;
    _ = &n;
    return @import("std").zig.c_translation.cast([*c]u_char, memmove(dst, src, n)) + n;
}
pub inline fn ngx_memcmp(s1: anytype, s2: anytype, n: anytype) @TypeOf(memcmp(s1, s2, n)) {
    _ = &s1;
    _ = &s2;
    _ = &n;
    return memcmp(s1, s2, n);
}
pub inline fn ngx_vsnprintf(buf: anytype, max: anytype, fmt: anytype, args: anytype) @TypeOf(ngx_vslprintf(buf, buf + max, fmt, args)) {
    _ = &buf;
    _ = &max;
    _ = &fmt;
    _ = &args;
    return ngx_vslprintf(buf, buf + max, fmt, args);
}
pub inline fn ngx_base64_encoded_length(len: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(len + @as(c_int, 2), @as(c_int, 3)) * @as(c_int, 4)) {
    _ = &len;
    return @import("std").zig.c_translation.MacroArithmetic.div(len + @as(c_int, 2), @as(c_int, 3)) * @as(c_int, 4);
}
pub inline fn ngx_base64_decoded_length(len: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(len + @as(c_int, 3), @as(c_int, 4)) * @as(c_int, 3)) {
    _ = &len;
    return @import("std").zig.c_translation.MacroArithmetic.div(len + @as(c_int, 3), @as(c_int, 4)) * @as(c_int, 3);
}
pub const NGX_ESCAPE_URI = @as(c_int, 0);
pub const NGX_ESCAPE_ARGS = @as(c_int, 1);
pub const NGX_ESCAPE_URI_COMPONENT = @as(c_int, 2);
pub const NGX_ESCAPE_HTML = @as(c_int, 3);
pub const NGX_ESCAPE_REFRESH = @as(c_int, 4);
pub const NGX_ESCAPE_MEMCACHED = @as(c_int, 5);
pub const NGX_ESCAPE_MAIL_AUTH = @as(c_int, 6);
pub const NGX_UNESCAPE_URI = @as(c_int, 1);
pub const NGX_UNESCAPE_REDIRECT = @as(c_int, 2);
pub const ngx_qsort = qsort;
pub const ngx_value_helper = @compileError("unable to translate C expr: unexpected token '#'");
// src/core/ngx_string.h:234:9
pub inline fn ngx_value(n: anytype) @TypeOf(ngx_value_helper(n)) {
    _ = &n;
    return ngx_value_helper(n);
}
pub const _NGX_FILES_H_INCLUDED_ = "";
pub const NGX_INVALID_FILE = -@as(c_int, 1);
pub const NGX_FILE_ERROR = -@as(c_int, 1);
pub const ngx_open_file = @compileError("unable to translate C expr: unexpected token 'const'");
// src/os/unix/ngx_files.h:65:9
pub const ngx_open_file_n = "open()";
pub const NGX_FILE_RDONLY = O_RDONLY;
pub const NGX_FILE_WRONLY = O_WRONLY;
pub const NGX_FILE_RDWR = O_RDWR;
pub const NGX_FILE_CREATE_OR_OPEN = O_CREAT;
pub const NGX_FILE_OPEN = @as(c_int, 0);
pub const NGX_FILE_TRUNCATE = O_CREAT | O_TRUNC;
pub const NGX_FILE_APPEND = O_WRONLY | O_APPEND;
pub const NGX_FILE_NONBLOCK = O_NONBLOCK;
pub const NGX_FILE_NOFOLLOW = O_NOFOLLOW;
pub const NGX_FILE_DIRECTORY = O_DIRECTORY;
pub const NGX_FILE_SEARCH = (O_PATH | O_RDONLY) | NGX_FILE_DIRECTORY;
pub const NGX_FILE_DEFAULT_ACCESS = @as(c_int, 0o644);
pub const NGX_FILE_OWNER_ACCESS = @as(c_int, 0o600);
pub const ngx_close_file = close;
pub const ngx_close_file_n = "close()";
pub const ngx_delete_file = @compileError("unable to translate C expr: unexpected token 'const'");
// src/os/unix/ngx_files.h:113:9
pub const ngx_delete_file_n = "unlink()";
pub const ngx_open_tempfile_n = "open()";
pub const ngx_read_file_n = "pread()";
pub const ngx_read_fd = read;
pub const ngx_read_fd_n = "read()";
pub const ngx_write_fd_n = "write()";
pub const ngx_write_console = ngx_write_fd;
pub const ngx_linefeed = @compileError("TODO postfix inc/dec expr");
// src/os/unix/ngx_files.h:156:9
pub const NGX_LINEFEED_SIZE = @as(c_int, 1);
pub const NGX_LINEFEED = "\x0a";
pub const ngx_rename_file = @compileError("unable to translate C expr: unexpected token 'const'");
// src/os/unix/ngx_files.h:161:9
pub const ngx_rename_file_n = "rename()";
pub const ngx_change_file_access = @compileError("unable to translate C expr: unexpected token 'const'");
// src/os/unix/ngx_files.h:165:9
pub const ngx_change_file_access_n = "chmod()";
pub const ngx_set_file_time_n = "utimes()";
pub const ngx_file_info = @compileError("unable to translate C expr: unexpected token 'const'");
// src/os/unix/ngx_files.h:173:9
pub const ngx_file_info_n = "stat()";
pub inline fn ngx_fd_info(fd: anytype, sb: anytype) @TypeOf(fstat(fd, sb)) {
    _ = &fd;
    _ = &sb;
    return fstat(fd, sb);
}
pub const ngx_fd_info_n = "fstat()";
pub const ngx_link_info = @compileError("unable to translate C expr: unexpected token 'const'");
// src/os/unix/ngx_files.h:179:9
pub const ngx_link_info_n = "lstat()";
pub inline fn ngx_is_dir(sb: anytype) @TypeOf(S_ISDIR(sb.*.st_mode)) {
    _ = &sb;
    return S_ISDIR(sb.*.st_mode);
}
pub inline fn ngx_is_file(sb: anytype) @TypeOf(S_ISREG(sb.*.st_mode)) {
    _ = &sb;
    return S_ISREG(sb.*.st_mode);
}
pub inline fn ngx_is_link(sb: anytype) @TypeOf(S_ISLNK(sb.*.st_mode)) {
    _ = &sb;
    return S_ISLNK(sb.*.st_mode);
}
pub inline fn ngx_is_exec(sb: anytype) @TypeOf((sb.*.st_mode & S_IXUSR) == S_IXUSR) {
    _ = &sb;
    return (sb.*.st_mode & S_IXUSR) == S_IXUSR;
}
pub inline fn ngx_file_access(sb: anytype) @TypeOf(sb.*.st_mode & @as(c_int, 0o777)) {
    _ = &sb;
    return sb.*.st_mode & @as(c_int, 0o777);
}
pub inline fn ngx_file_size(sb: anytype) @TypeOf(sb.*.st_size) {
    _ = &sb;
    return sb.*.st_size;
}
pub inline fn ngx_file_fs_size(sb: anytype) @TypeOf(if (((sb.*.st_blocks * @as(c_int, 512)) > sb.*.st_size) and ((sb.*.st_blocks * @as(c_int, 512)) < (sb.*.st_size + (@as(c_int, 8) * sb.*.st_blksize)))) sb.*.st_blocks * @as(c_int, 512) else sb.*.st_size) {
    _ = &sb;
    return if (((sb.*.st_blocks * @as(c_int, 512)) > sb.*.st_size) and ((sb.*.st_blocks * @as(c_int, 512)) < (sb.*.st_size + (@as(c_int, 8) * sb.*.st_blksize)))) sb.*.st_blocks * @as(c_int, 512) else sb.*.st_size;
}
pub inline fn ngx_file_mtime(sb: anytype) @TypeOf(sb.*.st_mtime) {
    _ = &sb;
    return sb.*.st_mtime;
}
pub inline fn ngx_file_uniq(sb: anytype) @TypeOf(sb.*.st_ino) {
    _ = &sb;
    return sb.*.st_ino;
}
pub inline fn ngx_realpath(p: anytype, r: anytype) [*c]u_char {
    _ = &p;
    _ = &r;
    return @import("std").zig.c_translation.cast([*c]u_char, realpath(@import("std").zig.c_translation.cast([*c]u8, p), @import("std").zig.c_translation.cast([*c]u8, r)));
}
pub const ngx_realpath_n = "realpath()";
pub inline fn ngx_getcwd(buf: anytype, size: anytype) @TypeOf(getcwd(@import("std").zig.c_translation.cast([*c]u8, buf), size) != NULL) {
    _ = &buf;
    _ = &size;
    return getcwd(@import("std").zig.c_translation.cast([*c]u8, buf), size) != NULL;
}
pub const ngx_getcwd_n = "getcwd()";
pub inline fn ngx_path_separator(c: anytype) @TypeOf(c == '/') {
    _ = &c;
    return c == '/';
}
pub const NGX_HAVE_MAX_PATH = @as(c_int, 1);
pub const NGX_MAX_PATH = PATH_MAX;
pub const ngx_open_dir_n = "opendir()";
pub inline fn ngx_close_dir(d: anytype) @TypeOf(closedir(d.*.dir)) {
    _ = &d;
    return closedir(d.*.dir);
}
pub const ngx_close_dir_n = "closedir()";
pub const ngx_read_dir_n = "readdir()";
pub const ngx_create_dir = @compileError("unable to translate C expr: unexpected token 'const'");
// src/os/unix/ngx_files.h:231:9
pub const ngx_create_dir_n = "mkdir()";
pub const ngx_delete_dir = @compileError("unable to translate C expr: unexpected token 'const'");
// src/os/unix/ngx_files.h:235:9
pub const ngx_delete_dir_n = "rmdir()";
pub inline fn ngx_dir_access(a: anytype) @TypeOf(a | ((a & @as(c_int, 0o444)) >> @as(c_int, 2))) {
    _ = &a;
    return a | ((a & @as(c_int, 0o444)) >> @as(c_int, 2));
}
pub inline fn ngx_de_name(dir: anytype) [*c]u_char {
    _ = &dir;
    return @import("std").zig.c_translation.cast([*c]u_char, dir.*.de.*.d_name);
}
pub inline fn ngx_de_namelen(dir: anytype) @TypeOf(ngx_strlen(dir.*.de.*.d_name)) {
    _ = &dir;
    return ngx_strlen(dir.*.de.*.d_name);
}
pub const ngx_de_info_n = "stat()";
pub const ngx_de_link_info = @compileError("unable to translate C expr: unexpected token 'const'");
// src/os/unix/ngx_files.h:257:9
pub const ngx_de_link_info_n = "lstat()";
pub inline fn ngx_de_is_dir(dir: anytype) @TypeOf(if (dir.*.type) dir.*.type == DT_DIR else S_ISDIR(dir.*.info.st_mode)) {
    _ = &dir;
    return if (dir.*.type) dir.*.type == DT_DIR else S_ISDIR(dir.*.info.st_mode);
}
pub inline fn ngx_de_is_file(dir: anytype) @TypeOf(if (dir.*.type) dir.*.type == DT_REG else S_ISREG(dir.*.info.st_mode)) {
    _ = &dir;
    return if (dir.*.type) dir.*.type == DT_REG else S_ISREG(dir.*.info.st_mode);
}
pub inline fn ngx_de_is_link(dir: anytype) @TypeOf(if (dir.*.type) dir.*.type == DT_LNK else S_ISLNK(dir.*.info.st_mode)) {
    _ = &dir;
    return if (dir.*.type) dir.*.type == DT_LNK else S_ISLNK(dir.*.info.st_mode);
}
pub inline fn ngx_de_access(dir: anytype) @TypeOf(dir.*.info.st_mode & @as(c_int, 0o777)) {
    _ = &dir;
    return dir.*.info.st_mode & @as(c_int, 0o777);
}
pub inline fn ngx_de_size(dir: anytype) @TypeOf(dir.*.info.st_size) {
    _ = &dir;
    return dir.*.info.st_size;
}
pub inline fn ngx_de_fs_size(dir: anytype) @TypeOf(ngx_max(dir.*.info.st_size, dir.*.info.st_blocks * @as(c_int, 512))) {
    _ = &dir;
    return ngx_max(dir.*.info.st_size, dir.*.info.st_blocks * @as(c_int, 512));
}
pub inline fn ngx_de_mtime(dir: anytype) @TypeOf(dir.*.info.st_mtime) {
    _ = &dir;
    return dir.*.info.st_mtime;
}
pub const ngx_open_glob_n = "glob()";
pub const ngx_trylock_fd_n = "fcntl(F_SETLK, F_WRLCK)";
pub const ngx_lock_fd_n = "fcntl(F_SETLKW, F_WRLCK)";
pub const ngx_unlock_fd_n = "fcntl(F_SETLK, F_UNLCK)";
pub const NGX_HAVE_READ_AHEAD = @as(c_int, 1);
pub const ngx_read_ahead_n = "posix_fadvise(POSIX_FADV_SEQUENTIAL)";
pub const ngx_directio_on_n = "fcntl(O_DIRECT)";
pub const ngx_directio_off_n = "fcntl(!O_DIRECT)";
pub const ngx_openat_file = @compileError("unable to translate C expr: unexpected token 'const'");
// src/os/unix/ngx_files.h:357:9
pub const ngx_openat_file_n = "openat()";
pub const ngx_file_at_info = @compileError("unable to translate C expr: unexpected token 'const'");
// src/os/unix/ngx_files.h:362:9
pub const ngx_file_at_info_n = "fstatat()";
pub const NGX_AT_FDCWD = @import("std").zig.c_translation.cast(ngx_fd_t, AT_FDCWD);
pub const ngx_stdout = STDOUT_FILENO;
pub const ngx_stderr = STDERR_FILENO;
pub inline fn ngx_set_stderr(fd: anytype) @TypeOf(dup2(fd, STDERR_FILENO)) {
    _ = &fd;
    return dup2(fd, STDERR_FILENO);
}
pub const ngx_set_stderr_n = "dup2(STDERR_FILENO)";
pub const _NGX_SHMEM_H_INCLUDED_ = "";
pub const _NGX_PROCESS_H_INCLUDED_ = "";
pub const _NGX_SETAFFINITY_H_INCLUDED_ = "";
pub const NGX_HAVE_CPU_AFFINITY = @as(c_int, 1);
pub const _NGX_SETPROCTITLE_H_INCLUDED_ = "";
pub const NGX_SETPROCTITLE_USES_ENV = @as(c_int, 1);
pub const NGX_SETPROCTITLE_PAD = '\x00';
pub const NGX_INVALID_PID = -@as(c_int, 1);
pub const NGX_MAX_PROCESSES = @as(c_int, 1024);
pub const NGX_PROCESS_NORESPAWN = -@as(c_int, 1);
pub const NGX_PROCESS_JUST_SPAWN = -@as(c_int, 2);
pub const NGX_PROCESS_RESPAWN = -@as(c_int, 3);
pub const NGX_PROCESS_JUST_RESPAWN = -@as(c_int, 4);
pub const NGX_PROCESS_DETACHED = -@as(c_int, 5);
pub const ngx_getpid = getpid;
pub const ngx_getppid = getppid;
// src/os/unix/ngx_process.h:60:9: warning: macro 'ngx_log_pid' contains a runtime value, translated to function
pub inline fn ngx_log_pid() @TypeOf(ngx_pid) {
    return ngx_pid;
}
pub inline fn ngx_sched_yield() @TypeOf(sched_yield()) {
    return sched_yield();
}
pub const _NGX_USER_H_INCLUDED_ = "";
pub const _NGX_DLOPEN_H_INCLUDED_ = "";
pub inline fn ngx_dlopen(path: anytype) @TypeOf(dlopen(@import("std").zig.c_translation.cast([*c]u8, path), RTLD_NOW | RTLD_GLOBAL)) {
    _ = &path;
    return dlopen(@import("std").zig.c_translation.cast([*c]u8, path), RTLD_NOW | RTLD_GLOBAL);
}
pub const ngx_dlopen_n = "dlopen()";
pub inline fn ngx_dlsym(handle: anytype, symbol: anytype) @TypeOf(dlsym(handle, symbol)) {
    _ = &handle;
    _ = &symbol;
    return dlsym(handle, symbol);
}
pub const ngx_dlsym_n = "dlsym()";
pub inline fn ngx_dlclose(handle: anytype) @TypeOf(dlclose(handle)) {
    _ = &handle;
    return dlclose(handle);
}
pub const ngx_dlclose_n = "dlclose()";
pub const _NGX_PARSE_H_INCLUDED_ = "";
pub const _NGX_PARSE_TIME_H_INCLUDED_ = "";
pub inline fn ngx_http_parse_time(value: anytype, len: anytype) @TypeOf(ngx_parse_http_time(value, len)) {
    _ = &value;
    _ = &len;
    return ngx_parse_http_time(value, len);
}
pub const _NGX_LOG_H_INCLUDED_ = "";
pub const NGX_LOG_STDERR = @as(c_int, 0);
pub const NGX_LOG_EMERG = @as(c_int, 1);
pub const NGX_LOG_ALERT = @as(c_int, 2);
pub const NGX_LOG_CRIT = @as(c_int, 3);
pub const NGX_LOG_ERR = @as(c_int, 4);
pub const NGX_LOG_WARN = @as(c_int, 5);
pub const NGX_LOG_NOTICE = @as(c_int, 6);
pub const NGX_LOG_INFO = @as(c_int, 7);
pub const NGX_LOG_DEBUG = @as(c_int, 8);
pub const NGX_LOG_DEBUG_CORE = @as(c_int, 0x010);
pub const NGX_LOG_DEBUG_ALLOC = @as(c_int, 0x020);
pub const NGX_LOG_DEBUG_MUTEX = @as(c_int, 0x040);
pub const NGX_LOG_DEBUG_EVENT = @as(c_int, 0x080);
pub const NGX_LOG_DEBUG_HTTP = @as(c_int, 0x100);
pub const NGX_LOG_DEBUG_MAIL = @as(c_int, 0x200);
pub const NGX_LOG_DEBUG_STREAM = @as(c_int, 0x400);
pub const NGX_LOG_DEBUG_FIRST = NGX_LOG_DEBUG_CORE;
pub const NGX_LOG_DEBUG_LAST = NGX_LOG_DEBUG_STREAM;
pub const NGX_LOG_DEBUG_CONNECTION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
pub const NGX_LOG_DEBUG_ALL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7ffffff0, .hex);
pub const NGX_MAX_ERROR_STR = @as(c_int, 2048);
pub const NGX_HAVE_VARIADIC_MACROS = @as(c_int, 1);
pub const ngx_log_error = @compileError("unable to translate C expr: expected ')' instead got '...'");
// src/core/ngx_log.h:85:9
pub const ngx_log_debug = @compileError("unable to translate C expr: expected ')' instead got '...'");
// src/core/ngx_log.h:91:9
pub const ngx_log_debug0 = @compileError("unable to translate C expr: unexpected token ''");
// src/core/ngx_log.h:215:9
pub const ngx_log_debug1 = @compileError("unable to translate C expr: unexpected token ''");
// src/core/ngx_log.h:216:9
pub const ngx_log_debug2 = @compileError("unable to translate C expr: unexpected token ''");
// src/core/ngx_log.h:217:9
pub const ngx_log_debug3 = @compileError("unable to translate C expr: unexpected token ''");
// src/core/ngx_log.h:218:9
pub const ngx_log_debug4 = @compileError("unable to translate C expr: unexpected token ''");
// src/core/ngx_log.h:219:9
pub const ngx_log_debug5 = @compileError("unable to translate C expr: unexpected token ''");
// src/core/ngx_log.h:220:9
pub const ngx_log_debug6 = @compileError("unable to translate C expr: unexpected token ''");
// src/core/ngx_log.h:221:9
pub const ngx_log_debug7 = @compileError("unable to translate C expr: unexpected token ''");
// src/core/ngx_log.h:222:9
pub const ngx_log_debug8 = @compileError("unable to translate C expr: unexpected token ''");
// src/core/ngx_log.h:224:9
pub const _NGX_ALLOC_H_INCLUDED_ = "";
pub const ngx_free = free;
pub const _NGX_PALLOC_H_INCLUDED_ = "";
// src/core/ngx_palloc.h:20:9: warning: macro 'NGX_MAX_ALLOC_FROM_POOL' contains a runtime value, translated to function
pub inline fn NGX_MAX_ALLOC_FROM_POOL() @TypeOf(ngx_pagesize - @as(c_int, 1)) {
    return ngx_pagesize - @as(c_int, 1);
}
pub const NGX_DEFAULT_POOL_SIZE = @as(c_int, 16) * @as(c_int, 1024);
pub const NGX_POOL_ALIGNMENT = @as(c_int, 16);
pub const NGX_MIN_POOL_SIZE = ngx_align(@import("std").zig.c_translation.sizeof(ngx_pool_t) + (@as(c_int, 2) * @import("std").zig.c_translation.sizeof(ngx_pool_large_t)), NGX_POOL_ALIGNMENT);
pub const _NGX_BUF_H_INCLUDED_ = "";
pub const NGX_CHAIN_ERROR = @import("std").zig.c_translation.cast([*c]ngx_chain_t, NGX_ERROR);
pub inline fn ngx_buf_in_memory(b: anytype) @TypeOf(((b.*.temporary != 0) or (b.*.memory != 0)) or (b.*.mmap != 0)) {
    _ = &b;
    return ((b.*.temporary != 0) or (b.*.memory != 0)) or (b.*.mmap != 0);
}
pub inline fn ngx_buf_in_memory_only(b: anytype) @TypeOf((ngx_buf_in_memory(b) != 0) and !(b.*.in_file != 0)) {
    _ = &b;
    return (ngx_buf_in_memory(b) != 0) and !(b.*.in_file != 0);
}
pub inline fn ngx_buf_special(b: anytype) @TypeOf(((((b.*.flush != 0) or (b.*.last_buf != 0)) or (b.*.sync != 0)) and !(ngx_buf_in_memory(b) != 0)) and !(b.*.in_file != 0)) {
    _ = &b;
    return ((((b.*.flush != 0) or (b.*.last_buf != 0)) or (b.*.sync != 0)) and !(ngx_buf_in_memory(b) != 0)) and !(b.*.in_file != 0);
}
pub inline fn ngx_buf_sync_only(b: anytype) @TypeOf(((((b.*.sync != 0) and !(ngx_buf_in_memory(b) != 0)) and !(b.*.in_file != 0)) and !(b.*.flush != 0)) and !(b.*.last_buf != 0)) {
    _ = &b;
    return ((((b.*.sync != 0) and !(ngx_buf_in_memory(b) != 0)) and !(b.*.in_file != 0)) and !(b.*.flush != 0)) and !(b.*.last_buf != 0);
}
pub inline fn ngx_buf_size(b: anytype) @TypeOf(if (ngx_buf_in_memory(b)) @import("std").zig.c_translation.cast(off_t, b.*.last - b.*.pos) else b.*.file_last - b.*.file_pos) {
    _ = &b;
    return if (ngx_buf_in_memory(b)) @import("std").zig.c_translation.cast(off_t, b.*.last - b.*.pos) else b.*.file_last - b.*.file_pos;
}
pub inline fn ngx_alloc_buf(pool: anytype) @TypeOf(ngx_palloc(pool, @import("std").zig.c_translation.sizeof(ngx_buf_t))) {
    _ = &pool;
    return ngx_palloc(pool, @import("std").zig.c_translation.sizeof(ngx_buf_t));
}
pub inline fn ngx_calloc_buf(pool: anytype) @TypeOf(ngx_pcalloc(pool, @import("std").zig.c_translation.sizeof(ngx_buf_t))) {
    _ = &pool;
    return ngx_pcalloc(pool, @import("std").zig.c_translation.sizeof(ngx_buf_t));
}
pub const ngx_free_chain = @compileError("unable to translate C expr: unexpected token '='");
// src/core/ngx_buf.h:148:9
pub const _NGX_QUEUE_H_INCLUDED_ = "";
pub const ngx_queue_init = @compileError("unable to translate C expr: unexpected token '='");
// src/core/ngx_queue.h:24:9
pub inline fn ngx_queue_empty(h: anytype) @TypeOf(h == h.*.prev) {
    _ = &h;
    return h == h.*.prev;
}
pub const ngx_queue_insert_head = @compileError("unable to translate C expr: unexpected token '='");
// src/core/ngx_queue.h:33:9
pub const ngx_queue_insert_after = ngx_queue_insert_head;
pub const ngx_queue_insert_tail = @compileError("unable to translate C expr: unexpected token '='");
// src/core/ngx_queue.h:43:9
pub const ngx_queue_insert_before = ngx_queue_insert_tail;
pub inline fn ngx_queue_head(h: anytype) @TypeOf(h.*.next) {
    _ = &h;
    return h.*.next;
}
pub inline fn ngx_queue_last(h: anytype) @TypeOf(h.*.prev) {
    _ = &h;
    return h.*.prev;
}
pub inline fn ngx_queue_sentinel(h: anytype) @TypeOf(h) {
    _ = &h;
    return h;
}
pub inline fn ngx_queue_next(q: anytype) @TypeOf(q.*.next) {
    _ = &q;
    return q.*.next;
}
pub inline fn ngx_queue_prev(q: anytype) @TypeOf(q.*.prev) {
    _ = &q;
    return q.*.prev;
}
pub const ngx_queue_remove = @compileError("unable to translate C expr: unexpected token '='");
// src/core/ngx_queue.h:83:9
pub const ngx_queue_split = @compileError("unable to translate C expr: unexpected token '='");
// src/core/ngx_queue.h:90:9
pub const ngx_queue_add = @compileError("unable to translate C expr: unexpected token '='");
// src/core/ngx_queue.h:99:9
pub const ngx_queue_data = @compileError("unable to translate C expr: unexpected token ')'");
// src/core/ngx_queue.h:106:9
pub const _NGX_ARRAY_H_INCLUDED_ = "";
pub const _NGX_LIST_H_INCLUDED_ = "";
pub const _NGX_HASH_H_INCLUDED_ = "";
pub const NGX_HASH_SMALL = @as(c_int, 1);
pub const NGX_HASH_LARGE = @as(c_int, 2);
pub const NGX_HASH_LARGE_ASIZE = @as(c_int, 16384);
pub const NGX_HASH_LARGE_HSIZE = @as(c_int, 10007);
pub const NGX_HASH_WILDCARD_KEY = @as(c_int, 1);
pub const NGX_HASH_READONLY_KEY = @as(c_int, 2);
pub inline fn ngx_hash(key: anytype, c: anytype) @TypeOf((@import("std").zig.c_translation.cast(ngx_uint_t, key) * @as(c_int, 31)) + c) {
    _ = &key;
    _ = &c;
    return (@import("std").zig.c_translation.cast(ngx_uint_t, key) * @as(c_int, 31)) + c;
}
pub const _NGX_FILE_H_INCLUDED_ = "";
pub const NGX_MAX_PATH_LEVEL = @as(c_int, 3);
pub const _NGX_CRC_H_INCLUDED_ = "";
pub const _NGX_CRC32_H_INCLUDED_ = "";
pub const ngx_crc32_init = @compileError("unable to translate C expr: unexpected token '='");
// src/core/ngx_crc32.h:53:9
pub const ngx_crc32_final = @compileError("unable to translate C expr: unexpected token '^='");
// src/core/ngx_crc32.h:72:9
pub const _NGX_MURMURHASH_H_INCLUDED_ = "";
pub const _NGX_REGEX_H_INCLUDED_ = "";
pub const PCRE2_CODE_UNIT_WIDTH = @as(c_int, 8);
pub const PCRE2_H_IDEMPOTENT_GUARD = "";
pub const PCRE2_MAJOR = @as(c_int, 10);
pub const PCRE2_MINOR = @as(c_int, 44);
pub const PCRE2_PRERELEASE = "";
pub const PCRE2_DATE = (@as(c_int, 2024) - @as(c_int, 0o6)) - @as(c_int, 0o7);
pub const PCRE2_EXP_DECL = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/pcre2.h:66:13
pub const PCRE2_CALL_CONVENTION = "";
pub const _INTTYPES_H = @as(c_int, 1);
pub const ____gwchar_t_defined = @as(c_int, 1);
pub const __PRI64_PREFIX = "l";
pub const __PRIPTR_PREFIX = "l";
pub const PRId8 = "d";
pub const PRId16 = "d";
pub const PRId32 = "d";
pub const PRId64 = __PRI64_PREFIX ++ "d";
pub const PRIdLEAST8 = "d";
pub const PRIdLEAST16 = "d";
pub const PRIdLEAST32 = "d";
pub const PRIdLEAST64 = __PRI64_PREFIX ++ "d";
pub const PRIdFAST8 = "d";
pub const PRIdFAST16 = __PRIPTR_PREFIX ++ "d";
pub const PRIdFAST32 = __PRIPTR_PREFIX ++ "d";
pub const PRIdFAST64 = __PRI64_PREFIX ++ "d";
pub const PRIi8 = "i";
pub const PRIi16 = "i";
pub const PRIi32 = "i";
pub const PRIi64 = __PRI64_PREFIX ++ "i";
pub const PRIiLEAST8 = "i";
pub const PRIiLEAST16 = "i";
pub const PRIiLEAST32 = "i";
pub const PRIiLEAST64 = __PRI64_PREFIX ++ "i";
pub const PRIiFAST8 = "i";
pub const PRIiFAST16 = __PRIPTR_PREFIX ++ "i";
pub const PRIiFAST32 = __PRIPTR_PREFIX ++ "i";
pub const PRIiFAST64 = __PRI64_PREFIX ++ "i";
pub const PRIo8 = "o";
pub const PRIo16 = "o";
pub const PRIo32 = "o";
pub const PRIo64 = __PRI64_PREFIX ++ "o";
pub const PRIoLEAST8 = "o";
pub const PRIoLEAST16 = "o";
pub const PRIoLEAST32 = "o";
pub const PRIoLEAST64 = __PRI64_PREFIX ++ "o";
pub const PRIoFAST8 = "o";
pub const PRIoFAST16 = __PRIPTR_PREFIX ++ "o";
pub const PRIoFAST32 = __PRIPTR_PREFIX ++ "o";
pub const PRIoFAST64 = __PRI64_PREFIX ++ "o";
pub const PRIu8 = "u";
pub const PRIu16 = "u";
pub const PRIu32 = "u";
pub const PRIu64 = __PRI64_PREFIX ++ "u";
pub const PRIuLEAST8 = "u";
pub const PRIuLEAST16 = "u";
pub const PRIuLEAST32 = "u";
pub const PRIuLEAST64 = __PRI64_PREFIX ++ "u";
pub const PRIuFAST8 = "u";
pub const PRIuFAST16 = __PRIPTR_PREFIX ++ "u";
pub const PRIuFAST32 = __PRIPTR_PREFIX ++ "u";
pub const PRIuFAST64 = __PRI64_PREFIX ++ "u";
pub const PRIx8 = "x";
pub const PRIx16 = "x";
pub const PRIx32 = "x";
pub const PRIx64 = __PRI64_PREFIX ++ "x";
pub const PRIxLEAST8 = "x";
pub const PRIxLEAST16 = "x";
pub const PRIxLEAST32 = "x";
pub const PRIxLEAST64 = __PRI64_PREFIX ++ "x";
pub const PRIxFAST8 = "x";
pub const PRIxFAST16 = __PRIPTR_PREFIX ++ "x";
pub const PRIxFAST32 = __PRIPTR_PREFIX ++ "x";
pub const PRIxFAST64 = __PRI64_PREFIX ++ "x";
pub const PRIX8 = "X";
pub const PRIX16 = "X";
pub const PRIX32 = "X";
pub const PRIX64 = __PRI64_PREFIX ++ "X";
pub const PRIXLEAST8 = "X";
pub const PRIXLEAST16 = "X";
pub const PRIXLEAST32 = "X";
pub const PRIXLEAST64 = __PRI64_PREFIX ++ "X";
pub const PRIXFAST8 = "X";
pub const PRIXFAST16 = __PRIPTR_PREFIX ++ "X";
pub const PRIXFAST32 = __PRIPTR_PREFIX ++ "X";
pub const PRIXFAST64 = __PRI64_PREFIX ++ "X";
pub const PRIdMAX = __PRI64_PREFIX ++ "d";
pub const PRIiMAX = __PRI64_PREFIX ++ "i";
pub const PRIoMAX = __PRI64_PREFIX ++ "o";
pub const PRIuMAX = __PRI64_PREFIX ++ "u";
pub const PRIxMAX = __PRI64_PREFIX ++ "x";
pub const PRIXMAX = __PRI64_PREFIX ++ "X";
pub const PRIdPTR = __PRIPTR_PREFIX ++ "d";
pub const PRIiPTR = __PRIPTR_PREFIX ++ "i";
pub const PRIoPTR = __PRIPTR_PREFIX ++ "o";
pub const PRIuPTR = __PRIPTR_PREFIX ++ "u";
pub const PRIxPTR = __PRIPTR_PREFIX ++ "x";
pub const PRIXPTR = __PRIPTR_PREFIX ++ "X";
pub const PRIb8 = "b";
pub const PRIb16 = "b";
pub const PRIb32 = "b";
pub const PRIb64 = __PRI64_PREFIX ++ "b";
pub const PRIbLEAST8 = "b";
pub const PRIbLEAST16 = "b";
pub const PRIbLEAST32 = "b";
pub const PRIbLEAST64 = __PRI64_PREFIX ++ "b";
pub const PRIbFAST8 = "b";
pub const PRIbFAST16 = __PRIPTR_PREFIX ++ "b";
pub const PRIbFAST32 = __PRIPTR_PREFIX ++ "b";
pub const PRIbFAST64 = __PRI64_PREFIX ++ "b";
pub const PRIbMAX = __PRI64_PREFIX ++ "b";
pub const PRIbPTR = __PRIPTR_PREFIX ++ "b";
pub const PRIB8 = "B";
pub const PRIB16 = "B";
pub const PRIB32 = "B";
pub const PRIB64 = __PRI64_PREFIX ++ "B";
pub const PRIBLEAST8 = "B";
pub const PRIBLEAST16 = "B";
pub const PRIBLEAST32 = "B";
pub const PRIBLEAST64 = __PRI64_PREFIX ++ "B";
pub const PRIBFAST8 = "B";
pub const PRIBFAST16 = __PRIPTR_PREFIX ++ "B";
pub const PRIBFAST32 = __PRIPTR_PREFIX ++ "B";
pub const PRIBFAST64 = __PRI64_PREFIX ++ "B";
pub const PRIBMAX = __PRI64_PREFIX ++ "B";
pub const PRIBPTR = __PRIPTR_PREFIX ++ "B";
pub const SCNd8 = "hhd";
pub const SCNd16 = "hd";
pub const SCNd32 = "d";
pub const SCNd64 = __PRI64_PREFIX ++ "d";
pub const SCNdLEAST8 = "hhd";
pub const SCNdLEAST16 = "hd";
pub const SCNdLEAST32 = "d";
pub const SCNdLEAST64 = __PRI64_PREFIX ++ "d";
pub const SCNdFAST8 = "hhd";
pub const SCNdFAST16 = __PRIPTR_PREFIX ++ "d";
pub const SCNdFAST32 = __PRIPTR_PREFIX ++ "d";
pub const SCNdFAST64 = __PRI64_PREFIX ++ "d";
pub const SCNi8 = "hhi";
pub const SCNi16 = "hi";
pub const SCNi32 = "i";
pub const SCNi64 = __PRI64_PREFIX ++ "i";
pub const SCNiLEAST8 = "hhi";
pub const SCNiLEAST16 = "hi";
pub const SCNiLEAST32 = "i";
pub const SCNiLEAST64 = __PRI64_PREFIX ++ "i";
pub const SCNiFAST8 = "hhi";
pub const SCNiFAST16 = __PRIPTR_PREFIX ++ "i";
pub const SCNiFAST32 = __PRIPTR_PREFIX ++ "i";
pub const SCNiFAST64 = __PRI64_PREFIX ++ "i";
pub const SCNu8 = "hhu";
pub const SCNu16 = "hu";
pub const SCNu32 = "u";
pub const SCNu64 = __PRI64_PREFIX ++ "u";
pub const SCNuLEAST8 = "hhu";
pub const SCNuLEAST16 = "hu";
pub const SCNuLEAST32 = "u";
pub const SCNuLEAST64 = __PRI64_PREFIX ++ "u";
pub const SCNuFAST8 = "hhu";
pub const SCNuFAST16 = __PRIPTR_PREFIX ++ "u";
pub const SCNuFAST32 = __PRIPTR_PREFIX ++ "u";
pub const SCNuFAST64 = __PRI64_PREFIX ++ "u";
pub const SCNo8 = "hho";
pub const SCNo16 = "ho";
pub const SCNo32 = "o";
pub const SCNo64 = __PRI64_PREFIX ++ "o";
pub const SCNoLEAST8 = "hho";
pub const SCNoLEAST16 = "ho";
pub const SCNoLEAST32 = "o";
pub const SCNoLEAST64 = __PRI64_PREFIX ++ "o";
pub const SCNoFAST8 = "hho";
pub const SCNoFAST16 = __PRIPTR_PREFIX ++ "o";
pub const SCNoFAST32 = __PRIPTR_PREFIX ++ "o";
pub const SCNoFAST64 = __PRI64_PREFIX ++ "o";
pub const SCNx8 = "hhx";
pub const SCNx16 = "hx";
pub const SCNx32 = "x";
pub const SCNx64 = __PRI64_PREFIX ++ "x";
pub const SCNxLEAST8 = "hhx";
pub const SCNxLEAST16 = "hx";
pub const SCNxLEAST32 = "x";
pub const SCNxLEAST64 = __PRI64_PREFIX ++ "x";
pub const SCNxFAST8 = "hhx";
pub const SCNxFAST16 = __PRIPTR_PREFIX ++ "x";
pub const SCNxFAST32 = __PRIPTR_PREFIX ++ "x";
pub const SCNxFAST64 = __PRI64_PREFIX ++ "x";
pub const SCNdMAX = __PRI64_PREFIX ++ "d";
pub const SCNiMAX = __PRI64_PREFIX ++ "i";
pub const SCNoMAX = __PRI64_PREFIX ++ "o";
pub const SCNuMAX = __PRI64_PREFIX ++ "u";
pub const SCNxMAX = __PRI64_PREFIX ++ "x";
pub const SCNdPTR = __PRIPTR_PREFIX ++ "d";
pub const SCNiPTR = __PRIPTR_PREFIX ++ "i";
pub const SCNoPTR = __PRIPTR_PREFIX ++ "o";
pub const SCNuPTR = __PRIPTR_PREFIX ++ "u";
pub const SCNxPTR = __PRIPTR_PREFIX ++ "x";
pub const SCNb8 = "hhb";
pub const SCNb16 = "hb";
pub const SCNb32 = "b";
pub const SCNb64 = __PRI64_PREFIX ++ "b";
pub const SCNbLEAST8 = "hhb";
pub const SCNbLEAST16 = "hb";
pub const SCNbLEAST32 = "b";
pub const SCNbLEAST64 = __PRI64_PREFIX ++ "b";
pub const SCNbFAST8 = "hhb";
pub const SCNbFAST16 = __PRIPTR_PREFIX ++ "b";
pub const SCNbFAST32 = __PRIPTR_PREFIX ++ "b";
pub const SCNbFAST64 = __PRI64_PREFIX ++ "b";
pub const SCNbMAX = __PRI64_PREFIX ++ "b";
pub const SCNbPTR = __PRIPTR_PREFIX ++ "b";
pub const PCRE2_ANCHORED = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x80000000, .hex);
pub const PCRE2_NO_UTF_CHECK = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x40000000, .hex);
pub const PCRE2_ENDANCHORED = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x20000000, .hex);
pub const PCRE2_ALLOW_EMPTY_CLASS = @as(c_uint, 0x00000001);
pub const PCRE2_ALT_BSUX = @as(c_uint, 0x00000002);
pub const PCRE2_AUTO_CALLOUT = @as(c_uint, 0x00000004);
pub const PCRE2_CASELESS = @as(c_uint, 0x00000008);
pub const PCRE2_DOLLAR_ENDONLY = @as(c_uint, 0x00000010);
pub const PCRE2_DOTALL = @as(c_uint, 0x00000020);
pub const PCRE2_DUPNAMES = @as(c_uint, 0x00000040);
pub const PCRE2_EXTENDED = @as(c_uint, 0x00000080);
pub const PCRE2_FIRSTLINE = @as(c_uint, 0x00000100);
pub const PCRE2_MATCH_UNSET_BACKREF = @as(c_uint, 0x00000200);
pub const PCRE2_MULTILINE = @as(c_uint, 0x00000400);
pub const PCRE2_NEVER_UCP = @as(c_uint, 0x00000800);
pub const PCRE2_NEVER_UTF = @as(c_uint, 0x00001000);
pub const PCRE2_NO_AUTO_CAPTURE = @as(c_uint, 0x00002000);
pub const PCRE2_NO_AUTO_POSSESS = @as(c_uint, 0x00004000);
pub const PCRE2_NO_DOTSTAR_ANCHOR = @as(c_uint, 0x00008000);
pub const PCRE2_NO_START_OPTIMIZE = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00010000, .hex);
pub const PCRE2_UCP = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00020000, .hex);
pub const PCRE2_UNGREEDY = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00040000, .hex);
pub const PCRE2_UTF = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00080000, .hex);
pub const PCRE2_NEVER_BACKSLASH_C = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00100000, .hex);
pub const PCRE2_ALT_CIRCUMFLEX = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00200000, .hex);
pub const PCRE2_ALT_VERBNAMES = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00400000, .hex);
pub const PCRE2_USE_OFFSET_LIMIT = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00800000, .hex);
pub const PCRE2_EXTENDED_MORE = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x01000000, .hex);
pub const PCRE2_LITERAL = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x02000000, .hex);
pub const PCRE2_MATCH_INVALID_UTF = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x04000000, .hex);
pub const PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES = @as(c_uint, 0x00000001);
pub const PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL = @as(c_uint, 0x00000002);
pub const PCRE2_EXTRA_MATCH_WORD = @as(c_uint, 0x00000004);
pub const PCRE2_EXTRA_MATCH_LINE = @as(c_uint, 0x00000008);
pub const PCRE2_EXTRA_ESCAPED_CR_IS_LF = @as(c_uint, 0x00000010);
pub const PCRE2_EXTRA_ALT_BSUX = @as(c_uint, 0x00000020);
pub const PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK = @as(c_uint, 0x00000040);
pub const PCRE2_EXTRA_CASELESS_RESTRICT = @as(c_uint, 0x00000080);
pub const PCRE2_EXTRA_ASCII_BSD = @as(c_uint, 0x00000100);
pub const PCRE2_EXTRA_ASCII_BSS = @as(c_uint, 0x00000200);
pub const PCRE2_EXTRA_ASCII_BSW = @as(c_uint, 0x00000400);
pub const PCRE2_EXTRA_ASCII_POSIX = @as(c_uint, 0x00000800);
pub const PCRE2_EXTRA_ASCII_DIGIT = @as(c_uint, 0x00001000);
pub const PCRE2_JIT_COMPLETE = @as(c_uint, 0x00000001);
pub const PCRE2_JIT_PARTIAL_SOFT = @as(c_uint, 0x00000002);
pub const PCRE2_JIT_PARTIAL_HARD = @as(c_uint, 0x00000004);
pub const PCRE2_JIT_INVALID_UTF = @as(c_uint, 0x00000100);
pub const PCRE2_NOTBOL = @as(c_uint, 0x00000001);
pub const PCRE2_NOTEOL = @as(c_uint, 0x00000002);
pub const PCRE2_NOTEMPTY = @as(c_uint, 0x00000004);
pub const PCRE2_NOTEMPTY_ATSTART = @as(c_uint, 0x00000008);
pub const PCRE2_PARTIAL_SOFT = @as(c_uint, 0x00000010);
pub const PCRE2_PARTIAL_HARD = @as(c_uint, 0x00000020);
pub const PCRE2_DFA_RESTART = @as(c_uint, 0x00000040);
pub const PCRE2_DFA_SHORTEST = @as(c_uint, 0x00000080);
pub const PCRE2_SUBSTITUTE_GLOBAL = @as(c_uint, 0x00000100);
pub const PCRE2_SUBSTITUTE_EXTENDED = @as(c_uint, 0x00000200);
pub const PCRE2_SUBSTITUTE_UNSET_EMPTY = @as(c_uint, 0x00000400);
pub const PCRE2_SUBSTITUTE_UNKNOWN_UNSET = @as(c_uint, 0x00000800);
pub const PCRE2_SUBSTITUTE_OVERFLOW_LENGTH = @as(c_uint, 0x00001000);
pub const PCRE2_NO_JIT = @as(c_uint, 0x00002000);
pub const PCRE2_COPY_MATCHED_SUBJECT = @as(c_uint, 0x00004000);
pub const PCRE2_SUBSTITUTE_LITERAL = @as(c_uint, 0x00008000);
pub const PCRE2_SUBSTITUTE_MATCHED = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00010000, .hex);
pub const PCRE2_SUBSTITUTE_REPLACEMENT_ONLY = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00020000, .hex);
pub const PCRE2_DISABLE_RECURSELOOP_CHECK = @import("std").zig.c_translation.promoteIntLiteral(c_uint, 0x00040000, .hex);
pub const PCRE2_CONVERT_UTF = @as(c_uint, 0x00000001);
pub const PCRE2_CONVERT_NO_UTF_CHECK = @as(c_uint, 0x00000002);
pub const PCRE2_CONVERT_POSIX_BASIC = @as(c_uint, 0x00000004);
pub const PCRE2_CONVERT_POSIX_EXTENDED = @as(c_uint, 0x00000008);
pub const PCRE2_CONVERT_GLOB = @as(c_uint, 0x00000010);
pub const PCRE2_CONVERT_GLOB_NO_WILD_SEPARATOR = @as(c_uint, 0x00000030);
pub const PCRE2_CONVERT_GLOB_NO_STARSTAR = @as(c_uint, 0x00000050);
pub const PCRE2_NEWLINE_CR = @as(c_int, 1);
pub const PCRE2_NEWLINE_LF = @as(c_int, 2);
pub const PCRE2_NEWLINE_CRLF = @as(c_int, 3);
pub const PCRE2_NEWLINE_ANY = @as(c_int, 4);
pub const PCRE2_NEWLINE_ANYCRLF = @as(c_int, 5);
pub const PCRE2_NEWLINE_NUL = @as(c_int, 6);
pub const PCRE2_BSR_UNICODE = @as(c_int, 1);
pub const PCRE2_BSR_ANYCRLF = @as(c_int, 2);
pub const PCRE2_ERROR_END_BACKSLASH = @as(c_int, 101);
pub const PCRE2_ERROR_END_BACKSLASH_C = @as(c_int, 102);
pub const PCRE2_ERROR_UNKNOWN_ESCAPE = @as(c_int, 103);
pub const PCRE2_ERROR_QUANTIFIER_OUT_OF_ORDER = @as(c_int, 104);
pub const PCRE2_ERROR_QUANTIFIER_TOO_BIG = @as(c_int, 105);
pub const PCRE2_ERROR_MISSING_SQUARE_BRACKET = @as(c_int, 106);
pub const PCRE2_ERROR_ESCAPE_INVALID_IN_CLASS = @as(c_int, 107);
pub const PCRE2_ERROR_CLASS_RANGE_ORDER = @as(c_int, 108);
pub const PCRE2_ERROR_QUANTIFIER_INVALID = @as(c_int, 109);
pub const PCRE2_ERROR_INTERNAL_UNEXPECTED_REPEAT = @as(c_int, 110);
pub const PCRE2_ERROR_INVALID_AFTER_PARENS_QUERY = @as(c_int, 111);
pub const PCRE2_ERROR_POSIX_CLASS_NOT_IN_CLASS = @as(c_int, 112);
pub const PCRE2_ERROR_POSIX_NO_SUPPORT_COLLATING = @as(c_int, 113);
pub const PCRE2_ERROR_MISSING_CLOSING_PARENTHESIS = @as(c_int, 114);
pub const PCRE2_ERROR_BAD_SUBPATTERN_REFERENCE = @as(c_int, 115);
pub const PCRE2_ERROR_NULL_PATTERN = @as(c_int, 116);
pub const PCRE2_ERROR_BAD_OPTIONS = @as(c_int, 117);
pub const PCRE2_ERROR_MISSING_COMMENT_CLOSING = @as(c_int, 118);
pub const PCRE2_ERROR_PARENTHESES_NEST_TOO_DEEP = @as(c_int, 119);
pub const PCRE2_ERROR_PATTERN_TOO_LARGE = @as(c_int, 120);
pub const PCRE2_ERROR_HEAP_FAILED = @as(c_int, 121);
pub const PCRE2_ERROR_UNMATCHED_CLOSING_PARENTHESIS = @as(c_int, 122);
pub const PCRE2_ERROR_INTERNAL_CODE_OVERFLOW = @as(c_int, 123);
pub const PCRE2_ERROR_MISSING_CONDITION_CLOSING = @as(c_int, 124);
pub const PCRE2_ERROR_LOOKBEHIND_NOT_FIXED_LENGTH = @as(c_int, 125);
pub const PCRE2_ERROR_ZERO_RELATIVE_REFERENCE = @as(c_int, 126);
pub const PCRE2_ERROR_TOO_MANY_CONDITION_BRANCHES = @as(c_int, 127);
pub const PCRE2_ERROR_CONDITION_ASSERTION_EXPECTED = @as(c_int, 128);
pub const PCRE2_ERROR_BAD_RELATIVE_REFERENCE = @as(c_int, 129);
pub const PCRE2_ERROR_UNKNOWN_POSIX_CLASS = @as(c_int, 130);
pub const PCRE2_ERROR_INTERNAL_STUDY_ERROR = @as(c_int, 131);
pub const PCRE2_ERROR_UNICODE_NOT_SUPPORTED = @as(c_int, 132);
pub const PCRE2_ERROR_PARENTHESES_STACK_CHECK = @as(c_int, 133);
pub const PCRE2_ERROR_CODE_POINT_TOO_BIG = @as(c_int, 134);
pub const PCRE2_ERROR_LOOKBEHIND_TOO_COMPLICATED = @as(c_int, 135);
pub const PCRE2_ERROR_LOOKBEHIND_INVALID_BACKSLASH_C = @as(c_int, 136);
pub const PCRE2_ERROR_UNSUPPORTED_ESCAPE_SEQUENCE = @as(c_int, 137);
pub const PCRE2_ERROR_CALLOUT_NUMBER_TOO_BIG = @as(c_int, 138);
pub const PCRE2_ERROR_MISSING_CALLOUT_CLOSING = @as(c_int, 139);
pub const PCRE2_ERROR_ESCAPE_INVALID_IN_VERB = @as(c_int, 140);
pub const PCRE2_ERROR_UNRECOGNIZED_AFTER_QUERY_P = @as(c_int, 141);
pub const PCRE2_ERROR_MISSING_NAME_TERMINATOR = @as(c_int, 142);
pub const PCRE2_ERROR_DUPLICATE_SUBPATTERN_NAME = @as(c_int, 143);
pub const PCRE2_ERROR_INVALID_SUBPATTERN_NAME = @as(c_int, 144);
pub const PCRE2_ERROR_UNICODE_PROPERTIES_UNAVAILABLE = @as(c_int, 145);
pub const PCRE2_ERROR_MALFORMED_UNICODE_PROPERTY = @as(c_int, 146);
pub const PCRE2_ERROR_UNKNOWN_UNICODE_PROPERTY = @as(c_int, 147);
pub const PCRE2_ERROR_SUBPATTERN_NAME_TOO_LONG = @as(c_int, 148);
pub const PCRE2_ERROR_TOO_MANY_NAMED_SUBPATTERNS = @as(c_int, 149);
pub const PCRE2_ERROR_CLASS_INVALID_RANGE = @as(c_int, 150);
pub const PCRE2_ERROR_OCTAL_BYTE_TOO_BIG = @as(c_int, 151);
pub const PCRE2_ERROR_INTERNAL_OVERRAN_WORKSPACE = @as(c_int, 152);
pub const PCRE2_ERROR_INTERNAL_MISSING_SUBPATTERN = @as(c_int, 153);
pub const PCRE2_ERROR_DEFINE_TOO_MANY_BRANCHES = @as(c_int, 154);
pub const PCRE2_ERROR_BACKSLASH_O_MISSING_BRACE = @as(c_int, 155);
pub const PCRE2_ERROR_INTERNAL_UNKNOWN_NEWLINE = @as(c_int, 156);
pub const PCRE2_ERROR_BACKSLASH_G_SYNTAX = @as(c_int, 157);
pub const PCRE2_ERROR_PARENS_QUERY_R_MISSING_CLOSING = @as(c_int, 158);
pub const PCRE2_ERROR_VERB_ARGUMENT_NOT_ALLOWED = @as(c_int, 159);
pub const PCRE2_ERROR_VERB_UNKNOWN = @as(c_int, 160);
pub const PCRE2_ERROR_SUBPATTERN_NUMBER_TOO_BIG = @as(c_int, 161);
pub const PCRE2_ERROR_SUBPATTERN_NAME_EXPECTED = @as(c_int, 162);
pub const PCRE2_ERROR_INTERNAL_PARSED_OVERFLOW = @as(c_int, 163);
pub const PCRE2_ERROR_INVALID_OCTAL = @as(c_int, 164);
pub const PCRE2_ERROR_SUBPATTERN_NAMES_MISMATCH = @as(c_int, 165);
pub const PCRE2_ERROR_MARK_MISSING_ARGUMENT = @as(c_int, 166);
pub const PCRE2_ERROR_INVALID_HEXADECIMAL = @as(c_int, 167);
pub const PCRE2_ERROR_BACKSLASH_C_SYNTAX = @as(c_int, 168);
pub const PCRE2_ERROR_BACKSLASH_K_SYNTAX = @as(c_int, 169);
pub const PCRE2_ERROR_INTERNAL_BAD_CODE_LOOKBEHINDS = @as(c_int, 170);
pub const PCRE2_ERROR_BACKSLASH_N_IN_CLASS = @as(c_int, 171);
pub const PCRE2_ERROR_CALLOUT_STRING_TOO_LONG = @as(c_int, 172);
pub const PCRE2_ERROR_UNICODE_DISALLOWED_CODE_POINT = @as(c_int, 173);
pub const PCRE2_ERROR_UTF_IS_DISABLED = @as(c_int, 174);
pub const PCRE2_ERROR_UCP_IS_DISABLED = @as(c_int, 175);
pub const PCRE2_ERROR_VERB_NAME_TOO_LONG = @as(c_int, 176);
pub const PCRE2_ERROR_BACKSLASH_U_CODE_POINT_TOO_BIG = @as(c_int, 177);
pub const PCRE2_ERROR_MISSING_OCTAL_OR_HEX_DIGITS = @as(c_int, 178);
pub const PCRE2_ERROR_VERSION_CONDITION_SYNTAX = @as(c_int, 179);
pub const PCRE2_ERROR_INTERNAL_BAD_CODE_AUTO_POSSESS = @as(c_int, 180);
pub const PCRE2_ERROR_CALLOUT_NO_STRING_DELIMITER = @as(c_int, 181);
pub const PCRE2_ERROR_CALLOUT_BAD_STRING_DELIMITER = @as(c_int, 182);
pub const PCRE2_ERROR_BACKSLASH_C_CALLER_DISABLED = @as(c_int, 183);
pub const PCRE2_ERROR_QUERY_BARJX_NEST_TOO_DEEP = @as(c_int, 184);
pub const PCRE2_ERROR_BACKSLASH_C_LIBRARY_DISABLED = @as(c_int, 185);
pub const PCRE2_ERROR_PATTERN_TOO_COMPLICATED = @as(c_int, 186);
pub const PCRE2_ERROR_LOOKBEHIND_TOO_LONG = @as(c_int, 187);
pub const PCRE2_ERROR_PATTERN_STRING_TOO_LONG = @as(c_int, 188);
pub const PCRE2_ERROR_INTERNAL_BAD_CODE = @as(c_int, 189);
pub const PCRE2_ERROR_INTERNAL_BAD_CODE_IN_SKIP = @as(c_int, 190);
pub const PCRE2_ERROR_NO_SURROGATES_IN_UTF16 = @as(c_int, 191);
pub const PCRE2_ERROR_BAD_LITERAL_OPTIONS = @as(c_int, 192);
pub const PCRE2_ERROR_SUPPORTED_ONLY_IN_UNICODE = @as(c_int, 193);
pub const PCRE2_ERROR_INVALID_HYPHEN_IN_OPTIONS = @as(c_int, 194);
pub const PCRE2_ERROR_ALPHA_ASSERTION_UNKNOWN = @as(c_int, 195);
pub const PCRE2_ERROR_SCRIPT_RUN_NOT_AVAILABLE = @as(c_int, 196);
pub const PCRE2_ERROR_TOO_MANY_CAPTURES = @as(c_int, 197);
pub const PCRE2_ERROR_CONDITION_ATOMIC_ASSERTION_EXPECTED = @as(c_int, 198);
pub const PCRE2_ERROR_BACKSLASH_K_IN_LOOKAROUND = @as(c_int, 199);
pub const PCRE2_ERROR_NOMATCH = -@as(c_int, 1);
pub const PCRE2_ERROR_PARTIAL = -@as(c_int, 2);
pub const PCRE2_ERROR_UTF8_ERR1 = -@as(c_int, 3);
pub const PCRE2_ERROR_UTF8_ERR2 = -@as(c_int, 4);
pub const PCRE2_ERROR_UTF8_ERR3 = -@as(c_int, 5);
pub const PCRE2_ERROR_UTF8_ERR4 = -@as(c_int, 6);
pub const PCRE2_ERROR_UTF8_ERR5 = -@as(c_int, 7);
pub const PCRE2_ERROR_UTF8_ERR6 = -@as(c_int, 8);
pub const PCRE2_ERROR_UTF8_ERR7 = -@as(c_int, 9);
pub const PCRE2_ERROR_UTF8_ERR8 = -@as(c_int, 10);
pub const PCRE2_ERROR_UTF8_ERR9 = -@as(c_int, 11);
pub const PCRE2_ERROR_UTF8_ERR10 = -@as(c_int, 12);
pub const PCRE2_ERROR_UTF8_ERR11 = -@as(c_int, 13);
pub const PCRE2_ERROR_UTF8_ERR12 = -@as(c_int, 14);
pub const PCRE2_ERROR_UTF8_ERR13 = -@as(c_int, 15);
pub const PCRE2_ERROR_UTF8_ERR14 = -@as(c_int, 16);
pub const PCRE2_ERROR_UTF8_ERR15 = -@as(c_int, 17);
pub const PCRE2_ERROR_UTF8_ERR16 = -@as(c_int, 18);
pub const PCRE2_ERROR_UTF8_ERR17 = -@as(c_int, 19);
pub const PCRE2_ERROR_UTF8_ERR18 = -@as(c_int, 20);
pub const PCRE2_ERROR_UTF8_ERR19 = -@as(c_int, 21);
pub const PCRE2_ERROR_UTF8_ERR20 = -@as(c_int, 22);
pub const PCRE2_ERROR_UTF8_ERR21 = -@as(c_int, 23);
pub const PCRE2_ERROR_UTF16_ERR1 = -@as(c_int, 24);
pub const PCRE2_ERROR_UTF16_ERR2 = -@as(c_int, 25);
pub const PCRE2_ERROR_UTF16_ERR3 = -@as(c_int, 26);
pub const PCRE2_ERROR_UTF32_ERR1 = -@as(c_int, 27);
pub const PCRE2_ERROR_UTF32_ERR2 = -@as(c_int, 28);
pub const PCRE2_ERROR_BADDATA = -@as(c_int, 29);
pub const PCRE2_ERROR_MIXEDTABLES = -@as(c_int, 30);
pub const PCRE2_ERROR_BADMAGIC = -@as(c_int, 31);
pub const PCRE2_ERROR_BADMODE = -@as(c_int, 32);
pub const PCRE2_ERROR_BADOFFSET = -@as(c_int, 33);
pub const PCRE2_ERROR_BADOPTION = -@as(c_int, 34);
pub const PCRE2_ERROR_BADREPLACEMENT = -@as(c_int, 35);
pub const PCRE2_ERROR_BADUTFOFFSET = -@as(c_int, 36);
pub const PCRE2_ERROR_CALLOUT = -@as(c_int, 37);
pub const PCRE2_ERROR_DFA_BADRESTART = -@as(c_int, 38);
pub const PCRE2_ERROR_DFA_RECURSE = -@as(c_int, 39);
pub const PCRE2_ERROR_DFA_UCOND = -@as(c_int, 40);
pub const PCRE2_ERROR_DFA_UFUNC = -@as(c_int, 41);
pub const PCRE2_ERROR_DFA_UITEM = -@as(c_int, 42);
pub const PCRE2_ERROR_DFA_WSSIZE = -@as(c_int, 43);
pub const PCRE2_ERROR_INTERNAL = -@as(c_int, 44);
pub const PCRE2_ERROR_JIT_BADOPTION = -@as(c_int, 45);
pub const PCRE2_ERROR_JIT_STACKLIMIT = -@as(c_int, 46);
pub const PCRE2_ERROR_MATCHLIMIT = -@as(c_int, 47);
pub const PCRE2_ERROR_NOMEMORY = -@as(c_int, 48);
pub const PCRE2_ERROR_NOSUBSTRING = -@as(c_int, 49);
pub const PCRE2_ERROR_NOUNIQUESUBSTRING = -@as(c_int, 50);
pub const PCRE2_ERROR_NULL = -@as(c_int, 51);
pub const PCRE2_ERROR_RECURSELOOP = -@as(c_int, 52);
pub const PCRE2_ERROR_DEPTHLIMIT = -@as(c_int, 53);
pub const PCRE2_ERROR_RECURSIONLIMIT = -@as(c_int, 53);
pub const PCRE2_ERROR_UNAVAILABLE = -@as(c_int, 54);
pub const PCRE2_ERROR_UNSET = -@as(c_int, 55);
pub const PCRE2_ERROR_BADOFFSETLIMIT = -@as(c_int, 56);
pub const PCRE2_ERROR_BADREPESCAPE = -@as(c_int, 57);
pub const PCRE2_ERROR_REPMISSINGBRACE = -@as(c_int, 58);
pub const PCRE2_ERROR_BADSUBSTITUTION = -@as(c_int, 59);
pub const PCRE2_ERROR_BADSUBSPATTERN = -@as(c_int, 60);
pub const PCRE2_ERROR_TOOMANYREPLACE = -@as(c_int, 61);
pub const PCRE2_ERROR_BADSERIALIZEDDATA = -@as(c_int, 62);
pub const PCRE2_ERROR_HEAPLIMIT = -@as(c_int, 63);
pub const PCRE2_ERROR_CONVERT_SYNTAX = -@as(c_int, 64);
pub const PCRE2_ERROR_INTERNAL_DUPMATCH = -@as(c_int, 65);
pub const PCRE2_ERROR_DFA_UINVALID_UTF = -@as(c_int, 66);
pub const PCRE2_ERROR_INVALIDOFFSET = -@as(c_int, 67);
pub const PCRE2_INFO_ALLOPTIONS = @as(c_int, 0);
pub const PCRE2_INFO_ARGOPTIONS = @as(c_int, 1);
pub const PCRE2_INFO_BACKREFMAX = @as(c_int, 2);
pub const PCRE2_INFO_BSR = @as(c_int, 3);
pub const PCRE2_INFO_CAPTURECOUNT = @as(c_int, 4);
pub const PCRE2_INFO_FIRSTCODEUNIT = @as(c_int, 5);
pub const PCRE2_INFO_FIRSTCODETYPE = @as(c_int, 6);
pub const PCRE2_INFO_FIRSTBITMAP = @as(c_int, 7);
pub const PCRE2_INFO_HASCRORLF = @as(c_int, 8);
pub const PCRE2_INFO_JCHANGED = @as(c_int, 9);
pub const PCRE2_INFO_JITSIZE = @as(c_int, 10);
pub const PCRE2_INFO_LASTCODEUNIT = @as(c_int, 11);
pub const PCRE2_INFO_LASTCODETYPE = @as(c_int, 12);
pub const PCRE2_INFO_MATCHEMPTY = @as(c_int, 13);
pub const PCRE2_INFO_MATCHLIMIT = @as(c_int, 14);
pub const PCRE2_INFO_MAXLOOKBEHIND = @as(c_int, 15);
pub const PCRE2_INFO_MINLENGTH = @as(c_int, 16);
pub const PCRE2_INFO_NAMECOUNT = @as(c_int, 17);
pub const PCRE2_INFO_NAMEENTRYSIZE = @as(c_int, 18);
pub const PCRE2_INFO_NAMETABLE = @as(c_int, 19);
pub const PCRE2_INFO_NEWLINE = @as(c_int, 20);
pub const PCRE2_INFO_DEPTHLIMIT = @as(c_int, 21);
pub const PCRE2_INFO_RECURSIONLIMIT = @as(c_int, 21);
pub const PCRE2_INFO_SIZE = @as(c_int, 22);
pub const PCRE2_INFO_HASBACKSLASHC = @as(c_int, 23);
pub const PCRE2_INFO_FRAMESIZE = @as(c_int, 24);
pub const PCRE2_INFO_HEAPLIMIT = @as(c_int, 25);
pub const PCRE2_INFO_EXTRAOPTIONS = @as(c_int, 26);
pub const PCRE2_CONFIG_BSR = @as(c_int, 0);
pub const PCRE2_CONFIG_JIT = @as(c_int, 1);
pub const PCRE2_CONFIG_JITTARGET = @as(c_int, 2);
pub const PCRE2_CONFIG_LINKSIZE = @as(c_int, 3);
pub const PCRE2_CONFIG_MATCHLIMIT = @as(c_int, 4);
pub const PCRE2_CONFIG_NEWLINE = @as(c_int, 5);
pub const PCRE2_CONFIG_PARENSLIMIT = @as(c_int, 6);
pub const PCRE2_CONFIG_DEPTHLIMIT = @as(c_int, 7);
pub const PCRE2_CONFIG_RECURSIONLIMIT = @as(c_int, 7);
pub const PCRE2_CONFIG_STACKRECURSE = @as(c_int, 8);
pub const PCRE2_CONFIG_UNICODE = @as(c_int, 9);
pub const PCRE2_CONFIG_UNICODE_VERSION = @as(c_int, 10);
pub const PCRE2_CONFIG_VERSION = @as(c_int, 11);
pub const PCRE2_CONFIG_HEAPLIMIT = @as(c_int, 12);
pub const PCRE2_CONFIG_NEVER_BACKSLASH_C = @as(c_int, 13);
pub const PCRE2_CONFIG_COMPILED_WIDTHS = @as(c_int, 14);
pub const PCRE2_CONFIG_TABLES_LENGTH = @as(c_int, 15);
pub const PCRE2_SIZE = usize;
pub const PCRE2_SIZE_MAX = SIZE_MAX;
pub const PCRE2_ZERO_TERMINATED = @compileError("unable to translate C expr: expected ')' instead got 'A number'");
// /usr/include/pcre2.h:481:9
pub const PCRE2_UNSET = @compileError("unable to translate C expr: expected ')' instead got 'A number'");
// /usr/include/pcre2.h:482:9
pub const PCRE2_TYPES_LIST = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/pcre2.h:487:9
pub const PCRE2_CALLOUT_STARTMATCH = @as(c_uint, 0x00000001);
pub const PCRE2_CALLOUT_BACKTRACK = @as(c_uint, 0x00000002);
pub const PCRE2_STRUCTURE_LIST = @compileError("unable to translate macro: undefined identifier `version`");
// /usr/include/pcre2.h:523:9
pub const PCRE2_GENERAL_INFO_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'int'");
// /usr/include/pcre2.h:576:9
pub const PCRE2_GENERAL_CONTEXT_FUNCTIONS = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/pcre2.h:582:9
pub const PCRE2_COMPILE_CONTEXT_FUNCTIONS = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/pcre2.h:591:9
pub const PCRE2_MATCH_CONTEXT_FUNCTIONS = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/pcre2.h:618:9
pub const PCRE2_CONVERT_CONTEXT_FUNCTIONS = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/pcre2.h:645:9
pub const PCRE2_COMPILE_FUNCTIONS = @compileError("unable to translate C expr: unexpected token ','");
// /usr/include/pcre2.h:660:9
pub const PCRE2_PATTERN_INFO_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'int'");
// /usr/include/pcre2.h:674:9
pub const PCRE2_MATCH_FUNCTIONS = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/pcre2.h:684:9
pub const PCRE2_SUBSTRING_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'int'");
// /usr/include/pcre2.h:714:9
pub const PCRE2_SERIALIZE_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/pcre2.h:745:9
pub const PCRE2_SUBSTITUTE_FUNCTION = @compileError("unable to translate C expr: unexpected token 'int'");
// /usr/include/pcre2.h:760:9
pub const PCRE2_CONVERT_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'int'");
// /usr/include/pcre2.h:769:9
pub const PCRE2_JIT_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'int'");
// /usr/include/pcre2.h:779:9
pub const PCRE2_OTHER_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'int'");
// /usr/include/pcre2.h:797:9
pub const PCRE2_JOIN = @compileError("unable to translate C expr: unexpected token '##'");
// /usr/include/pcre2.h:812:9
pub inline fn PCRE2_GLUE(a: anytype, b: anytype) @TypeOf(PCRE2_JOIN(a, b)) {
    _ = &a;
    _ = &b;
    return PCRE2_JOIN(a, b);
}
pub inline fn PCRE2_SUFFIX(a: anytype) @TypeOf(PCRE2_GLUE(a, PCRE2_LOCAL_WIDTH)) {
    _ = &a;
    return PCRE2_GLUE(a, PCRE2_LOCAL_WIDTH);
}
pub const PCRE2_UCHAR = PCRE2_SUFFIX(PCRE2_UCHAR);
pub const PCRE2_SPTR = PCRE2_SUFFIX(PCRE2_SPTR);
pub const pcre2_code = @compileError("unable to translate macro: undefined identifier `pcre2_code_`");
// /usr/include/pcre2.h:822:9
pub const pcre2_jit_callback = @compileError("unable to translate macro: undefined identifier `pcre2_jit_callback_`");
// /usr/include/pcre2.h:823:9
pub const pcre2_jit_stack = @compileError("unable to translate macro: undefined identifier `pcre2_jit_stack_`");
// /usr/include/pcre2.h:824:9
pub const pcre2_real_code = @compileError("unable to translate macro: undefined identifier `pcre2_real_code_`");
// /usr/include/pcre2.h:826:9
pub const pcre2_real_general_context = @compileError("unable to translate macro: undefined identifier `pcre2_real_general_context_`");
// /usr/include/pcre2.h:827:9
pub const pcre2_real_compile_context = @compileError("unable to translate macro: undefined identifier `pcre2_real_compile_context_`");
// /usr/include/pcre2.h:828:9
pub const pcre2_real_convert_context = @compileError("unable to translate macro: undefined identifier `pcre2_real_convert_context_`");
// /usr/include/pcre2.h:829:9
pub const pcre2_real_match_context = @compileError("unable to translate macro: undefined identifier `pcre2_real_match_context_`");
// /usr/include/pcre2.h:830:9
pub const pcre2_real_jit_stack = @compileError("unable to translate macro: undefined identifier `pcre2_real_jit_stack_`");
// /usr/include/pcre2.h:831:9
pub const pcre2_real_match_data = @compileError("unable to translate macro: undefined identifier `pcre2_real_match_data_`");
// /usr/include/pcre2.h:832:9
pub const pcre2_callout_block = @compileError("unable to translate macro: undefined identifier `pcre2_callout_block_`");
// /usr/include/pcre2.h:837:9
pub const pcre2_callout_enumerate_block = @compileError("unable to translate macro: undefined identifier `pcre2_callout_enumerate_block_`");
// /usr/include/pcre2.h:838:9
pub const pcre2_substitute_callout_block = @compileError("unable to translate macro: undefined identifier `pcre2_substitute_callout_block_`");
// /usr/include/pcre2.h:839:9
pub const pcre2_general_context = @compileError("unable to translate macro: undefined identifier `pcre2_general_context_`");
// /usr/include/pcre2.h:840:9
pub const pcre2_compile_context = @compileError("unable to translate macro: undefined identifier `pcre2_compile_context_`");
// /usr/include/pcre2.h:841:9
pub const pcre2_convert_context = @compileError("unable to translate macro: undefined identifier `pcre2_convert_context_`");
// /usr/include/pcre2.h:842:9
pub const pcre2_match_context = @compileError("unable to translate macro: undefined identifier `pcre2_match_context_`");
// /usr/include/pcre2.h:843:9
pub const pcre2_match_data = @compileError("unable to translate macro: undefined identifier `pcre2_match_data_`");
// /usr/include/pcre2.h:844:9
pub const pcre2_callout_enumerate = @compileError("unable to translate macro: undefined identifier `pcre2_callout_enumerate_`");
// /usr/include/pcre2.h:849:9
pub const pcre2_code_copy = @compileError("unable to translate macro: undefined identifier `pcre2_code_copy_`");
// /usr/include/pcre2.h:850:9
pub const pcre2_code_copy_with_tables = @compileError("unable to translate macro: undefined identifier `pcre2_code_copy_with_tables_`");
// /usr/include/pcre2.h:851:9
pub const pcre2_code_free = @compileError("unable to translate macro: undefined identifier `pcre2_code_free_`");
// /usr/include/pcre2.h:852:9
pub const pcre2_compile = @compileError("unable to translate macro: undefined identifier `pcre2_compile_`");
// /usr/include/pcre2.h:853:9
pub const pcre2_compile_context_copy = @compileError("unable to translate macro: undefined identifier `pcre2_compile_context_copy_`");
// /usr/include/pcre2.h:854:9
pub const pcre2_compile_context_create = @compileError("unable to translate macro: undefined identifier `pcre2_compile_context_create_`");
// /usr/include/pcre2.h:855:9
pub const pcre2_compile_context_free = @compileError("unable to translate macro: undefined identifier `pcre2_compile_context_free_`");
// /usr/include/pcre2.h:856:9
pub const pcre2_config = @compileError("unable to translate macro: undefined identifier `pcre2_config_`");
// /usr/include/pcre2.h:857:9
pub const pcre2_convert_context_copy = @compileError("unable to translate macro: undefined identifier `pcre2_convert_context_copy_`");
// /usr/include/pcre2.h:858:9
pub const pcre2_convert_context_create = @compileError("unable to translate macro: undefined identifier `pcre2_convert_context_create_`");
// /usr/include/pcre2.h:859:9
pub const pcre2_convert_context_free = @compileError("unable to translate macro: undefined identifier `pcre2_convert_context_free_`");
// /usr/include/pcre2.h:860:9
pub const pcre2_converted_pattern_free = @compileError("unable to translate macro: undefined identifier `pcre2_converted_pattern_free_`");
// /usr/include/pcre2.h:861:9
pub const pcre2_dfa_match = @compileError("unable to translate macro: undefined identifier `pcre2_dfa_match_`");
// /usr/include/pcre2.h:862:9
pub const pcre2_general_context_copy = @compileError("unable to translate macro: undefined identifier `pcre2_general_context_copy_`");
// /usr/include/pcre2.h:863:9
pub const pcre2_general_context_create = @compileError("unable to translate macro: undefined identifier `pcre2_general_context_create_`");
// /usr/include/pcre2.h:864:9
pub const pcre2_general_context_free = @compileError("unable to translate macro: undefined identifier `pcre2_general_context_free_`");
// /usr/include/pcre2.h:865:9
pub const pcre2_get_error_message = @compileError("unable to translate macro: undefined identifier `pcre2_get_error_message_`");
// /usr/include/pcre2.h:866:9
pub const pcre2_get_mark = @compileError("unable to translate macro: undefined identifier `pcre2_get_mark_`");
// /usr/include/pcre2.h:867:9
pub const pcre2_get_match_data_heapframes_size = @compileError("unable to translate macro: undefined identifier `pcre2_get_match_data_heapframes_size_`");
// /usr/include/pcre2.h:868:9
pub const pcre2_get_match_data_size = @compileError("unable to translate macro: undefined identifier `pcre2_get_match_data_size_`");
// /usr/include/pcre2.h:869:9
pub const pcre2_get_ovector_pointer = @compileError("unable to translate macro: undefined identifier `pcre2_get_ovector_pointer_`");
// /usr/include/pcre2.h:870:9
pub const pcre2_get_ovector_count = @compileError("unable to translate macro: undefined identifier `pcre2_get_ovector_count_`");
// /usr/include/pcre2.h:871:9
pub const pcre2_get_startchar = @compileError("unable to translate macro: undefined identifier `pcre2_get_startchar_`");
// /usr/include/pcre2.h:872:9
pub const pcre2_jit_compile = @compileError("unable to translate macro: undefined identifier `pcre2_jit_compile_`");
// /usr/include/pcre2.h:873:9
pub const pcre2_jit_match = @compileError("unable to translate macro: undefined identifier `pcre2_jit_match_`");
// /usr/include/pcre2.h:874:9
pub const pcre2_jit_free_unused_memory = @compileError("unable to translate macro: undefined identifier `pcre2_jit_free_unused_memory_`");
// /usr/include/pcre2.h:875:9
pub const pcre2_jit_stack_assign = @compileError("unable to translate macro: undefined identifier `pcre2_jit_stack_assign_`");
// /usr/include/pcre2.h:876:9
pub const pcre2_jit_stack_create = @compileError("unable to translate macro: undefined identifier `pcre2_jit_stack_create_`");
// /usr/include/pcre2.h:877:9
pub const pcre2_jit_stack_free = @compileError("unable to translate macro: undefined identifier `pcre2_jit_stack_free_`");
// /usr/include/pcre2.h:878:9
pub const pcre2_maketables = @compileError("unable to translate macro: undefined identifier `pcre2_maketables_`");
// /usr/include/pcre2.h:879:9
pub const pcre2_maketables_free = @compileError("unable to translate macro: undefined identifier `pcre2_maketables_free_`");
// /usr/include/pcre2.h:880:9
pub const pcre2_match = @compileError("unable to translate macro: undefined identifier `pcre2_match_`");
// /usr/include/pcre2.h:881:9
pub const pcre2_match_context_copy = @compileError("unable to translate macro: undefined identifier `pcre2_match_context_copy_`");
// /usr/include/pcre2.h:882:9
pub const pcre2_match_context_create = @compileError("unable to translate macro: undefined identifier `pcre2_match_context_create_`");
// /usr/include/pcre2.h:883:9
pub const pcre2_match_context_free = @compileError("unable to translate macro: undefined identifier `pcre2_match_context_free_`");
// /usr/include/pcre2.h:884:9
pub const pcre2_match_data_create = @compileError("unable to translate macro: undefined identifier `pcre2_match_data_create_`");
// /usr/include/pcre2.h:885:9
pub const pcre2_match_data_create_from_pattern = @compileError("unable to translate macro: undefined identifier `pcre2_match_data_create_from_pattern_`");
// /usr/include/pcre2.h:886:9
pub const pcre2_match_data_free = @compileError("unable to translate macro: undefined identifier `pcre2_match_data_free_`");
// /usr/include/pcre2.h:887:9
pub const pcre2_pattern_convert = @compileError("unable to translate macro: undefined identifier `pcre2_pattern_convert_`");
// /usr/include/pcre2.h:888:9
pub const pcre2_pattern_info = @compileError("unable to translate macro: undefined identifier `pcre2_pattern_info_`");
// /usr/include/pcre2.h:889:9
pub const pcre2_serialize_decode = @compileError("unable to translate macro: undefined identifier `pcre2_serialize_decode_`");
// /usr/include/pcre2.h:890:9
pub const pcre2_serialize_encode = @compileError("unable to translate macro: undefined identifier `pcre2_serialize_encode_`");
// /usr/include/pcre2.h:891:9
pub const pcre2_serialize_free = @compileError("unable to translate macro: undefined identifier `pcre2_serialize_free_`");
// /usr/include/pcre2.h:892:9
pub const pcre2_serialize_get_number_of_codes = @compileError("unable to translate macro: undefined identifier `pcre2_serialize_get_number_of_codes_`");
// /usr/include/pcre2.h:893:9
pub const pcre2_set_bsr = @compileError("unable to translate macro: undefined identifier `pcre2_set_bsr_`");
// /usr/include/pcre2.h:894:9
pub const pcre2_set_callout = @compileError("unable to translate macro: undefined identifier `pcre2_set_callout_`");
// /usr/include/pcre2.h:895:9
pub const pcre2_set_character_tables = @compileError("unable to translate macro: undefined identifier `pcre2_set_character_tables_`");
// /usr/include/pcre2.h:896:9
pub const pcre2_set_compile_extra_options = @compileError("unable to translate macro: undefined identifier `pcre2_set_compile_extra_options_`");
// /usr/include/pcre2.h:897:9
pub const pcre2_set_compile_recursion_guard = @compileError("unable to translate macro: undefined identifier `pcre2_set_compile_recursion_guard_`");
// /usr/include/pcre2.h:898:9
pub const pcre2_set_depth_limit = @compileError("unable to translate macro: undefined identifier `pcre2_set_depth_limit_`");
// /usr/include/pcre2.h:899:9
pub const pcre2_set_glob_escape = @compileError("unable to translate macro: undefined identifier `pcre2_set_glob_escape_`");
// /usr/include/pcre2.h:900:9
pub const pcre2_set_glob_separator = @compileError("unable to translate macro: undefined identifier `pcre2_set_glob_separator_`");
// /usr/include/pcre2.h:901:9
pub const pcre2_set_heap_limit = @compileError("unable to translate macro: undefined identifier `pcre2_set_heap_limit_`");
// /usr/include/pcre2.h:902:9
pub const pcre2_set_match_limit = @compileError("unable to translate macro: undefined identifier `pcre2_set_match_limit_`");
// /usr/include/pcre2.h:903:9
pub const pcre2_set_max_varlookbehind = @compileError("unable to translate macro: undefined identifier `pcre2_set_max_varlookbehind_`");
// /usr/include/pcre2.h:904:9
pub const pcre2_set_max_pattern_length = @compileError("unable to translate macro: undefined identifier `pcre2_set_max_pattern_length_`");
// /usr/include/pcre2.h:905:9
pub const pcre2_set_max_pattern_compiled_length = @compileError("unable to translate macro: undefined identifier `pcre2_set_max_pattern_compiled_length_`");
// /usr/include/pcre2.h:906:9
pub const pcre2_set_newline = @compileError("unable to translate macro: undefined identifier `pcre2_set_newline_`");
// /usr/include/pcre2.h:907:9
pub const pcre2_set_parens_nest_limit = @compileError("unable to translate macro: undefined identifier `pcre2_set_parens_nest_limit_`");
// /usr/include/pcre2.h:908:9
pub const pcre2_set_offset_limit = @compileError("unable to translate macro: undefined identifier `pcre2_set_offset_limit_`");
// /usr/include/pcre2.h:909:9
pub const pcre2_set_substitute_callout = @compileError("unable to translate macro: undefined identifier `pcre2_set_substitute_callout_`");
// /usr/include/pcre2.h:910:9
pub const pcre2_substitute = @compileError("unable to translate macro: undefined identifier `pcre2_substitute_`");
// /usr/include/pcre2.h:911:9
pub const pcre2_substring_copy_byname = @compileError("unable to translate macro: undefined identifier `pcre2_substring_copy_byname_`");
// /usr/include/pcre2.h:912:9
pub const pcre2_substring_copy_bynumber = @compileError("unable to translate macro: undefined identifier `pcre2_substring_copy_bynumber_`");
// /usr/include/pcre2.h:913:9
pub const pcre2_substring_free = @compileError("unable to translate macro: undefined identifier `pcre2_substring_free_`");
// /usr/include/pcre2.h:914:9
pub const pcre2_substring_get_byname = @compileError("unable to translate macro: undefined identifier `pcre2_substring_get_byname_`");
// /usr/include/pcre2.h:915:9
pub const pcre2_substring_get_bynumber = @compileError("unable to translate macro: undefined identifier `pcre2_substring_get_bynumber_`");
// /usr/include/pcre2.h:916:9
pub const pcre2_substring_length_byname = @compileError("unable to translate macro: undefined identifier `pcre2_substring_length_byname_`");
// /usr/include/pcre2.h:917:9
pub const pcre2_substring_length_bynumber = @compileError("unable to translate macro: undefined identifier `pcre2_substring_length_bynumber_`");
// /usr/include/pcre2.h:918:9
pub const pcre2_substring_list_get = @compileError("unable to translate macro: undefined identifier `pcre2_substring_list_get_`");
// /usr/include/pcre2.h:919:9
pub const pcre2_substring_list_free = @compileError("unable to translate macro: undefined identifier `pcre2_substring_list_free_`");
// /usr/include/pcre2.h:920:9
pub const pcre2_substring_nametable_scan = @compileError("unable to translate macro: undefined identifier `pcre2_substring_nametable_scan_`");
// /usr/include/pcre2.h:921:9
pub const pcre2_substring_number_from_name = @compileError("unable to translate macro: undefined identifier `pcre2_substring_number_from_name_`");
// /usr/include/pcre2.h:922:9
pub const pcre2_set_recursion_limit = @compileError("unable to translate macro: undefined identifier `pcre2_set_recursion_limit_`");
// /usr/include/pcre2.h:925:9
pub const pcre2_set_recursion_memory_management = @compileError("unable to translate macro: undefined identifier `pcre2_set_recursion_memory_management_`");
// /usr/include/pcre2.h:928:9
pub const PCRE2_TYPES_STRUCTURES_AND_FUNCTIONS = PCRE2_TYPES_LIST ++ PCRE2_STRUCTURE_LIST ++ PCRE2_GENERAL_INFO_FUNCTIONS ++ PCRE2_GENERAL_CONTEXT_FUNCTIONS ++ PCRE2_COMPILE_CONTEXT_FUNCTIONS ++ PCRE2_CONVERT_CONTEXT_FUNCTIONS ++ PCRE2_CONVERT_FUNCTIONS ++ PCRE2_MATCH_CONTEXT_FUNCTIONS ++ PCRE2_COMPILE_FUNCTIONS ++ PCRE2_PATTERN_INFO_FUNCTIONS ++ PCRE2_MATCH_FUNCTIONS ++ PCRE2_SUBSTRING_FUNCTIONS ++ PCRE2_SERIALIZE_FUNCTIONS ++ PCRE2_SUBSTITUTE_FUNCTION ++ PCRE2_JIT_FUNCTIONS ++ PCRE2_OTHER_FUNCTIONS;
pub const PCRE2_LOCAL_WIDTH = @as(c_int, 8);
pub const NGX_REGEX_NO_MATCHED = PCRE2_ERROR_NOMATCH;
pub const NGX_REGEX_CASELESS = @as(c_int, 0x00000001);
pub const NGX_REGEX_MULTILINE = @as(c_int, 0x00000002);
pub const ngx_regex_exec_n = "pcre2_match()";
pub const _NGX_RADIX_TREE_H_INCLUDED_ = "";
pub const NGX_RADIX_NO_VALUE = @import("std").zig.c_translation.cast(usize, -@as(c_int, 1));
pub const _NGX_TIMES_H_INCLUDED_ = "";
pub const ngx_next_time_n = "mktime()";
pub inline fn ngx_time() @TypeOf(ngx_cached_time.*.sec) {
    return ngx_cached_time.*.sec;
}
pub inline fn ngx_timeofday() [*c]ngx_time_t {
    return @import("std").zig.c_translation.cast([*c]ngx_time_t, ngx_cached_time);
}
pub const _NGX_RWLOCK_H_INCLUDED_ = "";
pub const _NGX_SHMTX_H_INCLUDED_ = "";
pub const _NGX_SLAB_H_INCLUDED_ = "";
pub const _NGX_INET_H_INCLUDED_ = "";
pub const NGX_INET_ADDRSTRLEN = @compileError("unable to translate C expr: unexpected token 'a string literal'");
// src/core/ngx_inet.h:16:9
pub const NGX_INET6_ADDRSTRLEN = @compileError("unable to translate C expr: unexpected token 'a string literal'");
// src/core/ngx_inet.h:17:9
pub const NGX_UNIX_ADDRSTRLEN = @compileError("unable to translate macro: undefined identifier `sun_path`");
// src/core/ngx_inet.h:19:9
pub const NGX_SOCKADDR_STRLEN = NGX_UNIX_ADDRSTRLEN;
pub const NGX_SOCKADDRLEN = @import("std").zig.c_translation.sizeof(ngx_sockaddr_t);
pub const _NGX_CYCLE_H_INCLUDED_ = "";
pub const NGX_CYCLE_POOL_SIZE = NGX_DEFAULT_POOL_SIZE;
pub const NGX_DEBUG_POINTS_STOP = @as(c_int, 1);
pub const NGX_DEBUG_POINTS_ABORT = @as(c_int, 2);
pub inline fn ngx_is_init_cycle(cycle: anytype) @TypeOf(cycle.*.conf_ctx == NULL) {
    _ = &cycle;
    return cycle.*.conf_ctx == NULL;
}
pub const _NGX_RESOLVER_H_INCLUDED_ = "";
pub const NGX_RESOLVE_A = @as(c_int, 1);
pub const NGX_RESOLVE_CNAME = @as(c_int, 5);
pub const NGX_RESOLVE_PTR = @as(c_int, 12);
pub const NGX_RESOLVE_MX = @as(c_int, 15);
pub const NGX_RESOLVE_TXT = @as(c_int, 16);
pub const NGX_RESOLVE_AAAA = @as(c_int, 28);
pub const NGX_RESOLVE_SRV = @as(c_int, 33);
pub const NGX_RESOLVE_DNAME = @as(c_int, 39);
pub const NGX_RESOLVE_FORMERR = @as(c_int, 1);
pub const NGX_RESOLVE_SERVFAIL = @as(c_int, 2);
pub const NGX_RESOLVE_NXDOMAIN = @as(c_int, 3);
pub const NGX_RESOLVE_NOTIMP = @as(c_int, 4);
pub const NGX_RESOLVE_REFUSED = @as(c_int, 5);
pub const NGX_RESOLVE_TIMEDOUT = NGX_ETIMEDOUT;
pub const NGX_NO_RESOLVER = @import("std").zig.c_translation.cast(?*anyopaque, -@as(c_int, 1));
pub const NGX_RESOLVER_MAX_RECURSION = @as(c_int, 50);
pub const _NGX_EVENT_OPENSSL_H_INCLUDED_ = "";
pub const OPENSSL_SUPPRESS_DEPRECATED = "";
pub const OPENSSL_SSL_H = "";
pub const OPENSSL_MACROS_H = "";
pub const OPENSSL_OPENSSLCONF_H = "";
pub const OPENSSL_CONFIGURATION_H = "";
pub const OPENSSL_CONFIGURED_API = @as(c_int, 30400);
pub const OPENSSL_RAND_SEED_OS = "";
pub const OPENSSL_THREADS = "";
pub const OPENSSL_NO_ACVP_TESTS = "";
pub const OPENSSL_NO_ASAN = "";
pub const OPENSSL_NO_BROTLI = "";
pub const OPENSSL_NO_BROTLI_DYNAMIC = "";
pub const OPENSSL_NO_CRYPTO_MDEBUG = "";
pub const OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE = "";
pub const OPENSSL_NO_DEMOS = "";
pub const OPENSSL_NO_DEVCRYPTOENG = "";
pub const OPENSSL_NO_EGD = "";
pub const OPENSSL_NO_EXTERNAL_TESTS = "";
pub const OPENSSL_NO_FIPS_POST = "";
pub const OPENSSL_NO_FIPS_SECURITYCHECKS = "";
pub const OPENSSL_NO_FUZZ_AFL = "";
pub const OPENSSL_NO_FUZZ_LIBFUZZER = "";
pub const OPENSSL_NO_H3DEMO = "";
pub const OPENSSL_NO_JITTER = "";
pub const OPENSSL_NO_MD2 = "";
pub const OPENSSL_NO_MSAN = "";
pub const OPENSSL_NO_PIE = "";
pub const OPENSSL_NO_RC5 = "";
pub const OPENSSL_NO_SCTP = "";
pub const OPENSSL_NO_SSL3 = "";
pub const OPENSSL_NO_SSL3_METHOD = "";
pub const OPENSSL_NO_TFO = "";
pub const OPENSSL_NO_TRACE = "";
pub const OPENSSL_NO_UBSAN = "";
pub const OPENSSL_NO_UNIT_TEST = "";
pub const OPENSSL_NO_UPLINK = "";
pub const OPENSSL_NO_WEAK_SSL_CIPHERS = "";
pub const OPENSSL_NO_WINSTORE = "";
pub const OPENSSL_NO_ZLIB = "";
pub const OPENSSL_NO_ZLIB_DYNAMIC = "";
pub const OPENSSL_NO_ZSTD = "";
pub const OPENSSL_NO_ZSTD_DYNAMIC = "";
pub const OPENSSL_NO_STATIC_ENGINE = "";
pub const SIXTY_FOUR_BIT_LONG = "";
pub const RC4_INT = c_uint;
pub const OPENSSL_NO_COMP_ALG = "";
pub const OPENSSL_OPENSSLV_H = "";
pub const OPENSSL_VERSION_MAJOR = @as(c_int, 3);
pub const OPENSSL_VERSION_MINOR = @as(c_int, 4);
pub const OPENSSL_VERSION_PATCH = @as(c_int, 0);
pub const OPENSSL_VERSION_PRE_RELEASE = "";
pub const OPENSSL_VERSION_BUILD_METADATA = "";
pub const OPENSSL_SHLIB_VERSION = @as(c_int, 3);
pub inline fn OPENSSL_VERSION_PREREQ(maj: anytype, min: anytype) @TypeOf(((OPENSSL_VERSION_MAJOR << @as(c_int, 16)) + OPENSSL_VERSION_MINOR) >= ((maj << @as(c_int, 16)) + min)) {
    _ = &maj;
    _ = &min;
    return ((OPENSSL_VERSION_MAJOR << @as(c_int, 16)) + OPENSSL_VERSION_MINOR) >= ((maj << @as(c_int, 16)) + min);
}
pub const OPENSSL_VERSION_STR = "3.4.0";
pub const OPENSSL_FULL_VERSION_STR = "3.4.0";
pub const OPENSSL_RELEASE_DATE = "22 Oct 2024";
pub const OPENSSL_VERSION_TEXT = "OpenSSL 3.4.0 22 Oct 2024";
pub const _OPENSSL_VERSION_PRE_RELEASE = @as(c_long, 0x0);
pub const OPENSSL_VERSION_NUMBER = (((OPENSSL_VERSION_MAJOR << @as(c_int, 28)) | (OPENSSL_VERSION_MINOR << @as(c_int, 20))) | (OPENSSL_VERSION_PATCH << @as(c_int, 4))) | _OPENSSL_VERSION_PRE_RELEASE;
pub const HEADER_OPENSSLV_H = "";
pub const OPENSSL_MSTR_HELPER = @compileError("unable to translate C expr: unexpected token '#'");
// /usr/include/openssl/macros.h:19:10
pub inline fn OPENSSL_MSTR(x: anytype) @TypeOf(OPENSSL_MSTR_HELPER(x)) {
    _ = &x;
    return OPENSSL_MSTR_HELPER(x);
}
pub const NON_EMPTY_TRANSLATION_UNIT = @compileError("unable to translate macro: undefined identifier `dummy`");
// /usr/include/openssl/macros.h:26:10
pub const OSSL_DEPRECATED = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/macros.h:79:11
pub const OSSL_DEPRECATED_FOR = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/macros.h:80:11
pub const OPENSSL_API_LEVEL = OPENSSL_CONFIGURED_API;
pub const OSSL_DEPRECATEDIN_3_4 = OSSL_DEPRECATED(@as(f64, 3.4));
pub inline fn OSSL_DEPRECATEDIN_3_4_FOR(msg: anytype) @TypeOf(OSSL_DEPRECATED_FOR(@as(f64, 3.4), msg)) {
    _ = &msg;
    return OSSL_DEPRECATED_FOR(@as(f64, 3.4), msg);
}
pub const OSSL_DEPRECATEDIN_3_1 = OSSL_DEPRECATED(@as(f64, 3.1));
pub inline fn OSSL_DEPRECATEDIN_3_1_FOR(msg: anytype) @TypeOf(OSSL_DEPRECATED_FOR(@as(f64, 3.1), msg)) {
    _ = &msg;
    return OSSL_DEPRECATED_FOR(@as(f64, 3.1), msg);
}
pub const OSSL_DEPRECATEDIN_3_0 = OSSL_DEPRECATED(@as(f64, 3.0));
pub inline fn OSSL_DEPRECATEDIN_3_0_FOR(msg: anytype) @TypeOf(OSSL_DEPRECATED_FOR(@as(f64, 3.0), msg)) {
    _ = &msg;
    return OSSL_DEPRECATED_FOR(@as(f64, 3.0), msg);
}
pub const OSSL_DEPRECATEDIN_1_1_1 = @compileError("invalid number suffix: '.1'");
// /usr/include/openssl/macros.h:217:12
pub const OSSL_DEPRECATEDIN_1_1_1_FOR = @compileError("invalid number suffix: '.1'");
// /usr/include/openssl/macros.h:218:12
pub const OSSL_DEPRECATEDIN_1_1_0 = @compileError("invalid number suffix: '.0'");
// /usr/include/openssl/macros.h:228:12
pub const OSSL_DEPRECATEDIN_1_1_0_FOR = @compileError("invalid number suffix: '.0'");
// /usr/include/openssl/macros.h:229:12
pub const OSSL_DEPRECATEDIN_1_0_2 = @compileError("invalid number suffix: '.2'");
// /usr/include/openssl/macros.h:239:12
pub const OSSL_DEPRECATEDIN_1_0_2_FOR = @compileError("invalid number suffix: '.2'");
// /usr/include/openssl/macros.h:240:12
pub const OSSL_DEPRECATEDIN_1_0_1 = @compileError("invalid number suffix: '.1'");
// /usr/include/openssl/macros.h:250:12
pub const OSSL_DEPRECATEDIN_1_0_1_FOR = @compileError("invalid number suffix: '.1'");
// /usr/include/openssl/macros.h:251:12
pub const OSSL_DEPRECATEDIN_1_0_0 = @compileError("invalid number suffix: '.0'");
// /usr/include/openssl/macros.h:261:12
pub const OSSL_DEPRECATEDIN_1_0_0_FOR = @compileError("invalid number suffix: '.0'");
// /usr/include/openssl/macros.h:262:12
pub const OSSL_DEPRECATEDIN_0_9_8 = @compileError("invalid number suffix: '.8'");
// /usr/include/openssl/macros.h:272:12
pub const OSSL_DEPRECATEDIN_0_9_8_FOR = @compileError("invalid number suffix: '.8'");
// /usr/include/openssl/macros.h:273:12
pub const OPENSSL_FILE = @compileError("unable to translate macro: undefined identifier `__FILE__`");
// /usr/include/openssl/macros.h:291:12
pub const OPENSSL_LINE = @compileError("unable to translate macro: undefined identifier `__LINE__`");
// /usr/include/openssl/macros.h:292:12
pub const OPENSSL_FUNC = @compileError("unable to translate C expr: unexpected token 'an identifier'");
// /usr/include/openssl/macros.h:312:13
pub const OSSL_CRYPTO_ALLOC = @compileError("unable to translate macro: undefined identifier `__malloc__`");
// /usr/include/openssl/macros.h:330:12
pub const HEADER_SSL_H = "";
pub const OPENSSL_E_OS2_H = "";
pub const HEADER_E_OS2_H = "";
pub const OPENSSL_SYS_UNIX = "";
pub const OPENSSL_SYS_LINUX = "";
pub const OPENSSL_EXPORT = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/e_os2.h:183:11
pub const OPENSSL_EXTERN = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/e_os2.h:184:11
pub const ossl_ssize_t = isize;
pub const OSSL_SSIZE_MAX = SSIZE_MAX;
pub const __owur = "";
pub const OPENSSL_NO_INTTYPES_H = "";
pub const OPENSSL_NO_STDINT_H = "";
pub const ossl_inline = @compileError("unable to translate C expr: unexpected token 'inline'");
// /usr/include/openssl/e_os2.h:274:12
pub const ossl_noreturn = @compileError("unable to translate C expr: unexpected token '_Noreturn'");
// /usr/include/openssl/e_os2.h:293:11
pub const ossl_unused = @compileError("unable to translate macro: undefined identifier `unused`");
// /usr/include/openssl/e_os2.h:302:11
pub const OPENSSL_E_OSTIME_H = "";
pub const OPENSSL_COMP_H = "";
pub const HEADER_COMP_H = "";
pub const OPENSSL_CRYPTO_H = "";
pub const HEADER_CRYPTO_H = "";
pub const OPENSSL_SAFESTACK_H = "";
pub const HEADER_SAFESTACK_H = "";
pub const OPENSSL_STACK_H = "";
pub const HEADER_STACK_H = "";
pub const _STACK = OPENSSL_STACK;
pub const sk_num = OPENSSL_sk_num;
pub const sk_value = OPENSSL_sk_value;
pub const sk_set = OPENSSL_sk_set;
pub const sk_new = OPENSSL_sk_new;
pub const sk_new_null = OPENSSL_sk_new_null;
pub const sk_free = OPENSSL_sk_free;
pub const sk_pop_free = OPENSSL_sk_pop_free;
pub const sk_deep_copy = OPENSSL_sk_deep_copy;
pub const sk_insert = OPENSSL_sk_insert;
pub const sk_delete = OPENSSL_sk_delete;
pub const sk_delete_ptr = OPENSSL_sk_delete_ptr;
pub const sk_find = OPENSSL_sk_find;
pub const sk_find_ex = OPENSSL_sk_find_ex;
pub const sk_push = OPENSSL_sk_push;
pub const sk_unshift = OPENSSL_sk_unshift;
pub const sk_shift = OPENSSL_sk_shift;
pub const sk_pop = OPENSSL_sk_pop;
pub const sk_zero = OPENSSL_sk_zero;
pub const sk_set_cmp_func = OPENSSL_sk_set_cmp_func;
pub const sk_dup = OPENSSL_sk_dup;
pub const sk_sort = OPENSSL_sk_sort;
pub const sk_is_sorted = OPENSSL_sk_is_sorted;
pub const STACK_OF = @compileError("unable to translate macro: undefined identifier `stack_st_`");
// /usr/include/openssl/safestack.h:31:10
pub const SKM_DEFINE_STACK_OF_INTERNAL = @compileError("unable to translate macro: undefined identifier `sk_`");
// /usr/include/openssl/safestack.h:34:10
pub const SKM_DEFINE_STACK_OF = @compileError("unable to translate macro: undefined identifier `sk_`");
// /usr/include/openssl/safestack.h:64:10
pub inline fn DEFINE_STACK_OF(t: anytype) @TypeOf(SKM_DEFINE_STACK_OF(t, t, t)) {
    _ = &t;
    return SKM_DEFINE_STACK_OF(t, t, t);
}
pub const DEFINE_STACK_OF_CONST = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/safestack.h:176:10
pub inline fn DEFINE_SPECIAL_STACK_OF(t1: anytype, t2: anytype) @TypeOf(SKM_DEFINE_STACK_OF(t1, t2, t2)) {
    _ = &t1;
    _ = &t2;
    return SKM_DEFINE_STACK_OF(t1, t2, t2);
}
pub const DEFINE_SPECIAL_STACK_OF_CONST = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/safestack.h:178:10
pub inline fn sk_OPENSSL_STRING_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_OPENSSL_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_OPENSSL_STRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_STRING_value(sk: anytype, idx: anytype) [*c]u8 {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_value(ossl_check_const_OPENSSL_STRING_sk_type(sk), idx));
}
pub const sk_OPENSSL_STRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:208:9
pub const sk_OPENSSL_STRING_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:209:9
pub const sk_OPENSSL_STRING_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:210:9
pub inline fn sk_OPENSSL_STRING_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_OPENSSL_STRING_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_OPENSSL_STRING_sk_type(sk), n);
}
pub inline fn sk_OPENSSL_STRING_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_OPENSSL_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_OPENSSL_STRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_STRING_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_OPENSSL_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_OPENSSL_STRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_STRING_delete(sk: anytype, i: anytype) [*c]u8 {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_delete(ossl_check_OPENSSL_STRING_sk_type(sk), i));
}
pub inline fn sk_OPENSSL_STRING_delete_ptr(sk: anytype, ptr: anytype) [*c]u8 {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_delete_ptr(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr)));
}
pub inline fn sk_OPENSSL_STRING_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr));
}
pub inline fn sk_OPENSSL_STRING_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr));
}
pub inline fn sk_OPENSSL_STRING_pop(sk: anytype) [*c]u8 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_pop(ossl_check_OPENSSL_STRING_sk_type(sk)));
}
pub inline fn sk_OPENSSL_STRING_shift(sk: anytype) [*c]u8 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_shift(ossl_check_OPENSSL_STRING_sk_type(sk)));
}
pub inline fn sk_OPENSSL_STRING_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_freefunc_type(freefunc));
}
pub inline fn sk_OPENSSL_STRING_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr), idx);
}
pub inline fn sk_OPENSSL_STRING_set(sk: anytype, idx: anytype, ptr: anytype) [*c]u8 {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]u8, OPENSSL_sk_set(ossl_check_OPENSSL_STRING_sk_type(sk), idx, ossl_check_OPENSSL_STRING_type(ptr)));
}
pub inline fn sk_OPENSSL_STRING_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr));
}
pub inline fn sk_OPENSSL_STRING_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr));
}
pub inline fn sk_OPENSSL_STRING_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_type(ptr), pnum);
}
pub inline fn sk_OPENSSL_STRING_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_OPENSSL_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_OPENSSL_STRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_STRING_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_STRING_sk_type(sk));
}
pub const sk_OPENSSL_STRING_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:228:9
pub const sk_OPENSSL_STRING_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:229:9
pub inline fn sk_OPENSSL_STRING_set_cmp_func(sk: anytype, cmp: anytype) sk_OPENSSL_STRING_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_OPENSSL_STRING_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_OPENSSL_STRING_sk_type(sk), ossl_check_OPENSSL_STRING_compfunc_type(cmp)));
}
pub inline fn sk_OPENSSL_CSTRING_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_OPENSSL_CSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_OPENSSL_CSTRING_sk_type(sk));
}
pub const sk_OPENSSL_CSTRING_value = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/safestack.h:233:9
pub const sk_OPENSSL_CSTRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:234:9
pub const sk_OPENSSL_CSTRING_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:235:9
pub const sk_OPENSSL_CSTRING_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:236:9
pub inline fn sk_OPENSSL_CSTRING_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_OPENSSL_CSTRING_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_OPENSSL_CSTRING_sk_type(sk), n);
}
pub inline fn sk_OPENSSL_CSTRING_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_OPENSSL_CSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_OPENSSL_CSTRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_CSTRING_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_OPENSSL_CSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_OPENSSL_CSTRING_sk_type(sk));
}
pub const sk_OPENSSL_CSTRING_delete = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/safestack.h:240:9
pub const sk_OPENSSL_CSTRING_delete_ptr = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/safestack.h:241:9
pub inline fn sk_OPENSSL_CSTRING_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr));
}
pub inline fn sk_OPENSSL_CSTRING_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr));
}
pub const sk_OPENSSL_CSTRING_pop = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/safestack.h:244:9
pub const sk_OPENSSL_CSTRING_shift = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/safestack.h:245:9
pub inline fn sk_OPENSSL_CSTRING_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_freefunc_type(freefunc));
}
pub inline fn sk_OPENSSL_CSTRING_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr), idx);
}
pub const sk_OPENSSL_CSTRING_set = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/safestack.h:248:9
pub inline fn sk_OPENSSL_CSTRING_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr));
}
pub inline fn sk_OPENSSL_CSTRING_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr));
}
pub inline fn sk_OPENSSL_CSTRING_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_type(ptr), pnum);
}
pub inline fn sk_OPENSSL_CSTRING_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_OPENSSL_CSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_OPENSSL_CSTRING_sk_type(sk));
}
pub inline fn sk_OPENSSL_CSTRING_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_CSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_CSTRING_sk_type(sk));
}
pub const sk_OPENSSL_CSTRING_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:254:9
pub const sk_OPENSSL_CSTRING_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:255:9
pub inline fn sk_OPENSSL_CSTRING_set_cmp_func(sk: anytype, cmp: anytype) sk_OPENSSL_CSTRING_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_OPENSSL_CSTRING_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_OPENSSL_CSTRING_sk_type(sk), ossl_check_OPENSSL_CSTRING_compfunc_type(cmp)));
}
pub inline fn sk_OPENSSL_BLOCK_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_OPENSSL_BLOCK_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_OPENSSL_BLOCK_sk_type(sk));
}
pub inline fn sk_OPENSSL_BLOCK_value(sk: anytype, idx: anytype) ?*anyopaque {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_value(ossl_check_const_OPENSSL_BLOCK_sk_type(sk), idx));
}
pub const sk_OPENSSL_BLOCK_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:268:9
pub const sk_OPENSSL_BLOCK_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:269:9
pub const sk_OPENSSL_BLOCK_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:270:9
pub inline fn sk_OPENSSL_BLOCK_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_OPENSSL_BLOCK_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_OPENSSL_BLOCK_sk_type(sk), n);
}
pub inline fn sk_OPENSSL_BLOCK_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_OPENSSL_BLOCK_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_OPENSSL_BLOCK_sk_type(sk));
}
pub inline fn sk_OPENSSL_BLOCK_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_OPENSSL_BLOCK_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_OPENSSL_BLOCK_sk_type(sk));
}
pub inline fn sk_OPENSSL_BLOCK_delete(sk: anytype, i: anytype) ?*anyopaque {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_delete(ossl_check_OPENSSL_BLOCK_sk_type(sk), i));
}
pub inline fn sk_OPENSSL_BLOCK_delete_ptr(sk: anytype, ptr: anytype) ?*anyopaque {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_delete_ptr(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr)));
}
pub inline fn sk_OPENSSL_BLOCK_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr));
}
pub inline fn sk_OPENSSL_BLOCK_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr));
}
pub inline fn sk_OPENSSL_BLOCK_pop(sk: anytype) ?*anyopaque {
    _ = &sk;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_pop(ossl_check_OPENSSL_BLOCK_sk_type(sk)));
}
pub inline fn sk_OPENSSL_BLOCK_shift(sk: anytype) ?*anyopaque {
    _ = &sk;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_shift(ossl_check_OPENSSL_BLOCK_sk_type(sk)));
}
pub inline fn sk_OPENSSL_BLOCK_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_freefunc_type(freefunc));
}
pub inline fn sk_OPENSSL_BLOCK_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr), idx);
}
pub inline fn sk_OPENSSL_BLOCK_set(sk: anytype, idx: anytype, ptr: anytype) ?*anyopaque {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_set(ossl_check_OPENSSL_BLOCK_sk_type(sk), idx, ossl_check_OPENSSL_BLOCK_type(ptr)));
}
pub inline fn sk_OPENSSL_BLOCK_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr));
}
pub inline fn sk_OPENSSL_BLOCK_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr));
}
pub inline fn sk_OPENSSL_BLOCK_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_type(ptr), pnum);
}
pub inline fn sk_OPENSSL_BLOCK_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_OPENSSL_BLOCK_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_OPENSSL_BLOCK_sk_type(sk));
}
pub inline fn sk_OPENSSL_BLOCK_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_BLOCK_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_OPENSSL_BLOCK_sk_type(sk));
}
pub const sk_OPENSSL_BLOCK_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:288:9
pub const sk_OPENSSL_BLOCK_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/safestack.h:289:9
pub inline fn sk_OPENSSL_BLOCK_set_cmp_func(sk: anytype, cmp: anytype) sk_OPENSSL_BLOCK_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_OPENSSL_BLOCK_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_OPENSSL_BLOCK_sk_type(sk), ossl_check_OPENSSL_BLOCK_compfunc_type(cmp)));
}
pub const OPENSSL_TYPES_H = "";
pub const OSSL_FUTURE_CONST = "";
pub const OPENSSL_CRYPTOERR_H = "";
pub const OPENSSL_SYMHACKS_H = "";
pub const HEADER_SYMHACKS_H = "";
pub const OPENSSL_CRYPTOERR_LEGACY_H = "";
pub const ASN1_F_A2D_ASN1_OBJECT = @as(c_int, 0);
pub const ASN1_F_A2I_ASN1_INTEGER = @as(c_int, 0);
pub const ASN1_F_A2I_ASN1_STRING = @as(c_int, 0);
pub const ASN1_F_APPEND_EXP = @as(c_int, 0);
pub const ASN1_F_ASN1_BIO_INIT = @as(c_int, 0);
pub const ASN1_F_ASN1_BIT_STRING_SET_BIT = @as(c_int, 0);
pub const ASN1_F_ASN1_CB = @as(c_int, 0);
pub const ASN1_F_ASN1_CHECK_TLEN = @as(c_int, 0);
pub const ASN1_F_ASN1_COLLECT = @as(c_int, 0);
pub const ASN1_F_ASN1_D2I_EX_PRIMITIVE = @as(c_int, 0);
pub const ASN1_F_ASN1_D2I_FP = @as(c_int, 0);
pub const ASN1_F_ASN1_D2I_READ_BIO = @as(c_int, 0);
pub const ASN1_F_ASN1_DIGEST = @as(c_int, 0);
pub const ASN1_F_ASN1_DO_ADB = @as(c_int, 0);
pub const ASN1_F_ASN1_DO_LOCK = @as(c_int, 0);
pub const ASN1_F_ASN1_DUP = @as(c_int, 0);
pub const ASN1_F_ASN1_ENC_SAVE = @as(c_int, 0);
pub const ASN1_F_ASN1_EX_C2I = @as(c_int, 0);
pub const ASN1_F_ASN1_FIND_END = @as(c_int, 0);
pub const ASN1_F_ASN1_GENERALIZEDTIME_ADJ = @as(c_int, 0);
pub const ASN1_F_ASN1_GENERATE_V3 = @as(c_int, 0);
pub const ASN1_F_ASN1_GET_INT64 = @as(c_int, 0);
pub const ASN1_F_ASN1_GET_OBJECT = @as(c_int, 0);
pub const ASN1_F_ASN1_GET_UINT64 = @as(c_int, 0);
pub const ASN1_F_ASN1_I2D_BIO = @as(c_int, 0);
pub const ASN1_F_ASN1_I2D_FP = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_D2I_FP = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_DUP = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_EMBED_D2I = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_EMBED_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_FLAGS_I2D = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_I2D_BIO = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_I2D_FP = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_PACK = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_SIGN = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_SIGN_CTX = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_UNPACK = @as(c_int, 0);
pub const ASN1_F_ASN1_ITEM_VERIFY = @as(c_int, 0);
pub const ASN1_F_ASN1_MBSTRING_NCOPY = @as(c_int, 0);
pub const ASN1_F_ASN1_OBJECT_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_OUTPUT_DATA = @as(c_int, 0);
pub const ASN1_F_ASN1_PCTX_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_PRIMITIVE_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_SCTX_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_SIGN = @as(c_int, 0);
pub const ASN1_F_ASN1_STR2TYPE = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_GET_INT64 = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_GET_UINT64 = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_SET = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_TABLE_ADD = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_TO_BN = @as(c_int, 0);
pub const ASN1_F_ASN1_STRING_TYPE_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_TEMPLATE_EX_D2I = @as(c_int, 0);
pub const ASN1_F_ASN1_TEMPLATE_NEW = @as(c_int, 0);
pub const ASN1_F_ASN1_TEMPLATE_NOEXP_D2I = @as(c_int, 0);
pub const ASN1_F_ASN1_TIME_ADJ = @as(c_int, 0);
pub const ASN1_F_ASN1_TYPE_GET_INT_OCTETSTRING = @as(c_int, 0);
pub const ASN1_F_ASN1_TYPE_GET_OCTETSTRING = @as(c_int, 0);
pub const ASN1_F_ASN1_UTCTIME_ADJ = @as(c_int, 0);
pub const ASN1_F_ASN1_VERIFY = @as(c_int, 0);
pub const ASN1_F_B64_READ_ASN1 = @as(c_int, 0);
pub const ASN1_F_B64_WRITE_ASN1 = @as(c_int, 0);
pub const ASN1_F_BIO_NEW_NDEF = @as(c_int, 0);
pub const ASN1_F_BITSTR_CB = @as(c_int, 0);
pub const ASN1_F_BN_TO_ASN1_STRING = @as(c_int, 0);
pub const ASN1_F_C2I_ASN1_BIT_STRING = @as(c_int, 0);
pub const ASN1_F_C2I_ASN1_INTEGER = @as(c_int, 0);
pub const ASN1_F_C2I_ASN1_OBJECT = @as(c_int, 0);
pub const ASN1_F_C2I_IBUF = @as(c_int, 0);
pub const ASN1_F_C2I_UINT64_INT = @as(c_int, 0);
pub const ASN1_F_COLLECT_DATA = @as(c_int, 0);
pub const ASN1_F_D2I_ASN1_OBJECT = @as(c_int, 0);
pub const ASN1_F_D2I_ASN1_UINTEGER = @as(c_int, 0);
pub const ASN1_F_D2I_AUTOPRIVATEKEY = @as(c_int, 0);
pub const ASN1_F_D2I_PRIVATEKEY = @as(c_int, 0);
pub const ASN1_F_D2I_PUBLICKEY = @as(c_int, 0);
pub const ASN1_F_DO_BUF = @as(c_int, 0);
pub const ASN1_F_DO_CREATE = @as(c_int, 0);
pub const ASN1_F_DO_DUMP = @as(c_int, 0);
pub const ASN1_F_DO_TCREATE = @as(c_int, 0);
pub const ASN1_F_I2A_ASN1_OBJECT = @as(c_int, 0);
pub const ASN1_F_I2D_ASN1_BIO_STREAM = @as(c_int, 0);
pub const ASN1_F_I2D_ASN1_OBJECT = @as(c_int, 0);
pub const ASN1_F_I2D_DSA_PUBKEY = @as(c_int, 0);
pub const ASN1_F_I2D_EC_PUBKEY = @as(c_int, 0);
pub const ASN1_F_I2D_PRIVATEKEY = @as(c_int, 0);
pub const ASN1_F_I2D_PUBLICKEY = @as(c_int, 0);
pub const ASN1_F_I2D_RSA_PUBKEY = @as(c_int, 0);
pub const ASN1_F_LONG_C2I = @as(c_int, 0);
pub const ASN1_F_NDEF_PREFIX = @as(c_int, 0);
pub const ASN1_F_NDEF_SUFFIX = @as(c_int, 0);
pub const ASN1_F_OID_MODULE_INIT = @as(c_int, 0);
pub const ASN1_F_PARSE_TAGGING = @as(c_int, 0);
pub const ASN1_F_PKCS5_PBE2_SET_IV = @as(c_int, 0);
pub const ASN1_F_PKCS5_PBE2_SET_SCRYPT = @as(c_int, 0);
pub const ASN1_F_PKCS5_PBE_SET = @as(c_int, 0);
pub const ASN1_F_PKCS5_PBE_SET0_ALGOR = @as(c_int, 0);
pub const ASN1_F_PKCS5_PBKDF2_SET = @as(c_int, 0);
pub const ASN1_F_PKCS5_SCRYPT_SET = @as(c_int, 0);
pub const ASN1_F_SMIME_READ_ASN1 = @as(c_int, 0);
pub const ASN1_F_SMIME_TEXT = @as(c_int, 0);
pub const ASN1_F_STABLE_GET = @as(c_int, 0);
pub const ASN1_F_STBL_MODULE_INIT = @as(c_int, 0);
pub const ASN1_F_UINT32_C2I = @as(c_int, 0);
pub const ASN1_F_UINT32_NEW = @as(c_int, 0);
pub const ASN1_F_UINT64_C2I = @as(c_int, 0);
pub const ASN1_F_UINT64_NEW = @as(c_int, 0);
pub const ASN1_F_X509_CRL_ADD0_REVOKED = @as(c_int, 0);
pub const ASN1_F_X509_INFO_NEW = @as(c_int, 0);
pub const ASN1_F_X509_NAME_ENCODE = @as(c_int, 0);
pub const ASN1_F_X509_NAME_EX_D2I = @as(c_int, 0);
pub const ASN1_F_X509_NAME_EX_NEW = @as(c_int, 0);
pub const ASN1_F_X509_PKEY_NEW = @as(c_int, 0);
pub const ASYNC_F_ASYNC_CTX_NEW = @as(c_int, 0);
pub const ASYNC_F_ASYNC_INIT_THREAD = @as(c_int, 0);
pub const ASYNC_F_ASYNC_JOB_NEW = @as(c_int, 0);
pub const ASYNC_F_ASYNC_PAUSE_JOB = @as(c_int, 0);
pub const ASYNC_F_ASYNC_START_FUNC = @as(c_int, 0);
pub const ASYNC_F_ASYNC_START_JOB = @as(c_int, 0);
pub const ASYNC_F_ASYNC_WAIT_CTX_SET_WAIT_FD = @as(c_int, 0);
pub const BIO_F_ACPT_STATE = @as(c_int, 0);
pub const BIO_F_ADDRINFO_WRAP = @as(c_int, 0);
pub const BIO_F_ADDR_STRINGS = @as(c_int, 0);
pub const BIO_F_BIO_ACCEPT = @as(c_int, 0);
pub const BIO_F_BIO_ACCEPT_EX = @as(c_int, 0);
pub const BIO_F_BIO_ACCEPT_NEW = @as(c_int, 0);
pub const BIO_F_BIO_ADDR_NEW = @as(c_int, 0);
pub const BIO_F_BIO_BIND = @as(c_int, 0);
pub const BIO_F_BIO_CALLBACK_CTRL = @as(c_int, 0);
pub const BIO_F_BIO_CONNECT = @as(c_int, 0);
pub const BIO_F_BIO_CONNECT_NEW = @as(c_int, 0);
pub const BIO_F_BIO_CTRL = @as(c_int, 0);
pub const BIO_F_BIO_GETS = @as(c_int, 0);
pub const BIO_F_BIO_GET_HOST_IP = @as(c_int, 0);
pub const BIO_F_BIO_GET_NEW_INDEX = @as(c_int, 0);
pub const BIO_F_BIO_GET_PORT = @as(c_int, 0);
pub const BIO_F_BIO_LISTEN = @as(c_int, 0);
pub const BIO_F_BIO_LOOKUP = @as(c_int, 0);
pub const BIO_F_BIO_LOOKUP_EX = @as(c_int, 0);
pub const BIO_F_BIO_MAKE_PAIR = @as(c_int, 0);
pub const BIO_F_BIO_METH_NEW = @as(c_int, 0);
pub const BIO_F_BIO_NEW = @as(c_int, 0);
pub const BIO_F_BIO_NEW_DGRAM_SCTP = @as(c_int, 0);
pub const BIO_F_BIO_NEW_FILE = @as(c_int, 0);
pub const BIO_F_BIO_NEW_MEM_BUF = @as(c_int, 0);
pub const BIO_F_BIO_NREAD = @as(c_int, 0);
pub const BIO_F_BIO_NREAD0 = @as(c_int, 0);
pub const BIO_F_BIO_NWRITE = @as(c_int, 0);
pub const BIO_F_BIO_NWRITE0 = @as(c_int, 0);
pub const BIO_F_BIO_PARSE_HOSTSERV = @as(c_int, 0);
pub const BIO_F_BIO_PUTS = @as(c_int, 0);
pub const BIO_F_BIO_READ = @as(c_int, 0);
pub const BIO_F_BIO_READ_EX = @as(c_int, 0);
pub const BIO_F_BIO_READ_INTERN = @as(c_int, 0);
pub const BIO_F_BIO_SOCKET = @as(c_int, 0);
pub const BIO_F_BIO_SOCKET_NBIO = @as(c_int, 0);
pub const BIO_F_BIO_SOCK_INFO = @as(c_int, 0);
pub const BIO_F_BIO_SOCK_INIT = @as(c_int, 0);
pub const BIO_F_BIO_WRITE = @as(c_int, 0);
pub const BIO_F_BIO_WRITE_EX = @as(c_int, 0);
pub const BIO_F_BIO_WRITE_INTERN = @as(c_int, 0);
pub const BIO_F_BUFFER_CTRL = @as(c_int, 0);
pub const BIO_F_CONN_CTRL = @as(c_int, 0);
pub const BIO_F_CONN_STATE = @as(c_int, 0);
pub const BIO_F_DGRAM_SCTP_NEW = @as(c_int, 0);
pub const BIO_F_DGRAM_SCTP_READ = @as(c_int, 0);
pub const BIO_F_DGRAM_SCTP_WRITE = @as(c_int, 0);
pub const BIO_F_DOAPR_OUTCH = @as(c_int, 0);
pub const BIO_F_FILE_CTRL = @as(c_int, 0);
pub const BIO_F_FILE_READ = @as(c_int, 0);
pub const BIO_F_LINEBUFFER_CTRL = @as(c_int, 0);
pub const BIO_F_LINEBUFFER_NEW = @as(c_int, 0);
pub const BIO_F_MEM_WRITE = @as(c_int, 0);
pub const BIO_F_NBIOF_NEW = @as(c_int, 0);
pub const BIO_F_SLG_WRITE = @as(c_int, 0);
pub const BIO_F_SSL_NEW = @as(c_int, 0);
pub const BN_F_BNRAND = @as(c_int, 0);
pub const BN_F_BNRAND_RANGE = @as(c_int, 0);
pub const BN_F_BN_BLINDING_CONVERT_EX = @as(c_int, 0);
pub const BN_F_BN_BLINDING_CREATE_PARAM = @as(c_int, 0);
pub const BN_F_BN_BLINDING_INVERT_EX = @as(c_int, 0);
pub const BN_F_BN_BLINDING_NEW = @as(c_int, 0);
pub const BN_F_BN_BLINDING_UPDATE = @as(c_int, 0);
pub const BN_F_BN_BN2DEC = @as(c_int, 0);
pub const BN_F_BN_BN2HEX = @as(c_int, 0);
pub const BN_F_BN_COMPUTE_WNAF = @as(c_int, 0);
pub const BN_F_BN_CTX_GET = @as(c_int, 0);
pub const BN_F_BN_CTX_NEW = @as(c_int, 0);
pub const BN_F_BN_CTX_START = @as(c_int, 0);
pub const BN_F_BN_DIV = @as(c_int, 0);
pub const BN_F_BN_DIV_RECP = @as(c_int, 0);
pub const BN_F_BN_EXP = @as(c_int, 0);
pub const BN_F_BN_EXPAND_INTERNAL = @as(c_int, 0);
pub const BN_F_BN_GENCB_NEW = @as(c_int, 0);
pub const BN_F_BN_GENERATE_DSA_NONCE = @as(c_int, 0);
pub const BN_F_BN_GENERATE_PRIME_EX = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_EXP = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_MUL = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_SOLVE_QUAD_ARR = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_SQR = @as(c_int, 0);
pub const BN_F_BN_GF2M_MOD_SQRT = @as(c_int, 0);
pub const BN_F_BN_LSHIFT = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP2_MONT = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP_MONT = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP_MONT_CONSTTIME = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP_MONT_WORD = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP_RECP = @as(c_int, 0);
pub const BN_F_BN_MOD_EXP_SIMPLE = @as(c_int, 0);
pub const BN_F_BN_MOD_INVERSE = @as(c_int, 0);
pub const BN_F_BN_MOD_INVERSE_NO_BRANCH = @as(c_int, 0);
pub const BN_F_BN_MOD_LSHIFT_QUICK = @as(c_int, 0);
pub const BN_F_BN_MOD_SQRT = @as(c_int, 0);
pub const BN_F_BN_MONT_CTX_NEW = @as(c_int, 0);
pub const BN_F_BN_MPI2BN = @as(c_int, 0);
pub const BN_F_BN_NEW = @as(c_int, 0);
pub const BN_F_BN_POOL_GET = @as(c_int, 0);
pub const BN_F_BN_RAND = @as(c_int, 0);
pub const BN_F_BN_RAND_RANGE = @as(c_int, 0);
pub const BN_F_BN_RECP_CTX_NEW = @as(c_int, 0);
pub const BN_F_BN_RSHIFT = @as(c_int, 0);
pub const BN_F_BN_SET_WORDS = @as(c_int, 0);
pub const BN_F_BN_STACK_PUSH = @as(c_int, 0);
pub const BN_F_BN_USUB = @as(c_int, 0);
pub const BUF_F_BUF_MEM_GROW = @as(c_int, 0);
pub const BUF_F_BUF_MEM_GROW_CLEAN = @as(c_int, 0);
pub const BUF_F_BUF_MEM_NEW = @as(c_int, 0);
pub const CMS_F_CHECK_CONTENT = @as(c_int, 0);
pub const CMS_F_CMS_ADD0_CERT = @as(c_int, 0);
pub const CMS_F_CMS_ADD0_RECIPIENT_KEY = @as(c_int, 0);
pub const CMS_F_CMS_ADD0_RECIPIENT_PASSWORD = @as(c_int, 0);
pub const CMS_F_CMS_ADD1_RECEIPTREQUEST = @as(c_int, 0);
pub const CMS_F_CMS_ADD1_RECIPIENT_CERT = @as(c_int, 0);
pub const CMS_F_CMS_ADD1_SIGNER = @as(c_int, 0);
pub const CMS_F_CMS_ADD1_SIGNINGTIME = @as(c_int, 0);
pub const CMS_F_CMS_COMPRESS = @as(c_int, 0);
pub const CMS_F_CMS_COMPRESSEDDATA_CREATE = @as(c_int, 0);
pub const CMS_F_CMS_COMPRESSEDDATA_INIT_BIO = @as(c_int, 0);
pub const CMS_F_CMS_COPY_CONTENT = @as(c_int, 0);
pub const CMS_F_CMS_COPY_MESSAGEDIGEST = @as(c_int, 0);
pub const CMS_F_CMS_DATA = @as(c_int, 0);
pub const CMS_F_CMS_DATAFINAL = @as(c_int, 0);
pub const CMS_F_CMS_DATAINIT = @as(c_int, 0);
pub const CMS_F_CMS_DECRYPT = @as(c_int, 0);
pub const CMS_F_CMS_DECRYPT_SET1_KEY = @as(c_int, 0);
pub const CMS_F_CMS_DECRYPT_SET1_PASSWORD = @as(c_int, 0);
pub const CMS_F_CMS_DECRYPT_SET1_PKEY = @as(c_int, 0);
pub const CMS_F_CMS_DIGESTALGORITHM_FIND_CTX = @as(c_int, 0);
pub const CMS_F_CMS_DIGESTALGORITHM_INIT_BIO = @as(c_int, 0);
pub const CMS_F_CMS_DIGESTEDDATA_DO_FINAL = @as(c_int, 0);
pub const CMS_F_CMS_DIGEST_VERIFY = @as(c_int, 0);
pub const CMS_F_CMS_ENCODE_RECEIPT = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPTEDCONTENT_INIT = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPTEDCONTENT_INIT_BIO = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPTEDDATA_DECRYPT = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPTEDDATA_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_ENCRYPTEDDATA_SET1_KEY = @as(c_int, 0);
pub const CMS_F_CMS_ENVELOPEDDATA_CREATE = @as(c_int, 0);
pub const CMS_F_CMS_ENVELOPEDDATA_INIT_BIO = @as(c_int, 0);
pub const CMS_F_CMS_ENVELOPED_DATA_INIT = @as(c_int, 0);
pub const CMS_F_CMS_ENV_ASN1_CTRL = @as(c_int, 0);
pub const CMS_F_CMS_FINAL = @as(c_int, 0);
pub const CMS_F_CMS_GET0_CERTIFICATE_CHOICES = @as(c_int, 0);
pub const CMS_F_CMS_GET0_CONTENT = @as(c_int, 0);
pub const CMS_F_CMS_GET0_ECONTENT_TYPE = @as(c_int, 0);
pub const CMS_F_CMS_GET0_ENVELOPED = @as(c_int, 0);
pub const CMS_F_CMS_GET0_REVOCATION_CHOICES = @as(c_int, 0);
pub const CMS_F_CMS_GET0_SIGNED = @as(c_int, 0);
pub const CMS_F_CMS_MSGSIGDIGEST_ADD1 = @as(c_int, 0);
pub const CMS_F_CMS_RECEIPTREQUEST_CREATE0 = @as(c_int, 0);
pub const CMS_F_CMS_RECEIPT_VERIFY = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_DECRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KARI_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ALG = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KARI_GET0_ORIG_ID = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KARI_GET0_REKS = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KARI_ORIG_ID_CMP = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_DECRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_GET0_ID = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KEKRI_ID_CMP = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_CERT_CMP = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_DECRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_ENCRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_ALGS = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_KTRI_GET0_SIGNER_ID = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_PWRI_CRYPT = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_SET0_KEY = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_SET0_PASSWORD = @as(c_int, 0);
pub const CMS_F_CMS_RECIPIENTINFO_SET0_PKEY = @as(c_int, 0);
pub const CMS_F_CMS_SD_ASN1_CTRL = @as(c_int, 0);
pub const CMS_F_CMS_SET1_IAS = @as(c_int, 0);
pub const CMS_F_CMS_SET1_KEYID = @as(c_int, 0);
pub const CMS_F_CMS_SET1_SIGNERIDENTIFIER = @as(c_int, 0);
pub const CMS_F_CMS_SET_DETACHED = @as(c_int, 0);
pub const CMS_F_CMS_SIGN = @as(c_int, 0);
pub const CMS_F_CMS_SIGNED_DATA_INIT = @as(c_int, 0);
pub const CMS_F_CMS_SIGNERINFO_CONTENT_SIGN = @as(c_int, 0);
pub const CMS_F_CMS_SIGNERINFO_SIGN = @as(c_int, 0);
pub const CMS_F_CMS_SIGNERINFO_VERIFY = @as(c_int, 0);
pub const CMS_F_CMS_SIGNERINFO_VERIFY_CERT = @as(c_int, 0);
pub const CMS_F_CMS_SIGNERINFO_VERIFY_CONTENT = @as(c_int, 0);
pub const CMS_F_CMS_SIGN_RECEIPT = @as(c_int, 0);
pub const CMS_F_CMS_SI_CHECK_ATTRIBUTES = @as(c_int, 0);
pub const CMS_F_CMS_STREAM = @as(c_int, 0);
pub const CMS_F_CMS_UNCOMPRESS = @as(c_int, 0);
pub const CMS_F_CMS_VERIFY = @as(c_int, 0);
pub const CMS_F_KEK_UNWRAP_KEY = @as(c_int, 0);
pub const COMP_F_BIO_ZLIB_FLUSH = @as(c_int, 0);
pub const COMP_F_BIO_ZLIB_NEW = @as(c_int, 0);
pub const COMP_F_BIO_ZLIB_READ = @as(c_int, 0);
pub const COMP_F_BIO_ZLIB_WRITE = @as(c_int, 0);
pub const COMP_F_COMP_CTX_NEW = @as(c_int, 0);
pub const CONF_F_CONF_DUMP_FP = @as(c_int, 0);
pub const CONF_F_CONF_LOAD = @as(c_int, 0);
pub const CONF_F_CONF_LOAD_FP = @as(c_int, 0);
pub const CONF_F_CONF_PARSE_LIST = @as(c_int, 0);
pub const CONF_F_DEF_LOAD = @as(c_int, 0);
pub const CONF_F_DEF_LOAD_BIO = @as(c_int, 0);
pub const CONF_F_GET_NEXT_FILE = @as(c_int, 0);
pub const CONF_F_MODULE_ADD = @as(c_int, 0);
pub const CONF_F_MODULE_INIT = @as(c_int, 0);
pub const CONF_F_MODULE_LOAD_DSO = @as(c_int, 0);
pub const CONF_F_MODULE_RUN = @as(c_int, 0);
pub const CONF_F_NCONF_DUMP_BIO = @as(c_int, 0);
pub const CONF_F_NCONF_DUMP_FP = @as(c_int, 0);
pub const CONF_F_NCONF_GET_NUMBER_E = @as(c_int, 0);
pub const CONF_F_NCONF_GET_SECTION = @as(c_int, 0);
pub const CONF_F_NCONF_GET_STRING = @as(c_int, 0);
pub const CONF_F_NCONF_LOAD = @as(c_int, 0);
pub const CONF_F_NCONF_LOAD_BIO = @as(c_int, 0);
pub const CONF_F_NCONF_LOAD_FP = @as(c_int, 0);
pub const CONF_F_NCONF_NEW = @as(c_int, 0);
pub const CONF_F_PROCESS_INCLUDE = @as(c_int, 0);
pub const CONF_F_SSL_MODULE_INIT = @as(c_int, 0);
pub const CONF_F_STR_COPY = @as(c_int, 0);
pub const CRYPTO_F_CMAC_CTX_NEW = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_DUP_EX_DATA = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_FREE_EX_DATA = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_GET_EX_NEW_INDEX = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_MEMDUP = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_NEW_EX_DATA = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_OCB128_COPY_CTX = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_OCB128_INIT = @as(c_int, 0);
pub const CRYPTO_F_CRYPTO_SET_EX_DATA = @as(c_int, 0);
pub const CRYPTO_F_GET_AND_LOCK = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_ATEXIT = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_BUF2HEXSTR = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_FOPEN = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_HEXSTR2BUF = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_INIT_CRYPTO = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_LH_NEW = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_SK_DEEP_COPY = @as(c_int, 0);
pub const CRYPTO_F_OPENSSL_SK_DUP = @as(c_int, 0);
pub const CRYPTO_F_PKEY_HMAC_INIT = @as(c_int, 0);
pub const CRYPTO_F_PKEY_POLY1305_INIT = @as(c_int, 0);
pub const CRYPTO_F_PKEY_SIPHASH_INIT = @as(c_int, 0);
pub const CRYPTO_F_SK_RESERVE = @as(c_int, 0);
pub const CT_F_CTLOG_NEW = @as(c_int, 0);
pub const CT_F_CTLOG_NEW_FROM_BASE64 = @as(c_int, 0);
pub const CT_F_CTLOG_NEW_FROM_CONF = @as(c_int, 0);
pub const CT_F_CTLOG_STORE_LOAD_CTX_NEW = @as(c_int, 0);
pub const CT_F_CTLOG_STORE_LOAD_FILE = @as(c_int, 0);
pub const CT_F_CTLOG_STORE_LOAD_LOG = @as(c_int, 0);
pub const CT_F_CTLOG_STORE_NEW = @as(c_int, 0);
pub const CT_F_CT_BASE64_DECODE = @as(c_int, 0);
pub const CT_F_CT_POLICY_EVAL_CTX_NEW = @as(c_int, 0);
pub const CT_F_CT_V1_LOG_ID_FROM_PKEY = @as(c_int, 0);
pub const CT_F_I2O_SCT = @as(c_int, 0);
pub const CT_F_I2O_SCT_LIST = @as(c_int, 0);
pub const CT_F_I2O_SCT_SIGNATURE = @as(c_int, 0);
pub const CT_F_O2I_SCT = @as(c_int, 0);
pub const CT_F_O2I_SCT_LIST = @as(c_int, 0);
pub const CT_F_O2I_SCT_SIGNATURE = @as(c_int, 0);
pub const CT_F_SCT_CTX_NEW = @as(c_int, 0);
pub const CT_F_SCT_CTX_VERIFY = @as(c_int, 0);
pub const CT_F_SCT_NEW = @as(c_int, 0);
pub const CT_F_SCT_NEW_FROM_BASE64 = @as(c_int, 0);
pub const CT_F_SCT_SET0_LOG_ID = @as(c_int, 0);
pub const CT_F_SCT_SET1_EXTENSIONS = @as(c_int, 0);
pub const CT_F_SCT_SET1_LOG_ID = @as(c_int, 0);
pub const CT_F_SCT_SET1_SIGNATURE = @as(c_int, 0);
pub const CT_F_SCT_SET_LOG_ENTRY_TYPE = @as(c_int, 0);
pub const CT_F_SCT_SET_SIGNATURE_NID = @as(c_int, 0);
pub const CT_F_SCT_SET_VERSION = @as(c_int, 0);
pub const DH_F_COMPUTE_KEY = @as(c_int, 0);
pub const DH_F_DHPARAMS_PRINT_FP = @as(c_int, 0);
pub const DH_F_DH_BUILTIN_GENPARAMS = @as(c_int, 0);
pub const DH_F_DH_CHECK_EX = @as(c_int, 0);
pub const DH_F_DH_CHECK_PARAMS_EX = @as(c_int, 0);
pub const DH_F_DH_CHECK_PUB_KEY_EX = @as(c_int, 0);
pub const DH_F_DH_CMS_DECRYPT = @as(c_int, 0);
pub const DH_F_DH_CMS_SET_PEERKEY = @as(c_int, 0);
pub const DH_F_DH_CMS_SET_SHARED_INFO = @as(c_int, 0);
pub const DH_F_DH_METH_DUP = @as(c_int, 0);
pub const DH_F_DH_METH_NEW = @as(c_int, 0);
pub const DH_F_DH_METH_SET1_NAME = @as(c_int, 0);
pub const DH_F_DH_NEW_BY_NID = @as(c_int, 0);
pub const DH_F_DH_NEW_METHOD = @as(c_int, 0);
pub const DH_F_DH_PARAM_DECODE = @as(c_int, 0);
pub const DH_F_DH_PKEY_PUBLIC_CHECK = @as(c_int, 0);
pub const DH_F_DH_PRIV_DECODE = @as(c_int, 0);
pub const DH_F_DH_PRIV_ENCODE = @as(c_int, 0);
pub const DH_F_DH_PUB_DECODE = @as(c_int, 0);
pub const DH_F_DH_PUB_ENCODE = @as(c_int, 0);
pub const DH_F_DO_DH_PRINT = @as(c_int, 0);
pub const DH_F_GENERATE_KEY = @as(c_int, 0);
pub const DH_F_PKEY_DH_CTRL_STR = @as(c_int, 0);
pub const DH_F_PKEY_DH_DERIVE = @as(c_int, 0);
pub const DH_F_PKEY_DH_INIT = @as(c_int, 0);
pub const DH_F_PKEY_DH_KEYGEN = @as(c_int, 0);
pub const DSA_F_DSAPARAMS_PRINT = @as(c_int, 0);
pub const DSA_F_DSAPARAMS_PRINT_FP = @as(c_int, 0);
pub const DSA_F_DSA_BUILTIN_PARAMGEN = @as(c_int, 0);
pub const DSA_F_DSA_BUILTIN_PARAMGEN2 = @as(c_int, 0);
pub const DSA_F_DSA_DO_SIGN = @as(c_int, 0);
pub const DSA_F_DSA_DO_VERIFY = @as(c_int, 0);
pub const DSA_F_DSA_METH_DUP = @as(c_int, 0);
pub const DSA_F_DSA_METH_NEW = @as(c_int, 0);
pub const DSA_F_DSA_METH_SET1_NAME = @as(c_int, 0);
pub const DSA_F_DSA_NEW_METHOD = @as(c_int, 0);
pub const DSA_F_DSA_PARAM_DECODE = @as(c_int, 0);
pub const DSA_F_DSA_PRINT_FP = @as(c_int, 0);
pub const DSA_F_DSA_PRIV_DECODE = @as(c_int, 0);
pub const DSA_F_DSA_PRIV_ENCODE = @as(c_int, 0);
pub const DSA_F_DSA_PUB_DECODE = @as(c_int, 0);
pub const DSA_F_DSA_PUB_ENCODE = @as(c_int, 0);
pub const DSA_F_DSA_SIGN = @as(c_int, 0);
pub const DSA_F_DSA_SIGN_SETUP = @as(c_int, 0);
pub const DSA_F_DSA_SIG_NEW = @as(c_int, 0);
pub const DSA_F_OLD_DSA_PRIV_DECODE = @as(c_int, 0);
pub const DSA_F_PKEY_DSA_CTRL = @as(c_int, 0);
pub const DSA_F_PKEY_DSA_CTRL_STR = @as(c_int, 0);
pub const DSA_F_PKEY_DSA_KEYGEN = @as(c_int, 0);
pub const EC_F_BN_TO_FELEM = @as(c_int, 0);
pub const EC_F_D2I_ECPARAMETERS = @as(c_int, 0);
pub const EC_F_D2I_ECPKPARAMETERS = @as(c_int, 0);
pub const EC_F_D2I_ECPRIVATEKEY = @as(c_int, 0);
pub const EC_F_DO_EC_KEY_PRINT = @as(c_int, 0);
pub const EC_F_ECDH_CMS_DECRYPT = @as(c_int, 0);
pub const EC_F_ECDH_CMS_SET_SHARED_INFO = @as(c_int, 0);
pub const EC_F_ECDH_COMPUTE_KEY = @as(c_int, 0);
pub const EC_F_ECDH_SIMPLE_COMPUTE_KEY = @as(c_int, 0);
pub const EC_F_ECDSA_DO_SIGN_EX = @as(c_int, 0);
pub const EC_F_ECDSA_DO_VERIFY = @as(c_int, 0);
pub const EC_F_ECDSA_SIGN_EX = @as(c_int, 0);
pub const EC_F_ECDSA_SIGN_SETUP = @as(c_int, 0);
pub const EC_F_ECDSA_SIG_NEW = @as(c_int, 0);
pub const EC_F_ECDSA_VERIFY = @as(c_int, 0);
pub const EC_F_ECD_ITEM_VERIFY = @as(c_int, 0);
pub const EC_F_ECKEY_PARAM2TYPE = @as(c_int, 0);
pub const EC_F_ECKEY_PARAM_DECODE = @as(c_int, 0);
pub const EC_F_ECKEY_PRIV_DECODE = @as(c_int, 0);
pub const EC_F_ECKEY_PRIV_ENCODE = @as(c_int, 0);
pub const EC_F_ECKEY_PUB_DECODE = @as(c_int, 0);
pub const EC_F_ECKEY_PUB_ENCODE = @as(c_int, 0);
pub const EC_F_ECKEY_TYPE2PARAM = @as(c_int, 0);
pub const EC_F_ECPARAMETERS_PRINT = @as(c_int, 0);
pub const EC_F_ECPARAMETERS_PRINT_FP = @as(c_int, 0);
pub const EC_F_ECPKPARAMETERS_PRINT = @as(c_int, 0);
pub const EC_F_ECPKPARAMETERS_PRINT_FP = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_GET_AFFINE = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_INV_MOD_ORD = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_MULT_PRECOMPUTE = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_POINTS_MUL = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_PRE_COMP_NEW = @as(c_int, 0);
pub const EC_F_ECP_NISTZ256_WINDOWED_MUL = @as(c_int, 0);
pub const EC_F_ECX_KEY_OP = @as(c_int, 0);
pub const EC_F_ECX_PRIV_ENCODE = @as(c_int, 0);
pub const EC_F_ECX_PUB_ENCODE = @as(c_int, 0);
pub const EC_F_EC_ASN1_GROUP2CURVE = @as(c_int, 0);
pub const EC_F_EC_ASN1_GROUP2FIELDID = @as(c_int, 0);
pub const EC_F_EC_GF2M_MONTGOMERY_POINT_MULTIPLY = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_FIELD_INV = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_GROUP_CHECK_DISCRIMINANT = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_LADDER_POST = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_LADDER_PRE = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_OCT2POINT = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_POINT2OCT = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_POINTS_MUL = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_POINT_SET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GF2M_SIMPLE_SET_COMPRESSED_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_DECODE = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_ENCODE = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_INV = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_MUL = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_SET_TO_ONE = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_FIELD_SQR = @as(c_int, 0);
pub const EC_F_EC_GFP_MONT_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP224_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP224_POINTS_MUL = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP224_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP256_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP256_POINTS_MUL = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP256_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP521_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP521_POINTS_MUL = @as(c_int, 0);
pub const EC_F_EC_GFP_NISTP521_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_NIST_FIELD_MUL = @as(c_int, 0);
pub const EC_F_EC_GFP_NIST_FIELD_SQR = @as(c_int, 0);
pub const EC_F_EC_GFP_NIST_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_BLIND_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_FIELD_INV = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_GROUP_CHECK_DISCRIMINANT = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_MAKE_AFFINE = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_OCT2POINT = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_POINT2OCT = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_POINTS_MAKE_AFFINE = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_POINT_SET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GFP_SIMPLE_SET_COMPRESSED_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_GROUP_CHECK = @as(c_int, 0);
pub const EC_F_EC_GROUP_CHECK_DISCRIMINANT = @as(c_int, 0);
pub const EC_F_EC_GROUP_COPY = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_CURVE_GF2M = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_CURVE_GFP = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_DEGREE = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_ECPARAMETERS = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_ECPKPARAMETERS = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_PENTANOMIAL_BASIS = @as(c_int, 0);
pub const EC_F_EC_GROUP_GET_TRINOMIAL_BASIS = @as(c_int, 0);
pub const EC_F_EC_GROUP_NEW = @as(c_int, 0);
pub const EC_F_EC_GROUP_NEW_BY_CURVE_NAME = @as(c_int, 0);
pub const EC_F_EC_GROUP_NEW_FROM_DATA = @as(c_int, 0);
pub const EC_F_EC_GROUP_NEW_FROM_ECPARAMETERS = @as(c_int, 0);
pub const EC_F_EC_GROUP_NEW_FROM_ECPKPARAMETERS = @as(c_int, 0);
pub const EC_F_EC_GROUP_SET_CURVE = @as(c_int, 0);
pub const EC_F_EC_GROUP_SET_CURVE_GF2M = @as(c_int, 0);
pub const EC_F_EC_GROUP_SET_CURVE_GFP = @as(c_int, 0);
pub const EC_F_EC_GROUP_SET_GENERATOR = @as(c_int, 0);
pub const EC_F_EC_GROUP_SET_SEED = @as(c_int, 0);
pub const EC_F_EC_KEY_CHECK_KEY = @as(c_int, 0);
pub const EC_F_EC_KEY_COPY = @as(c_int, 0);
pub const EC_F_EC_KEY_GENERATE_KEY = @as(c_int, 0);
pub const EC_F_EC_KEY_NEW = @as(c_int, 0);
pub const EC_F_EC_KEY_NEW_METHOD = @as(c_int, 0);
pub const EC_F_EC_KEY_OCT2PRIV = @as(c_int, 0);
pub const EC_F_EC_KEY_PRINT = @as(c_int, 0);
pub const EC_F_EC_KEY_PRINT_FP = @as(c_int, 0);
pub const EC_F_EC_KEY_PRIV2BUF = @as(c_int, 0);
pub const EC_F_EC_KEY_PRIV2OCT = @as(c_int, 0);
pub const EC_F_EC_KEY_SET_PUBLIC_KEY_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_KEY_SIMPLE_CHECK_KEY = @as(c_int, 0);
pub const EC_F_EC_KEY_SIMPLE_OCT2PRIV = @as(c_int, 0);
pub const EC_F_EC_KEY_SIMPLE_PRIV2OCT = @as(c_int, 0);
pub const EC_F_EC_PKEY_CHECK = @as(c_int, 0);
pub const EC_F_EC_PKEY_PARAM_CHECK = @as(c_int, 0);
pub const EC_F_EC_POINTS_MAKE_AFFINE = @as(c_int, 0);
pub const EC_F_EC_POINTS_MUL = @as(c_int, 0);
pub const EC_F_EC_POINT_ADD = @as(c_int, 0);
pub const EC_F_EC_POINT_BN2POINT = @as(c_int, 0);
pub const EC_F_EC_POINT_CMP = @as(c_int, 0);
pub const EC_F_EC_POINT_COPY = @as(c_int, 0);
pub const EC_F_EC_POINT_DBL = @as(c_int, 0);
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GF2M = @as(c_int, 0);
pub const EC_F_EC_POINT_GET_AFFINE_COORDINATES_GFP = @as(c_int, 0);
pub const EC_F_EC_POINT_GET_JPROJECTIVE_COORDINATES_GFP = @as(c_int, 0);
pub const EC_F_EC_POINT_INVERT = @as(c_int, 0);
pub const EC_F_EC_POINT_IS_AT_INFINITY = @as(c_int, 0);
pub const EC_F_EC_POINT_IS_ON_CURVE = @as(c_int, 0);
pub const EC_F_EC_POINT_MAKE_AFFINE = @as(c_int, 0);
pub const EC_F_EC_POINT_NEW = @as(c_int, 0);
pub const EC_F_EC_POINT_OCT2POINT = @as(c_int, 0);
pub const EC_F_EC_POINT_POINT2BUF = @as(c_int, 0);
pub const EC_F_EC_POINT_POINT2OCT = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GF2M = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_AFFINE_COORDINATES_GFP = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GF2M = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_COMPRESSED_COORDINATES_GFP = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP = @as(c_int, 0);
pub const EC_F_EC_POINT_SET_TO_INFINITY = @as(c_int, 0);
pub const EC_F_EC_PRE_COMP_NEW = @as(c_int, 0);
pub const EC_F_EC_SCALAR_MUL_LADDER = @as(c_int, 0);
pub const EC_F_EC_WNAF_MUL = @as(c_int, 0);
pub const EC_F_EC_WNAF_PRECOMPUTE_MULT = @as(c_int, 0);
pub const EC_F_I2D_ECPARAMETERS = @as(c_int, 0);
pub const EC_F_I2D_ECPKPARAMETERS = @as(c_int, 0);
pub const EC_F_I2D_ECPRIVATEKEY = @as(c_int, 0);
pub const EC_F_I2O_ECPUBLICKEY = @as(c_int, 0);
pub const EC_F_NISTP224_PRE_COMP_NEW = @as(c_int, 0);
pub const EC_F_NISTP256_PRE_COMP_NEW = @as(c_int, 0);
pub const EC_F_NISTP521_PRE_COMP_NEW = @as(c_int, 0);
pub const EC_F_O2I_ECPUBLICKEY = @as(c_int, 0);
pub const EC_F_OLD_EC_PRIV_DECODE = @as(c_int, 0);
pub const EC_F_OSSL_ECDH_COMPUTE_KEY = @as(c_int, 0);
pub const EC_F_OSSL_ECDSA_SIGN_SIG = @as(c_int, 0);
pub const EC_F_OSSL_ECDSA_VERIFY_SIG = @as(c_int, 0);
pub const EC_F_PKEY_ECD_CTRL = @as(c_int, 0);
pub const EC_F_PKEY_ECD_DIGESTSIGN = @as(c_int, 0);
pub const EC_F_PKEY_ECD_DIGESTSIGN25519 = @as(c_int, 0);
pub const EC_F_PKEY_ECD_DIGESTSIGN448 = @as(c_int, 0);
pub const EC_F_PKEY_ECX_DERIVE = @as(c_int, 0);
pub const EC_F_PKEY_EC_CTRL = @as(c_int, 0);
pub const EC_F_PKEY_EC_CTRL_STR = @as(c_int, 0);
pub const EC_F_PKEY_EC_DERIVE = @as(c_int, 0);
pub const EC_F_PKEY_EC_INIT = @as(c_int, 0);
pub const EC_F_PKEY_EC_KDF_DERIVE = @as(c_int, 0);
pub const EC_F_PKEY_EC_KEYGEN = @as(c_int, 0);
pub const EC_F_PKEY_EC_PARAMGEN = @as(c_int, 0);
pub const EC_F_PKEY_EC_SIGN = @as(c_int, 0);
pub const EC_F_VALIDATE_ECX_DERIVE = @as(c_int, 0);
pub const ENGINE_F_DIGEST_UPDATE = @as(c_int, 0);
pub const ENGINE_F_DYNAMIC_CTRL = @as(c_int, 0);
pub const ENGINE_F_DYNAMIC_GET_DATA_CTX = @as(c_int, 0);
pub const ENGINE_F_DYNAMIC_LOAD = @as(c_int, 0);
pub const ENGINE_F_DYNAMIC_SET_DATA_CTX = @as(c_int, 0);
pub const ENGINE_F_ENGINE_ADD = @as(c_int, 0);
pub const ENGINE_F_ENGINE_BY_ID = @as(c_int, 0);
pub const ENGINE_F_ENGINE_CMD_IS_EXECUTABLE = @as(c_int, 0);
pub const ENGINE_F_ENGINE_CTRL = @as(c_int, 0);
pub const ENGINE_F_ENGINE_CTRL_CMD = @as(c_int, 0);
pub const ENGINE_F_ENGINE_CTRL_CMD_STRING = @as(c_int, 0);
pub const ENGINE_F_ENGINE_FINISH = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_CIPHER = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_DIGEST = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_FIRST = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_LAST = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_NEXT = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_PKEY_ASN1_METH = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_PKEY_METH = @as(c_int, 0);
pub const ENGINE_F_ENGINE_GET_PREV = @as(c_int, 0);
pub const ENGINE_F_ENGINE_INIT = @as(c_int, 0);
pub const ENGINE_F_ENGINE_LIST_ADD = @as(c_int, 0);
pub const ENGINE_F_ENGINE_LIST_REMOVE = @as(c_int, 0);
pub const ENGINE_F_ENGINE_LOAD_PRIVATE_KEY = @as(c_int, 0);
pub const ENGINE_F_ENGINE_LOAD_PUBLIC_KEY = @as(c_int, 0);
pub const ENGINE_F_ENGINE_LOAD_SSL_CLIENT_CERT = @as(c_int, 0);
pub const ENGINE_F_ENGINE_NEW = @as(c_int, 0);
pub const ENGINE_F_ENGINE_PKEY_ASN1_FIND_STR = @as(c_int, 0);
pub const ENGINE_F_ENGINE_REMOVE = @as(c_int, 0);
pub const ENGINE_F_ENGINE_SET_DEFAULT_STRING = @as(c_int, 0);
pub const ENGINE_F_ENGINE_SET_ID = @as(c_int, 0);
pub const ENGINE_F_ENGINE_SET_NAME = @as(c_int, 0);
pub const ENGINE_F_ENGINE_TABLE_REGISTER = @as(c_int, 0);
pub const ENGINE_F_ENGINE_UNLOCKED_FINISH = @as(c_int, 0);
pub const ENGINE_F_ENGINE_UP_REF = @as(c_int, 0);
pub const ENGINE_F_INT_CLEANUP_ITEM = @as(c_int, 0);
pub const ENGINE_F_INT_CTRL_HELPER = @as(c_int, 0);
pub const ENGINE_F_INT_ENGINE_CONFIGURE = @as(c_int, 0);
pub const ENGINE_F_INT_ENGINE_MODULE_INIT = @as(c_int, 0);
pub const ENGINE_F_OSSL_HMAC_INIT = @as(c_int, 0);
pub const EVP_F_AESNI_INIT_KEY = @as(c_int, 0);
pub const EVP_F_AESNI_XTS_INIT_KEY = @as(c_int, 0);
pub const EVP_F_AES_GCM_CTRL = @as(c_int, 0);
pub const EVP_F_AES_INIT_KEY = @as(c_int, 0);
pub const EVP_F_AES_OCB_CIPHER = @as(c_int, 0);
pub const EVP_F_AES_T4_INIT_KEY = @as(c_int, 0);
pub const EVP_F_AES_T4_XTS_INIT_KEY = @as(c_int, 0);
pub const EVP_F_AES_WRAP_CIPHER = @as(c_int, 0);
pub const EVP_F_AES_XTS_INIT_KEY = @as(c_int, 0);
pub const EVP_F_ALG_MODULE_INIT = @as(c_int, 0);
pub const EVP_F_ARIA_CCM_INIT_KEY = @as(c_int, 0);
pub const EVP_F_ARIA_GCM_CTRL = @as(c_int, 0);
pub const EVP_F_ARIA_GCM_INIT_KEY = @as(c_int, 0);
pub const EVP_F_ARIA_INIT_KEY = @as(c_int, 0);
pub const EVP_F_B64_NEW = @as(c_int, 0);
pub const EVP_F_CAMELLIA_INIT_KEY = @as(c_int, 0);
pub const EVP_F_CHACHA20_POLY1305_CTRL = @as(c_int, 0);
pub const EVP_F_CMLL_T4_INIT_KEY = @as(c_int, 0);
pub const EVP_F_DES_EDE3_WRAP_CIPHER = @as(c_int, 0);
pub const EVP_F_DO_SIGVER_INIT = @as(c_int, 0);
pub const EVP_F_ENC_NEW = @as(c_int, 0);
pub const EVP_F_EVP_CIPHERINIT_EX = @as(c_int, 0);
pub const EVP_F_EVP_CIPHER_ASN1_TO_PARAM = @as(c_int, 0);
pub const EVP_F_EVP_CIPHER_CTX_COPY = @as(c_int, 0);
pub const EVP_F_EVP_CIPHER_CTX_CTRL = @as(c_int, 0);
pub const EVP_F_EVP_CIPHER_CTX_SET_KEY_LENGTH = @as(c_int, 0);
pub const EVP_F_EVP_CIPHER_PARAM_TO_ASN1 = @as(c_int, 0);
pub const EVP_F_EVP_DECRYPTFINAL_EX = @as(c_int, 0);
pub const EVP_F_EVP_DECRYPTUPDATE = @as(c_int, 0);
pub const EVP_F_EVP_DIGESTFINALXOF = @as(c_int, 0);
pub const EVP_F_EVP_DIGESTINIT_EX = @as(c_int, 0);
pub const EVP_F_EVP_ENCRYPTDECRYPTUPDATE = @as(c_int, 0);
pub const EVP_F_EVP_ENCRYPTFINAL_EX = @as(c_int, 0);
pub const EVP_F_EVP_ENCRYPTUPDATE = @as(c_int, 0);
pub const EVP_F_EVP_MD_CTX_COPY_EX = @as(c_int, 0);
pub const EVP_F_EVP_MD_SIZE = @as(c_int, 0);
pub const EVP_F_EVP_OPENINIT = @as(c_int, 0);
pub const EVP_F_EVP_PBE_ALG_ADD = @as(c_int, 0);
pub const EVP_F_EVP_PBE_ALG_ADD_TYPE = @as(c_int, 0);
pub const EVP_F_EVP_PBE_CIPHERINIT = @as(c_int, 0);
pub const EVP_F_EVP_PBE_SCRYPT = @as(c_int, 0);
pub const EVP_F_EVP_PKCS82PKEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY2PKCS8 = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_ASN1_ADD0 = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_CHECK = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_COPY_PARAMETERS = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_CTX_CTRL = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_CTX_CTRL_STR = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_CTX_DUP = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_CTX_MD = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DECRYPT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DECRYPT_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DECRYPT_OLD = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DERIVE = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DERIVE_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_DERIVE_SET_PEER = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_ENCRYPT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_ENCRYPT_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_ENCRYPT_OLD = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_DH = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_DSA = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_EC_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_HMAC = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_POLY1305 = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_RSA = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET0_SIPHASH = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET_RAW_PRIVATE_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_GET_RAW_PUBLIC_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_KEYGEN = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_KEYGEN_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_METH_ADD0 = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_METH_NEW = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_NEW = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_NEW_CMAC_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_NEW_RAW_PRIVATE_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_NEW_RAW_PUBLIC_KEY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_PARAMGEN = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_PARAMGEN_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_PARAM_CHECK = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_PUBLIC_CHECK = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_SET1_ENGINE = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_SET_ALIAS_TYPE = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_SIGN = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_SIGN_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_VERIFY = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_VERIFY_INIT = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER = @as(c_int, 0);
pub const EVP_F_EVP_PKEY_VERIFY_RECOVER_INIT = @as(c_int, 0);
pub const EVP_F_EVP_SIGNFINAL = @as(c_int, 0);
pub const EVP_F_EVP_VERIFYFINAL = @as(c_int, 0);
pub const EVP_F_INT_CTX_NEW = @as(c_int, 0);
pub const EVP_F_OK_NEW = @as(c_int, 0);
pub const EVP_F_PKCS5_PBE_KEYIVGEN = @as(c_int, 0);
pub const EVP_F_PKCS5_V2_PBE_KEYIVGEN = @as(c_int, 0);
pub const EVP_F_PKCS5_V2_PBKDF2_KEYIVGEN = @as(c_int, 0);
pub const EVP_F_PKCS5_V2_SCRYPT_KEYIVGEN = @as(c_int, 0);
pub const EVP_F_PKEY_SET_TYPE = @as(c_int, 0);
pub const EVP_F_RC2_MAGIC_TO_METH = @as(c_int, 0);
pub const EVP_F_RC5_CTRL = @as(c_int, 0);
pub const EVP_F_R_32_12_16_INIT_KEY = @as(c_int, 0);
pub const EVP_F_S390X_AES_GCM_CTRL = @as(c_int, 0);
pub const EVP_F_UPDATE = @as(c_int, 0);
pub const KDF_F_PKEY_HKDF_CTRL_STR = @as(c_int, 0);
pub const KDF_F_PKEY_HKDF_DERIVE = @as(c_int, 0);
pub const KDF_F_PKEY_HKDF_INIT = @as(c_int, 0);
pub const KDF_F_PKEY_SCRYPT_CTRL_STR = @as(c_int, 0);
pub const KDF_F_PKEY_SCRYPT_CTRL_UINT64 = @as(c_int, 0);
pub const KDF_F_PKEY_SCRYPT_DERIVE = @as(c_int, 0);
pub const KDF_F_PKEY_SCRYPT_INIT = @as(c_int, 0);
pub const KDF_F_PKEY_SCRYPT_SET_MEMBUF = @as(c_int, 0);
pub const KDF_F_PKEY_TLS1_PRF_CTRL_STR = @as(c_int, 0);
pub const KDF_F_PKEY_TLS1_PRF_DERIVE = @as(c_int, 0);
pub const KDF_F_PKEY_TLS1_PRF_INIT = @as(c_int, 0);
pub const KDF_F_TLS1_PRF_ALG = @as(c_int, 0);
pub const KDF_R_INVALID_DIGEST = @as(c_int, 0);
pub const KDF_R_MISSING_ITERATION_COUNT = @as(c_int, 0);
pub const KDF_R_MISSING_KEY = @as(c_int, 0);
pub const KDF_R_MISSING_MESSAGE_DIGEST = @as(c_int, 0);
pub const KDF_R_MISSING_PARAMETER = @as(c_int, 0);
pub const KDF_R_MISSING_PASS = @as(c_int, 0);
pub const KDF_R_MISSING_SALT = @as(c_int, 0);
pub const KDF_R_MISSING_SECRET = @as(c_int, 0);
pub const KDF_R_MISSING_SEED = @as(c_int, 0);
pub const KDF_R_UNKNOWN_PARAMETER_TYPE = @as(c_int, 0);
pub const KDF_R_VALUE_ERROR = @as(c_int, 0);
pub const KDF_R_VALUE_MISSING = @as(c_int, 0);
pub const OBJ_F_OBJ_ADD_OBJECT = @as(c_int, 0);
pub const OBJ_F_OBJ_ADD_SIGID = @as(c_int, 0);
pub const OBJ_F_OBJ_CREATE = @as(c_int, 0);
pub const OBJ_F_OBJ_DUP = @as(c_int, 0);
pub const OBJ_F_OBJ_NAME_NEW_INDEX = @as(c_int, 0);
pub const OBJ_F_OBJ_NID2LN = @as(c_int, 0);
pub const OBJ_F_OBJ_NID2OBJ = @as(c_int, 0);
pub const OBJ_F_OBJ_NID2SN = @as(c_int, 0);
pub const OBJ_F_OBJ_TXT2OBJ = @as(c_int, 0);
pub const OCSP_F_D2I_OCSP_NONCE = @as(c_int, 0);
pub const OCSP_F_OCSP_BASIC_ADD1_STATUS = @as(c_int, 0);
pub const OCSP_F_OCSP_BASIC_SIGN = @as(c_int, 0);
pub const OCSP_F_OCSP_BASIC_SIGN_CTX = @as(c_int, 0);
pub const OCSP_F_OCSP_BASIC_VERIFY = @as(c_int, 0);
pub const OCSP_F_OCSP_CERT_ID_NEW = @as(c_int, 0);
pub const OCSP_F_OCSP_CHECK_DELEGATED = @as(c_int, 0);
pub const OCSP_F_OCSP_CHECK_IDS = @as(c_int, 0);
pub const OCSP_F_OCSP_CHECK_ISSUER = @as(c_int, 0);
pub const OCSP_F_OCSP_CHECK_VALIDITY = @as(c_int, 0);
pub const OCSP_F_OCSP_MATCH_ISSUERID = @as(c_int, 0);
pub const OCSP_F_OCSP_PARSE_URL = @as(c_int, 0);
pub const OCSP_F_OCSP_REQUEST_SIGN = @as(c_int, 0);
pub const OCSP_F_OCSP_REQUEST_VERIFY = @as(c_int, 0);
pub const OCSP_F_OCSP_RESPONSE_GET1_BASIC = @as(c_int, 0);
pub const OCSP_F_PARSE_HTTP_LINE1 = @as(c_int, 0);
pub const PEM_F_B2I_DSS = @as(c_int, 0);
pub const PEM_F_B2I_PVK_BIO = @as(c_int, 0);
pub const PEM_F_B2I_RSA = @as(c_int, 0);
pub const PEM_F_CHECK_BITLEN_DSA = @as(c_int, 0);
pub const PEM_F_CHECK_BITLEN_RSA = @as(c_int, 0);
pub const PEM_F_D2I_PKCS8PRIVATEKEY_BIO = @as(c_int, 0);
pub const PEM_F_D2I_PKCS8PRIVATEKEY_FP = @as(c_int, 0);
pub const PEM_F_DO_B2I = @as(c_int, 0);
pub const PEM_F_DO_B2I_BIO = @as(c_int, 0);
pub const PEM_F_DO_BLOB_HEADER = @as(c_int, 0);
pub const PEM_F_DO_I2B = @as(c_int, 0);
pub const PEM_F_DO_PK8PKEY = @as(c_int, 0);
pub const PEM_F_DO_PK8PKEY_FP = @as(c_int, 0);
pub const PEM_F_DO_PVK_BODY = @as(c_int, 0);
pub const PEM_F_DO_PVK_HEADER = @as(c_int, 0);
pub const PEM_F_GET_HEADER_AND_DATA = @as(c_int, 0);
pub const PEM_F_GET_NAME = @as(c_int, 0);
pub const PEM_F_I2B_PVK = @as(c_int, 0);
pub const PEM_F_I2B_PVK_BIO = @as(c_int, 0);
pub const PEM_F_LOAD_IV = @as(c_int, 0);
pub const PEM_F_PEM_ASN1_READ = @as(c_int, 0);
pub const PEM_F_PEM_ASN1_READ_BIO = @as(c_int, 0);
pub const PEM_F_PEM_ASN1_WRITE = @as(c_int, 0);
pub const PEM_F_PEM_ASN1_WRITE_BIO = @as(c_int, 0);
pub const PEM_F_PEM_DEF_CALLBACK = @as(c_int, 0);
pub const PEM_F_PEM_DO_HEADER = @as(c_int, 0);
pub const PEM_F_PEM_GET_EVP_CIPHER_INFO = @as(c_int, 0);
pub const PEM_F_PEM_READ = @as(c_int, 0);
pub const PEM_F_PEM_READ_BIO = @as(c_int, 0);
pub const PEM_F_PEM_READ_BIO_DHPARAMS = @as(c_int, 0);
pub const PEM_F_PEM_READ_BIO_EX = @as(c_int, 0);
pub const PEM_F_PEM_READ_BIO_PARAMETERS = @as(c_int, 0);
pub const PEM_F_PEM_READ_BIO_PRIVATEKEY = @as(c_int, 0);
pub const PEM_F_PEM_READ_DHPARAMS = @as(c_int, 0);
pub const PEM_F_PEM_READ_PRIVATEKEY = @as(c_int, 0);
pub const PEM_F_PEM_SIGNFINAL = @as(c_int, 0);
pub const PEM_F_PEM_WRITE = @as(c_int, 0);
pub const PEM_F_PEM_WRITE_BIO = @as(c_int, 0);
pub const PEM_F_PEM_WRITE_BIO_PRIVATEKEY_TRADITIONAL = @as(c_int, 0);
pub const PEM_F_PEM_WRITE_PRIVATEKEY = @as(c_int, 0);
pub const PEM_F_PEM_X509_INFO_READ = @as(c_int, 0);
pub const PEM_F_PEM_X509_INFO_READ_BIO = @as(c_int, 0);
pub const PEM_F_PEM_X509_INFO_WRITE_BIO = @as(c_int, 0);
pub const PKCS12_F_OPENSSL_ASC2UNI = @as(c_int, 0);
pub const PKCS12_F_OPENSSL_UNI2ASC = @as(c_int, 0);
pub const PKCS12_F_OPENSSL_UNI2UTF8 = @as(c_int, 0);
pub const PKCS12_F_OPENSSL_UTF82UNI = @as(c_int, 0);
pub const PKCS12_F_PKCS12_CREATE = @as(c_int, 0);
pub const PKCS12_F_PKCS12_GEN_MAC = @as(c_int, 0);
pub const PKCS12_F_PKCS12_INIT = @as(c_int, 0);
pub const PKCS12_F_PKCS12_ITEM_DECRYPT_D2I = @as(c_int, 0);
pub const PKCS12_F_PKCS12_ITEM_I2D_ENCRYPT = @as(c_int, 0);
pub const PKCS12_F_PKCS12_ITEM_PACK_SAFEBAG = @as(c_int, 0);
pub const PKCS12_F_PKCS12_KEY_GEN_ASC = @as(c_int, 0);
pub const PKCS12_F_PKCS12_KEY_GEN_UNI = @as(c_int, 0);
pub const PKCS12_F_PKCS12_KEY_GEN_UTF8 = @as(c_int, 0);
pub const PKCS12_F_PKCS12_NEWPASS = @as(c_int, 0);
pub const PKCS12_F_PKCS12_PACK_P7DATA = @as(c_int, 0);
pub const PKCS12_F_PKCS12_PACK_P7ENCDATA = @as(c_int, 0);
pub const PKCS12_F_PKCS12_PARSE = @as(c_int, 0);
pub const PKCS12_F_PKCS12_PBE_CRYPT = @as(c_int, 0);
pub const PKCS12_F_PKCS12_PBE_KEYIVGEN = @as(c_int, 0);
pub const PKCS12_F_PKCS12_SAFEBAG_CREATE0_P8INF = @as(c_int, 0);
pub const PKCS12_F_PKCS12_SAFEBAG_CREATE0_PKCS8 = @as(c_int, 0);
pub const PKCS12_F_PKCS12_SAFEBAG_CREATE_PKCS8_ENCRYPT = @as(c_int, 0);
pub const PKCS12_F_PKCS12_SETUP_MAC = @as(c_int, 0);
pub const PKCS12_F_PKCS12_SET_MAC = @as(c_int, 0);
pub const PKCS12_F_PKCS12_UNPACK_AUTHSAFES = @as(c_int, 0);
pub const PKCS12_F_PKCS12_UNPACK_P7DATA = @as(c_int, 0);
pub const PKCS12_F_PKCS12_VERIFY_MAC = @as(c_int, 0);
pub const PKCS12_F_PKCS8_ENCRYPT = @as(c_int, 0);
pub const PKCS12_F_PKCS8_SET0_PBE = @as(c_int, 0);
pub const PKCS7_F_DO_PKCS7_SIGNED_ATTRIB = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD0_ATTRIB_SIGNING_TIME = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_ATTRIB_SMIMECAP = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_CERTIFICATE = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_CRL = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_RECIPIENT_INFO = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_SIGNATURE = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ADD_SIGNER = @as(c_int, 0);
pub const PKCS7_F_PKCS7_BIO_ADD_DIGEST = @as(c_int, 0);
pub const PKCS7_F_PKCS7_COPY_EXISTING_DIGEST = @as(c_int, 0);
pub const PKCS7_F_PKCS7_CTRL = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DATADECODE = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DATAFINAL = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DATAINIT = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DATAVERIFY = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DECRYPT = @as(c_int, 0);
pub const PKCS7_F_PKCS7_DECRYPT_RINFO = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ENCODE_RINFO = @as(c_int, 0);
pub const PKCS7_F_PKCS7_ENCRYPT = @as(c_int, 0);
pub const PKCS7_F_PKCS7_FINAL = @as(c_int, 0);
pub const PKCS7_F_PKCS7_FIND_DIGEST = @as(c_int, 0);
pub const PKCS7_F_PKCS7_GET0_SIGNERS = @as(c_int, 0);
pub const PKCS7_F_PKCS7_RECIP_INFO_SET = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SET_CIPHER = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SET_CONTENT = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SET_DIGEST = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SET_TYPE = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIGN = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIGNATUREVERIFY = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIGNER_INFO_SET = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIGNER_INFO_SIGN = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIGN_ADD_SIGNER = @as(c_int, 0);
pub const PKCS7_F_PKCS7_SIMPLE_SMIMECAP = @as(c_int, 0);
pub const PKCS7_F_PKCS7_VERIFY = @as(c_int, 0);
pub const RAND_F_DATA_COLLECT_METHOD = @as(c_int, 0);
pub const RAND_F_DRBG_BYTES = @as(c_int, 0);
pub const RAND_F_DRBG_GET_ENTROPY = @as(c_int, 0);
pub const RAND_F_DRBG_SETUP = @as(c_int, 0);
pub const RAND_F_GET_ENTROPY = @as(c_int, 0);
pub const RAND_F_RAND_BYTES = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_ENABLE_LOCKING = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_GENERATE = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_GET_ENTROPY = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_GET_NONCE = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_INSTANTIATE = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_NEW = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_RESEED = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_RESTART = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_SET = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_SET_DEFAULTS = @as(c_int, 0);
pub const RAND_F_RAND_DRBG_UNINSTANTIATE = @as(c_int, 0);
pub const RAND_F_RAND_LOAD_FILE = @as(c_int, 0);
pub const RAND_F_RAND_POOL_ACQUIRE_ENTROPY = @as(c_int, 0);
pub const RAND_F_RAND_POOL_ADD = @as(c_int, 0);
pub const RAND_F_RAND_POOL_ADD_BEGIN = @as(c_int, 0);
pub const RAND_F_RAND_POOL_ADD_END = @as(c_int, 0);
pub const RAND_F_RAND_POOL_ATTACH = @as(c_int, 0);
pub const RAND_F_RAND_POOL_BYTES_NEEDED = @as(c_int, 0);
pub const RAND_F_RAND_POOL_GROW = @as(c_int, 0);
pub const RAND_F_RAND_POOL_NEW = @as(c_int, 0);
pub const RAND_F_RAND_PSEUDO_BYTES = @as(c_int, 0);
pub const RAND_F_RAND_WRITE_FILE = @as(c_int, 0);
pub const RSA_F_CHECK_PADDING_MD = @as(c_int, 0);
pub const RSA_F_ENCODE_PKCS1 = @as(c_int, 0);
pub const RSA_F_INT_RSA_VERIFY = @as(c_int, 0);
pub const RSA_F_OLD_RSA_PRIV_DECODE = @as(c_int, 0);
pub const RSA_F_PKEY_PSS_INIT = @as(c_int, 0);
pub const RSA_F_PKEY_RSA_CTRL = @as(c_int, 0);
pub const RSA_F_PKEY_RSA_CTRL_STR = @as(c_int, 0);
pub const RSA_F_PKEY_RSA_SIGN = @as(c_int, 0);
pub const RSA_F_PKEY_RSA_VERIFY = @as(c_int, 0);
pub const RSA_F_PKEY_RSA_VERIFYRECOVER = @as(c_int, 0);
pub const RSA_F_RSA_ALGOR_TO_MD = @as(c_int, 0);
pub const RSA_F_RSA_BUILTIN_KEYGEN = @as(c_int, 0);
pub const RSA_F_RSA_CHECK_KEY = @as(c_int, 0);
pub const RSA_F_RSA_CHECK_KEY_EX = @as(c_int, 0);
pub const RSA_F_RSA_CMS_DECRYPT = @as(c_int, 0);
pub const RSA_F_RSA_CMS_VERIFY = @as(c_int, 0);
pub const RSA_F_RSA_ITEM_VERIFY = @as(c_int, 0);
pub const RSA_F_RSA_METH_DUP = @as(c_int, 0);
pub const RSA_F_RSA_METH_NEW = @as(c_int, 0);
pub const RSA_F_RSA_METH_SET1_NAME = @as(c_int, 0);
pub const RSA_F_RSA_MGF1_TO_MD = @as(c_int, 0);
pub const RSA_F_RSA_MULTIP_INFO_NEW = @as(c_int, 0);
pub const RSA_F_RSA_NEW_METHOD = @as(c_int, 0);
pub const RSA_F_RSA_NULL = @as(c_int, 0);
pub const RSA_F_RSA_NULL_PRIVATE_DECRYPT = @as(c_int, 0);
pub const RSA_F_RSA_NULL_PRIVATE_ENCRYPT = @as(c_int, 0);
pub const RSA_F_RSA_NULL_PUBLIC_DECRYPT = @as(c_int, 0);
pub const RSA_F_RSA_NULL_PUBLIC_ENCRYPT = @as(c_int, 0);
pub const RSA_F_RSA_OSSL_PRIVATE_DECRYPT = @as(c_int, 0);
pub const RSA_F_RSA_OSSL_PRIVATE_ENCRYPT = @as(c_int, 0);
pub const RSA_F_RSA_OSSL_PUBLIC_DECRYPT = @as(c_int, 0);
pub const RSA_F_RSA_OSSL_PUBLIC_ENCRYPT = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_NONE = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_OAEP = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_OAEP_MGF1 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_PSS = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_SSLV23 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_ADD_X931 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_NONE = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP_MGF1 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_SSLV23 = @as(c_int, 0);
pub const RSA_F_RSA_PADDING_CHECK_X931 = @as(c_int, 0);
pub const RSA_F_RSA_PARAM_DECODE = @as(c_int, 0);
pub const RSA_F_RSA_PRINT = @as(c_int, 0);
pub const RSA_F_RSA_PRINT_FP = @as(c_int, 0);
pub const RSA_F_RSA_PRIV_DECODE = @as(c_int, 0);
pub const RSA_F_RSA_PRIV_ENCODE = @as(c_int, 0);
pub const RSA_F_RSA_PSS_GET_PARAM = @as(c_int, 0);
pub const RSA_F_RSA_PSS_TO_CTX = @as(c_int, 0);
pub const RSA_F_RSA_PUB_DECODE = @as(c_int, 0);
pub const RSA_F_RSA_SETUP_BLINDING = @as(c_int, 0);
pub const RSA_F_RSA_SIGN = @as(c_int, 0);
pub const RSA_F_RSA_SIGN_ASN1_OCTET_STRING = @as(c_int, 0);
pub const RSA_F_RSA_VERIFY = @as(c_int, 0);
pub const RSA_F_RSA_VERIFY_ASN1_OCTET_STRING = @as(c_int, 0);
pub const RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1 = @as(c_int, 0);
pub const RSA_F_SETUP_TBUF = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_CTRL = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_FIND = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_GET_PASS = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_LOAD = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_LOAD_TRY_DECODE = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_NAME_TO_URI = @as(c_int, 0);
pub const OSSL_STORE_F_FILE_OPEN = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_ATTACH_PEM_BIO = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_EXPECT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_FILE_ATTACH_PEM_BIO_INT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_FIND = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_GET0_LOADER_INT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_CERT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_CRL = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_NAME_DESCRIPTION = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_PARAMS = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_GET1_PKEY = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_CERT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_CRL = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_EMBEDDED = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_NAME = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_PARAMS = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_NEW_PKEY = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INFO_SET0_NAME_DESCRIPTION = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_INIT_ONCE = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_LOADER_NEW = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_OPEN = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_OPEN_INT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_REGISTER_LOADER_INT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_ALIAS = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_ISSUER_SERIAL = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_KEY_FINGERPRINT = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_SEARCH_BY_NAME = @as(c_int, 0);
pub const OSSL_STORE_F_OSSL_STORE_UNREGISTER_LOADER_INT = @as(c_int, 0);
pub const OSSL_STORE_F_TRY_DECODE_PARAMS = @as(c_int, 0);
pub const OSSL_STORE_F_TRY_DECODE_PKCS12 = @as(c_int, 0);
pub const OSSL_STORE_F_TRY_DECODE_PKCS8ENCRYPTED = @as(c_int, 0);
pub const TS_F_DEF_SERIAL_CB = @as(c_int, 0);
pub const TS_F_DEF_TIME_CB = @as(c_int, 0);
pub const TS_F_ESS_ADD_SIGNING_CERT = @as(c_int, 0);
pub const TS_F_ESS_ADD_SIGNING_CERT_V2 = @as(c_int, 0);
pub const TS_F_ESS_CERT_ID_NEW_INIT = @as(c_int, 0);
pub const TS_F_ESS_CERT_ID_V2_NEW_INIT = @as(c_int, 0);
pub const TS_F_ESS_SIGNING_CERT_NEW_INIT = @as(c_int, 0);
pub const TS_F_ESS_SIGNING_CERT_V2_NEW_INIT = @as(c_int, 0);
pub const TS_F_INT_TS_RESP_VERIFY_TOKEN = @as(c_int, 0);
pub const TS_F_PKCS7_TO_TS_TST_INFO = @as(c_int, 0);
pub const TS_F_TS_ACCURACY_SET_MICROS = @as(c_int, 0);
pub const TS_F_TS_ACCURACY_SET_MILLIS = @as(c_int, 0);
pub const TS_F_TS_ACCURACY_SET_SECONDS = @as(c_int, 0);
pub const TS_F_TS_CHECK_IMPRINTS = @as(c_int, 0);
pub const TS_F_TS_CHECK_NONCES = @as(c_int, 0);
pub const TS_F_TS_CHECK_POLICY = @as(c_int, 0);
pub const TS_F_TS_CHECK_SIGNING_CERTS = @as(c_int, 0);
pub const TS_F_TS_CHECK_STATUS_INFO = @as(c_int, 0);
pub const TS_F_TS_COMPUTE_IMPRINT = @as(c_int, 0);
pub const TS_F_TS_CONF_INVALID = @as(c_int, 0);
pub const TS_F_TS_CONF_LOAD_CERT = @as(c_int, 0);
pub const TS_F_TS_CONF_LOAD_CERTS = @as(c_int, 0);
pub const TS_F_TS_CONF_LOAD_KEY = @as(c_int, 0);
pub const TS_F_TS_CONF_LOOKUP_FAIL = @as(c_int, 0);
pub const TS_F_TS_CONF_SET_DEFAULT_ENGINE = @as(c_int, 0);
pub const TS_F_TS_GET_STATUS_TEXT = @as(c_int, 0);
pub const TS_F_TS_MSG_IMPRINT_SET_ALGO = @as(c_int, 0);
pub const TS_F_TS_REQ_SET_MSG_IMPRINT = @as(c_int, 0);
pub const TS_F_TS_REQ_SET_NONCE = @as(c_int, 0);
pub const TS_F_TS_REQ_SET_POLICY_ID = @as(c_int, 0);
pub const TS_F_TS_RESP_CREATE_RESPONSE = @as(c_int, 0);
pub const TS_F_TS_RESP_CREATE_TST_INFO = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_ADD_FAILURE_INFO = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_ADD_MD = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_ADD_POLICY = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_NEW = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_SET_ACCURACY = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_SET_CERTS = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_SET_DEF_POLICY = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_SET_SIGNER_CERT = @as(c_int, 0);
pub const TS_F_TS_RESP_CTX_SET_STATUS_INFO = @as(c_int, 0);
pub const TS_F_TS_RESP_GET_POLICY = @as(c_int, 0);
pub const TS_F_TS_RESP_SET_GENTIME_WITH_PRECISION = @as(c_int, 0);
pub const TS_F_TS_RESP_SET_STATUS_INFO = @as(c_int, 0);
pub const TS_F_TS_RESP_SET_TST_INFO = @as(c_int, 0);
pub const TS_F_TS_RESP_SIGN = @as(c_int, 0);
pub const TS_F_TS_RESP_VERIFY_SIGNATURE = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_ACCURACY = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_MSG_IMPRINT = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_NONCE = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_POLICY_ID = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_SERIAL = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_TIME = @as(c_int, 0);
pub const TS_F_TS_TST_INFO_SET_TSA = @as(c_int, 0);
pub const TS_F_TS_VERIFY = @as(c_int, 0);
pub const TS_F_TS_VERIFY_CERT = @as(c_int, 0);
pub const TS_F_TS_VERIFY_CTX_NEW = @as(c_int, 0);
pub const UI_F_CLOSE_CONSOLE = @as(c_int, 0);
pub const UI_F_ECHO_CONSOLE = @as(c_int, 0);
pub const UI_F_GENERAL_ALLOCATE_BOOLEAN = @as(c_int, 0);
pub const UI_F_GENERAL_ALLOCATE_PROMPT = @as(c_int, 0);
pub const UI_F_NOECHO_CONSOLE = @as(c_int, 0);
pub const UI_F_OPEN_CONSOLE = @as(c_int, 0);
pub const UI_F_UI_CONSTRUCT_PROMPT = @as(c_int, 0);
pub const UI_F_UI_CREATE_METHOD = @as(c_int, 0);
pub const UI_F_UI_CTRL = @as(c_int, 0);
pub const UI_F_UI_DUP_ERROR_STRING = @as(c_int, 0);
pub const UI_F_UI_DUP_INFO_STRING = @as(c_int, 0);
pub const UI_F_UI_DUP_INPUT_BOOLEAN = @as(c_int, 0);
pub const UI_F_UI_DUP_INPUT_STRING = @as(c_int, 0);
pub const UI_F_UI_DUP_USER_DATA = @as(c_int, 0);
pub const UI_F_UI_DUP_VERIFY_STRING = @as(c_int, 0);
pub const UI_F_UI_GET0_RESULT = @as(c_int, 0);
pub const UI_F_UI_GET_RESULT_LENGTH = @as(c_int, 0);
pub const UI_F_UI_NEW_METHOD = @as(c_int, 0);
pub const UI_F_UI_PROCESS = @as(c_int, 0);
pub const UI_F_UI_SET_RESULT = @as(c_int, 0);
pub const UI_F_UI_SET_RESULT_EX = @as(c_int, 0);
pub const X509_F_ADD_CERT_DIR = @as(c_int, 0);
pub const X509_F_BUILD_CHAIN = @as(c_int, 0);
pub const X509_F_BY_FILE_CTRL = @as(c_int, 0);
pub const X509_F_CHECK_NAME_CONSTRAINTS = @as(c_int, 0);
pub const X509_F_CHECK_POLICY = @as(c_int, 0);
pub const X509_F_DANE_I2D = @as(c_int, 0);
pub const X509_F_DIR_CTRL = @as(c_int, 0);
pub const X509_F_GET_CERT_BY_SUBJECT = @as(c_int, 0);
pub const X509_F_I2D_X509_AUX = @as(c_int, 0);
pub const X509_F_LOOKUP_CERTS_SK = @as(c_int, 0);
pub const X509_F_NETSCAPE_SPKI_B64_DECODE = @as(c_int, 0);
pub const X509_F_NETSCAPE_SPKI_B64_ENCODE = @as(c_int, 0);
pub const X509_F_NEW_DIR = @as(c_int, 0);
pub const X509_F_X509AT_ADD1_ATTR = @as(c_int, 0);
pub const X509_F_X509V3_ADD_EXT = @as(c_int, 0);
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_NID = @as(c_int, 0);
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_OBJ = @as(c_int, 0);
pub const X509_F_X509_ATTRIBUTE_CREATE_BY_TXT = @as(c_int, 0);
pub const X509_F_X509_ATTRIBUTE_GET0_DATA = @as(c_int, 0);
pub const X509_F_X509_ATTRIBUTE_SET1_DATA = @as(c_int, 0);
pub const X509_F_X509_CHECK_PRIVATE_KEY = @as(c_int, 0);
pub const X509_F_X509_CRL_DIFF = @as(c_int, 0);
pub const X509_F_X509_CRL_METHOD_NEW = @as(c_int, 0);
pub const X509_F_X509_CRL_PRINT_FP = @as(c_int, 0);
pub const X509_F_X509_EXTENSION_CREATE_BY_NID = @as(c_int, 0);
pub const X509_F_X509_EXTENSION_CREATE_BY_OBJ = @as(c_int, 0);
pub const X509_F_X509_GET_PUBKEY_PARAMETERS = @as(c_int, 0);
pub const X509_F_X509_LOAD_CERT_CRL_FILE = @as(c_int, 0);
pub const X509_F_X509_LOAD_CERT_FILE = @as(c_int, 0);
pub const X509_F_X509_LOAD_CRL_FILE = @as(c_int, 0);
pub const X509_F_X509_LOOKUP_METH_NEW = @as(c_int, 0);
pub const X509_F_X509_LOOKUP_NEW = @as(c_int, 0);
pub const X509_F_X509_NAME_ADD_ENTRY = @as(c_int, 0);
pub const X509_F_X509_NAME_CANON = @as(c_int, 0);
pub const X509_F_X509_NAME_ENTRY_CREATE_BY_NID = @as(c_int, 0);
pub const X509_F_X509_NAME_ENTRY_CREATE_BY_TXT = @as(c_int, 0);
pub const X509_F_X509_NAME_ENTRY_SET_OBJECT = @as(c_int, 0);
pub const X509_F_X509_NAME_ONELINE = @as(c_int, 0);
pub const X509_F_X509_NAME_PRINT = @as(c_int, 0);
pub const X509_F_X509_OBJECT_NEW = @as(c_int, 0);
pub const X509_F_X509_PRINT_EX_FP = @as(c_int, 0);
pub const X509_F_X509_PUBKEY_DECODE = @as(c_int, 0);
pub const X509_F_X509_PUBKEY_GET = @as(c_int, 0);
pub const X509_F_X509_PUBKEY_GET0 = @as(c_int, 0);
pub const X509_F_X509_PUBKEY_SET = @as(c_int, 0);
pub const X509_F_X509_REQ_CHECK_PRIVATE_KEY = @as(c_int, 0);
pub const X509_F_X509_REQ_PRINT_EX = @as(c_int, 0);
pub const X509_F_X509_REQ_PRINT_FP = @as(c_int, 0);
pub const X509_F_X509_REQ_TO_X509 = @as(c_int, 0);
pub const X509_F_X509_STORE_ADD_CERT = @as(c_int, 0);
pub const X509_F_X509_STORE_ADD_CRL = @as(c_int, 0);
pub const X509_F_X509_STORE_ADD_LOOKUP = @as(c_int, 0);
pub const X509_F_X509_STORE_CTX_GET1_ISSUER = @as(c_int, 0);
pub const X509_F_X509_STORE_CTX_INIT = @as(c_int, 0);
pub const X509_F_X509_STORE_CTX_NEW = @as(c_int, 0);
pub const X509_F_X509_STORE_CTX_PURPOSE_INHERIT = @as(c_int, 0);
pub const X509_F_X509_STORE_NEW = @as(c_int, 0);
pub const X509_F_X509_TO_X509_REQ = @as(c_int, 0);
pub const X509_F_X509_TRUST_ADD = @as(c_int, 0);
pub const X509_F_X509_TRUST_SET = @as(c_int, 0);
pub const X509_F_X509_VERIFY_CERT = @as(c_int, 0);
pub const X509_F_X509_VERIFY_PARAM_NEW = @as(c_int, 0);
pub const X509V3_F_A2I_GENERAL_NAME = @as(c_int, 0);
pub const X509V3_F_ADDR_VALIDATE_PATH_INTERNAL = @as(c_int, 0);
pub const X509V3_F_ASIDENTIFIERCHOICE_CANONIZE = @as(c_int, 0);
pub const X509V3_F_ASIDENTIFIERCHOICE_IS_CANONICAL = @as(c_int, 0);
pub const X509V3_F_BIGNUM_TO_STRING = @as(c_int, 0);
pub const X509V3_F_COPY_EMAIL = @as(c_int, 0);
pub const X509V3_F_COPY_ISSUER = @as(c_int, 0);
pub const X509V3_F_DO_DIRNAME = @as(c_int, 0);
pub const X509V3_F_DO_EXT_I2D = @as(c_int, 0);
pub const X509V3_F_DO_EXT_NCONF = @as(c_int, 0);
pub const X509V3_F_GNAMES_FROM_SECTNAME = @as(c_int, 0);
pub const X509V3_F_I2S_ASN1_ENUMERATED = @as(c_int, 0);
pub const X509V3_F_I2S_ASN1_IA5STRING = @as(c_int, 0);
pub const X509V3_F_I2S_ASN1_INTEGER = @as(c_int, 0);
pub const X509V3_F_I2V_AUTHORITY_INFO_ACCESS = @as(c_int, 0);
pub const X509V3_F_LEVEL_ADD_NODE = @as(c_int, 0);
pub const X509V3_F_NOTICE_SECTION = @as(c_int, 0);
pub const X509V3_F_NREF_NOS = @as(c_int, 0);
pub const X509V3_F_POLICY_CACHE_CREATE = @as(c_int, 0);
pub const X509V3_F_POLICY_CACHE_NEW = @as(c_int, 0);
pub const X509V3_F_POLICY_DATA_NEW = @as(c_int, 0);
pub const X509V3_F_POLICY_SECTION = @as(c_int, 0);
pub const X509V3_F_PROCESS_PCI_VALUE = @as(c_int, 0);
pub const X509V3_F_R2I_CERTPOL = @as(c_int, 0);
pub const X509V3_F_R2I_PCI = @as(c_int, 0);
pub const X509V3_F_S2I_ASN1_IA5STRING = @as(c_int, 0);
pub const X509V3_F_S2I_ASN1_INTEGER = @as(c_int, 0);
pub const X509V3_F_S2I_ASN1_OCTET_STRING = @as(c_int, 0);
pub const X509V3_F_S2I_SKEY_ID = @as(c_int, 0);
pub const X509V3_F_SET_DIST_POINT_NAME = @as(c_int, 0);
pub const X509V3_F_SXNET_ADD_ID_ASC = @as(c_int, 0);
pub const X509V3_F_SXNET_ADD_ID_INTEGER = @as(c_int, 0);
pub const X509V3_F_SXNET_ADD_ID_ULONG = @as(c_int, 0);
pub const X509V3_F_SXNET_GET_ID_ASC = @as(c_int, 0);
pub const X509V3_F_SXNET_GET_ID_ULONG = @as(c_int, 0);
pub const X509V3_F_TREE_INIT = @as(c_int, 0);
pub const X509V3_F_V2I_ASIDENTIFIERS = @as(c_int, 0);
pub const X509V3_F_V2I_ASN1_BIT_STRING = @as(c_int, 0);
pub const X509V3_F_V2I_AUTHORITY_INFO_ACCESS = @as(c_int, 0);
pub const X509V3_F_V2I_AUTHORITY_KEYID = @as(c_int, 0);
pub const X509V3_F_V2I_BASIC_CONSTRAINTS = @as(c_int, 0);
pub const X509V3_F_V2I_CRLD = @as(c_int, 0);
pub const X509V3_F_V2I_EXTENDED_KEY_USAGE = @as(c_int, 0);
pub const X509V3_F_V2I_GENERAL_NAMES = @as(c_int, 0);
pub const X509V3_F_V2I_GENERAL_NAME_EX = @as(c_int, 0);
pub const X509V3_F_V2I_IDP = @as(c_int, 0);
pub const X509V3_F_V2I_IPADDRBLOCKS = @as(c_int, 0);
pub const X509V3_F_V2I_ISSUER_ALT = @as(c_int, 0);
pub const X509V3_F_V2I_NAME_CONSTRAINTS = @as(c_int, 0);
pub const X509V3_F_V2I_POLICY_CONSTRAINTS = @as(c_int, 0);
pub const X509V3_F_V2I_POLICY_MAPPINGS = @as(c_int, 0);
pub const X509V3_F_V2I_SUBJECT_ALT = @as(c_int, 0);
pub const X509V3_F_V2I_TLS_FEATURE = @as(c_int, 0);
pub const X509V3_F_V3_GENERIC_EXTENSION = @as(c_int, 0);
pub const X509V3_F_X509V3_ADD1_I2D = @as(c_int, 0);
pub const X509V3_F_X509V3_ADD_VALUE = @as(c_int, 0);
pub const X509V3_F_X509V3_EXT_ADD = @as(c_int, 0);
pub const X509V3_F_X509V3_EXT_ADD_ALIAS = @as(c_int, 0);
pub const X509V3_F_X509V3_EXT_I2D = @as(c_int, 0);
pub const X509V3_F_X509V3_EXT_NCONF = @as(c_int, 0);
pub const X509V3_F_X509V3_GET_SECTION = @as(c_int, 0);
pub const X509V3_F_X509V3_GET_STRING = @as(c_int, 0);
pub const X509V3_F_X509V3_GET_VALUE_BOOL = @as(c_int, 0);
pub const X509V3_F_X509V3_PARSE_LIST = @as(c_int, 0);
pub const X509V3_F_X509_PURPOSE_ADD = @as(c_int, 0);
pub const X509V3_F_X509_PURPOSE_SET = @as(c_int, 0);
pub const EVP_R_OPERATON_NOT_INITIALIZED = EVP_R_OPERATION_NOT_INITIALIZED;
pub const CRYPTO_R_BAD_ALGORITHM_NAME = @as(c_int, 117);
pub const CRYPTO_R_CONFLICTING_NAMES = @as(c_int, 118);
pub const CRYPTO_R_HEX_STRING_TOO_SHORT = @as(c_int, 121);
pub const CRYPTO_R_ILLEGAL_HEX_DIGIT = @as(c_int, 102);
pub const CRYPTO_R_INSUFFICIENT_DATA_SPACE = @as(c_int, 106);
pub const CRYPTO_R_INSUFFICIENT_PARAM_SIZE = @as(c_int, 107);
pub const CRYPTO_R_INSUFFICIENT_SECURE_DATA_SPACE = @as(c_int, 108);
pub const CRYPTO_R_INTEGER_OVERFLOW = @as(c_int, 127);
pub const CRYPTO_R_INVALID_NEGATIVE_VALUE = @as(c_int, 122);
pub const CRYPTO_R_INVALID_NULL_ARGUMENT = @as(c_int, 109);
pub const CRYPTO_R_INVALID_OSSL_PARAM_TYPE = @as(c_int, 110);
pub const CRYPTO_R_NO_PARAMS_TO_MERGE = @as(c_int, 131);
pub const CRYPTO_R_NO_SPACE_FOR_TERMINATING_NULL = @as(c_int, 128);
pub const CRYPTO_R_ODD_NUMBER_OF_DIGITS = @as(c_int, 103);
pub const CRYPTO_R_PARAM_CANNOT_BE_REPRESENTED_EXACTLY = @as(c_int, 123);
pub const CRYPTO_R_PARAM_NOT_INTEGER_TYPE = @as(c_int, 124);
pub const CRYPTO_R_PARAM_OF_INCOMPATIBLE_TYPE = @as(c_int, 129);
pub const CRYPTO_R_PARAM_UNSIGNED_INTEGER_NEGATIVE_VALUE_UNSUPPORTED = @as(c_int, 125);
pub const CRYPTO_R_PARAM_UNSUPPORTED_FLOATING_POINT_FORMAT = @as(c_int, 130);
pub const CRYPTO_R_PARAM_VALUE_TOO_LARGE_FOR_DESTINATION = @as(c_int, 126);
pub const CRYPTO_R_PROVIDER_ALREADY_EXISTS = @as(c_int, 104);
pub const CRYPTO_R_PROVIDER_SECTION_ERROR = @as(c_int, 105);
pub const CRYPTO_R_RANDOM_SECTION_ERROR = @as(c_int, 119);
pub const CRYPTO_R_SECURE_MALLOC_FAILURE = @as(c_int, 111);
pub const CRYPTO_R_STRING_TOO_LONG = @as(c_int, 112);
pub const CRYPTO_R_TOO_MANY_BYTES = @as(c_int, 113);
pub const CRYPTO_R_TOO_MANY_NAMES = @as(c_int, 132);
pub const CRYPTO_R_TOO_MANY_RECORDS = @as(c_int, 114);
pub const CRYPTO_R_TOO_SMALL_BUFFER = @as(c_int, 116);
pub const CRYPTO_R_UNKNOWN_NAME_IN_RANDOM_SECTION = @as(c_int, 120);
pub const CRYPTO_R_ZERO_LENGTH_NUMBER = @as(c_int, 115);
pub const OPENSSL_CORE_H = "";
pub const OSSL_DISPATCH_END = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/openssl/core.h:45:10
pub const OSSL_PARAM_INTEGER = @as(c_int, 1);
pub const OSSL_PARAM_UNSIGNED_INTEGER = @as(c_int, 2);
pub const OSSL_PARAM_REAL = @as(c_int, 3);
pub const OSSL_PARAM_UTF8_STRING = @as(c_int, 4);
pub const OSSL_PARAM_OCTET_STRING = @as(c_int, 5);
pub const OSSL_PARAM_UTF8_PTR = @as(c_int, 6);
pub const OSSL_PARAM_OCTET_PTR = @as(c_int, 7);
pub const SSLeay = OpenSSL_version_num;
pub const SSLeay_version = OpenSSL_version;
pub const SSLEAY_VERSION_NUMBER = OPENSSL_VERSION_NUMBER;
pub const SSLEAY_VERSION = OPENSSL_VERSION;
pub const SSLEAY_CFLAGS = OPENSSL_CFLAGS;
pub const SSLEAY_BUILT_ON = OPENSSL_BUILT_ON;
pub const SSLEAY_PLATFORM = OPENSSL_PLATFORM;
pub const SSLEAY_DIR = OPENSSL_DIR;
pub const OPENSSL_malloc_init = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/crypto.h:99:9
pub inline fn OPENSSL_malloc(num: anytype) @TypeOf(CRYPTO_malloc(num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &num;
    return CRYPTO_malloc(num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_zalloc(num: anytype) @TypeOf(CRYPTO_zalloc(num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &num;
    return CRYPTO_zalloc(num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_aligned_alloc(num: anytype, alignment: anytype, freeptr: anytype) @TypeOf(CRYPTO_aligned_alloc(num, alignment, freeptr, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &num;
    _ = &alignment;
    _ = &freeptr;
    return CRYPTO_aligned_alloc(num, alignment, freeptr, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_realloc(addr: anytype, num: anytype) @TypeOf(CRYPTO_realloc(addr, num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    _ = &num;
    return CRYPTO_realloc(addr, num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_clear_realloc(addr: anytype, old_num: anytype, num: anytype) @TypeOf(CRYPTO_clear_realloc(addr, old_num, num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    _ = &old_num;
    _ = &num;
    return CRYPTO_clear_realloc(addr, old_num, num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_clear_free(addr: anytype, num: anytype) @TypeOf(CRYPTO_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    _ = &num;
    return CRYPTO_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_free(addr: anytype) @TypeOf(CRYPTO_free(addr, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    return CRYPTO_free(addr, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_memdup(str: anytype, s: anytype) @TypeOf(CRYPTO_memdup(str, s, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &str;
    _ = &s;
    return CRYPTO_memdup(str, s, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_strdup(str: anytype) @TypeOf(CRYPTO_strdup(str, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &str;
    return CRYPTO_strdup(str, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_strndup(str: anytype, n: anytype) @TypeOf(CRYPTO_strndup(str, n, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &str;
    _ = &n;
    return CRYPTO_strndup(str, n, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_secure_malloc(num: anytype) @TypeOf(CRYPTO_secure_malloc(num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &num;
    return CRYPTO_secure_malloc(num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_secure_zalloc(num: anytype) @TypeOf(CRYPTO_secure_zalloc(num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &num;
    return CRYPTO_secure_zalloc(num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_secure_free(addr: anytype) @TypeOf(CRYPTO_secure_free(addr, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    return CRYPTO_secure_free(addr, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_secure_clear_free(addr: anytype, num: anytype) @TypeOf(CRYPTO_secure_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE)) {
    _ = &addr;
    _ = &num;
    return CRYPTO_secure_clear_free(addr, num, OPENSSL_FILE, OPENSSL_LINE);
}
pub inline fn OPENSSL_secure_actual_size(ptr: anytype) @TypeOf(CRYPTO_secure_actual_size(ptr)) {
    _ = &ptr;
    return CRYPTO_secure_actual_size(ptr);
}
pub inline fn OPENSSL_MALLOC_MAX_NELEMS(@"type": anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div((@as(c_uint, 1) << ((@import("std").zig.c_translation.sizeof(c_int) * @as(c_int, 8)) - @as(c_int, 1))) - @as(c_int, 1), @import("std").zig.c_translation.sizeof(@"type"))) {
    _ = &@"type";
    return @import("std").zig.c_translation.MacroArithmetic.div((@as(c_uint, 1) << ((@import("std").zig.c_translation.sizeof(c_int) * @as(c_int, 8)) - @as(c_int, 1))) - @as(c_int, 1), @import("std").zig.c_translation.sizeof(@"type"));
}
pub const OPENSSL_VERSION = @as(c_int, 0);
pub const OPENSSL_CFLAGS = @as(c_int, 1);
pub const OPENSSL_BUILT_ON = @as(c_int, 2);
pub const OPENSSL_PLATFORM = @as(c_int, 3);
pub const OPENSSL_DIR = @as(c_int, 4);
pub const OPENSSL_ENGINES_DIR = @as(c_int, 5);
pub const OPENSSL_VERSION_STRING = @as(c_int, 6);
pub const OPENSSL_FULL_VERSION_STRING = @as(c_int, 7);
pub const OPENSSL_MODULES_DIR = @as(c_int, 8);
pub const OPENSSL_CPU_INFO = @as(c_int, 9);
pub const OPENSSL_WINCTX = @as(c_int, 10);
pub const OPENSSL_INFO_CONFIG_DIR = @as(c_int, 1001);
pub const OPENSSL_INFO_ENGINES_DIR = @as(c_int, 1002);
pub const OPENSSL_INFO_MODULES_DIR = @as(c_int, 1003);
pub const OPENSSL_INFO_DSO_EXTENSION = @as(c_int, 1004);
pub const OPENSSL_INFO_DIR_FILENAME_SEPARATOR = @as(c_int, 1005);
pub const OPENSSL_INFO_LIST_SEPARATOR = @as(c_int, 1006);
pub const OPENSSL_INFO_SEED_SOURCE = @as(c_int, 1007);
pub const OPENSSL_INFO_CPU_SETTINGS = @as(c_int, 1008);
pub const OPENSSL_INFO_WINDOWS_CONTEXT = @as(c_int, 1009);
pub inline fn sk_void_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_void_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_void_sk_type(sk));
}
pub inline fn sk_void_value(sk: anytype, idx: anytype) ?*anyopaque {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_value(ossl_check_const_void_sk_type(sk), idx));
}
pub const sk_void_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/crypto.h:200:9
pub const sk_void_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/crypto.h:201:9
pub const sk_void_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/crypto.h:202:9
pub inline fn sk_void_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_void_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_void_sk_type(sk), n);
}
pub inline fn sk_void_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_void_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_void_sk_type(sk));
}
pub inline fn sk_void_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_void_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_void_sk_type(sk));
}
pub inline fn sk_void_delete(sk: anytype, i: anytype) ?*anyopaque {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_delete(ossl_check_void_sk_type(sk), i));
}
pub inline fn sk_void_delete_ptr(sk: anytype, ptr: anytype) ?*anyopaque {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_delete_ptr(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr)));
}
pub inline fn sk_void_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr));
}
pub inline fn sk_void_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr));
}
pub inline fn sk_void_pop(sk: anytype) ?*anyopaque {
    _ = &sk;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_pop(ossl_check_void_sk_type(sk)));
}
pub inline fn sk_void_shift(sk: anytype) ?*anyopaque {
    _ = &sk;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_shift(ossl_check_void_sk_type(sk)));
}
pub inline fn sk_void_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_void_sk_type(sk), ossl_check_void_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_void_sk_type(sk), ossl_check_void_freefunc_type(freefunc));
}
pub inline fn sk_void_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr), idx);
}
pub inline fn sk_void_set(sk: anytype, idx: anytype, ptr: anytype) ?*anyopaque {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast(?*anyopaque, OPENSSL_sk_set(ossl_check_void_sk_type(sk), idx, ossl_check_void_type(ptr)));
}
pub inline fn sk_void_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr));
}
pub inline fn sk_void_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr));
}
pub inline fn sk_void_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_void_sk_type(sk), ossl_check_void_type(ptr), pnum);
}
pub inline fn sk_void_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_void_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_void_sk_type(sk));
}
pub inline fn sk_void_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_void_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_void_sk_type(sk));
}
pub const sk_void_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/crypto.h:220:9
pub const sk_void_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/crypto.h:221:9
pub inline fn sk_void_set_cmp_func(sk: anytype, cmp: anytype) sk_void_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_void_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_void_sk_type(sk), ossl_check_void_compfunc_type(cmp)));
}
pub const CRYPTO_EX_INDEX_SSL = @as(c_int, 0);
pub const CRYPTO_EX_INDEX_SSL_CTX = @as(c_int, 1);
pub const CRYPTO_EX_INDEX_SSL_SESSION = @as(c_int, 2);
pub const CRYPTO_EX_INDEX_X509 = @as(c_int, 3);
pub const CRYPTO_EX_INDEX_X509_STORE = @as(c_int, 4);
pub const CRYPTO_EX_INDEX_X509_STORE_CTX = @as(c_int, 5);
pub const CRYPTO_EX_INDEX_DH = @as(c_int, 6);
pub const CRYPTO_EX_INDEX_DSA = @as(c_int, 7);
pub const CRYPTO_EX_INDEX_EC_KEY = @as(c_int, 8);
pub const CRYPTO_EX_INDEX_RSA = @as(c_int, 9);
pub const CRYPTO_EX_INDEX_ENGINE = @as(c_int, 10);
pub const CRYPTO_EX_INDEX_UI = @as(c_int, 11);
pub const CRYPTO_EX_INDEX_BIO = @as(c_int, 12);
pub const CRYPTO_EX_INDEX_APP = @as(c_int, 13);
pub const CRYPTO_EX_INDEX_UI_METHOD = @as(c_int, 14);
pub const CRYPTO_EX_INDEX_RAND_DRBG = @as(c_int, 15);
pub const CRYPTO_EX_INDEX_DRBG = CRYPTO_EX_INDEX_RAND_DRBG;
pub const CRYPTO_EX_INDEX_OSSL_LIB_CTX = @as(c_int, 16);
pub const CRYPTO_EX_INDEX_EVP_PKEY = @as(c_int, 17);
pub const CRYPTO_EX_INDEX__COUNT = @as(c_int, 18);
pub const CRYPTO_cleanup_all_ex_data = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/crypto.h:289:10
pub inline fn CRYPTO_num_locks() @TypeOf(@as(c_int, 1)) {
    return @as(c_int, 1);
}
pub const CRYPTO_set_locking_callback = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/openssl/crypto.h:302:11
pub inline fn CRYPTO_get_locking_callback() @TypeOf(NULL) {
    return NULL;
}
pub const CRYPTO_set_add_lock_callback = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/openssl/crypto.h:304:11
pub inline fn CRYPTO_get_add_lock_callback() @TypeOf(NULL) {
    return NULL;
}
pub const CRYPTO_LOCK = @as(c_int, 1);
pub const CRYPTO_UNLOCK = @as(c_int, 2);
pub const CRYPTO_READ = @as(c_int, 4);
pub const CRYPTO_WRITE = @as(c_int, 8);
pub const CRYPTO_THREADID_set_numeric = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/openssl/crypto.h:322:11
pub const CRYPTO_THREADID_set_pointer = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/openssl/crypto.h:323:11
pub inline fn CRYPTO_THREADID_set_callback(threadid_func: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &threadid_func;
    return @as(c_int, 0);
}
pub inline fn CRYPTO_THREADID_get_callback() @TypeOf(NULL) {
    return NULL;
}
pub const CRYPTO_THREADID_current = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/openssl/crypto.h:326:11
pub inline fn CRYPTO_THREADID_cmp(a: anytype, b: anytype) @TypeOf(-@as(c_int, 1)) {
    _ = &a;
    _ = &b;
    return -@as(c_int, 1);
}
pub const CRYPTO_THREADID_cpy = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/openssl/crypto.h:328:11
pub inline fn CRYPTO_THREADID_hash(id: anytype) @TypeOf(@as(c_ulong, 0)) {
    _ = &id;
    return @as(c_ulong, 0);
}
pub const CRYPTO_set_id_callback = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/openssl/crypto.h:332:12
pub inline fn CRYPTO_get_id_callback() @TypeOf(NULL) {
    return NULL;
}
pub inline fn CRYPTO_thread_id() @TypeOf(@as(c_ulong, 0)) {
    return @as(c_ulong, 0);
}
pub const CRYPTO_set_dynlock_create_callback = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/openssl/crypto.h:337:11
pub const CRYPTO_set_dynlock_lock_callback = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/openssl/crypto.h:338:11
pub const CRYPTO_set_dynlock_destroy_callback = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/openssl/crypto.h:339:11
pub inline fn CRYPTO_get_dynlock_create_callback() @TypeOf(NULL) {
    return NULL;
}
pub inline fn CRYPTO_get_dynlock_lock_callback() @TypeOf(NULL) {
    return NULL;
}
pub inline fn CRYPTO_get_dynlock_destroy_callback() @TypeOf(NULL) {
    return NULL;
}
pub inline fn OpenSSLDie(f: anytype, l: anytype, a: anytype) @TypeOf(OPENSSL_die(a, f, l)) {
    _ = &f;
    _ = &l;
    _ = &a;
    return OPENSSL_die(a, f, l);
}
pub const OPENSSL_assert = @compileError("unable to translate C expr: expected ',' or ')' instead got '#'");
// /usr/include/openssl/crypto.h:434:10
pub const OPENSSL_INIT_NO_LOAD_CRYPTO_STRINGS = @as(c_long, 0x00000001);
pub const OPENSSL_INIT_LOAD_CRYPTO_STRINGS = @as(c_long, 0x00000002);
pub const OPENSSL_INIT_ADD_ALL_CIPHERS = @as(c_long, 0x00000004);
pub const OPENSSL_INIT_ADD_ALL_DIGESTS = @as(c_long, 0x00000008);
pub const OPENSSL_INIT_NO_ADD_ALL_CIPHERS = @as(c_long, 0x00000010);
pub const OPENSSL_INIT_NO_ADD_ALL_DIGESTS = @as(c_long, 0x00000020);
pub const OPENSSL_INIT_LOAD_CONFIG = @as(c_long, 0x00000040);
pub const OPENSSL_INIT_NO_LOAD_CONFIG = @as(c_long, 0x00000080);
pub const OPENSSL_INIT_ASYNC = @as(c_long, 0x00000100);
pub const OPENSSL_INIT_ENGINE_RDRAND = @as(c_long, 0x00000200);
pub const OPENSSL_INIT_ENGINE_DYNAMIC = @as(c_long, 0x00000400);
pub const OPENSSL_INIT_ENGINE_OPENSSL = @as(c_long, 0x00000800);
pub const OPENSSL_INIT_ENGINE_CRYPTODEV = @as(c_long, 0x00001000);
pub const OPENSSL_INIT_ENGINE_CAPI = @as(c_long, 0x00002000);
pub const OPENSSL_INIT_ENGINE_PADLOCK = @as(c_long, 0x00004000);
pub const OPENSSL_INIT_ENGINE_AFALG = @as(c_long, 0x00008000);
pub const OPENSSL_INIT_ATFORK = @as(c_long, 0x00020000);
pub const OPENSSL_INIT_NO_ATEXIT = @as(c_long, 0x00080000);
pub const OPENSSL_INIT_ENGINE_ALL_BUILTIN = (((OPENSSL_INIT_ENGINE_RDRAND | OPENSSL_INIT_ENGINE_DYNAMIC) | OPENSSL_INIT_ENGINE_CRYPTODEV) | OPENSSL_INIT_ENGINE_CAPI) | OPENSSL_INIT_ENGINE_PADLOCK;
pub const _PTHREAD_H = @as(c_int, 1);
pub const _BITS_SETJMP_H = @as(c_int, 1);
pub const __jmp_buf_tag_defined = @as(c_int, 1);
pub const PTHREAD_MUTEX_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/pthread.h:90:9
pub const PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/pthread.h:93:10
pub const PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/pthread.h:95:10
pub const PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/pthread.h:97:10
pub const PTHREAD_RWLOCK_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/pthread.h:114:10
pub const PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/pthread.h:117:11
pub const PTHREAD_COND_INITIALIZER = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/pthread.h:155:9
pub const PTHREAD_CANCELED = @import("std").zig.c_translation.cast(?*anyopaque, -@as(c_int, 1));
pub const PTHREAD_ONCE_INIT = @as(c_int, 0);
pub const PTHREAD_BARRIER_SERIAL_THREAD = -@as(c_int, 1);
pub const PTHREAD_ATTR_NO_SIGMASK_NP = -@as(c_int, 1);
pub const __cleanup_fct_attribute = "";
pub const pthread_cleanup_push = @compileError("unable to translate macro: undefined identifier `__cancel_buf`");
// /usr/include/pthread.h:681:10
pub const pthread_cleanup_pop = @compileError("unable to translate macro: undefined identifier `__cancel_buf`");
// /usr/include/pthread.h:702:10
pub const pthread_cleanup_push_defer_np = @compileError("unable to translate macro: undefined identifier `__cancel_buf`");
// /usr/include/pthread.h:716:11
pub const pthread_cleanup_pop_restore_np = @compileError("unable to translate macro: undefined identifier `__cancel_buf`");
// /usr/include/pthread.h:738:11
pub inline fn __sigsetjmp_cancel(env: anytype, savemask: anytype) @TypeOf(__sigsetjmp(@import("std").zig.c_translation.cast([*c]struct___jmp_buf_tag, @import("std").zig.c_translation.cast(?*anyopaque, env)), savemask)) {
    _ = &env;
    _ = &savemask;
    return __sigsetjmp(@import("std").zig.c_translation.cast([*c]struct___jmp_buf_tag, @import("std").zig.c_translation.cast(?*anyopaque, env)), savemask);
}
pub const CRYPTO_ONCE_STATIC_INIT = PTHREAD_ONCE_INIT;
pub const OPENSSL_COMPERR_H = "";
pub const COMP_R_BROTLI_DECODE_ERROR = @as(c_int, 102);
pub const COMP_R_BROTLI_ENCODE_ERROR = @as(c_int, 103);
pub const COMP_R_BROTLI_NOT_SUPPORTED = @as(c_int, 104);
pub const COMP_R_ZLIB_DEFLATE_ERROR = @as(c_int, 99);
pub const COMP_R_ZLIB_INFLATE_ERROR = @as(c_int, 100);
pub const COMP_R_ZLIB_NOT_SUPPORTED = @as(c_int, 101);
pub const COMP_R_ZSTD_COMPRESS_ERROR = @as(c_int, 105);
pub const COMP_R_ZSTD_DECODE_ERROR = @as(c_int, 106);
pub const COMP_R_ZSTD_DECOMPRESS_ERROR = @as(c_int, 107);
pub const COMP_R_ZSTD_NOT_SUPPORTED = @as(c_int, 108);
pub const COMP_zlib_cleanup = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/comp.h:53:12
pub inline fn sk_SSL_COMP_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_SSL_COMP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_SSL_COMP_sk_type(sk));
}
pub inline fn sk_SSL_COMP_value(sk: anytype, idx: anytype) [*c]SSL_COMP {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_value(ossl_check_const_SSL_COMP_sk_type(sk), idx));
}
pub const sk_SSL_COMP_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/comp.h:69:9
pub const sk_SSL_COMP_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/comp.h:70:9
pub const sk_SSL_COMP_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/comp.h:71:9
pub inline fn sk_SSL_COMP_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_SSL_COMP_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_SSL_COMP_sk_type(sk), n);
}
pub inline fn sk_SSL_COMP_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_SSL_COMP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_SSL_COMP_sk_type(sk));
}
pub inline fn sk_SSL_COMP_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_SSL_COMP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_SSL_COMP_sk_type(sk));
}
pub inline fn sk_SSL_COMP_delete(sk: anytype, i: anytype) [*c]SSL_COMP {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_delete(ossl_check_SSL_COMP_sk_type(sk), i));
}
pub inline fn sk_SSL_COMP_delete_ptr(sk: anytype, ptr: anytype) [*c]SSL_COMP {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_delete_ptr(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr)));
}
pub inline fn sk_SSL_COMP_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr));
}
pub inline fn sk_SSL_COMP_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr));
}
pub inline fn sk_SSL_COMP_pop(sk: anytype) [*c]SSL_COMP {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_pop(ossl_check_SSL_COMP_sk_type(sk)));
}
pub inline fn sk_SSL_COMP_shift(sk: anytype) [*c]SSL_COMP {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_shift(ossl_check_SSL_COMP_sk_type(sk)));
}
pub inline fn sk_SSL_COMP_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_freefunc_type(freefunc));
}
pub inline fn sk_SSL_COMP_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr), idx);
}
pub inline fn sk_SSL_COMP_set(sk: anytype, idx: anytype, ptr: anytype) [*c]SSL_COMP {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SSL_COMP, OPENSSL_sk_set(ossl_check_SSL_COMP_sk_type(sk), idx, ossl_check_SSL_COMP_type(ptr)));
}
pub inline fn sk_SSL_COMP_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr));
}
pub inline fn sk_SSL_COMP_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr));
}
pub inline fn sk_SSL_COMP_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_type(ptr), pnum);
}
pub inline fn sk_SSL_COMP_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_SSL_COMP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_SSL_COMP_sk_type(sk));
}
pub inline fn sk_SSL_COMP_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_SSL_COMP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_SSL_COMP_sk_type(sk));
}
pub const sk_SSL_COMP_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/comp.h:89:9
pub const sk_SSL_COMP_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/comp.h:90:9
pub inline fn sk_SSL_COMP_set_cmp_func(sk: anytype, cmp: anytype) sk_SSL_COMP_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_SSL_COMP_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_SSL_COMP_sk_type(sk), ossl_check_SSL_COMP_compfunc_type(cmp)));
}
pub const OPENSSL_BIO_H = "";
pub const HEADER_BIO_H = "";
pub const OPENSSL_BIOERR_H = "";
pub const BIO_R_ACCEPT_ERROR = @as(c_int, 100);
pub const BIO_R_ADDRINFO_ADDR_IS_NOT_AF_INET = @as(c_int, 141);
pub const BIO_R_AMBIGUOUS_HOST_OR_SERVICE = @as(c_int, 129);
pub const BIO_R_BAD_FOPEN_MODE = @as(c_int, 101);
pub const BIO_R_BROKEN_PIPE = @as(c_int, 124);
pub const BIO_R_CONNECT_ERROR = @as(c_int, 103);
pub const BIO_R_CONNECT_TIMEOUT = @as(c_int, 147);
pub const BIO_R_GETHOSTBYNAME_ADDR_IS_NOT_AF_INET = @as(c_int, 107);
pub const BIO_R_GETSOCKNAME_ERROR = @as(c_int, 132);
pub const BIO_R_GETSOCKNAME_TRUNCATED_ADDRESS = @as(c_int, 133);
pub const BIO_R_GETTING_SOCKTYPE = @as(c_int, 134);
pub const BIO_R_INVALID_ARGUMENT = @as(c_int, 125);
pub const BIO_R_INVALID_SOCKET = @as(c_int, 135);
pub const BIO_R_IN_USE = @as(c_int, 123);
pub const BIO_R_LENGTH_TOO_LONG = @as(c_int, 102);
pub const BIO_R_LISTEN_V6_ONLY = @as(c_int, 136);
pub const BIO_R_LOCAL_ADDR_NOT_AVAILABLE = @as(c_int, 111);
pub const BIO_R_LOOKUP_RETURNED_NOTHING = @as(c_int, 142);
pub const BIO_R_MALFORMED_HOST_OR_SERVICE = @as(c_int, 130);
pub const BIO_R_NBIO_CONNECT_ERROR = @as(c_int, 110);
pub const BIO_R_NON_FATAL = @as(c_int, 112);
pub const BIO_R_NO_ACCEPT_ADDR_OR_SERVICE_SPECIFIED = @as(c_int, 143);
pub const BIO_R_NO_HOSTNAME_OR_SERVICE_SPECIFIED = @as(c_int, 144);
pub const BIO_R_NO_PORT_DEFINED = @as(c_int, 113);
pub const BIO_R_NO_SUCH_FILE = @as(c_int, 128);
pub const BIO_R_NULL_PARAMETER = @as(c_int, 115);
pub const BIO_R_TFO_DISABLED = @as(c_int, 106);
pub const BIO_R_TFO_NO_KERNEL_SUPPORT = @as(c_int, 108);
pub const BIO_R_TRANSFER_ERROR = @as(c_int, 104);
pub const BIO_R_TRANSFER_TIMEOUT = @as(c_int, 105);
pub const BIO_R_UNABLE_TO_BIND_SOCKET = @as(c_int, 117);
pub const BIO_R_UNABLE_TO_CREATE_SOCKET = @as(c_int, 118);
pub const BIO_R_UNABLE_TO_KEEPALIVE = @as(c_int, 137);
pub const BIO_R_UNABLE_TO_LISTEN_SOCKET = @as(c_int, 119);
pub const BIO_R_UNABLE_TO_NODELAY = @as(c_int, 138);
pub const BIO_R_UNABLE_TO_REUSEADDR = @as(c_int, 139);
pub const BIO_R_UNABLE_TO_TFO = @as(c_int, 109);
pub const BIO_R_UNAVAILABLE_IP_FAMILY = @as(c_int, 145);
pub const BIO_R_UNINITIALIZED = @as(c_int, 120);
pub const BIO_R_UNKNOWN_INFO_TYPE = @as(c_int, 140);
pub const BIO_R_UNSUPPORTED_IP_FAMILY = @as(c_int, 146);
pub const BIO_R_UNSUPPORTED_METHOD = @as(c_int, 121);
pub const BIO_R_UNSUPPORTED_PROTOCOL_FAMILY = @as(c_int, 131);
pub const BIO_R_WRITE_TO_READ_ONLY_BIO = @as(c_int, 126);
pub const BIO_R_WSASTARTUP = @as(c_int, 122);
pub const BIO_R_PORT_MISMATCH = @as(c_int, 150);
pub const BIO_R_PEER_ADDR_NOT_AVAILABLE = @as(c_int, 151);
pub const BIO_TYPE_DESCRIPTOR = @as(c_int, 0x0100);
pub const BIO_TYPE_FILTER = @as(c_int, 0x0200);
pub const BIO_TYPE_SOURCE_SINK = @as(c_int, 0x0400);
pub const BIO_TYPE_NONE = @as(c_int, 0);
pub const BIO_TYPE_MEM = @as(c_int, 1) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_FILE = @as(c_int, 2) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_FD = (@as(c_int, 4) | BIO_TYPE_SOURCE_SINK) | BIO_TYPE_DESCRIPTOR;
pub const BIO_TYPE_SOCKET = (@as(c_int, 5) | BIO_TYPE_SOURCE_SINK) | BIO_TYPE_DESCRIPTOR;
pub const BIO_TYPE_NULL = @as(c_int, 6) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_SSL = @as(c_int, 7) | BIO_TYPE_FILTER;
pub const BIO_TYPE_MD = @as(c_int, 8) | BIO_TYPE_FILTER;
pub const BIO_TYPE_BUFFER = @as(c_int, 9) | BIO_TYPE_FILTER;
pub const BIO_TYPE_CIPHER = @as(c_int, 10) | BIO_TYPE_FILTER;
pub const BIO_TYPE_BASE64 = @as(c_int, 11) | BIO_TYPE_FILTER;
pub const BIO_TYPE_CONNECT = (@as(c_int, 12) | BIO_TYPE_SOURCE_SINK) | BIO_TYPE_DESCRIPTOR;
pub const BIO_TYPE_ACCEPT = (@as(c_int, 13) | BIO_TYPE_SOURCE_SINK) | BIO_TYPE_DESCRIPTOR;
pub const BIO_TYPE_NBIO_TEST = @as(c_int, 16) | BIO_TYPE_FILTER;
pub const BIO_TYPE_NULL_FILTER = @as(c_int, 17) | BIO_TYPE_FILTER;
pub const BIO_TYPE_BIO = @as(c_int, 19) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_LINEBUFFER = @as(c_int, 20) | BIO_TYPE_FILTER;
pub const BIO_TYPE_DGRAM = (@as(c_int, 21) | BIO_TYPE_SOURCE_SINK) | BIO_TYPE_DESCRIPTOR;
pub const BIO_TYPE_ASN1 = @as(c_int, 22) | BIO_TYPE_FILTER;
pub const BIO_TYPE_COMP = @as(c_int, 23) | BIO_TYPE_FILTER;
pub const BIO_TYPE_CORE_TO_PROV = @as(c_int, 25) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_DGRAM_PAIR = @as(c_int, 26) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_DGRAM_MEM = @as(c_int, 27) | BIO_TYPE_SOURCE_SINK;
pub const BIO_TYPE_START = @as(c_int, 128);
pub const BIO_TYPE_MASK = @as(c_int, 0xFF);
pub const BIO_NOCLOSE = @as(c_int, 0x00);
pub const BIO_CLOSE = @as(c_int, 0x01);
pub const BIO_CTRL_RESET = @as(c_int, 1);
pub const BIO_CTRL_EOF = @as(c_int, 2);
pub const BIO_CTRL_INFO = @as(c_int, 3);
pub const BIO_CTRL_SET = @as(c_int, 4);
pub const BIO_CTRL_GET = @as(c_int, 5);
pub const BIO_CTRL_PUSH = @as(c_int, 6);
pub const BIO_CTRL_POP = @as(c_int, 7);
pub const BIO_CTRL_GET_CLOSE = @as(c_int, 8);
pub const BIO_CTRL_SET_CLOSE = @as(c_int, 9);
pub const BIO_CTRL_PENDING = @as(c_int, 10);
pub const BIO_CTRL_FLUSH = @as(c_int, 11);
pub const BIO_CTRL_DUP = @as(c_int, 12);
pub const BIO_CTRL_WPENDING = @as(c_int, 13);
pub const BIO_CTRL_SET_CALLBACK = @as(c_int, 14);
pub const BIO_CTRL_GET_CALLBACK = @as(c_int, 15);
pub const BIO_CTRL_PEEK = @as(c_int, 29);
pub const BIO_CTRL_SET_FILENAME = @as(c_int, 30);
pub const BIO_CTRL_DGRAM_CONNECT = @as(c_int, 31);
pub const BIO_CTRL_DGRAM_SET_CONNECTED = @as(c_int, 32);
pub const BIO_CTRL_DGRAM_SET_RECV_TIMEOUT = @as(c_int, 33);
pub const BIO_CTRL_DGRAM_GET_RECV_TIMEOUT = @as(c_int, 34);
pub const BIO_CTRL_DGRAM_SET_SEND_TIMEOUT = @as(c_int, 35);
pub const BIO_CTRL_DGRAM_GET_SEND_TIMEOUT = @as(c_int, 36);
pub const BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP = @as(c_int, 37);
pub const BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP = @as(c_int, 38);
pub const BIO_CTRL_DGRAM_MTU_DISCOVER = @as(c_int, 39);
pub const BIO_CTRL_DGRAM_QUERY_MTU = @as(c_int, 40);
pub const BIO_CTRL_DGRAM_GET_FALLBACK_MTU = @as(c_int, 47);
pub const BIO_CTRL_DGRAM_GET_MTU = @as(c_int, 41);
pub const BIO_CTRL_DGRAM_SET_MTU = @as(c_int, 42);
pub const BIO_CTRL_DGRAM_MTU_EXCEEDED = @as(c_int, 43);
pub const BIO_CTRL_DGRAM_GET_PEER = @as(c_int, 46);
pub const BIO_CTRL_DGRAM_SET_PEER = @as(c_int, 44);
pub const BIO_CTRL_DGRAM_SET_NEXT_TIMEOUT = @as(c_int, 45);
pub const BIO_CTRL_DGRAM_SET_DONT_FRAG = @as(c_int, 48);
pub const BIO_CTRL_DGRAM_GET_MTU_OVERHEAD = @as(c_int, 49);
pub const BIO_CTRL_DGRAM_SCTP_SET_IN_HANDSHAKE = @as(c_int, 50);
pub const BIO_CTRL_DGRAM_SET_PEEK_MODE = @as(c_int, 71);
pub const BIO_CTRL_GET_KTLS_SEND = @as(c_int, 73);
pub const BIO_CTRL_GET_KTLS_RECV = @as(c_int, 76);
pub const BIO_CTRL_DGRAM_SCTP_WAIT_FOR_DRY = @as(c_int, 77);
pub const BIO_CTRL_DGRAM_SCTP_MSG_WAITING = @as(c_int, 78);
pub const BIO_CTRL_SET_PREFIX = @as(c_int, 79);
pub const BIO_CTRL_SET_INDENT = @as(c_int, 80);
pub const BIO_CTRL_GET_INDENT = @as(c_int, 81);
pub const BIO_CTRL_DGRAM_GET_LOCAL_ADDR_CAP = @as(c_int, 82);
pub const BIO_CTRL_DGRAM_GET_LOCAL_ADDR_ENABLE = @as(c_int, 83);
pub const BIO_CTRL_DGRAM_SET_LOCAL_ADDR_ENABLE = @as(c_int, 84);
pub const BIO_CTRL_DGRAM_GET_EFFECTIVE_CAPS = @as(c_int, 85);
pub const BIO_CTRL_DGRAM_GET_CAPS = @as(c_int, 86);
pub const BIO_CTRL_DGRAM_SET_CAPS = @as(c_int, 87);
pub const BIO_CTRL_DGRAM_GET_NO_TRUNC = @as(c_int, 88);
pub const BIO_CTRL_DGRAM_SET_NO_TRUNC = @as(c_int, 89);
pub const BIO_CTRL_GET_RPOLL_DESCRIPTOR = @as(c_int, 91);
pub const BIO_CTRL_GET_WPOLL_DESCRIPTOR = @as(c_int, 92);
pub const BIO_CTRL_DGRAM_DETECT_PEER_ADDR = @as(c_int, 93);
pub const BIO_DGRAM_CAP_NONE = @as(c_uint, 0);
pub const BIO_DGRAM_CAP_HANDLES_SRC_ADDR = @as(c_uint, 1) << @as(c_int, 0);
pub const BIO_DGRAM_CAP_HANDLES_DST_ADDR = @as(c_uint, 1) << @as(c_int, 1);
pub const BIO_DGRAM_CAP_PROVIDES_SRC_ADDR = @as(c_uint, 1) << @as(c_int, 2);
pub const BIO_DGRAM_CAP_PROVIDES_DST_ADDR = @as(c_uint, 1) << @as(c_int, 3);
pub inline fn BIO_get_ktls_send(b: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_GET_KTLS_SEND, @as(c_int, 0), NULL) > @as(c_int, 0)) {
    _ = &b;
    return BIO_ctrl(b, BIO_CTRL_GET_KTLS_SEND, @as(c_int, 0), NULL) > @as(c_int, 0);
}
pub inline fn BIO_get_ktls_recv(b: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_GET_KTLS_RECV, @as(c_int, 0), NULL) > @as(c_int, 0)) {
    _ = &b;
    return BIO_ctrl(b, BIO_CTRL_GET_KTLS_RECV, @as(c_int, 0), NULL) > @as(c_int, 0);
}
pub const BIO_FP_READ = @as(c_int, 0x02);
pub const BIO_FP_WRITE = @as(c_int, 0x04);
pub const BIO_FP_APPEND = @as(c_int, 0x08);
pub const BIO_FP_TEXT = @as(c_int, 0x10);
pub const BIO_FLAGS_READ = @as(c_int, 0x01);
pub const BIO_FLAGS_WRITE = @as(c_int, 0x02);
pub const BIO_FLAGS_IO_SPECIAL = @as(c_int, 0x04);
pub const BIO_FLAGS_RWS = (BIO_FLAGS_READ | BIO_FLAGS_WRITE) | BIO_FLAGS_IO_SPECIAL;
pub const BIO_FLAGS_SHOULD_RETRY = @as(c_int, 0x08);
pub const BIO_FLAGS_UPLINK = @as(c_int, 0);
pub const BIO_FLAGS_BASE64_NO_NL = @as(c_int, 0x100);
pub const BIO_FLAGS_MEM_RDONLY = @as(c_int, 0x200);
pub const BIO_FLAGS_NONCLEAR_RST = @as(c_int, 0x400);
pub const BIO_FLAGS_IN_EOF = @as(c_int, 0x800);
pub inline fn BIO_get_flags(b: anytype) @TypeOf(BIO_test_flags(b, ~@as(c_int, 0x0))) {
    _ = &b;
    return BIO_test_flags(b, ~@as(c_int, 0x0));
}
pub inline fn BIO_set_retry_special(b: anytype) @TypeOf(BIO_set_flags(b, BIO_FLAGS_IO_SPECIAL | BIO_FLAGS_SHOULD_RETRY)) {
    _ = &b;
    return BIO_set_flags(b, BIO_FLAGS_IO_SPECIAL | BIO_FLAGS_SHOULD_RETRY);
}
pub inline fn BIO_set_retry_read(b: anytype) @TypeOf(BIO_set_flags(b, BIO_FLAGS_READ | BIO_FLAGS_SHOULD_RETRY)) {
    _ = &b;
    return BIO_set_flags(b, BIO_FLAGS_READ | BIO_FLAGS_SHOULD_RETRY);
}
pub inline fn BIO_set_retry_write(b: anytype) @TypeOf(BIO_set_flags(b, BIO_FLAGS_WRITE | BIO_FLAGS_SHOULD_RETRY)) {
    _ = &b;
    return BIO_set_flags(b, BIO_FLAGS_WRITE | BIO_FLAGS_SHOULD_RETRY);
}
pub inline fn BIO_clear_retry_flags(b: anytype) @TypeOf(BIO_clear_flags(b, BIO_FLAGS_RWS | BIO_FLAGS_SHOULD_RETRY)) {
    _ = &b;
    return BIO_clear_flags(b, BIO_FLAGS_RWS | BIO_FLAGS_SHOULD_RETRY);
}
pub inline fn BIO_get_retry_flags(b: anytype) @TypeOf(BIO_test_flags(b, BIO_FLAGS_RWS | BIO_FLAGS_SHOULD_RETRY)) {
    _ = &b;
    return BIO_test_flags(b, BIO_FLAGS_RWS | BIO_FLAGS_SHOULD_RETRY);
}
pub inline fn BIO_should_read(a: anytype) @TypeOf(BIO_test_flags(a, BIO_FLAGS_READ)) {
    _ = &a;
    return BIO_test_flags(a, BIO_FLAGS_READ);
}
pub inline fn BIO_should_write(a: anytype) @TypeOf(BIO_test_flags(a, BIO_FLAGS_WRITE)) {
    _ = &a;
    return BIO_test_flags(a, BIO_FLAGS_WRITE);
}
pub inline fn BIO_should_io_special(a: anytype) @TypeOf(BIO_test_flags(a, BIO_FLAGS_IO_SPECIAL)) {
    _ = &a;
    return BIO_test_flags(a, BIO_FLAGS_IO_SPECIAL);
}
pub inline fn BIO_retry_type(a: anytype) @TypeOf(BIO_test_flags(a, BIO_FLAGS_RWS)) {
    _ = &a;
    return BIO_test_flags(a, BIO_FLAGS_RWS);
}
pub inline fn BIO_should_retry(a: anytype) @TypeOf(BIO_test_flags(a, BIO_FLAGS_SHOULD_RETRY)) {
    _ = &a;
    return BIO_test_flags(a, BIO_FLAGS_SHOULD_RETRY);
}
pub const BIO_RR_SSL_X509_LOOKUP = @as(c_int, 0x01);
pub const BIO_RR_CONNECT = @as(c_int, 0x02);
pub const BIO_RR_ACCEPT = @as(c_int, 0x03);
pub const BIO_CB_FREE = @as(c_int, 0x01);
pub const BIO_CB_READ = @as(c_int, 0x02);
pub const BIO_CB_WRITE = @as(c_int, 0x03);
pub const BIO_CB_PUTS = @as(c_int, 0x04);
pub const BIO_CB_GETS = @as(c_int, 0x05);
pub const BIO_CB_CTRL = @as(c_int, 0x06);
pub const BIO_CB_RECVMMSG = @as(c_int, 0x07);
pub const BIO_CB_SENDMMSG = @as(c_int, 0x08);
pub const BIO_CB_RETURN = @as(c_int, 0x80);
pub inline fn BIO_CB_return(a: anytype) @TypeOf(a | BIO_CB_RETURN) {
    _ = &a;
    return a | BIO_CB_RETURN;
}
pub inline fn BIO_cb_pre(a: anytype) @TypeOf(!((a & BIO_CB_RETURN) != 0)) {
    _ = &a;
    return !((a & BIO_CB_RETURN) != 0);
}
pub inline fn BIO_cb_post(a: anytype) @TypeOf(a & BIO_CB_RETURN) {
    _ = &a;
    return a & BIO_CB_RETURN;
}
pub inline fn sk_BIO_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_BIO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_BIO_sk_type(sk));
}
pub inline fn sk_BIO_value(sk: anytype, idx: anytype) [*c]BIO {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_value(ossl_check_const_BIO_sk_type(sk), idx));
}
pub const sk_BIO_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/bio.h:338:9
pub const sk_BIO_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/bio.h:339:9
pub const sk_BIO_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/bio.h:340:9
pub inline fn sk_BIO_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_BIO_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_BIO_sk_type(sk), n);
}
pub inline fn sk_BIO_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_BIO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_BIO_sk_type(sk));
}
pub inline fn sk_BIO_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_BIO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_BIO_sk_type(sk));
}
pub inline fn sk_BIO_delete(sk: anytype, i: anytype) [*c]BIO {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_delete(ossl_check_BIO_sk_type(sk), i));
}
pub inline fn sk_BIO_delete_ptr(sk: anytype, ptr: anytype) [*c]BIO {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_delete_ptr(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr)));
}
pub inline fn sk_BIO_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr));
}
pub inline fn sk_BIO_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr));
}
pub inline fn sk_BIO_pop(sk: anytype) [*c]BIO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_pop(ossl_check_BIO_sk_type(sk)));
}
pub inline fn sk_BIO_shift(sk: anytype) [*c]BIO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_shift(ossl_check_BIO_sk_type(sk)));
}
pub inline fn sk_BIO_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_BIO_sk_type(sk), ossl_check_BIO_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_BIO_sk_type(sk), ossl_check_BIO_freefunc_type(freefunc));
}
pub inline fn sk_BIO_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr), idx);
}
pub inline fn sk_BIO_set(sk: anytype, idx: anytype, ptr: anytype) [*c]BIO {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]BIO, OPENSSL_sk_set(ossl_check_BIO_sk_type(sk), idx, ossl_check_BIO_type(ptr)));
}
pub inline fn sk_BIO_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr));
}
pub inline fn sk_BIO_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr));
}
pub inline fn sk_BIO_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_BIO_sk_type(sk), ossl_check_BIO_type(ptr), pnum);
}
pub inline fn sk_BIO_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_BIO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_BIO_sk_type(sk));
}
pub inline fn sk_BIO_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_BIO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_BIO_sk_type(sk));
}
pub const sk_BIO_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/bio.h:358:9
pub const sk_BIO_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/bio.h:359:9
pub inline fn sk_BIO_set_cmp_func(sk: anytype, cmp: anytype) sk_BIO_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_BIO_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_BIO_sk_type(sk), ossl_check_BIO_compfunc_type(cmp)));
}
pub const BIO_POLL_DESCRIPTOR_TYPE_NONE = @as(c_int, 0);
pub const BIO_POLL_DESCRIPTOR_TYPE_SOCK_FD = @as(c_int, 1);
pub const BIO_POLL_DESCRIPTOR_TYPE_SSL = @as(c_int, 2);
pub const BIO_POLL_DESCRIPTOR_CUSTOM_START = @as(c_int, 8192);
pub const BIO_C_SET_CONNECT = @as(c_int, 100);
pub const BIO_C_DO_STATE_MACHINE = @as(c_int, 101);
pub const BIO_C_SET_NBIO = @as(c_int, 102);
pub const BIO_C_SET_FD = @as(c_int, 104);
pub const BIO_C_GET_FD = @as(c_int, 105);
pub const BIO_C_SET_FILE_PTR = @as(c_int, 106);
pub const BIO_C_GET_FILE_PTR = @as(c_int, 107);
pub const BIO_C_SET_FILENAME = @as(c_int, 108);
pub const BIO_C_SET_SSL = @as(c_int, 109);
pub const BIO_C_GET_SSL = @as(c_int, 110);
pub const BIO_C_SET_MD = @as(c_int, 111);
pub const BIO_C_GET_MD = @as(c_int, 112);
pub const BIO_C_GET_CIPHER_STATUS = @as(c_int, 113);
pub const BIO_C_SET_BUF_MEM = @as(c_int, 114);
pub const BIO_C_GET_BUF_MEM_PTR = @as(c_int, 115);
pub const BIO_C_GET_BUFF_NUM_LINES = @as(c_int, 116);
pub const BIO_C_SET_BUFF_SIZE = @as(c_int, 117);
pub const BIO_C_SET_ACCEPT = @as(c_int, 118);
pub const BIO_C_SSL_MODE = @as(c_int, 119);
pub const BIO_C_GET_MD_CTX = @as(c_int, 120);
pub const BIO_C_SET_BUFF_READ_DATA = @as(c_int, 122);
pub const BIO_C_GET_CONNECT = @as(c_int, 123);
pub const BIO_C_GET_ACCEPT = @as(c_int, 124);
pub const BIO_C_SET_SSL_RENEGOTIATE_BYTES = @as(c_int, 125);
pub const BIO_C_GET_SSL_NUM_RENEGOTIATES = @as(c_int, 126);
pub const BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT = @as(c_int, 127);
pub const BIO_C_FILE_SEEK = @as(c_int, 128);
pub const BIO_C_GET_CIPHER_CTX = @as(c_int, 129);
pub const BIO_C_SET_BUF_MEM_EOF_RETURN = @as(c_int, 130);
pub const BIO_C_SET_BIND_MODE = @as(c_int, 131);
pub const BIO_C_GET_BIND_MODE = @as(c_int, 132);
pub const BIO_C_FILE_TELL = @as(c_int, 133);
pub const BIO_C_GET_SOCKS = @as(c_int, 134);
pub const BIO_C_SET_SOCKS = @as(c_int, 135);
pub const BIO_C_SET_WRITE_BUF_SIZE = @as(c_int, 136);
pub const BIO_C_GET_WRITE_BUF_SIZE = @as(c_int, 137);
pub const BIO_C_MAKE_BIO_PAIR = @as(c_int, 138);
pub const BIO_C_DESTROY_BIO_PAIR = @as(c_int, 139);
pub const BIO_C_GET_WRITE_GUARANTEE = @as(c_int, 140);
pub const BIO_C_GET_READ_REQUEST = @as(c_int, 141);
pub const BIO_C_SHUTDOWN_WR = @as(c_int, 142);
pub const BIO_C_NREAD0 = @as(c_int, 143);
pub const BIO_C_NREAD = @as(c_int, 144);
pub const BIO_C_NWRITE0 = @as(c_int, 145);
pub const BIO_C_NWRITE = @as(c_int, 146);
pub const BIO_C_RESET_READ_REQUEST = @as(c_int, 147);
pub const BIO_C_SET_MD_CTX = @as(c_int, 148);
pub const BIO_C_SET_PREFIX = @as(c_int, 149);
pub const BIO_C_GET_PREFIX = @as(c_int, 150);
pub const BIO_C_SET_SUFFIX = @as(c_int, 151);
pub const BIO_C_GET_SUFFIX = @as(c_int, 152);
pub const BIO_C_SET_EX_ARG = @as(c_int, 153);
pub const BIO_C_GET_EX_ARG = @as(c_int, 154);
pub const BIO_C_SET_CONNECT_MODE = @as(c_int, 155);
pub const BIO_C_SET_TFO = @as(c_int, 156);
pub const BIO_C_SET_SOCK_TYPE = @as(c_int, 157);
pub const BIO_C_GET_SOCK_TYPE = @as(c_int, 158);
pub const BIO_C_GET_DGRAM_BIO = @as(c_int, 159);
pub inline fn BIO_set_app_data(s: anytype, arg: anytype) @TypeOf(BIO_set_ex_data(s, @as(c_int, 0), arg)) {
    _ = &s;
    _ = &arg;
    return BIO_set_ex_data(s, @as(c_int, 0), arg);
}
pub inline fn BIO_get_app_data(s: anytype) @TypeOf(BIO_get_ex_data(s, @as(c_int, 0))) {
    _ = &s;
    return BIO_get_ex_data(s, @as(c_int, 0));
}
pub inline fn BIO_set_nbio(b: anytype, n: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_NBIO, n, NULL)) {
    _ = &b;
    _ = &n;
    return BIO_ctrl(b, BIO_C_SET_NBIO, n, NULL);
}
pub inline fn BIO_set_tfo(b: anytype, n: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_TFO, n, NULL)) {
    _ = &b;
    _ = &n;
    return BIO_ctrl(b, BIO_C_SET_TFO, n, NULL);
}
pub const BIO_FAMILY_IPV4 = @as(c_int, 4);
pub const BIO_FAMILY_IPV6 = @as(c_int, 6);
pub const BIO_FAMILY_IPANY = @as(c_int, 256);
pub inline fn BIO_set_conn_hostname(b: anytype, name: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, name))) {
    _ = &b;
    _ = &name;
    return BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, name));
}
pub inline fn BIO_set_conn_port(b: anytype, port: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, port))) {
    _ = &b;
    _ = &port;
    return BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, port));
}
pub inline fn BIO_set_conn_address(b: anytype, addr: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 2), @import("std").zig.c_translation.cast([*c]u8, addr))) {
    _ = &b;
    _ = &addr;
    return BIO_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 2), @import("std").zig.c_translation.cast([*c]u8, addr));
}
pub inline fn BIO_set_conn_ip_family(b: anytype, f: anytype) @TypeOf(BIO_int_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 3), f)) {
    _ = &b;
    _ = &f;
    return BIO_int_ctrl(b, BIO_C_SET_CONNECT, @as(c_int, 3), f);
}
pub const BIO_get_conn_hostname = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/bio.h:519:11
pub const BIO_get_conn_port = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/bio.h:520:11
pub const BIO_get_conn_address = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/bio.h:521:11
pub inline fn BIO_get_conn_ip_family(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_CONNECT, @as(c_int, 3), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_CONNECT, @as(c_int, 3), NULL);
}
pub inline fn BIO_get_conn_mode(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_CONNECT, @as(c_int, 4), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_CONNECT, @as(c_int, 4), NULL);
}
pub inline fn BIO_set_conn_mode(b: anytype, n: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_CONNECT_MODE, n, NULL)) {
    _ = &b;
    _ = &n;
    return BIO_ctrl(b, BIO_C_SET_CONNECT_MODE, n, NULL);
}
pub inline fn BIO_set_sock_type(b: anytype, t: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_SOCK_TYPE, t, NULL)) {
    _ = &b;
    _ = &t;
    return BIO_ctrl(b, BIO_C_SET_SOCK_TYPE, t, NULL);
}
pub inline fn BIO_get_sock_type(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_SOCK_TYPE, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_SOCK_TYPE, @as(c_int, 0), NULL);
}
pub const BIO_get0_dgram_bio = @compileError("unable to translate C expr: expected ')' instead got '*'");
// /usr/include/openssl/bio.h:527:11
pub inline fn BIO_set_accept_name(b: anytype, name: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, name))) {
    _ = &b;
    _ = &name;
    return BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, name));
}
pub inline fn BIO_set_accept_port(b: anytype, port: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, port))) {
    _ = &b;
    _ = &port;
    return BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, port));
}
pub const BIO_get_accept_name = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/bio.h:534:11
pub const BIO_get_accept_port = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/bio.h:535:11
pub const BIO_get_peer_name = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/bio.h:536:11
pub const BIO_get_peer_port = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/bio.h:537:11
pub inline fn BIO_set_nbio_accept(b: anytype, n: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 2), if (n) @import("std").zig.c_translation.cast(?*anyopaque, "a") else NULL)) {
    _ = &b;
    _ = &n;
    return BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 2), if (n) @import("std").zig.c_translation.cast(?*anyopaque, "a") else NULL);
}
pub inline fn BIO_set_accept_bios(b: anytype, bio: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 3), @import("std").zig.c_translation.cast([*c]u8, bio))) {
    _ = &b;
    _ = &bio;
    return BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 3), @import("std").zig.c_translation.cast([*c]u8, bio));
}
pub inline fn BIO_set_accept_ip_family(b: anytype, f: anytype) @TypeOf(BIO_int_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 4), f)) {
    _ = &b;
    _ = &f;
    return BIO_int_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 4), f);
}
pub inline fn BIO_get_accept_ip_family(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_ACCEPT, @as(c_int, 4), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_ACCEPT, @as(c_int, 4), NULL);
}
pub inline fn BIO_set_tfo_accept(b: anytype, n: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 5), if (n) @import("std").zig.c_translation.cast(?*anyopaque, "a") else NULL)) {
    _ = &b;
    _ = &n;
    return BIO_ctrl(b, BIO_C_SET_ACCEPT, @as(c_int, 5), if (n) @import("std").zig.c_translation.cast(?*anyopaque, "a") else NULL);
}
pub const BIO_BIND_NORMAL = @as(c_int, 0);
pub const BIO_BIND_REUSEADDR = BIO_SOCK_REUSEADDR;
pub const BIO_BIND_REUSEADDR_IF_UNUSED = BIO_SOCK_REUSEADDR;
pub inline fn BIO_set_bind_mode(b: anytype, mode: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_BIND_MODE, mode, NULL)) {
    _ = &b;
    _ = &mode;
    return BIO_ctrl(b, BIO_C_SET_BIND_MODE, mode, NULL);
}
pub inline fn BIO_get_bind_mode(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_BIND_MODE, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_BIND_MODE, @as(c_int, 0), NULL);
}
pub inline fn BIO_do_connect(b: anytype) @TypeOf(BIO_do_handshake(b)) {
    _ = &b;
    return BIO_do_handshake(b);
}
pub inline fn BIO_do_accept(b: anytype) @TypeOf(BIO_do_handshake(b)) {
    _ = &b;
    return BIO_do_handshake(b);
}
pub inline fn BIO_do_handshake(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_DO_STATE_MACHINE, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_DO_STATE_MACHINE, @as(c_int, 0), NULL);
}
pub inline fn BIO_set_fd(b: anytype, fd: anytype, c: anytype) @TypeOf(BIO_int_ctrl(b, BIO_C_SET_FD, c, fd)) {
    _ = &b;
    _ = &fd;
    _ = &c;
    return BIO_int_ctrl(b, BIO_C_SET_FD, c, fd);
}
pub inline fn BIO_get_fd(b: anytype, c: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_FD, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, c))) {
    _ = &b;
    _ = &c;
    return BIO_ctrl(b, BIO_C_GET_FD, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, c));
}
pub inline fn BIO_set_fp(b: anytype, fp: anytype, c: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_FILE_PTR, c, @import("std").zig.c_translation.cast([*c]u8, fp))) {
    _ = &b;
    _ = &fp;
    _ = &c;
    return BIO_ctrl(b, BIO_C_SET_FILE_PTR, c, @import("std").zig.c_translation.cast([*c]u8, fp));
}
pub inline fn BIO_get_fp(b: anytype, fpp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_FILE_PTR, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, fpp))) {
    _ = &b;
    _ = &fpp;
    return BIO_ctrl(b, BIO_C_GET_FILE_PTR, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, fpp));
}
pub inline fn BIO_seek(b: anytype, ofs: anytype) c_int {
    _ = &b;
    _ = &ofs;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_FILE_SEEK, ofs, NULL));
}
pub inline fn BIO_tell(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_FILE_TELL, @as(c_int, 0), NULL));
}
pub inline fn BIO_read_filename(b: anytype, name: anytype) c_int {
    _ = &b;
    _ = &name;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SET_FILENAME, BIO_CLOSE | BIO_FP_READ, @import("std").zig.c_translation.cast([*c]u8, name)));
}
pub inline fn BIO_write_filename(b: anytype, name: anytype) c_int {
    _ = &b;
    _ = &name;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SET_FILENAME, BIO_CLOSE | BIO_FP_WRITE, name));
}
pub inline fn BIO_append_filename(b: anytype, name: anytype) c_int {
    _ = &b;
    _ = &name;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SET_FILENAME, BIO_CLOSE | BIO_FP_APPEND, name));
}
pub inline fn BIO_rw_filename(b: anytype, name: anytype) c_int {
    _ = &b;
    _ = &name;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SET_FILENAME, (BIO_CLOSE | BIO_FP_READ) | BIO_FP_WRITE, name));
}
pub inline fn BIO_set_ssl(b: anytype, ssl: anytype, c: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_SSL, c, @import("std").zig.c_translation.cast([*c]u8, ssl))) {
    _ = &b;
    _ = &ssl;
    _ = &c;
    return BIO_ctrl(b, BIO_C_SET_SSL, c, @import("std").zig.c_translation.cast([*c]u8, ssl));
}
pub inline fn BIO_get_ssl(b: anytype, sslp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_SSL, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sslp))) {
    _ = &b;
    _ = &sslp;
    return BIO_ctrl(b, BIO_C_GET_SSL, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sslp));
}
pub inline fn BIO_set_ssl_mode(b: anytype, client: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SSL_MODE, client, NULL)) {
    _ = &b;
    _ = &client;
    return BIO_ctrl(b, BIO_C_SSL_MODE, client, NULL);
}
pub inline fn BIO_set_ssl_renegotiate_bytes(b: anytype, num: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_SSL_RENEGOTIATE_BYTES, num, NULL)) {
    _ = &b;
    _ = &num;
    return BIO_ctrl(b, BIO_C_SET_SSL_RENEGOTIATE_BYTES, num, NULL);
}
pub inline fn BIO_get_num_renegotiates(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_SSL_NUM_RENEGOTIATES, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_SSL_NUM_RENEGOTIATES, @as(c_int, 0), NULL);
}
pub inline fn BIO_set_ssl_renegotiate_timeout(b: anytype, seconds: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT, seconds, NULL)) {
    _ = &b;
    _ = &seconds;
    return BIO_ctrl(b, BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT, seconds, NULL);
}
pub inline fn BIO_get_mem_data(b: anytype, pp: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_INFO, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, pp))) {
    _ = &b;
    _ = &pp;
    return BIO_ctrl(b, BIO_CTRL_INFO, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, pp));
}
pub inline fn BIO_set_mem_buf(b: anytype, bm: anytype, c: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_BUF_MEM, c, @import("std").zig.c_translation.cast([*c]u8, bm))) {
    _ = &b;
    _ = &bm;
    _ = &c;
    return BIO_ctrl(b, BIO_C_SET_BUF_MEM, c, @import("std").zig.c_translation.cast([*c]u8, bm));
}
pub inline fn BIO_get_mem_ptr(b: anytype, pp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_BUF_MEM_PTR, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, pp))) {
    _ = &b;
    _ = &pp;
    return BIO_ctrl(b, BIO_C_GET_BUF_MEM_PTR, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, pp));
}
pub inline fn BIO_set_mem_eof_return(b: anytype, v: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_BUF_MEM_EOF_RETURN, v, NULL)) {
    _ = &b;
    _ = &v;
    return BIO_ctrl(b, BIO_C_SET_BUF_MEM_EOF_RETURN, v, NULL);
}
pub inline fn BIO_get_buffer_num_lines(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_BUFF_NUM_LINES, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_BUFF_NUM_LINES, @as(c_int, 0), NULL);
}
pub inline fn BIO_set_buffer_size(b: anytype, size: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_BUFF_SIZE, size, NULL)) {
    _ = &b;
    _ = &size;
    return BIO_ctrl(b, BIO_C_SET_BUFF_SIZE, size, NULL);
}
pub inline fn BIO_set_read_buffer_size(b: anytype, size: anytype) @TypeOf(BIO_int_ctrl(b, BIO_C_SET_BUFF_SIZE, size, @as(c_int, 0))) {
    _ = &b;
    _ = &size;
    return BIO_int_ctrl(b, BIO_C_SET_BUFF_SIZE, size, @as(c_int, 0));
}
pub inline fn BIO_set_write_buffer_size(b: anytype, size: anytype) @TypeOf(BIO_int_ctrl(b, BIO_C_SET_BUFF_SIZE, size, @as(c_int, 1))) {
    _ = &b;
    _ = &size;
    return BIO_int_ctrl(b, BIO_C_SET_BUFF_SIZE, size, @as(c_int, 1));
}
pub inline fn BIO_set_buffer_read_data(b: anytype, buf: anytype, num: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_BUFF_READ_DATA, num, buf)) {
    _ = &b;
    _ = &buf;
    _ = &num;
    return BIO_ctrl(b, BIO_C_SET_BUFF_READ_DATA, num, buf);
}
pub inline fn BIO_dup_state(b: anytype, ret: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_DUP, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ret))) {
    _ = &b;
    _ = &ret;
    return BIO_ctrl(b, BIO_CTRL_DUP, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ret));
}
pub inline fn BIO_reset(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_RESET, @as(c_int, 0), NULL));
}
pub inline fn BIO_eof(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_EOF, @as(c_int, 0), NULL));
}
pub inline fn BIO_set_close(b: anytype, c: anytype) c_int {
    _ = &b;
    _ = &c;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_SET_CLOSE, c, NULL));
}
pub inline fn BIO_get_close(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_GET_CLOSE, @as(c_int, 0), NULL));
}
pub inline fn BIO_pending(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_PENDING, @as(c_int, 0), NULL));
}
pub inline fn BIO_wpending(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_WPENDING, @as(c_int, 0), NULL));
}
pub inline fn BIO_flush(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_FLUSH, @as(c_int, 0), NULL));
}
pub inline fn BIO_get_info_callback(b: anytype, cbp: anytype) c_int {
    _ = &b;
    _ = &cbp;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_GET_CALLBACK, @as(c_int, 0), cbp));
}
pub inline fn BIO_set_info_callback(b: anytype, cb: anytype) c_int {
    _ = &b;
    _ = &cb;
    return @import("std").zig.c_translation.cast(c_int, BIO_callback_ctrl(b, BIO_CTRL_SET_CALLBACK, cb));
}
pub inline fn BIO_buffer_get_num_lines(b: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_GET, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_CTRL_GET, @as(c_int, 0), NULL);
}
pub inline fn BIO_buffer_peek(b: anytype, s: anytype, l: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_PEEK, l, s)) {
    _ = &b;
    _ = &s;
    _ = &l;
    return BIO_ctrl(b, BIO_CTRL_PEEK, l, s);
}
pub inline fn BIO_set_write_buf_size(b: anytype, size: anytype) c_int {
    _ = &b;
    _ = &size;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SET_WRITE_BUF_SIZE, size, NULL));
}
pub inline fn BIO_get_write_buf_size(b: anytype, size: anytype) usize {
    _ = &b;
    _ = &size;
    return @import("std").zig.c_translation.cast(usize, BIO_ctrl(b, BIO_C_GET_WRITE_BUF_SIZE, size, NULL));
}
pub inline fn BIO_make_bio_pair(b1: anytype, b2: anytype) c_int {
    _ = &b1;
    _ = &b2;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b1, BIO_C_MAKE_BIO_PAIR, @as(c_int, 0), b2));
}
pub inline fn BIO_destroy_bio_pair(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_DESTROY_BIO_PAIR, @as(c_int, 0), NULL));
}
pub inline fn BIO_shutdown_wr(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_SHUTDOWN_WR, @as(c_int, 0), NULL));
}
pub inline fn BIO_get_write_guarantee(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_GET_WRITE_GUARANTEE, @as(c_int, 0), NULL));
}
pub inline fn BIO_get_read_request(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_C_GET_READ_REQUEST, @as(c_int, 0), NULL));
}
pub inline fn BIO_ctrl_dgram_connect(b: anytype, peer: anytype) c_int {
    _ = &b;
    _ = &peer;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_CONNECT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, peer)));
}
pub inline fn BIO_ctrl_set_connected(b: anytype, peer: anytype) c_int {
    _ = &b;
    _ = &peer;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_CONNECTED, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, peer)));
}
pub inline fn BIO_dgram_recv_timedout(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_RECV_TIMER_EXP, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_send_timedout(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_SEND_TIMER_EXP, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_get_peer(b: anytype, peer: anytype) c_int {
    _ = &b;
    _ = &peer;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_PEER, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, peer)));
}
pub inline fn BIO_dgram_set_peer(b: anytype, peer: anytype) c_int {
    _ = &b;
    _ = &peer;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_PEER, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, peer)));
}
pub inline fn BIO_dgram_detect_peer_addr(b: anytype, peer: anytype) c_int {
    _ = &b;
    _ = &peer;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_DETECT_PEER_ADDR, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, peer)));
}
pub inline fn BIO_dgram_get_mtu_overhead(b: anytype) c_uint {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_uint, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_MTU_OVERHEAD, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_get_local_addr_cap(b: anytype) c_int {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_LOCAL_ADDR_CAP, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_get_local_addr_enable(b: anytype, penable: anytype) c_int {
    _ = &b;
    _ = &penable;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_LOCAL_ADDR_ENABLE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, penable)));
}
pub inline fn BIO_dgram_set_local_addr_enable(b: anytype, enable: anytype) c_int {
    _ = &b;
    _ = &enable;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_LOCAL_ADDR_ENABLE, enable, NULL));
}
pub inline fn BIO_dgram_get_effective_caps(b: anytype) u32 {
    _ = &b;
    return @import("std").zig.c_translation.cast(u32, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_EFFECTIVE_CAPS, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_get_caps(b: anytype) u32 {
    _ = &b;
    return @import("std").zig.c_translation.cast(u32, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_CAPS, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_set_caps(b: anytype, caps: anytype) c_int {
    _ = &b;
    _ = &caps;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_CAPS, @import("std").zig.c_translation.cast(c_long, caps), NULL));
}
pub inline fn BIO_dgram_get_no_trunc(b: anytype) c_uint {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_uint, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_NO_TRUNC, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_set_no_trunc(b: anytype, enable: anytype) c_int {
    _ = &b;
    _ = &enable;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_NO_TRUNC, enable, NULL));
}
pub inline fn BIO_dgram_get_mtu(b: anytype) c_uint {
    _ = &b;
    return @import("std").zig.c_translation.cast(c_uint, BIO_ctrl(b, BIO_CTRL_DGRAM_GET_MTU, @as(c_int, 0), NULL));
}
pub inline fn BIO_dgram_set_mtu(b: anytype, mtu: anytype) c_int {
    _ = &b;
    _ = &mtu;
    return @import("std").zig.c_translation.cast(c_int, BIO_ctrl(b, BIO_CTRL_DGRAM_SET_MTU, mtu, NULL));
}
pub inline fn BIO_set_prefix(b: anytype, p: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_SET_PREFIX, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, p))) {
    _ = &b;
    _ = &p;
    return BIO_ctrl(b, BIO_CTRL_SET_PREFIX, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, p));
}
pub inline fn BIO_set_indent(b: anytype, i: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_SET_INDENT, i, NULL)) {
    _ = &b;
    _ = &i;
    return BIO_ctrl(b, BIO_CTRL_SET_INDENT, i, NULL);
}
pub inline fn BIO_get_indent(b: anytype) @TypeOf(BIO_ctrl(b, BIO_CTRL_GET_INDENT, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_CTRL_GET_INDENT, @as(c_int, 0), NULL);
}
pub inline fn BIO_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_BIO, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_BIO, l, p, newf, dupf, freef);
}
pub const BIO_sock_cleanup = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/bio.h:876:11
pub const BIO_SOCK_REUSEADDR = @as(c_int, 0x01);
pub const BIO_SOCK_V6_ONLY = @as(c_int, 0x02);
pub const BIO_SOCK_KEEPALIVE = @as(c_int, 0x04);
pub const BIO_SOCK_NONBLOCK = @as(c_int, 0x08);
pub const BIO_SOCK_NODELAY = @as(c_int, 0x10);
pub const BIO_SOCK_TFO = @as(c_int, 0x20);
pub const ossl_bio__attr__ = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/openssl/bio.h:936:10
pub const ossl_bio__printf__ = @compileError("unable to translate macro: undefined identifier `__printf__`");
// /usr/include/openssl/bio.h:950:13
pub const OPENSSL_X509_H = "";
pub const HEADER_X509_H = "";
pub const OPENSSL_BUFFER_H = "";
pub const HEADER_BUFFER_H = "";
pub const OPENSSL_BUFFERERR_H = "";
pub inline fn BUF_strdup(s: anytype) @TypeOf(OPENSSL_strdup(s)) {
    _ = &s;
    return OPENSSL_strdup(s);
}
pub inline fn BUF_strndup(s: anytype, size: anytype) @TypeOf(OPENSSL_strndup(s, size)) {
    _ = &s;
    _ = &size;
    return OPENSSL_strndup(s, size);
}
pub inline fn BUF_memdup(data: anytype, size: anytype) @TypeOf(OPENSSL_memdup(data, size)) {
    _ = &data;
    _ = &size;
    return OPENSSL_memdup(data, size);
}
pub inline fn BUF_strlcpy(dst: anytype, src: anytype, size: anytype) @TypeOf(OPENSSL_strlcpy(dst, src, size)) {
    _ = &dst;
    _ = &src;
    _ = &size;
    return OPENSSL_strlcpy(dst, src, size);
}
pub inline fn BUF_strlcat(dst: anytype, src: anytype, size: anytype) @TypeOf(OPENSSL_strlcat(dst, src, size)) {
    _ = &dst;
    _ = &src;
    _ = &size;
    return OPENSSL_strlcat(dst, src, size);
}
pub inline fn BUF_strnlen(str: anytype, maxlen: anytype) @TypeOf(OPENSSL_strnlen(str, maxlen)) {
    _ = &str;
    _ = &maxlen;
    return OPENSSL_strnlen(str, maxlen);
}
pub const BUF_MEM_FLAG_SECURE = @as(c_int, 0x01);
pub const OPENSSL_EVP_H = "";
pub const HEADER_ENVELOPE_H = "";
pub const OPENSSL_CORE_NUMBERS_H = "";
pub const OPENSSL_INDICATOR_H = "";
pub const OPENSSL_PARAMS_H = "";
pub const OPENSSL_BN_H = "";
pub const HEADER_BN_H = "";
pub const OPENSSL_BNERR_H = "";
pub const BN_R_ARG2_LT_ARG3 = @as(c_int, 100);
pub const BN_R_BAD_RECIPROCAL = @as(c_int, 101);
pub const BN_R_BIGNUM_TOO_LONG = @as(c_int, 114);
pub const BN_R_BITS_TOO_SMALL = @as(c_int, 118);
pub const BN_R_CALLED_WITH_EVEN_MODULUS = @as(c_int, 102);
pub const BN_R_DIV_BY_ZERO = @as(c_int, 103);
pub const BN_R_ENCODING_ERROR = @as(c_int, 104);
pub const BN_R_EXPAND_ON_STATIC_BIGNUM_DATA = @as(c_int, 105);
pub const BN_R_INPUT_NOT_REDUCED = @as(c_int, 110);
pub const BN_R_INVALID_LENGTH = @as(c_int, 106);
pub const BN_R_INVALID_RANGE = @as(c_int, 115);
pub const BN_R_INVALID_SHIFT = @as(c_int, 119);
pub const BN_R_NOT_A_SQUARE = @as(c_int, 111);
pub const BN_R_NOT_INITIALIZED = @as(c_int, 107);
pub const BN_R_NO_INVERSE = @as(c_int, 108);
pub const BN_R_NO_PRIME_CANDIDATE = @as(c_int, 121);
pub const BN_R_NO_SOLUTION = @as(c_int, 116);
pub const BN_R_NO_SUITABLE_DIGEST = @as(c_int, 120);
pub const BN_R_PRIVATE_KEY_TOO_LARGE = @as(c_int, 117);
pub const BN_R_P_IS_NOT_PRIME = @as(c_int, 112);
pub const BN_R_TOO_MANY_ITERATIONS = @as(c_int, 113);
pub const BN_R_TOO_MANY_TEMPORARY_VARIABLES = @as(c_int, 109);
pub const BN_ULONG = c_ulong;
pub const BN_BYTES = @as(c_int, 8);
pub const BN_BITS2 = BN_BYTES * @as(c_int, 8);
pub const BN_BITS = BN_BITS2 * @as(c_int, 2);
pub const BN_TBIT = @compileError("unable to translate C expr: expected ')' instead got 'A number'");
// /usr/include/openssl/bn.h:56:10
pub const BN_FLG_MALLOCED = @as(c_int, 0x01);
pub const BN_FLG_STATIC_DATA = @as(c_int, 0x02);
pub const BN_FLG_CONSTTIME = @as(c_int, 0x04);
pub const BN_FLG_SECURE = @as(c_int, 0x08);
pub const BN_FLG_EXP_CONSTTIME = BN_FLG_CONSTTIME;
pub const BN_FLG_FREE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const BN_RAND_TOP_ANY = -@as(c_int, 1);
pub const BN_RAND_TOP_ONE = @as(c_int, 0);
pub const BN_RAND_TOP_TWO = @as(c_int, 1);
pub const BN_RAND_BOTTOM_ANY = @as(c_int, 0);
pub const BN_RAND_BOTTOM_ODD = @as(c_int, 1);
pub const BN_prime_checks = @as(c_int, 0);
pub inline fn BN_prime_checks_for_size(b: anytype) @TypeOf(if (b >= @as(c_int, 3747)) @as(c_int, 3) else if (b >= @as(c_int, 1345)) @as(c_int, 4) else if (b >= @as(c_int, 476)) @as(c_int, 5) else if (b >= @as(c_int, 400)) @as(c_int, 6) else if (b >= @as(c_int, 347)) @as(c_int, 7) else if (b >= @as(c_int, 308)) @as(c_int, 8) else if (b >= @as(c_int, 55)) @as(c_int, 27) else @as(c_int, 34)) {
    _ = &b;
    return if (b >= @as(c_int, 3747)) @as(c_int, 3) else if (b >= @as(c_int, 1345)) @as(c_int, 4) else if (b >= @as(c_int, 476)) @as(c_int, 5) else if (b >= @as(c_int, 400)) @as(c_int, 6) else if (b >= @as(c_int, 347)) @as(c_int, 7) else if (b >= @as(c_int, 308)) @as(c_int, 8) else if (b >= @as(c_int, 55)) @as(c_int, 27) else @as(c_int, 34);
}
pub inline fn BN_num_bytes(a: anytype) @TypeOf(@import("std").zig.c_translation.MacroArithmetic.div(BN_num_bits(a) + @as(c_int, 7), @as(c_int, 8))) {
    _ = &a;
    return @import("std").zig.c_translation.MacroArithmetic.div(BN_num_bits(a) + @as(c_int, 7), @as(c_int, 8));
}
pub inline fn BN_one(a: anytype) @TypeOf(BN_set_word(a, @as(c_int, 1))) {
    _ = &a;
    return BN_set_word(a, @as(c_int, 1));
}
pub inline fn BN_zero(a: anytype) @TypeOf(BN_zero_ex(a)) {
    _ = &a;
    return BN_zero_ex(a);
}
pub inline fn BN_mod(rem: anytype, m: anytype, d: anytype, ctx: anytype) @TypeOf(BN_div(NULL, rem, m, d, ctx)) {
    _ = &rem;
    _ = &m;
    _ = &d;
    _ = &ctx;
    return BN_div(NULL, rem, m, d, ctx);
}
pub const BN_BLINDING_NO_UPDATE = @as(c_int, 0x00000001);
pub const BN_BLINDING_NO_RECREATE = @as(c_int, 0x00000002);
pub inline fn BN_GF2m_sub(r: anytype, a: anytype, b: anytype) @TypeOf(BN_GF2m_add(r, a, b)) {
    _ = &r;
    _ = &a;
    _ = &b;
    return BN_GF2m_add(r, a, b);
}
pub inline fn BN_GF2m_cmp(a: anytype, b: anytype) @TypeOf(BN_ucmp(a, b)) {
    _ = &a;
    _ = &b;
    return BN_ucmp(a, b);
}
pub const get_rfc2409_prime_768 = BN_get_rfc2409_prime_768;
pub const get_rfc2409_prime_1024 = BN_get_rfc2409_prime_1024;
pub const get_rfc3526_prime_1536 = BN_get_rfc3526_prime_1536;
pub const get_rfc3526_prime_2048 = BN_get_rfc3526_prime_2048;
pub const get_rfc3526_prime_3072 = BN_get_rfc3526_prime_3072;
pub const get_rfc3526_prime_4096 = BN_get_rfc3526_prime_4096;
pub const get_rfc3526_prime_6144 = BN_get_rfc3526_prime_6144;
pub const get_rfc3526_prime_8192 = BN_get_rfc3526_prime_8192;
pub const OSSL_PARAM_UNMODIFIED = @import("std").zig.c_translation.cast(usize, -@as(c_int, 1));
pub const OSSL_PARAM_END = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/openssl/params.h:24:10
pub const OSSL_PARAM_DEFN = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/openssl/params.h:27:10
pub inline fn OSSL_PARAM_int(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_int))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_int));
}
pub inline fn OSSL_PARAM_uint(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_uint))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_uint));
}
pub inline fn OSSL_PARAM_long(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_long))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_long));
}
pub inline fn OSSL_PARAM_ulong(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_ulong))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(c_ulong));
}
pub inline fn OSSL_PARAM_int32(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(i32))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(i32));
}
pub inline fn OSSL_PARAM_uint32(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(u32))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(u32));
}
pub inline fn OSSL_PARAM_int64(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(i64))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(i64));
}
pub inline fn OSSL_PARAM_uint64(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(u64))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(u64));
}
pub inline fn OSSL_PARAM_size_t(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(usize))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, addr, @import("std").zig.c_translation.sizeof(usize));
}
pub inline fn OSSL_PARAM_time_t(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(time_t))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_INTEGER, addr, @import("std").zig.c_translation.sizeof(time_t));
}
pub inline fn OSSL_PARAM_double(key: anytype, addr: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_REAL, addr, @import("std").zig.c_translation.sizeof(f64))) {
    _ = &key;
    _ = &addr;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_REAL, addr, @import("std").zig.c_translation.sizeof(f64));
}
pub inline fn OSSL_PARAM_BN(key: anytype, bn: anytype, sz: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, bn, sz)) {
    _ = &key;
    _ = &bn;
    _ = &sz;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UNSIGNED_INTEGER, bn, sz);
}
pub inline fn OSSL_PARAM_utf8_string(key: anytype, addr: anytype, sz: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UTF8_STRING, addr, sz)) {
    _ = &key;
    _ = &addr;
    _ = &sz;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UTF8_STRING, addr, sz);
}
pub inline fn OSSL_PARAM_octet_string(key: anytype, addr: anytype, sz: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_OCTET_STRING, addr, sz)) {
    _ = &key;
    _ = &addr;
    _ = &sz;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_OCTET_STRING, addr, sz);
}
pub inline fn OSSL_PARAM_utf8_ptr(key: anytype, addr: anytype, sz: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_UTF8_PTR, addr, sz)) {
    _ = &key;
    _ = &addr;
    _ = &sz;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_UTF8_PTR, addr, sz);
}
pub inline fn OSSL_PARAM_octet_ptr(key: anytype, addr: anytype, sz: anytype) @TypeOf(OSSL_PARAM_DEFN(key, OSSL_PARAM_OCTET_PTR, addr, sz)) {
    _ = &key;
    _ = &addr;
    _ = &sz;
    return OSSL_PARAM_DEFN(key, OSSL_PARAM_OCTET_PTR, addr, sz);
}
pub const OSSL_CORE_MAKE_FUNC = @compileError("unable to translate macro: undefined identifier `OSSL_FUNC_`");
// /usr/include/openssl/core_dispatch.h:48:9
pub const OSSL_FUNC_CORE_GETTABLE_PARAMS = @as(c_int, 1);
pub const OSSL_FUNC_CORE_GET_PARAMS = @as(c_int, 2);
pub const OSSL_FUNC_CORE_THREAD_START = @as(c_int, 3);
pub const OSSL_FUNC_CORE_GET_LIBCTX = @as(c_int, 4);
pub const OSSL_FUNC_CORE_NEW_ERROR = @as(c_int, 5);
pub const OSSL_FUNC_CORE_SET_ERROR_DEBUG = @as(c_int, 6);
pub const OSSL_FUNC_CORE_VSET_ERROR = @as(c_int, 7);
pub const OSSL_FUNC_CORE_SET_ERROR_MARK = @as(c_int, 8);
pub const OSSL_FUNC_CORE_CLEAR_LAST_ERROR_MARK = @as(c_int, 9);
pub const OSSL_FUNC_CORE_POP_ERROR_TO_MARK = @as(c_int, 10);
pub const OSSL_FUNC_CORE_OBJ_ADD_SIGID = @as(c_int, 11);
pub const OSSL_FUNC_CORE_OBJ_CREATE = @as(c_int, 12);
pub const OSSL_FUNC_CRYPTO_MALLOC = @as(c_int, 20);
pub const OSSL_FUNC_CRYPTO_ZALLOC = @as(c_int, 21);
pub const OSSL_FUNC_CRYPTO_FREE = @as(c_int, 22);
pub const OSSL_FUNC_CRYPTO_CLEAR_FREE = @as(c_int, 23);
pub const OSSL_FUNC_CRYPTO_REALLOC = @as(c_int, 24);
pub const OSSL_FUNC_CRYPTO_CLEAR_REALLOC = @as(c_int, 25);
pub const OSSL_FUNC_CRYPTO_SECURE_MALLOC = @as(c_int, 26);
pub const OSSL_FUNC_CRYPTO_SECURE_ZALLOC = @as(c_int, 27);
pub const OSSL_FUNC_CRYPTO_SECURE_FREE = @as(c_int, 28);
pub const OSSL_FUNC_CRYPTO_SECURE_CLEAR_FREE = @as(c_int, 29);
pub const OSSL_FUNC_CRYPTO_SECURE_ALLOCATED = @as(c_int, 30);
pub const OSSL_FUNC_OPENSSL_CLEANSE = @as(c_int, 31);
pub const OSSL_FUNC_BIO_NEW_FILE = @as(c_int, 40);
pub const OSSL_FUNC_BIO_NEW_MEMBUF = @as(c_int, 41);
pub const OSSL_FUNC_BIO_READ_EX = @as(c_int, 42);
pub const OSSL_FUNC_BIO_WRITE_EX = @as(c_int, 43);
pub const OSSL_FUNC_BIO_UP_REF = @as(c_int, 44);
pub const OSSL_FUNC_BIO_FREE = @as(c_int, 45);
pub const OSSL_FUNC_BIO_VPRINTF = @as(c_int, 46);
pub const OSSL_FUNC_BIO_VSNPRINTF = @as(c_int, 47);
pub const OSSL_FUNC_BIO_PUTS = @as(c_int, 48);
pub const OSSL_FUNC_BIO_GETS = @as(c_int, 49);
pub const OSSL_FUNC_BIO_CTRL = @as(c_int, 50);
pub const OSSL_FUNC_CLEANUP_USER_ENTROPY = @as(c_int, 96);
pub const OSSL_FUNC_CLEANUP_USER_NONCE = @as(c_int, 97);
pub const OSSL_FUNC_GET_USER_ENTROPY = @as(c_int, 98);
pub const OSSL_FUNC_GET_USER_NONCE = @as(c_int, 99);
pub const OSSL_FUNC_INDICATOR_CB = @as(c_int, 95);
pub const OSSL_FUNC_SELF_TEST_CB = @as(c_int, 100);
pub const OSSL_FUNC_GET_ENTROPY = @as(c_int, 101);
pub const OSSL_FUNC_CLEANUP_ENTROPY = @as(c_int, 102);
pub const OSSL_FUNC_GET_NONCE = @as(c_int, 103);
pub const OSSL_FUNC_CLEANUP_NONCE = @as(c_int, 104);
pub const OSSL_FUNC_PROVIDER_REGISTER_CHILD_CB = @as(c_int, 105);
pub const OSSL_FUNC_PROVIDER_DEREGISTER_CHILD_CB = @as(c_int, 106);
pub const OSSL_FUNC_PROVIDER_NAME = @as(c_int, 107);
pub const OSSL_FUNC_PROVIDER_GET0_PROVIDER_CTX = @as(c_int, 108);
pub const OSSL_FUNC_PROVIDER_GET0_DISPATCH = @as(c_int, 109);
pub const OSSL_FUNC_PROVIDER_UP_REF = @as(c_int, 110);
pub const OSSL_FUNC_PROVIDER_FREE = @as(c_int, 111);
pub const OSSL_FUNC_PROVIDER_TEARDOWN = @as(c_int, 1024);
pub const OSSL_FUNC_PROVIDER_GETTABLE_PARAMS = @as(c_int, 1025);
pub const OSSL_FUNC_PROVIDER_GET_PARAMS = @as(c_int, 1026);
pub const OSSL_FUNC_PROVIDER_QUERY_OPERATION = @as(c_int, 1027);
pub const OSSL_FUNC_PROVIDER_UNQUERY_OPERATION = @as(c_int, 1028);
pub const OSSL_FUNC_PROVIDER_GET_REASON_STRINGS = @as(c_int, 1029);
pub const OSSL_FUNC_PROVIDER_GET_CAPABILITIES = @as(c_int, 1030);
pub const OSSL_FUNC_PROVIDER_SELF_TEST = @as(c_int, 1031);
pub const OSSL_OP_DIGEST = @as(c_int, 1);
pub const OSSL_OP_CIPHER = @as(c_int, 2);
pub const OSSL_OP_MAC = @as(c_int, 3);
pub const OSSL_OP_KDF = @as(c_int, 4);
pub const OSSL_OP_RAND = @as(c_int, 5);
pub const OSSL_OP_KEYMGMT = @as(c_int, 10);
pub const OSSL_OP_KEYEXCH = @as(c_int, 11);
pub const OSSL_OP_SIGNATURE = @as(c_int, 12);
pub const OSSL_OP_ASYM_CIPHER = @as(c_int, 13);
pub const OSSL_OP_KEM = @as(c_int, 14);
pub const OSSL_OP_ENCODER = @as(c_int, 20);
pub const OSSL_OP_DECODER = @as(c_int, 21);
pub const OSSL_OP_STORE = @as(c_int, 22);
pub const OSSL_OP__HIGHEST = @as(c_int, 22);
pub const OSSL_FUNC_DIGEST_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_DIGEST_INIT = @as(c_int, 2);
pub const OSSL_FUNC_DIGEST_UPDATE = @as(c_int, 3);
pub const OSSL_FUNC_DIGEST_FINAL = @as(c_int, 4);
pub const OSSL_FUNC_DIGEST_DIGEST = @as(c_int, 5);
pub const OSSL_FUNC_DIGEST_FREECTX = @as(c_int, 6);
pub const OSSL_FUNC_DIGEST_DUPCTX = @as(c_int, 7);
pub const OSSL_FUNC_DIGEST_GET_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_DIGEST_SET_CTX_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_DIGEST_GET_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_DIGEST_GETTABLE_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_DIGEST_SETTABLE_CTX_PARAMS = @as(c_int, 12);
pub const OSSL_FUNC_DIGEST_GETTABLE_CTX_PARAMS = @as(c_int, 13);
pub const OSSL_FUNC_DIGEST_SQUEEZE = @as(c_int, 14);
pub const OSSL_FUNC_CIPHER_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_CIPHER_ENCRYPT_INIT = @as(c_int, 2);
pub const OSSL_FUNC_CIPHER_DECRYPT_INIT = @as(c_int, 3);
pub const OSSL_FUNC_CIPHER_UPDATE = @as(c_int, 4);
pub const OSSL_FUNC_CIPHER_FINAL = @as(c_int, 5);
pub const OSSL_FUNC_CIPHER_CIPHER = @as(c_int, 6);
pub const OSSL_FUNC_CIPHER_FREECTX = @as(c_int, 7);
pub const OSSL_FUNC_CIPHER_DUPCTX = @as(c_int, 8);
pub const OSSL_FUNC_CIPHER_GET_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_CIPHER_GET_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_CIPHER_SET_CTX_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_CIPHER_GETTABLE_PARAMS = @as(c_int, 12);
pub const OSSL_FUNC_CIPHER_GETTABLE_CTX_PARAMS = @as(c_int, 13);
pub const OSSL_FUNC_CIPHER_SETTABLE_CTX_PARAMS = @as(c_int, 14);
pub const OSSL_FUNC_MAC_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_MAC_DUPCTX = @as(c_int, 2);
pub const OSSL_FUNC_MAC_FREECTX = @as(c_int, 3);
pub const OSSL_FUNC_MAC_INIT = @as(c_int, 4);
pub const OSSL_FUNC_MAC_UPDATE = @as(c_int, 5);
pub const OSSL_FUNC_MAC_FINAL = @as(c_int, 6);
pub const OSSL_FUNC_MAC_GET_PARAMS = @as(c_int, 7);
pub const OSSL_FUNC_MAC_GET_CTX_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_MAC_SET_CTX_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_MAC_GETTABLE_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_MAC_GETTABLE_CTX_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_MAC_SETTABLE_CTX_PARAMS = @as(c_int, 12);
pub const OSSL_FUNC_KDF_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_KDF_DUPCTX = @as(c_int, 2);
pub const OSSL_FUNC_KDF_FREECTX = @as(c_int, 3);
pub const OSSL_FUNC_KDF_RESET = @as(c_int, 4);
pub const OSSL_FUNC_KDF_DERIVE = @as(c_int, 5);
pub const OSSL_FUNC_KDF_GETTABLE_PARAMS = @as(c_int, 6);
pub const OSSL_FUNC_KDF_GETTABLE_CTX_PARAMS = @as(c_int, 7);
pub const OSSL_FUNC_KDF_SETTABLE_CTX_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_KDF_GET_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_KDF_GET_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_KDF_SET_CTX_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_RAND_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_RAND_FREECTX = @as(c_int, 2);
pub const OSSL_FUNC_RAND_INSTANTIATE = @as(c_int, 3);
pub const OSSL_FUNC_RAND_UNINSTANTIATE = @as(c_int, 4);
pub const OSSL_FUNC_RAND_GENERATE = @as(c_int, 5);
pub const OSSL_FUNC_RAND_RESEED = @as(c_int, 6);
pub const OSSL_FUNC_RAND_NONCE = @as(c_int, 7);
pub const OSSL_FUNC_RAND_ENABLE_LOCKING = @as(c_int, 8);
pub const OSSL_FUNC_RAND_LOCK = @as(c_int, 9);
pub const OSSL_FUNC_RAND_UNLOCK = @as(c_int, 10);
pub const OSSL_FUNC_RAND_GETTABLE_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_RAND_GETTABLE_CTX_PARAMS = @as(c_int, 12);
pub const OSSL_FUNC_RAND_SETTABLE_CTX_PARAMS = @as(c_int, 13);
pub const OSSL_FUNC_RAND_GET_PARAMS = @as(c_int, 14);
pub const OSSL_FUNC_RAND_GET_CTX_PARAMS = @as(c_int, 15);
pub const OSSL_FUNC_RAND_SET_CTX_PARAMS = @as(c_int, 16);
pub const OSSL_FUNC_RAND_VERIFY_ZEROIZATION = @as(c_int, 17);
pub const OSSL_FUNC_RAND_GET_SEED = @as(c_int, 18);
pub const OSSL_FUNC_RAND_CLEAR_SEED = @as(c_int, 19);
pub const OSSL_KEYMGMT_SELECT_PRIVATE_KEY = @as(c_int, 0x01);
pub const OSSL_KEYMGMT_SELECT_PUBLIC_KEY = @as(c_int, 0x02);
pub const OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS = @as(c_int, 0x04);
pub const OSSL_KEYMGMT_SELECT_OTHER_PARAMETERS = @as(c_int, 0x80);
pub const OSSL_KEYMGMT_SELECT_ALL_PARAMETERS = OSSL_KEYMGMT_SELECT_DOMAIN_PARAMETERS | OSSL_KEYMGMT_SELECT_OTHER_PARAMETERS;
pub const OSSL_KEYMGMT_SELECT_KEYPAIR = OSSL_KEYMGMT_SELECT_PRIVATE_KEY | OSSL_KEYMGMT_SELECT_PUBLIC_KEY;
pub const OSSL_KEYMGMT_SELECT_ALL = OSSL_KEYMGMT_SELECT_KEYPAIR | OSSL_KEYMGMT_SELECT_ALL_PARAMETERS;
pub const OSSL_KEYMGMT_VALIDATE_FULL_CHECK = @as(c_int, 0);
pub const OSSL_KEYMGMT_VALIDATE_QUICK_CHECK = @as(c_int, 1);
pub const OSSL_FUNC_KEYMGMT_NEW = @as(c_int, 1);
pub const OSSL_FUNC_KEYMGMT_GEN_INIT = @as(c_int, 2);
pub const OSSL_FUNC_KEYMGMT_GEN_SET_TEMPLATE = @as(c_int, 3);
pub const OSSL_FUNC_KEYMGMT_GEN_SET_PARAMS = @as(c_int, 4);
pub const OSSL_FUNC_KEYMGMT_GEN_SETTABLE_PARAMS = @as(c_int, 5);
pub const OSSL_FUNC_KEYMGMT_GEN = @as(c_int, 6);
pub const OSSL_FUNC_KEYMGMT_GEN_CLEANUP = @as(c_int, 7);
pub const OSSL_FUNC_KEYMGMT_GEN_GET_PARAMS = @as(c_int, 15);
pub const OSSL_FUNC_KEYMGMT_GEN_GETTABLE_PARAMS = @as(c_int, 16);
pub const OSSL_FUNC_KEYMGMT_LOAD = @as(c_int, 8);
pub const OSSL_FUNC_KEYMGMT_FREE = @as(c_int, 10);
pub const OSSL_FUNC_KEYMGMT_GET_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_KEYMGMT_GETTABLE_PARAMS = @as(c_int, 12);
pub const OSSL_FUNC_KEYMGMT_SET_PARAMS = @as(c_int, 13);
pub const OSSL_FUNC_KEYMGMT_SETTABLE_PARAMS = @as(c_int, 14);
pub const OSSL_FUNC_KEYMGMT_QUERY_OPERATION_NAME = @as(c_int, 20);
pub const OSSL_FUNC_KEYMGMT_HAS = @as(c_int, 21);
pub const OSSL_FUNC_KEYMGMT_VALIDATE = @as(c_int, 22);
pub const OSSL_FUNC_KEYMGMT_MATCH = @as(c_int, 23);
pub const OSSL_FUNC_KEYMGMT_IMPORT = @as(c_int, 40);
pub const OSSL_FUNC_KEYMGMT_IMPORT_TYPES = @as(c_int, 41);
pub const OSSL_FUNC_KEYMGMT_EXPORT = @as(c_int, 42);
pub const OSSL_FUNC_KEYMGMT_EXPORT_TYPES = @as(c_int, 43);
pub const OSSL_FUNC_KEYMGMT_DUP = @as(c_int, 44);
pub const OSSL_FUNC_KEYMGMT_IMPORT_TYPES_EX = @as(c_int, 45);
pub const OSSL_FUNC_KEYMGMT_EXPORT_TYPES_EX = @as(c_int, 46);
pub const OSSL_FUNC_KEYEXCH_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_KEYEXCH_INIT = @as(c_int, 2);
pub const OSSL_FUNC_KEYEXCH_DERIVE = @as(c_int, 3);
pub const OSSL_FUNC_KEYEXCH_SET_PEER = @as(c_int, 4);
pub const OSSL_FUNC_KEYEXCH_FREECTX = @as(c_int, 5);
pub const OSSL_FUNC_KEYEXCH_DUPCTX = @as(c_int, 6);
pub const OSSL_FUNC_KEYEXCH_SET_CTX_PARAMS = @as(c_int, 7);
pub const OSSL_FUNC_KEYEXCH_SETTABLE_CTX_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_KEYEXCH_GET_CTX_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_KEYEXCH_GETTABLE_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_SIGNATURE_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_SIGNATURE_SIGN_INIT = @as(c_int, 2);
pub const OSSL_FUNC_SIGNATURE_SIGN = @as(c_int, 3);
pub const OSSL_FUNC_SIGNATURE_VERIFY_INIT = @as(c_int, 4);
pub const OSSL_FUNC_SIGNATURE_VERIFY = @as(c_int, 5);
pub const OSSL_FUNC_SIGNATURE_VERIFY_RECOVER_INIT = @as(c_int, 6);
pub const OSSL_FUNC_SIGNATURE_VERIFY_RECOVER = @as(c_int, 7);
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN_INIT = @as(c_int, 8);
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN_UPDATE = @as(c_int, 9);
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN_FINAL = @as(c_int, 10);
pub const OSSL_FUNC_SIGNATURE_DIGEST_SIGN = @as(c_int, 11);
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_INIT = @as(c_int, 12);
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_UPDATE = @as(c_int, 13);
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY_FINAL = @as(c_int, 14);
pub const OSSL_FUNC_SIGNATURE_DIGEST_VERIFY = @as(c_int, 15);
pub const OSSL_FUNC_SIGNATURE_FREECTX = @as(c_int, 16);
pub const OSSL_FUNC_SIGNATURE_DUPCTX = @as(c_int, 17);
pub const OSSL_FUNC_SIGNATURE_GET_CTX_PARAMS = @as(c_int, 18);
pub const OSSL_FUNC_SIGNATURE_GETTABLE_CTX_PARAMS = @as(c_int, 19);
pub const OSSL_FUNC_SIGNATURE_SET_CTX_PARAMS = @as(c_int, 20);
pub const OSSL_FUNC_SIGNATURE_SETTABLE_CTX_PARAMS = @as(c_int, 21);
pub const OSSL_FUNC_SIGNATURE_GET_CTX_MD_PARAMS = @as(c_int, 22);
pub const OSSL_FUNC_SIGNATURE_GETTABLE_CTX_MD_PARAMS = @as(c_int, 23);
pub const OSSL_FUNC_SIGNATURE_SET_CTX_MD_PARAMS = @as(c_int, 24);
pub const OSSL_FUNC_SIGNATURE_SETTABLE_CTX_MD_PARAMS = @as(c_int, 25);
pub const OSSL_FUNC_SIGNATURE_QUERY_KEY_TYPES = @as(c_int, 26);
pub const OSSL_FUNC_SIGNATURE_SIGN_MESSAGE_INIT = @as(c_int, 27);
pub const OSSL_FUNC_SIGNATURE_SIGN_MESSAGE_UPDATE = @as(c_int, 28);
pub const OSSL_FUNC_SIGNATURE_SIGN_MESSAGE_FINAL = @as(c_int, 29);
pub const OSSL_FUNC_SIGNATURE_VERIFY_MESSAGE_INIT = @as(c_int, 30);
pub const OSSL_FUNC_SIGNATURE_VERIFY_MESSAGE_UPDATE = @as(c_int, 31);
pub const OSSL_FUNC_SIGNATURE_VERIFY_MESSAGE_FINAL = @as(c_int, 32);
pub const OSSL_FUNC_ASYM_CIPHER_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_ASYM_CIPHER_ENCRYPT_INIT = @as(c_int, 2);
pub const OSSL_FUNC_ASYM_CIPHER_ENCRYPT = @as(c_int, 3);
pub const OSSL_FUNC_ASYM_CIPHER_DECRYPT_INIT = @as(c_int, 4);
pub const OSSL_FUNC_ASYM_CIPHER_DECRYPT = @as(c_int, 5);
pub const OSSL_FUNC_ASYM_CIPHER_FREECTX = @as(c_int, 6);
pub const OSSL_FUNC_ASYM_CIPHER_DUPCTX = @as(c_int, 7);
pub const OSSL_FUNC_ASYM_CIPHER_GET_CTX_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_ASYM_CIPHER_GETTABLE_CTX_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_ASYM_CIPHER_SET_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_ASYM_CIPHER_SETTABLE_CTX_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_KEM_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_KEM_ENCAPSULATE_INIT = @as(c_int, 2);
pub const OSSL_FUNC_KEM_ENCAPSULATE = @as(c_int, 3);
pub const OSSL_FUNC_KEM_DECAPSULATE_INIT = @as(c_int, 4);
pub const OSSL_FUNC_KEM_DECAPSULATE = @as(c_int, 5);
pub const OSSL_FUNC_KEM_FREECTX = @as(c_int, 6);
pub const OSSL_FUNC_KEM_DUPCTX = @as(c_int, 7);
pub const OSSL_FUNC_KEM_GET_CTX_PARAMS = @as(c_int, 8);
pub const OSSL_FUNC_KEM_GETTABLE_CTX_PARAMS = @as(c_int, 9);
pub const OSSL_FUNC_KEM_SET_CTX_PARAMS = @as(c_int, 10);
pub const OSSL_FUNC_KEM_SETTABLE_CTX_PARAMS = @as(c_int, 11);
pub const OSSL_FUNC_KEM_AUTH_ENCAPSULATE_INIT = @as(c_int, 12);
pub const OSSL_FUNC_KEM_AUTH_DECAPSULATE_INIT = @as(c_int, 13);
pub const OSSL_FUNC_ENCODER_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_ENCODER_FREECTX = @as(c_int, 2);
pub const OSSL_FUNC_ENCODER_GET_PARAMS = @as(c_int, 3);
pub const OSSL_FUNC_ENCODER_GETTABLE_PARAMS = @as(c_int, 4);
pub const OSSL_FUNC_ENCODER_SET_CTX_PARAMS = @as(c_int, 5);
pub const OSSL_FUNC_ENCODER_SETTABLE_CTX_PARAMS = @as(c_int, 6);
pub const OSSL_FUNC_ENCODER_DOES_SELECTION = @as(c_int, 10);
pub const OSSL_FUNC_ENCODER_ENCODE = @as(c_int, 11);
pub const OSSL_FUNC_ENCODER_IMPORT_OBJECT = @as(c_int, 20);
pub const OSSL_FUNC_ENCODER_FREE_OBJECT = @as(c_int, 21);
pub const OSSL_FUNC_DECODER_NEWCTX = @as(c_int, 1);
pub const OSSL_FUNC_DECODER_FREECTX = @as(c_int, 2);
pub const OSSL_FUNC_DECODER_GET_PARAMS = @as(c_int, 3);
pub const OSSL_FUNC_DECODER_GETTABLE_PARAMS = @as(c_int, 4);
pub const OSSL_FUNC_DECODER_SET_CTX_PARAMS = @as(c_int, 5);
pub const OSSL_FUNC_DECODER_SETTABLE_CTX_PARAMS = @as(c_int, 6);
pub const OSSL_FUNC_DECODER_DOES_SELECTION = @as(c_int, 10);
pub const OSSL_FUNC_DECODER_DECODE = @as(c_int, 11);
pub const OSSL_FUNC_DECODER_EXPORT_OBJECT = @as(c_int, 20);
pub const OSSL_FUNC_STORE_OPEN = @as(c_int, 1);
pub const OSSL_FUNC_STORE_ATTACH = @as(c_int, 2);
pub const OSSL_FUNC_STORE_SETTABLE_CTX_PARAMS = @as(c_int, 3);
pub const OSSL_FUNC_STORE_SET_CTX_PARAMS = @as(c_int, 4);
pub const OSSL_FUNC_STORE_LOAD = @as(c_int, 5);
pub const OSSL_FUNC_STORE_EOF = @as(c_int, 6);
pub const OSSL_FUNC_STORE_CLOSE = @as(c_int, 7);
pub const OSSL_FUNC_STORE_EXPORT_OBJECT = @as(c_int, 8);
pub const OSSL_FUNC_STORE_DELETE = @as(c_int, 9);
pub const OSSL_FUNC_STORE_OPEN_EX = @as(c_int, 10);
pub const OPENSSL_EVPERR_H = "";
pub const EVP_R_AES_KEY_SETUP_FAILED = @as(c_int, 143);
pub const EVP_R_ARIA_KEY_SETUP_FAILED = @as(c_int, 176);
pub const EVP_R_BAD_ALGORITHM_NAME = @as(c_int, 200);
pub const EVP_R_BAD_DECRYPT = @as(c_int, 100);
pub const EVP_R_BAD_KEY_LENGTH = @as(c_int, 195);
pub const EVP_R_BUFFER_TOO_SMALL = @as(c_int, 155);
pub const EVP_R_CACHE_CONSTANTS_FAILED = @as(c_int, 225);
pub const EVP_R_CAMELLIA_KEY_SETUP_FAILED = @as(c_int, 157);
pub const EVP_R_CANNOT_GET_PARAMETERS = @as(c_int, 197);
pub const EVP_R_CANNOT_SET_PARAMETERS = @as(c_int, 198);
pub const EVP_R_CIPHER_NOT_GCM_MODE = @as(c_int, 184);
pub const EVP_R_CIPHER_PARAMETER_ERROR = @as(c_int, 122);
pub const EVP_R_COMMAND_NOT_SUPPORTED = @as(c_int, 147);
pub const EVP_R_CONFLICTING_ALGORITHM_NAME = @as(c_int, 201);
pub const EVP_R_COPY_ERROR = @as(c_int, 173);
pub const EVP_R_CTRL_NOT_IMPLEMENTED = @as(c_int, 132);
pub const EVP_R_CTRL_OPERATION_NOT_IMPLEMENTED = @as(c_int, 133);
pub const EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH = @as(c_int, 138);
pub const EVP_R_DECODE_ERROR = @as(c_int, 114);
pub const EVP_R_DEFAULT_QUERY_PARSE_ERROR = @as(c_int, 210);
pub const EVP_R_DIFFERENT_KEY_TYPES = @as(c_int, 101);
pub const EVP_R_DIFFERENT_PARAMETERS = @as(c_int, 153);
pub const EVP_R_ERROR_LOADING_SECTION = @as(c_int, 165);
pub const EVP_R_EXPECTING_AN_HMAC_KEY = @as(c_int, 174);
pub const EVP_R_EXPECTING_AN_RSA_KEY = @as(c_int, 127);
pub const EVP_R_EXPECTING_A_DH_KEY = @as(c_int, 128);
pub const EVP_R_EXPECTING_A_DSA_KEY = @as(c_int, 129);
pub const EVP_R_EXPECTING_A_ECX_KEY = @as(c_int, 219);
pub const EVP_R_EXPECTING_A_EC_KEY = @as(c_int, 142);
pub const EVP_R_EXPECTING_A_POLY1305_KEY = @as(c_int, 164);
pub const EVP_R_EXPECTING_A_SIPHASH_KEY = @as(c_int, 175);
pub const EVP_R_FINAL_ERROR = @as(c_int, 188);
pub const EVP_R_GENERATE_ERROR = @as(c_int, 214);
pub const EVP_R_GETTING_ALGORITHMIDENTIFIER_NOT_SUPPORTED = @as(c_int, 229);
pub const EVP_R_GET_RAW_KEY_FAILED = @as(c_int, 182);
pub const EVP_R_ILLEGAL_SCRYPT_PARAMETERS = @as(c_int, 171);
pub const EVP_R_INACCESSIBLE_DOMAIN_PARAMETERS = @as(c_int, 204);
pub const EVP_R_INACCESSIBLE_KEY = @as(c_int, 203);
pub const EVP_R_INITIALIZATION_ERROR = @as(c_int, 134);
pub const EVP_R_INPUT_NOT_INITIALIZED = @as(c_int, 111);
pub const EVP_R_INVALID_CUSTOM_LENGTH = @as(c_int, 185);
pub const EVP_R_INVALID_DIGEST = @as(c_int, 152);
pub const EVP_R_INVALID_IV_LENGTH = @as(c_int, 194);
pub const EVP_R_INVALID_KEY = @as(c_int, 163);
pub const EVP_R_INVALID_KEY_LENGTH = @as(c_int, 130);
pub const EVP_R_INVALID_LENGTH = @as(c_int, 221);
pub const EVP_R_INVALID_NULL_ALGORITHM = @as(c_int, 218);
pub const EVP_R_INVALID_OPERATION = @as(c_int, 148);
pub const EVP_R_INVALID_PROVIDER_FUNCTIONS = @as(c_int, 193);
pub const EVP_R_INVALID_SALT_LENGTH = @as(c_int, 186);
pub const EVP_R_INVALID_SECRET_LENGTH = @as(c_int, 223);
pub const EVP_R_INVALID_SEED_LENGTH = @as(c_int, 220);
pub const EVP_R_INVALID_VALUE = @as(c_int, 222);
pub const EVP_R_KEYMGMT_EXPORT_FAILURE = @as(c_int, 205);
pub const EVP_R_KEY_SETUP_FAILED = @as(c_int, 180);
pub const EVP_R_LOCKING_NOT_SUPPORTED = @as(c_int, 213);
pub const EVP_R_MEMORY_LIMIT_EXCEEDED = @as(c_int, 172);
pub const EVP_R_MESSAGE_DIGEST_IS_NULL = @as(c_int, 159);
pub const EVP_R_METHOD_NOT_SUPPORTED = @as(c_int, 144);
pub const EVP_R_MISSING_PARAMETERS = @as(c_int, 103);
pub const EVP_R_NOT_ABLE_TO_COPY_CTX = @as(c_int, 190);
pub const EVP_R_NOT_XOF_OR_INVALID_LENGTH = @as(c_int, 178);
pub const EVP_R_NO_CIPHER_SET = @as(c_int, 131);
pub const EVP_R_NO_DEFAULT_DIGEST = @as(c_int, 158);
pub const EVP_R_NO_DIGEST_SET = @as(c_int, 139);
pub const EVP_R_NO_IMPORT_FUNCTION = @as(c_int, 206);
pub const EVP_R_NO_KEYMGMT_AVAILABLE = @as(c_int, 199);
pub const EVP_R_NO_KEYMGMT_PRESENT = @as(c_int, 196);
pub const EVP_R_NO_KEY_SET = @as(c_int, 154);
pub const EVP_R_NO_OPERATION_SET = @as(c_int, 149);
pub const EVP_R_NULL_MAC_PKEY_CTX = @as(c_int, 208);
pub const EVP_R_ONLY_ONESHOT_SUPPORTED = @as(c_int, 177);
pub const EVP_R_OPERATION_NOT_INITIALIZED = @as(c_int, 151);
pub const EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE = @as(c_int, 150);
pub const EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_SIGNATURE_TYPE = @as(c_int, 226);
pub const EVP_R_OUTPUT_WOULD_OVERFLOW = @as(c_int, 202);
pub const EVP_R_PARAMETER_TOO_LARGE = @as(c_int, 187);
pub const EVP_R_PARTIALLY_OVERLAPPING = @as(c_int, 162);
pub const EVP_R_PBKDF2_ERROR = @as(c_int, 181);
pub const EVP_R_PKEY_APPLICATION_ASN1_METHOD_ALREADY_REGISTERED = @as(c_int, 179);
pub const EVP_R_PRIVATE_KEY_DECODE_ERROR = @as(c_int, 145);
pub const EVP_R_PRIVATE_KEY_ENCODE_ERROR = @as(c_int, 146);
pub const EVP_R_PUBLIC_KEY_NOT_RSA = @as(c_int, 106);
pub const EVP_R_SETTING_XOF_FAILED = @as(c_int, 227);
pub const EVP_R_SET_DEFAULT_PROPERTY_FAILURE = @as(c_int, 209);
pub const EVP_R_SIGNATURE_TYPE_AND_KEY_TYPE_INCOMPATIBLE = @as(c_int, 228);
pub const EVP_R_TOO_MANY_RECORDS = @as(c_int, 183);
pub const EVP_R_UNABLE_TO_ENABLE_LOCKING = @as(c_int, 212);
pub const EVP_R_UNABLE_TO_GET_MAXIMUM_REQUEST_SIZE = @as(c_int, 215);
pub const EVP_R_UNABLE_TO_GET_RANDOM_STRENGTH = @as(c_int, 216);
pub const EVP_R_UNABLE_TO_LOCK_CONTEXT = @as(c_int, 211);
pub const EVP_R_UNABLE_TO_SET_CALLBACKS = @as(c_int, 217);
pub const EVP_R_UNKNOWN_BITS = @as(c_int, 166);
pub const EVP_R_UNKNOWN_CIPHER = @as(c_int, 160);
pub const EVP_R_UNKNOWN_DIGEST = @as(c_int, 161);
pub const EVP_R_UNKNOWN_KEY_TYPE = @as(c_int, 207);
pub const EVP_R_UNKNOWN_MAX_SIZE = @as(c_int, 167);
pub const EVP_R_UNKNOWN_OPTION = @as(c_int, 169);
pub const EVP_R_UNKNOWN_PBE_ALGORITHM = @as(c_int, 121);
pub const EVP_R_UNKNOWN_SECURITY_BITS = @as(c_int, 168);
pub const EVP_R_UNSUPPORTED_ALGORITHM = @as(c_int, 156);
pub const EVP_R_UNSUPPORTED_CIPHER = @as(c_int, 107);
pub const EVP_R_UNSUPPORTED_KEYLENGTH = @as(c_int, 123);
pub const EVP_R_UNSUPPORTED_KEY_DERIVATION_FUNCTION = @as(c_int, 124);
pub const EVP_R_UNSUPPORTED_KEY_SIZE = @as(c_int, 108);
pub const EVP_R_UNSUPPORTED_KEY_TYPE = @as(c_int, 224);
pub const EVP_R_UNSUPPORTED_NUMBER_OF_ROUNDS = @as(c_int, 135);
pub const EVP_R_UNSUPPORTED_PRF = @as(c_int, 125);
pub const EVP_R_UNSUPPORTED_PRIVATE_KEY_ALGORITHM = @as(c_int, 118);
pub const EVP_R_UNSUPPORTED_SALT_TYPE = @as(c_int, 126);
pub const EVP_R_UPDATE_ERROR = @as(c_int, 189);
pub const EVP_R_WRAP_MODE_NOT_ALLOWED = @as(c_int, 170);
pub const EVP_R_WRONG_FINAL_BLOCK_LENGTH = @as(c_int, 109);
pub const EVP_R_XTS_DATA_UNIT_IS_TOO_LARGE = @as(c_int, 191);
pub const EVP_R_XTS_DUPLICATED_KEYS = @as(c_int, 192);
pub const EVP_MAX_MD_SIZE = @as(c_int, 64);
pub const EVP_MAX_KEY_LENGTH = @as(c_int, 64);
pub const EVP_MAX_IV_LENGTH = @as(c_int, 16);
pub const EVP_MAX_BLOCK_LENGTH = @as(c_int, 32);
pub const EVP_MAX_AEAD_TAG_LENGTH = @as(c_int, 16);
pub const PKCS5_SALT_LEN = @as(c_int, 8);
pub const PKCS5_DEFAULT_ITER = @as(c_int, 2048);
pub const OPENSSL_OBJECTS_H = "";
pub const HEADER_OBJECTS_H = "";
pub const OPENSSL_OBJ_MAC_H = "";
pub const SN_undef = "UNDEF";
pub const LN_undef = "undefined";
pub const NID_undef = @as(c_int, 0);
pub const OBJ_undef = @as(c_long, 0);
pub const SN_itu_t = "ITU-T";
pub const LN_itu_t = "itu-t";
pub const NID_itu_t = @as(c_int, 645);
pub const OBJ_itu_t = @as(c_long, 0);
pub const NID_ccitt = @as(c_int, 404);
pub const OBJ_ccitt = OBJ_itu_t;
pub const SN_iso = "ISO";
pub const LN_iso = "iso";
pub const NID_iso = @as(c_int, 181);
pub const OBJ_iso = @as(c_long, 1);
pub const SN_joint_iso_itu_t = "JOINT-ISO-ITU-T";
pub const LN_joint_iso_itu_t = "joint-iso-itu-t";
pub const NID_joint_iso_itu_t = @as(c_int, 646);
pub const OBJ_joint_iso_itu_t = @as(c_long, 2);
pub const NID_joint_iso_ccitt = @as(c_int, 393);
pub const OBJ_joint_iso_ccitt = OBJ_joint_iso_itu_t;
pub const SN_member_body = "member-body";
pub const LN_member_body = "ISO Member Body";
pub const NID_member_body = @as(c_int, 182);
pub const OBJ_member_body = blk: {
    _ = &OBJ_iso;
    break :blk @as(c_long, 2);
};
pub const SN_identified_organization = "identified-organization";
pub const NID_identified_organization = @as(c_int, 676);
pub const OBJ_identified_organization = blk: {
    _ = &OBJ_iso;
    break :blk @as(c_long, 3);
};
pub const SN_gmac = "GMAC";
pub const LN_gmac = "gmac";
pub const NID_gmac = @as(c_int, 1195);
pub const OBJ_gmac = blk: {
    _ = &OBJ_iso;
    _ = @as(c_long, 0);
    _ = @as(c_long, 9797);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 4);
};
pub const SN_hmac_md5 = "HMAC-MD5";
pub const LN_hmac_md5 = "hmac-md5";
pub const NID_hmac_md5 = @as(c_int, 780);
pub const OBJ_hmac_md5 = blk: {
    _ = &OBJ_identified_organization;
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    _ = @as(c_long, 5);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_hmac_sha1 = "HMAC-SHA1";
pub const LN_hmac_sha1 = "hmac-sha1";
pub const NID_hmac_sha1 = @as(c_int, 781);
pub const OBJ_hmac_sha1 = blk: {
    _ = &OBJ_identified_organization;
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    _ = @as(c_long, 5);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_x509ExtAdmission = "x509ExtAdmission";
pub const LN_x509ExtAdmission = "Professional Information or basis for Admission";
pub const NID_x509ExtAdmission = @as(c_int, 1093);
pub const OBJ_x509ExtAdmission = blk: {
    _ = &OBJ_identified_organization;
    _ = @as(c_long, 36);
    _ = @as(c_long, 8);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 3);
};
pub const SN_certicom_arc = "certicom-arc";
pub const NID_certicom_arc = @as(c_int, 677);
pub const OBJ_certicom_arc = blk: {
    _ = &OBJ_identified_organization;
    break :blk @as(c_long, 132);
};
pub const SN_ieee = "ieee";
pub const NID_ieee = @as(c_int, 1170);
pub const OBJ_ieee = blk: {
    _ = &OBJ_identified_organization;
    break :blk @as(c_long, 111);
};
pub const SN_ieee_siswg = "ieee-siswg";
pub const LN_ieee_siswg = "IEEE Security in Storage Working Group";
pub const NID_ieee_siswg = @as(c_int, 1171);
pub const OBJ_ieee_siswg = blk: {
    _ = &OBJ_ieee;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1619);
};
pub const SN_international_organizations = "international-organizations";
pub const LN_international_organizations = "International Organizations";
pub const NID_international_organizations = @as(c_int, 647);
pub const OBJ_international_organizations = blk: {
    _ = &OBJ_joint_iso_itu_t;
    break :blk @as(c_long, 23);
};
pub const SN_wap = "wap";
pub const NID_wap = @as(c_int, 678);
pub const OBJ_wap = blk: {
    _ = &OBJ_international_organizations;
    break :blk @as(c_long, 43);
};
pub const SN_wap_wsg = "wap-wsg";
pub const NID_wap_wsg = @as(c_int, 679);
pub const OBJ_wap_wsg = blk: {
    _ = &OBJ_wap;
    break :blk @as(c_long, 1);
};
pub const SN_selected_attribute_types = "selected-attribute-types";
pub const LN_selected_attribute_types = "Selected Attribute Types";
pub const NID_selected_attribute_types = @as(c_int, 394);
pub const OBJ_selected_attribute_types = blk: {
    _ = &OBJ_joint_iso_itu_t;
    _ = @as(c_long, 5);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 5);
};
pub const SN_clearance = "clearance";
pub const NID_clearance = @as(c_int, 395);
pub const OBJ_clearance = blk: {
    _ = &OBJ_selected_attribute_types;
    break :blk @as(c_long, 55);
};
pub const SN_ISO_US = "ISO-US";
pub const LN_ISO_US = "ISO US Member Body";
pub const NID_ISO_US = @as(c_int, 183);
pub const OBJ_ISO_US = blk: {
    _ = &OBJ_member_body;
    break :blk @as(c_long, 840);
};
pub const SN_X9_57 = "X9-57";
pub const LN_X9_57 = "X9.57";
pub const NID_X9_57 = @as(c_int, 184);
pub const OBJ_X9_57 = blk: {
    _ = &OBJ_ISO_US;
    break :blk @as(c_long, 10040);
};
pub const SN_X9cm = "X9cm";
pub const LN_X9cm = "X9.57 CM ?";
pub const NID_X9cm = @as(c_int, 185);
pub const OBJ_X9cm = blk: {
    _ = &OBJ_X9_57;
    break :blk @as(c_long, 4);
};
pub const SN_ISO_CN = "ISO-CN";
pub const LN_ISO_CN = "ISO CN Member Body";
pub const NID_ISO_CN = @as(c_int, 1140);
pub const OBJ_ISO_CN = blk: {
    _ = &OBJ_member_body;
    break :blk @as(c_long, 156);
};
pub const SN_oscca = "oscca";
pub const NID_oscca = @as(c_int, 1141);
pub const OBJ_oscca = blk: {
    _ = &OBJ_ISO_CN;
    break :blk @as(c_long, 10197);
};
pub const SN_sm_scheme = "sm-scheme";
pub const NID_sm_scheme = @as(c_int, 1142);
pub const OBJ_sm_scheme = blk: {
    _ = &OBJ_oscca;
    break :blk @as(c_long, 1);
};
pub const SN_dsa = "DSA";
pub const LN_dsa = "dsaEncryption";
pub const NID_dsa = @as(c_int, 116);
pub const OBJ_dsa = blk: {
    _ = &OBJ_X9cm;
    break :blk @as(c_long, 1);
};
pub const SN_dsaWithSHA1 = "DSA-SHA1";
pub const LN_dsaWithSHA1 = "dsaWithSHA1";
pub const NID_dsaWithSHA1 = @as(c_int, 113);
pub const OBJ_dsaWithSHA1 = blk: {
    _ = &OBJ_X9cm;
    break :blk @as(c_long, 3);
};
pub const SN_ansi_X9_62 = "ansi-X9-62";
pub const LN_ansi_X9_62 = "ANSI X9.62";
pub const NID_ansi_X9_62 = @as(c_int, 405);
pub const OBJ_ansi_X9_62 = blk: {
    _ = &OBJ_ISO_US;
    break :blk @as(c_long, 10045);
};
pub const OBJ_X9_62_id_fieldType = blk: {
    _ = &OBJ_ansi_X9_62;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_prime_field = "prime-field";
pub const NID_X9_62_prime_field = @as(c_int, 406);
pub const OBJ_X9_62_prime_field = blk: {
    _ = &OBJ_X9_62_id_fieldType;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_characteristic_two_field = "characteristic-two-field";
pub const NID_X9_62_characteristic_two_field = @as(c_int, 407);
pub const OBJ_X9_62_characteristic_two_field = blk: {
    _ = &OBJ_X9_62_id_fieldType;
    break :blk @as(c_long, 2);
};
pub const SN_X9_62_id_characteristic_two_basis = "id-characteristic-two-basis";
pub const NID_X9_62_id_characteristic_two_basis = @as(c_int, 680);
pub const OBJ_X9_62_id_characteristic_two_basis = blk: {
    _ = &OBJ_X9_62_characteristic_two_field;
    break :blk @as(c_long, 3);
};
pub const SN_X9_62_onBasis = "onBasis";
pub const NID_X9_62_onBasis = @as(c_int, 681);
pub const OBJ_X9_62_onBasis = blk: {
    _ = &OBJ_X9_62_id_characteristic_two_basis;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_tpBasis = "tpBasis";
pub const NID_X9_62_tpBasis = @as(c_int, 682);
pub const OBJ_X9_62_tpBasis = blk: {
    _ = &OBJ_X9_62_id_characteristic_two_basis;
    break :blk @as(c_long, 2);
};
pub const SN_X9_62_ppBasis = "ppBasis";
pub const NID_X9_62_ppBasis = @as(c_int, 683);
pub const OBJ_X9_62_ppBasis = blk: {
    _ = &OBJ_X9_62_id_characteristic_two_basis;
    break :blk @as(c_long, 3);
};
pub const OBJ_X9_62_id_publicKeyType = blk: {
    _ = &OBJ_ansi_X9_62;
    break :blk @as(c_long, 2);
};
pub const SN_X9_62_id_ecPublicKey = "id-ecPublicKey";
pub const NID_X9_62_id_ecPublicKey = @as(c_int, 408);
pub const OBJ_X9_62_id_ecPublicKey = blk: {
    _ = &OBJ_X9_62_id_publicKeyType;
    break :blk @as(c_long, 1);
};
pub const OBJ_X9_62_ellipticCurve = blk: {
    _ = &OBJ_ansi_X9_62;
    break :blk @as(c_long, 3);
};
pub const OBJ_X9_62_c_TwoCurve = blk: {
    _ = &OBJ_X9_62_ellipticCurve;
    break :blk @as(c_long, 0);
};
pub const SN_X9_62_c2pnb163v1 = "c2pnb163v1";
pub const NID_X9_62_c2pnb163v1 = @as(c_int, 684);
pub const OBJ_X9_62_c2pnb163v1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_c2pnb163v2 = "c2pnb163v2";
pub const NID_X9_62_c2pnb163v2 = @as(c_int, 685);
pub const OBJ_X9_62_c2pnb163v2 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 2);
};
pub const SN_X9_62_c2pnb163v3 = "c2pnb163v3";
pub const NID_X9_62_c2pnb163v3 = @as(c_int, 686);
pub const OBJ_X9_62_c2pnb163v3 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 3);
};
pub const SN_X9_62_c2pnb176v1 = "c2pnb176v1";
pub const NID_X9_62_c2pnb176v1 = @as(c_int, 687);
pub const OBJ_X9_62_c2pnb176v1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 4);
};
pub const SN_X9_62_c2tnb191v1 = "c2tnb191v1";
pub const NID_X9_62_c2tnb191v1 = @as(c_int, 688);
pub const OBJ_X9_62_c2tnb191v1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 5);
};
pub const SN_X9_62_c2tnb191v2 = "c2tnb191v2";
pub const NID_X9_62_c2tnb191v2 = @as(c_int, 689);
pub const OBJ_X9_62_c2tnb191v2 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 6);
};
pub const SN_X9_62_c2tnb191v3 = "c2tnb191v3";
pub const NID_X9_62_c2tnb191v3 = @as(c_int, 690);
pub const OBJ_X9_62_c2tnb191v3 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 7);
};
pub const SN_X9_62_c2onb191v4 = "c2onb191v4";
pub const NID_X9_62_c2onb191v4 = @as(c_int, 691);
pub const OBJ_X9_62_c2onb191v4 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 8);
};
pub const SN_X9_62_c2onb191v5 = "c2onb191v5";
pub const NID_X9_62_c2onb191v5 = @as(c_int, 692);
pub const OBJ_X9_62_c2onb191v5 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 9);
};
pub const SN_X9_62_c2pnb208w1 = "c2pnb208w1";
pub const NID_X9_62_c2pnb208w1 = @as(c_int, 693);
pub const OBJ_X9_62_c2pnb208w1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 10);
};
pub const SN_X9_62_c2tnb239v1 = "c2tnb239v1";
pub const NID_X9_62_c2tnb239v1 = @as(c_int, 694);
pub const OBJ_X9_62_c2tnb239v1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 11);
};
pub const SN_X9_62_c2tnb239v2 = "c2tnb239v2";
pub const NID_X9_62_c2tnb239v2 = @as(c_int, 695);
pub const OBJ_X9_62_c2tnb239v2 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 12);
};
pub const SN_X9_62_c2tnb239v3 = "c2tnb239v3";
pub const NID_X9_62_c2tnb239v3 = @as(c_int, 696);
pub const OBJ_X9_62_c2tnb239v3 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 13);
};
pub const SN_X9_62_c2onb239v4 = "c2onb239v4";
pub const NID_X9_62_c2onb239v4 = @as(c_int, 697);
pub const OBJ_X9_62_c2onb239v4 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 14);
};
pub const SN_X9_62_c2onb239v5 = "c2onb239v5";
pub const NID_X9_62_c2onb239v5 = @as(c_int, 698);
pub const OBJ_X9_62_c2onb239v5 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 15);
};
pub const SN_X9_62_c2pnb272w1 = "c2pnb272w1";
pub const NID_X9_62_c2pnb272w1 = @as(c_int, 699);
pub const OBJ_X9_62_c2pnb272w1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 16);
};
pub const SN_X9_62_c2pnb304w1 = "c2pnb304w1";
pub const NID_X9_62_c2pnb304w1 = @as(c_int, 700);
pub const OBJ_X9_62_c2pnb304w1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 17);
};
pub const SN_X9_62_c2tnb359v1 = "c2tnb359v1";
pub const NID_X9_62_c2tnb359v1 = @as(c_int, 701);
pub const OBJ_X9_62_c2tnb359v1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 18);
};
pub const SN_X9_62_c2pnb368w1 = "c2pnb368w1";
pub const NID_X9_62_c2pnb368w1 = @as(c_int, 702);
pub const OBJ_X9_62_c2pnb368w1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 19);
};
pub const SN_X9_62_c2tnb431r1 = "c2tnb431r1";
pub const NID_X9_62_c2tnb431r1 = @as(c_int, 703);
pub const OBJ_X9_62_c2tnb431r1 = blk: {
    _ = &OBJ_X9_62_c_TwoCurve;
    break :blk @as(c_long, 20);
};
pub const OBJ_X9_62_primeCurve = blk: {
    _ = &OBJ_X9_62_ellipticCurve;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_prime192v1 = "prime192v1";
pub const NID_X9_62_prime192v1 = @as(c_int, 409);
pub const OBJ_X9_62_prime192v1 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 1);
};
pub const SN_X9_62_prime192v2 = "prime192v2";
pub const NID_X9_62_prime192v2 = @as(c_int, 410);
pub const OBJ_X9_62_prime192v2 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 2);
};
pub const SN_X9_62_prime192v3 = "prime192v3";
pub const NID_X9_62_prime192v3 = @as(c_int, 411);
pub const OBJ_X9_62_prime192v3 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 3);
};
pub const SN_X9_62_prime239v1 = "prime239v1";
pub const NID_X9_62_prime239v1 = @as(c_int, 412);
pub const OBJ_X9_62_prime239v1 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 4);
};
pub const SN_X9_62_prime239v2 = "prime239v2";
pub const NID_X9_62_prime239v2 = @as(c_int, 413);
pub const OBJ_X9_62_prime239v2 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 5);
};
pub const SN_X9_62_prime239v3 = "prime239v3";
pub const NID_X9_62_prime239v3 = @as(c_int, 414);
pub const OBJ_X9_62_prime239v3 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 6);
};
pub const SN_X9_62_prime256v1 = "prime256v1";
pub const NID_X9_62_prime256v1 = @as(c_int, 415);
pub const OBJ_X9_62_prime256v1 = blk: {
    _ = &OBJ_X9_62_primeCurve;
    break :blk @as(c_long, 7);
};
pub const OBJ_X9_62_id_ecSigType = blk: {
    _ = &OBJ_ansi_X9_62;
    break :blk @as(c_long, 4);
};
pub const SN_ecdsa_with_SHA1 = "ecdsa-with-SHA1";
pub const NID_ecdsa_with_SHA1 = @as(c_int, 416);
pub const OBJ_ecdsa_with_SHA1 = blk: {
    _ = &OBJ_X9_62_id_ecSigType;
    break :blk @as(c_long, 1);
};
pub const SN_ecdsa_with_Recommended = "ecdsa-with-Recommended";
pub const NID_ecdsa_with_Recommended = @as(c_int, 791);
pub const OBJ_ecdsa_with_Recommended = blk: {
    _ = &OBJ_X9_62_id_ecSigType;
    break :blk @as(c_long, 2);
};
pub const SN_ecdsa_with_Specified = "ecdsa-with-Specified";
pub const NID_ecdsa_with_Specified = @as(c_int, 792);
pub const OBJ_ecdsa_with_Specified = blk: {
    _ = &OBJ_X9_62_id_ecSigType;
    break :blk @as(c_long, 3);
};
pub const SN_ecdsa_with_SHA224 = "ecdsa-with-SHA224";
pub const NID_ecdsa_with_SHA224 = @as(c_int, 793);
pub const OBJ_ecdsa_with_SHA224 = blk: {
    _ = &OBJ_ecdsa_with_Specified;
    break :blk @as(c_long, 1);
};
pub const SN_ecdsa_with_SHA256 = "ecdsa-with-SHA256";
pub const NID_ecdsa_with_SHA256 = @as(c_int, 794);
pub const OBJ_ecdsa_with_SHA256 = blk: {
    _ = &OBJ_ecdsa_with_Specified;
    break :blk @as(c_long, 2);
};
pub const SN_ecdsa_with_SHA384 = "ecdsa-with-SHA384";
pub const NID_ecdsa_with_SHA384 = @as(c_int, 795);
pub const OBJ_ecdsa_with_SHA384 = blk: {
    _ = &OBJ_ecdsa_with_Specified;
    break :blk @as(c_long, 3);
};
pub const SN_ecdsa_with_SHA512 = "ecdsa-with-SHA512";
pub const NID_ecdsa_with_SHA512 = @as(c_int, 796);
pub const OBJ_ecdsa_with_SHA512 = blk: {
    _ = &OBJ_ecdsa_with_Specified;
    break :blk @as(c_long, 4);
};
pub const OBJ_secg_ellipticCurve = blk: {
    _ = &OBJ_certicom_arc;
    break :blk @as(c_long, 0);
};
pub const SN_secp112r1 = "secp112r1";
pub const NID_secp112r1 = @as(c_int, 704);
pub const OBJ_secp112r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 6);
};
pub const SN_secp112r2 = "secp112r2";
pub const NID_secp112r2 = @as(c_int, 705);
pub const OBJ_secp112r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 7);
};
pub const SN_secp128r1 = "secp128r1";
pub const NID_secp128r1 = @as(c_int, 706);
pub const OBJ_secp128r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 28);
};
pub const SN_secp128r2 = "secp128r2";
pub const NID_secp128r2 = @as(c_int, 707);
pub const OBJ_secp128r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 29);
};
pub const SN_secp160k1 = "secp160k1";
pub const NID_secp160k1 = @as(c_int, 708);
pub const OBJ_secp160k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 9);
};
pub const SN_secp160r1 = "secp160r1";
pub const NID_secp160r1 = @as(c_int, 709);
pub const OBJ_secp160r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 8);
};
pub const SN_secp160r2 = "secp160r2";
pub const NID_secp160r2 = @as(c_int, 710);
pub const OBJ_secp160r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 30);
};
pub const SN_secp192k1 = "secp192k1";
pub const NID_secp192k1 = @as(c_int, 711);
pub const OBJ_secp192k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 31);
};
pub const SN_secp224k1 = "secp224k1";
pub const NID_secp224k1 = @as(c_int, 712);
pub const OBJ_secp224k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 32);
};
pub const SN_secp224r1 = "secp224r1";
pub const NID_secp224r1 = @as(c_int, 713);
pub const OBJ_secp224r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 33);
};
pub const SN_secp256k1 = "secp256k1";
pub const NID_secp256k1 = @as(c_int, 714);
pub const OBJ_secp256k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 10);
};
pub const SN_secp384r1 = "secp384r1";
pub const NID_secp384r1 = @as(c_int, 715);
pub const OBJ_secp384r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 34);
};
pub const SN_secp521r1 = "secp521r1";
pub const NID_secp521r1 = @as(c_int, 716);
pub const OBJ_secp521r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 35);
};
pub const SN_sect113r1 = "sect113r1";
pub const NID_sect113r1 = @as(c_int, 717);
pub const OBJ_sect113r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 4);
};
pub const SN_sect113r2 = "sect113r2";
pub const NID_sect113r2 = @as(c_int, 718);
pub const OBJ_sect113r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 5);
};
pub const SN_sect131r1 = "sect131r1";
pub const NID_sect131r1 = @as(c_int, 719);
pub const OBJ_sect131r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 22);
};
pub const SN_sect131r2 = "sect131r2";
pub const NID_sect131r2 = @as(c_int, 720);
pub const OBJ_sect131r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 23);
};
pub const SN_sect163k1 = "sect163k1";
pub const NID_sect163k1 = @as(c_int, 721);
pub const OBJ_sect163k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 1);
};
pub const SN_sect163r1 = "sect163r1";
pub const NID_sect163r1 = @as(c_int, 722);
pub const OBJ_sect163r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 2);
};
pub const SN_sect163r2 = "sect163r2";
pub const NID_sect163r2 = @as(c_int, 723);
pub const OBJ_sect163r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 15);
};
pub const SN_sect193r1 = "sect193r1";
pub const NID_sect193r1 = @as(c_int, 724);
pub const OBJ_sect193r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 24);
};
pub const SN_sect193r2 = "sect193r2";
pub const NID_sect193r2 = @as(c_int, 725);
pub const OBJ_sect193r2 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 25);
};
pub const SN_sect233k1 = "sect233k1";
pub const NID_sect233k1 = @as(c_int, 726);
pub const OBJ_sect233k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 26);
};
pub const SN_sect233r1 = "sect233r1";
pub const NID_sect233r1 = @as(c_int, 727);
pub const OBJ_sect233r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 27);
};
pub const SN_sect239k1 = "sect239k1";
pub const NID_sect239k1 = @as(c_int, 728);
pub const OBJ_sect239k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 3);
};
pub const SN_sect283k1 = "sect283k1";
pub const NID_sect283k1 = @as(c_int, 729);
pub const OBJ_sect283k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 16);
};
pub const SN_sect283r1 = "sect283r1";
pub const NID_sect283r1 = @as(c_int, 730);
pub const OBJ_sect283r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 17);
};
pub const SN_sect409k1 = "sect409k1";
pub const NID_sect409k1 = @as(c_int, 731);
pub const OBJ_sect409k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 36);
};
pub const SN_sect409r1 = "sect409r1";
pub const NID_sect409r1 = @as(c_int, 732);
pub const OBJ_sect409r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 37);
};
pub const SN_sect571k1 = "sect571k1";
pub const NID_sect571k1 = @as(c_int, 733);
pub const OBJ_sect571k1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 38);
};
pub const SN_sect571r1 = "sect571r1";
pub const NID_sect571r1 = @as(c_int, 734);
pub const OBJ_sect571r1 = blk: {
    _ = &OBJ_secg_ellipticCurve;
    break :blk @as(c_long, 39);
};
pub const OBJ_wap_wsg_idm_ecid = blk: {
    _ = &OBJ_wap_wsg;
    break :blk @as(c_long, 4);
};
pub const SN_wap_wsg_idm_ecid_wtls1 = "wap-wsg-idm-ecid-wtls1";
pub const NID_wap_wsg_idm_ecid_wtls1 = @as(c_int, 735);
pub const OBJ_wap_wsg_idm_ecid_wtls1 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 1);
};
pub const SN_wap_wsg_idm_ecid_wtls3 = "wap-wsg-idm-ecid-wtls3";
pub const NID_wap_wsg_idm_ecid_wtls3 = @as(c_int, 736);
pub const OBJ_wap_wsg_idm_ecid_wtls3 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 3);
};
pub const SN_wap_wsg_idm_ecid_wtls4 = "wap-wsg-idm-ecid-wtls4";
pub const NID_wap_wsg_idm_ecid_wtls4 = @as(c_int, 737);
pub const OBJ_wap_wsg_idm_ecid_wtls4 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 4);
};
pub const SN_wap_wsg_idm_ecid_wtls5 = "wap-wsg-idm-ecid-wtls5";
pub const NID_wap_wsg_idm_ecid_wtls5 = @as(c_int, 738);
pub const OBJ_wap_wsg_idm_ecid_wtls5 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 5);
};
pub const SN_wap_wsg_idm_ecid_wtls6 = "wap-wsg-idm-ecid-wtls6";
pub const NID_wap_wsg_idm_ecid_wtls6 = @as(c_int, 739);
pub const OBJ_wap_wsg_idm_ecid_wtls6 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 6);
};
pub const SN_wap_wsg_idm_ecid_wtls7 = "wap-wsg-idm-ecid-wtls7";
pub const NID_wap_wsg_idm_ecid_wtls7 = @as(c_int, 740);
pub const OBJ_wap_wsg_idm_ecid_wtls7 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 7);
};
pub const SN_wap_wsg_idm_ecid_wtls8 = "wap-wsg-idm-ecid-wtls8";
pub const NID_wap_wsg_idm_ecid_wtls8 = @as(c_int, 741);
pub const OBJ_wap_wsg_idm_ecid_wtls8 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 8);
};
pub const SN_wap_wsg_idm_ecid_wtls9 = "wap-wsg-idm-ecid-wtls9";
pub const NID_wap_wsg_idm_ecid_wtls9 = @as(c_int, 742);
pub const OBJ_wap_wsg_idm_ecid_wtls9 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 9);
};
pub const SN_wap_wsg_idm_ecid_wtls10 = "wap-wsg-idm-ecid-wtls10";
pub const NID_wap_wsg_idm_ecid_wtls10 = @as(c_int, 743);
pub const OBJ_wap_wsg_idm_ecid_wtls10 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 10);
};
pub const SN_wap_wsg_idm_ecid_wtls11 = "wap-wsg-idm-ecid-wtls11";
pub const NID_wap_wsg_idm_ecid_wtls11 = @as(c_int, 744);
pub const OBJ_wap_wsg_idm_ecid_wtls11 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 11);
};
pub const SN_wap_wsg_idm_ecid_wtls12 = "wap-wsg-idm-ecid-wtls12";
pub const NID_wap_wsg_idm_ecid_wtls12 = @as(c_int, 745);
pub const OBJ_wap_wsg_idm_ecid_wtls12 = blk: {
    _ = &OBJ_wap_wsg_idm_ecid;
    break :blk @as(c_long, 12);
};
pub const SN_cast5_cbc = "CAST5-CBC";
pub const LN_cast5_cbc = "cast5-cbc";
pub const NID_cast5_cbc = @as(c_int, 108);
pub const OBJ_cast5_cbc = blk: {
    _ = &OBJ_ISO_US;
    _ = @as(c_long, 113533);
    _ = @as(c_long, 7);
    _ = @as(c_long, 66);
    break :blk @as(c_long, 10);
};
pub const SN_cast5_ecb = "CAST5-ECB";
pub const LN_cast5_ecb = "cast5-ecb";
pub const NID_cast5_ecb = @as(c_int, 109);
pub const SN_cast5_cfb64 = "CAST5-CFB";
pub const LN_cast5_cfb64 = "cast5-cfb";
pub const NID_cast5_cfb64 = @as(c_int, 110);
pub const SN_cast5_ofb64 = "CAST5-OFB";
pub const LN_cast5_ofb64 = "cast5-ofb";
pub const NID_cast5_ofb64 = @as(c_int, 111);
pub const LN_pbeWithMD5AndCast5_CBC = "pbeWithMD5AndCast5CBC";
pub const NID_pbeWithMD5AndCast5_CBC = @as(c_int, 112);
pub const OBJ_pbeWithMD5AndCast5_CBC = blk: {
    _ = &OBJ_ISO_US;
    _ = @as(c_long, 113533);
    _ = @as(c_long, 7);
    _ = @as(c_long, 66);
    break :blk @as(c_long, 12);
};
pub const SN_id_PasswordBasedMAC = "id-PasswordBasedMAC";
pub const LN_id_PasswordBasedMAC = "password based MAC";
pub const NID_id_PasswordBasedMAC = @as(c_int, 782);
pub const OBJ_id_PasswordBasedMAC = blk: {
    _ = &OBJ_ISO_US;
    _ = @as(c_long, 113533);
    _ = @as(c_long, 7);
    _ = @as(c_long, 66);
    break :blk @as(c_long, 13);
};
pub const SN_id_DHBasedMac = "id-DHBasedMac";
pub const LN_id_DHBasedMac = "Diffie-Hellman based MAC";
pub const NID_id_DHBasedMac = @as(c_int, 783);
pub const OBJ_id_DHBasedMac = blk: {
    _ = &OBJ_ISO_US;
    _ = @as(c_long, 113533);
    _ = @as(c_long, 7);
    _ = @as(c_long, 66);
    break :blk @as(c_long, 30);
};
pub const SN_rsadsi = "rsadsi";
pub const LN_rsadsi = "RSA Data Security, Inc.";
pub const NID_rsadsi = @as(c_int, 1);
pub const OBJ_rsadsi = blk: {
    _ = &OBJ_ISO_US;
    break :blk @as(c_long, 113549);
};
pub const SN_pkcs = "pkcs";
pub const LN_pkcs = "RSA Data Security, Inc. PKCS";
pub const NID_pkcs = @as(c_int, 2);
pub const OBJ_pkcs = blk: {
    _ = &OBJ_rsadsi;
    break :blk @as(c_long, 1);
};
pub const SN_pkcs1 = "pkcs1";
pub const NID_pkcs1 = @as(c_int, 186);
pub const OBJ_pkcs1 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 1);
};
pub const LN_rsaEncryption = "rsaEncryption";
pub const NID_rsaEncryption = @as(c_int, 6);
pub const OBJ_rsaEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 1);
};
pub const SN_md2WithRSAEncryption = "RSA-MD2";
pub const LN_md2WithRSAEncryption = "md2WithRSAEncryption";
pub const NID_md2WithRSAEncryption = @as(c_int, 7);
pub const OBJ_md2WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 2);
};
pub const SN_md4WithRSAEncryption = "RSA-MD4";
pub const LN_md4WithRSAEncryption = "md4WithRSAEncryption";
pub const NID_md4WithRSAEncryption = @as(c_int, 396);
pub const OBJ_md4WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 3);
};
pub const SN_md5WithRSAEncryption = "RSA-MD5";
pub const LN_md5WithRSAEncryption = "md5WithRSAEncryption";
pub const NID_md5WithRSAEncryption = @as(c_int, 8);
pub const OBJ_md5WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 4);
};
pub const SN_sha1WithRSAEncryption = "RSA-SHA1";
pub const LN_sha1WithRSAEncryption = "sha1WithRSAEncryption";
pub const NID_sha1WithRSAEncryption = @as(c_int, 65);
pub const OBJ_sha1WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 5);
};
pub const SN_rsaesOaep = "RSAES-OAEP";
pub const LN_rsaesOaep = "rsaesOaep";
pub const NID_rsaesOaep = @as(c_int, 919);
pub const OBJ_rsaesOaep = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 7);
};
pub const SN_mgf1 = "MGF1";
pub const LN_mgf1 = "mgf1";
pub const NID_mgf1 = @as(c_int, 911);
pub const OBJ_mgf1 = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 8);
};
pub const SN_pSpecified = "PSPECIFIED";
pub const LN_pSpecified = "pSpecified";
pub const NID_pSpecified = @as(c_int, 935);
pub const OBJ_pSpecified = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 9);
};
pub const SN_rsassaPss = "RSASSA-PSS";
pub const LN_rsassaPss = "rsassaPss";
pub const NID_rsassaPss = @as(c_int, 912);
pub const OBJ_rsassaPss = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 10);
};
pub const SN_sha256WithRSAEncryption = "RSA-SHA256";
pub const LN_sha256WithRSAEncryption = "sha256WithRSAEncryption";
pub const NID_sha256WithRSAEncryption = @as(c_int, 668);
pub const OBJ_sha256WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 11);
};
pub const SN_sha384WithRSAEncryption = "RSA-SHA384";
pub const LN_sha384WithRSAEncryption = "sha384WithRSAEncryption";
pub const NID_sha384WithRSAEncryption = @as(c_int, 669);
pub const OBJ_sha384WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 12);
};
pub const SN_sha512WithRSAEncryption = "RSA-SHA512";
pub const LN_sha512WithRSAEncryption = "sha512WithRSAEncryption";
pub const NID_sha512WithRSAEncryption = @as(c_int, 670);
pub const OBJ_sha512WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 13);
};
pub const SN_sha224WithRSAEncryption = "RSA-SHA224";
pub const LN_sha224WithRSAEncryption = "sha224WithRSAEncryption";
pub const NID_sha224WithRSAEncryption = @as(c_int, 671);
pub const OBJ_sha224WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 14);
};
pub const SN_sha512_224WithRSAEncryption = "RSA-SHA512/224";
pub const LN_sha512_224WithRSAEncryption = "sha512-224WithRSAEncryption";
pub const NID_sha512_224WithRSAEncryption = @as(c_int, 1145);
pub const OBJ_sha512_224WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 15);
};
pub const SN_sha512_256WithRSAEncryption = "RSA-SHA512/256";
pub const LN_sha512_256WithRSAEncryption = "sha512-256WithRSAEncryption";
pub const NID_sha512_256WithRSAEncryption = @as(c_int, 1146);
pub const OBJ_sha512_256WithRSAEncryption = blk: {
    _ = &OBJ_pkcs1;
    break :blk @as(c_long, 16);
};
pub const SN_pkcs3 = "pkcs3";
pub const NID_pkcs3 = @as(c_int, 27);
pub const OBJ_pkcs3 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 3);
};
pub const LN_dhKeyAgreement = "dhKeyAgreement";
pub const NID_dhKeyAgreement = @as(c_int, 28);
pub const OBJ_dhKeyAgreement = blk: {
    _ = &OBJ_pkcs3;
    break :blk @as(c_long, 1);
};
pub const SN_pkcs5 = "pkcs5";
pub const NID_pkcs5 = @as(c_int, 187);
pub const OBJ_pkcs5 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 5);
};
pub const SN_pbeWithMD2AndDES_CBC = "PBE-MD2-DES";
pub const LN_pbeWithMD2AndDES_CBC = "pbeWithMD2AndDES-CBC";
pub const NID_pbeWithMD2AndDES_CBC = @as(c_int, 9);
pub const OBJ_pbeWithMD2AndDES_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 1);
};
pub const SN_pbeWithMD5AndDES_CBC = "PBE-MD5-DES";
pub const LN_pbeWithMD5AndDES_CBC = "pbeWithMD5AndDES-CBC";
pub const NID_pbeWithMD5AndDES_CBC = @as(c_int, 10);
pub const OBJ_pbeWithMD5AndDES_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 3);
};
pub const SN_pbeWithMD2AndRC2_CBC = "PBE-MD2-RC2-64";
pub const LN_pbeWithMD2AndRC2_CBC = "pbeWithMD2AndRC2-CBC";
pub const NID_pbeWithMD2AndRC2_CBC = @as(c_int, 168);
pub const OBJ_pbeWithMD2AndRC2_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 4);
};
pub const SN_pbeWithMD5AndRC2_CBC = "PBE-MD5-RC2-64";
pub const LN_pbeWithMD5AndRC2_CBC = "pbeWithMD5AndRC2-CBC";
pub const NID_pbeWithMD5AndRC2_CBC = @as(c_int, 169);
pub const OBJ_pbeWithMD5AndRC2_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 6);
};
pub const SN_pbeWithSHA1AndDES_CBC = "PBE-SHA1-DES";
pub const LN_pbeWithSHA1AndDES_CBC = "pbeWithSHA1AndDES-CBC";
pub const NID_pbeWithSHA1AndDES_CBC = @as(c_int, 170);
pub const OBJ_pbeWithSHA1AndDES_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 10);
};
pub const SN_pbeWithSHA1AndRC2_CBC = "PBE-SHA1-RC2-64";
pub const LN_pbeWithSHA1AndRC2_CBC = "pbeWithSHA1AndRC2-CBC";
pub const NID_pbeWithSHA1AndRC2_CBC = @as(c_int, 68);
pub const OBJ_pbeWithSHA1AndRC2_CBC = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 11);
};
pub const LN_id_pbkdf2 = "PBKDF2";
pub const NID_id_pbkdf2 = @as(c_int, 69);
pub const OBJ_id_pbkdf2 = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 12);
};
pub const LN_pbes2 = "PBES2";
pub const NID_pbes2 = @as(c_int, 161);
pub const OBJ_pbes2 = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 13);
};
pub const LN_pbmac1 = "PBMAC1";
pub const NID_pbmac1 = @as(c_int, 162);
pub const OBJ_pbmac1 = blk: {
    _ = &OBJ_pkcs5;
    break :blk @as(c_long, 14);
};
pub const SN_pkcs7 = "pkcs7";
pub const NID_pkcs7 = @as(c_int, 20);
pub const OBJ_pkcs7 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 7);
};
pub const LN_pkcs7_data = "pkcs7-data";
pub const NID_pkcs7_data = @as(c_int, 21);
pub const OBJ_pkcs7_data = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 1);
};
pub const LN_pkcs7_signed = "pkcs7-signedData";
pub const NID_pkcs7_signed = @as(c_int, 22);
pub const OBJ_pkcs7_signed = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 2);
};
pub const LN_pkcs7_enveloped = "pkcs7-envelopedData";
pub const NID_pkcs7_enveloped = @as(c_int, 23);
pub const OBJ_pkcs7_enveloped = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 3);
};
pub const LN_pkcs7_signedAndEnveloped = "pkcs7-signedAndEnvelopedData";
pub const NID_pkcs7_signedAndEnveloped = @as(c_int, 24);
pub const OBJ_pkcs7_signedAndEnveloped = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 4);
};
pub const LN_pkcs7_digest = "pkcs7-digestData";
pub const NID_pkcs7_digest = @as(c_int, 25);
pub const OBJ_pkcs7_digest = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 5);
};
pub const LN_pkcs7_encrypted = "pkcs7-encryptedData";
pub const NID_pkcs7_encrypted = @as(c_int, 26);
pub const OBJ_pkcs7_encrypted = blk: {
    _ = &OBJ_pkcs7;
    break :blk @as(c_long, 6);
};
pub const SN_pkcs9 = "pkcs9";
pub const NID_pkcs9 = @as(c_int, 47);
pub const OBJ_pkcs9 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 9);
};
pub const LN_pkcs9_emailAddress = "emailAddress";
pub const NID_pkcs9_emailAddress = @as(c_int, 48);
pub const OBJ_pkcs9_emailAddress = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 1);
};
pub const LN_pkcs9_unstructuredName = "unstructuredName";
pub const NID_pkcs9_unstructuredName = @as(c_int, 49);
pub const OBJ_pkcs9_unstructuredName = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 2);
};
pub const LN_pkcs9_contentType = "contentType";
pub const NID_pkcs9_contentType = @as(c_int, 50);
pub const OBJ_pkcs9_contentType = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 3);
};
pub const LN_pkcs9_messageDigest = "messageDigest";
pub const NID_pkcs9_messageDigest = @as(c_int, 51);
pub const OBJ_pkcs9_messageDigest = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 4);
};
pub const LN_pkcs9_signingTime = "signingTime";
pub const NID_pkcs9_signingTime = @as(c_int, 52);
pub const OBJ_pkcs9_signingTime = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 5);
};
pub const LN_pkcs9_countersignature = "countersignature";
pub const NID_pkcs9_countersignature = @as(c_int, 53);
pub const OBJ_pkcs9_countersignature = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 6);
};
pub const LN_pkcs9_challengePassword = "challengePassword";
pub const NID_pkcs9_challengePassword = @as(c_int, 54);
pub const OBJ_pkcs9_challengePassword = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 7);
};
pub const LN_pkcs9_unstructuredAddress = "unstructuredAddress";
pub const NID_pkcs9_unstructuredAddress = @as(c_int, 55);
pub const OBJ_pkcs9_unstructuredAddress = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 8);
};
pub const LN_pkcs9_extCertAttributes = "extendedCertificateAttributes";
pub const NID_pkcs9_extCertAttributes = @as(c_int, 56);
pub const OBJ_pkcs9_extCertAttributes = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 9);
};
pub const SN_ext_req = "extReq";
pub const LN_ext_req = "Extension Request";
pub const NID_ext_req = @as(c_int, 172);
pub const OBJ_ext_req = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 14);
};
pub const SN_SMIMECapabilities = "SMIME-CAPS";
pub const LN_SMIMECapabilities = "S/MIME Capabilities";
pub const NID_SMIMECapabilities = @as(c_int, 167);
pub const OBJ_SMIMECapabilities = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 15);
};
pub const SN_SMIME = "SMIME";
pub const LN_SMIME = "S/MIME";
pub const NID_SMIME = @as(c_int, 188);
pub const OBJ_SMIME = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 16);
};
pub const SN_id_smime_mod = "id-smime-mod";
pub const NID_id_smime_mod = @as(c_int, 189);
pub const OBJ_id_smime_mod = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 0);
};
pub const SN_id_smime_ct = "id-smime-ct";
pub const NID_id_smime_ct = @as(c_int, 190);
pub const OBJ_id_smime_ct = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_aa = "id-smime-aa";
pub const NID_id_smime_aa = @as(c_int, 191);
pub const OBJ_id_smime_aa = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_alg = "id-smime-alg";
pub const NID_id_smime_alg = @as(c_int, 192);
pub const OBJ_id_smime_alg = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_cd = "id-smime-cd";
pub const NID_id_smime_cd = @as(c_int, 193);
pub const OBJ_id_smime_cd = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_spq = "id-smime-spq";
pub const NID_id_smime_spq = @as(c_int, 194);
pub const OBJ_id_smime_spq = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_cti = "id-smime-cti";
pub const NID_id_smime_cti = @as(c_int, 195);
pub const OBJ_id_smime_cti = blk: {
    _ = &OBJ_SMIME;
    break :blk @as(c_long, 6);
};
pub const SN_id_smime_mod_cms = "id-smime-mod-cms";
pub const NID_id_smime_mod_cms = @as(c_int, 196);
pub const OBJ_id_smime_mod_cms = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_mod_ess = "id-smime-mod-ess";
pub const NID_id_smime_mod_ess = @as(c_int, 197);
pub const OBJ_id_smime_mod_ess = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_mod_oid = "id-smime-mod-oid";
pub const NID_id_smime_mod_oid = @as(c_int, 198);
pub const OBJ_id_smime_mod_oid = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_mod_msg_v3 = "id-smime-mod-msg-v3";
pub const NID_id_smime_mod_msg_v3 = @as(c_int, 199);
pub const OBJ_id_smime_mod_msg_v3 = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_mod_ets_eSignature_88 = "id-smime-mod-ets-eSignature-88";
pub const NID_id_smime_mod_ets_eSignature_88 = @as(c_int, 200);
pub const OBJ_id_smime_mod_ets_eSignature_88 = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_mod_ets_eSignature_97 = "id-smime-mod-ets-eSignature-97";
pub const NID_id_smime_mod_ets_eSignature_97 = @as(c_int, 201);
pub const OBJ_id_smime_mod_ets_eSignature_97 = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 6);
};
pub const SN_id_smime_mod_ets_eSigPolicy_88 = "id-smime-mod-ets-eSigPolicy-88";
pub const NID_id_smime_mod_ets_eSigPolicy_88 = @as(c_int, 202);
pub const OBJ_id_smime_mod_ets_eSigPolicy_88 = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 7);
};
pub const SN_id_smime_mod_ets_eSigPolicy_97 = "id-smime-mod-ets-eSigPolicy-97";
pub const NID_id_smime_mod_ets_eSigPolicy_97 = @as(c_int, 203);
pub const OBJ_id_smime_mod_ets_eSigPolicy_97 = blk: {
    _ = &OBJ_id_smime_mod;
    break :blk @as(c_long, 8);
};
pub const SN_id_smime_ct_receipt = "id-smime-ct-receipt";
pub const NID_id_smime_ct_receipt = @as(c_int, 204);
pub const OBJ_id_smime_ct_receipt = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_ct_authData = "id-smime-ct-authData";
pub const NID_id_smime_ct_authData = @as(c_int, 205);
pub const OBJ_id_smime_ct_authData = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_ct_publishCert = "id-smime-ct-publishCert";
pub const NID_id_smime_ct_publishCert = @as(c_int, 206);
pub const OBJ_id_smime_ct_publishCert = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_ct_TSTInfo = "id-smime-ct-TSTInfo";
pub const NID_id_smime_ct_TSTInfo = @as(c_int, 207);
pub const OBJ_id_smime_ct_TSTInfo = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_ct_TDTInfo = "id-smime-ct-TDTInfo";
pub const NID_id_smime_ct_TDTInfo = @as(c_int, 208);
pub const OBJ_id_smime_ct_TDTInfo = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_ct_contentInfo = "id-smime-ct-contentInfo";
pub const NID_id_smime_ct_contentInfo = @as(c_int, 209);
pub const OBJ_id_smime_ct_contentInfo = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 6);
};
pub const SN_id_smime_ct_DVCSRequestData = "id-smime-ct-DVCSRequestData";
pub const NID_id_smime_ct_DVCSRequestData = @as(c_int, 210);
pub const OBJ_id_smime_ct_DVCSRequestData = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 7);
};
pub const SN_id_smime_ct_DVCSResponseData = "id-smime-ct-DVCSResponseData";
pub const NID_id_smime_ct_DVCSResponseData = @as(c_int, 211);
pub const OBJ_id_smime_ct_DVCSResponseData = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 8);
};
pub const SN_id_smime_ct_compressedData = "id-smime-ct-compressedData";
pub const NID_id_smime_ct_compressedData = @as(c_int, 786);
pub const OBJ_id_smime_ct_compressedData = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 9);
};
pub const SN_id_smime_ct_contentCollection = "id-smime-ct-contentCollection";
pub const NID_id_smime_ct_contentCollection = @as(c_int, 1058);
pub const OBJ_id_smime_ct_contentCollection = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 19);
};
pub const SN_id_smime_ct_authEnvelopedData = "id-smime-ct-authEnvelopedData";
pub const NID_id_smime_ct_authEnvelopedData = @as(c_int, 1059);
pub const OBJ_id_smime_ct_authEnvelopedData = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 23);
};
pub const SN_id_ct_routeOriginAuthz = "id-ct-routeOriginAuthz";
pub const NID_id_ct_routeOriginAuthz = @as(c_int, 1234);
pub const OBJ_id_ct_routeOriginAuthz = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 24);
};
pub const SN_id_ct_rpkiManifest = "id-ct-rpkiManifest";
pub const NID_id_ct_rpkiManifest = @as(c_int, 1235);
pub const OBJ_id_ct_rpkiManifest = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 26);
};
pub const SN_id_ct_asciiTextWithCRLF = "id-ct-asciiTextWithCRLF";
pub const NID_id_ct_asciiTextWithCRLF = @as(c_int, 787);
pub const OBJ_id_ct_asciiTextWithCRLF = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 27);
};
pub const SN_id_ct_xml = "id-ct-xml";
pub const NID_id_ct_xml = @as(c_int, 1060);
pub const OBJ_id_ct_xml = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 28);
};
pub const SN_id_ct_rpkiGhostbusters = "id-ct-rpkiGhostbusters";
pub const NID_id_ct_rpkiGhostbusters = @as(c_int, 1236);
pub const OBJ_id_ct_rpkiGhostbusters = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 35);
};
pub const SN_id_ct_resourceTaggedAttest = "id-ct-resourceTaggedAttest";
pub const NID_id_ct_resourceTaggedAttest = @as(c_int, 1237);
pub const OBJ_id_ct_resourceTaggedAttest = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 36);
};
pub const SN_id_ct_geofeedCSVwithCRLF = "id-ct-geofeedCSVwithCRLF";
pub const NID_id_ct_geofeedCSVwithCRLF = @as(c_int, 1246);
pub const OBJ_id_ct_geofeedCSVwithCRLF = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 47);
};
pub const SN_id_ct_signedChecklist = "id-ct-signedChecklist";
pub const NID_id_ct_signedChecklist = @as(c_int, 1247);
pub const OBJ_id_ct_signedChecklist = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 48);
};
pub const SN_id_ct_ASPA = "id-ct-ASPA";
pub const NID_id_ct_ASPA = @as(c_int, 1250);
pub const OBJ_id_ct_ASPA = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 49);
};
pub const SN_id_ct_signedTAL = "id-ct-signedTAL";
pub const NID_id_ct_signedTAL = @as(c_int, 1284);
pub const OBJ_id_ct_signedTAL = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 50);
};
pub const SN_id_ct_rpkiSignedPrefixList = "id-ct-rpkiSignedPrefixList";
pub const NID_id_ct_rpkiSignedPrefixList = @as(c_int, 1320);
pub const OBJ_id_ct_rpkiSignedPrefixList = blk: {
    _ = &OBJ_id_smime_ct;
    break :blk @as(c_long, 51);
};
pub const SN_id_smime_aa_receiptRequest = "id-smime-aa-receiptRequest";
pub const NID_id_smime_aa_receiptRequest = @as(c_int, 212);
pub const OBJ_id_smime_aa_receiptRequest = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_aa_securityLabel = "id-smime-aa-securityLabel";
pub const NID_id_smime_aa_securityLabel = @as(c_int, 213);
pub const OBJ_id_smime_aa_securityLabel = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_aa_mlExpandHistory = "id-smime-aa-mlExpandHistory";
pub const NID_id_smime_aa_mlExpandHistory = @as(c_int, 214);
pub const OBJ_id_smime_aa_mlExpandHistory = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_aa_contentHint = "id-smime-aa-contentHint";
pub const NID_id_smime_aa_contentHint = @as(c_int, 215);
pub const OBJ_id_smime_aa_contentHint = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_aa_msgSigDigest = "id-smime-aa-msgSigDigest";
pub const NID_id_smime_aa_msgSigDigest = @as(c_int, 216);
pub const OBJ_id_smime_aa_msgSigDigest = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_aa_encapContentType = "id-smime-aa-encapContentType";
pub const NID_id_smime_aa_encapContentType = @as(c_int, 217);
pub const OBJ_id_smime_aa_encapContentType = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 6);
};
pub const SN_id_smime_aa_contentIdentifier = "id-smime-aa-contentIdentifier";
pub const NID_id_smime_aa_contentIdentifier = @as(c_int, 218);
pub const OBJ_id_smime_aa_contentIdentifier = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 7);
};
pub const SN_id_smime_aa_macValue = "id-smime-aa-macValue";
pub const NID_id_smime_aa_macValue = @as(c_int, 219);
pub const OBJ_id_smime_aa_macValue = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 8);
};
pub const SN_id_smime_aa_equivalentLabels = "id-smime-aa-equivalentLabels";
pub const NID_id_smime_aa_equivalentLabels = @as(c_int, 220);
pub const OBJ_id_smime_aa_equivalentLabels = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 9);
};
pub const SN_id_smime_aa_contentReference = "id-smime-aa-contentReference";
pub const NID_id_smime_aa_contentReference = @as(c_int, 221);
pub const OBJ_id_smime_aa_contentReference = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 10);
};
pub const SN_id_smime_aa_encrypKeyPref = "id-smime-aa-encrypKeyPref";
pub const NID_id_smime_aa_encrypKeyPref = @as(c_int, 222);
pub const OBJ_id_smime_aa_encrypKeyPref = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 11);
};
pub const SN_id_smime_aa_signingCertificate = "id-smime-aa-signingCertificate";
pub const NID_id_smime_aa_signingCertificate = @as(c_int, 223);
pub const OBJ_id_smime_aa_signingCertificate = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 12);
};
pub const SN_id_smime_aa_smimeEncryptCerts = "id-smime-aa-smimeEncryptCerts";
pub const NID_id_smime_aa_smimeEncryptCerts = @as(c_int, 224);
pub const OBJ_id_smime_aa_smimeEncryptCerts = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 13);
};
pub const SN_id_smime_aa_timeStampToken = "id-smime-aa-timeStampToken";
pub const NID_id_smime_aa_timeStampToken = @as(c_int, 225);
pub const OBJ_id_smime_aa_timeStampToken = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 14);
};
pub const SN_id_smime_aa_ets_sigPolicyId = "id-smime-aa-ets-sigPolicyId";
pub const NID_id_smime_aa_ets_sigPolicyId = @as(c_int, 226);
pub const OBJ_id_smime_aa_ets_sigPolicyId = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 15);
};
pub const SN_id_smime_aa_ets_commitmentType = "id-smime-aa-ets-commitmentType";
pub const NID_id_smime_aa_ets_commitmentType = @as(c_int, 227);
pub const OBJ_id_smime_aa_ets_commitmentType = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 16);
};
pub const SN_id_smime_aa_ets_signerLocation = "id-smime-aa-ets-signerLocation";
pub const NID_id_smime_aa_ets_signerLocation = @as(c_int, 228);
pub const OBJ_id_smime_aa_ets_signerLocation = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 17);
};
pub const SN_id_smime_aa_ets_signerAttr = "id-smime-aa-ets-signerAttr";
pub const NID_id_smime_aa_ets_signerAttr = @as(c_int, 229);
pub const OBJ_id_smime_aa_ets_signerAttr = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 18);
};
pub const SN_id_smime_aa_ets_otherSigCert = "id-smime-aa-ets-otherSigCert";
pub const NID_id_smime_aa_ets_otherSigCert = @as(c_int, 230);
pub const OBJ_id_smime_aa_ets_otherSigCert = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 19);
};
pub const SN_id_smime_aa_ets_contentTimestamp = "id-smime-aa-ets-contentTimestamp";
pub const NID_id_smime_aa_ets_contentTimestamp = @as(c_int, 231);
pub const OBJ_id_smime_aa_ets_contentTimestamp = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 20);
};
pub const SN_id_smime_aa_ets_CertificateRefs = "id-smime-aa-ets-CertificateRefs";
pub const NID_id_smime_aa_ets_CertificateRefs = @as(c_int, 232);
pub const OBJ_id_smime_aa_ets_CertificateRefs = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 21);
};
pub const SN_id_smime_aa_ets_RevocationRefs = "id-smime-aa-ets-RevocationRefs";
pub const NID_id_smime_aa_ets_RevocationRefs = @as(c_int, 233);
pub const OBJ_id_smime_aa_ets_RevocationRefs = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 22);
};
pub const SN_id_smime_aa_ets_certValues = "id-smime-aa-ets-certValues";
pub const NID_id_smime_aa_ets_certValues = @as(c_int, 234);
pub const OBJ_id_smime_aa_ets_certValues = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 23);
};
pub const SN_id_smime_aa_ets_revocationValues = "id-smime-aa-ets-revocationValues";
pub const NID_id_smime_aa_ets_revocationValues = @as(c_int, 235);
pub const OBJ_id_smime_aa_ets_revocationValues = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 24);
};
pub const SN_id_smime_aa_ets_escTimeStamp = "id-smime-aa-ets-escTimeStamp";
pub const NID_id_smime_aa_ets_escTimeStamp = @as(c_int, 236);
pub const OBJ_id_smime_aa_ets_escTimeStamp = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 25);
};
pub const SN_id_smime_aa_ets_certCRLTimestamp = "id-smime-aa-ets-certCRLTimestamp";
pub const NID_id_smime_aa_ets_certCRLTimestamp = @as(c_int, 237);
pub const OBJ_id_smime_aa_ets_certCRLTimestamp = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 26);
};
pub const SN_id_smime_aa_ets_archiveTimeStamp = "id-smime-aa-ets-archiveTimeStamp";
pub const NID_id_smime_aa_ets_archiveTimeStamp = @as(c_int, 238);
pub const OBJ_id_smime_aa_ets_archiveTimeStamp = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 27);
};
pub const SN_id_smime_aa_signatureType = "id-smime-aa-signatureType";
pub const NID_id_smime_aa_signatureType = @as(c_int, 239);
pub const OBJ_id_smime_aa_signatureType = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 28);
};
pub const SN_id_smime_aa_dvcs_dvc = "id-smime-aa-dvcs-dvc";
pub const NID_id_smime_aa_dvcs_dvc = @as(c_int, 240);
pub const OBJ_id_smime_aa_dvcs_dvc = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 29);
};
pub const SN_id_aa_ets_attrCertificateRefs = "id-aa-ets-attrCertificateRefs";
pub const NID_id_aa_ets_attrCertificateRefs = @as(c_int, 1261);
pub const OBJ_id_aa_ets_attrCertificateRefs = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 44);
};
pub const SN_id_aa_ets_attrRevocationRefs = "id-aa-ets-attrRevocationRefs";
pub const NID_id_aa_ets_attrRevocationRefs = @as(c_int, 1262);
pub const OBJ_id_aa_ets_attrRevocationRefs = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 45);
};
pub const SN_id_smime_aa_signingCertificateV2 = "id-smime-aa-signingCertificateV2";
pub const NID_id_smime_aa_signingCertificateV2 = @as(c_int, 1086);
pub const OBJ_id_smime_aa_signingCertificateV2 = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 47);
};
pub const SN_id_aa_ets_archiveTimestampV2 = "id-aa-ets-archiveTimestampV2";
pub const NID_id_aa_ets_archiveTimestampV2 = @as(c_int, 1280);
pub const OBJ_id_aa_ets_archiveTimestampV2 = blk: {
    _ = &OBJ_id_smime_aa;
    break :blk @as(c_long, 48);
};
pub const SN_id_smime_alg_ESDHwith3DES = "id-smime-alg-ESDHwith3DES";
pub const NID_id_smime_alg_ESDHwith3DES = @as(c_int, 241);
pub const OBJ_id_smime_alg_ESDHwith3DES = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_alg_ESDHwithRC2 = "id-smime-alg-ESDHwithRC2";
pub const NID_id_smime_alg_ESDHwithRC2 = @as(c_int, 242);
pub const OBJ_id_smime_alg_ESDHwithRC2 = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_alg_3DESwrap = "id-smime-alg-3DESwrap";
pub const NID_id_smime_alg_3DESwrap = @as(c_int, 243);
pub const OBJ_id_smime_alg_3DESwrap = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_alg_RC2wrap = "id-smime-alg-RC2wrap";
pub const NID_id_smime_alg_RC2wrap = @as(c_int, 244);
pub const OBJ_id_smime_alg_RC2wrap = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_alg_ESDH = "id-smime-alg-ESDH";
pub const NID_id_smime_alg_ESDH = @as(c_int, 245);
pub const OBJ_id_smime_alg_ESDH = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_alg_CMS3DESwrap = "id-smime-alg-CMS3DESwrap";
pub const NID_id_smime_alg_CMS3DESwrap = @as(c_int, 246);
pub const OBJ_id_smime_alg_CMS3DESwrap = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 6);
};
pub const SN_id_smime_alg_CMSRC2wrap = "id-smime-alg-CMSRC2wrap";
pub const NID_id_smime_alg_CMSRC2wrap = @as(c_int, 247);
pub const OBJ_id_smime_alg_CMSRC2wrap = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 7);
};
pub const SN_id_alg_PWRI_KEK = "id-alg-PWRI-KEK";
pub const NID_id_alg_PWRI_KEK = @as(c_int, 893);
pub const OBJ_id_alg_PWRI_KEK = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 9);
};
pub const SN_id_smime_cd_ldap = "id-smime-cd-ldap";
pub const NID_id_smime_cd_ldap = @as(c_int, 248);
pub const OBJ_id_smime_cd_ldap = blk: {
    _ = &OBJ_id_smime_cd;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_spq_ets_sqt_uri = "id-smime-spq-ets-sqt-uri";
pub const NID_id_smime_spq_ets_sqt_uri = @as(c_int, 249);
pub const OBJ_id_smime_spq_ets_sqt_uri = blk: {
    _ = &OBJ_id_smime_spq;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_spq_ets_sqt_unotice = "id-smime-spq-ets-sqt-unotice";
pub const NID_id_smime_spq_ets_sqt_unotice = @as(c_int, 250);
pub const OBJ_id_smime_spq_ets_sqt_unotice = blk: {
    _ = &OBJ_id_smime_spq;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_cti_ets_proofOfOrigin = "id-smime-cti-ets-proofOfOrigin";
pub const NID_id_smime_cti_ets_proofOfOrigin = @as(c_int, 251);
pub const OBJ_id_smime_cti_ets_proofOfOrigin = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 1);
};
pub const SN_id_smime_cti_ets_proofOfReceipt = "id-smime-cti-ets-proofOfReceipt";
pub const NID_id_smime_cti_ets_proofOfReceipt = @as(c_int, 252);
pub const OBJ_id_smime_cti_ets_proofOfReceipt = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 2);
};
pub const SN_id_smime_cti_ets_proofOfDelivery = "id-smime-cti-ets-proofOfDelivery";
pub const NID_id_smime_cti_ets_proofOfDelivery = @as(c_int, 253);
pub const OBJ_id_smime_cti_ets_proofOfDelivery = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 3);
};
pub const SN_id_smime_cti_ets_proofOfSender = "id-smime-cti-ets-proofOfSender";
pub const NID_id_smime_cti_ets_proofOfSender = @as(c_int, 254);
pub const OBJ_id_smime_cti_ets_proofOfSender = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 4);
};
pub const SN_id_smime_cti_ets_proofOfApproval = "id-smime-cti-ets-proofOfApproval";
pub const NID_id_smime_cti_ets_proofOfApproval = @as(c_int, 255);
pub const OBJ_id_smime_cti_ets_proofOfApproval = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 5);
};
pub const SN_id_smime_cti_ets_proofOfCreation = "id-smime-cti-ets-proofOfCreation";
pub const NID_id_smime_cti_ets_proofOfCreation = @as(c_int, 256);
pub const OBJ_id_smime_cti_ets_proofOfCreation = blk: {
    _ = &OBJ_id_smime_cti;
    break :blk @as(c_long, 6);
};
pub const LN_friendlyName = "friendlyName";
pub const NID_friendlyName = @as(c_int, 156);
pub const OBJ_friendlyName = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 20);
};
pub const LN_localKeyID = "localKeyID";
pub const NID_localKeyID = @as(c_int, 157);
pub const OBJ_localKeyID = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 21);
};
pub const OBJ_ms_corp = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 311);
};
pub const SN_ms_csp_name = "CSPName";
pub const LN_ms_csp_name = "Microsoft CSP Name";
pub const NID_ms_csp_name = @as(c_int, 417);
pub const OBJ_ms_csp_name = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 17);
    break :blk @as(c_long, 1);
};
pub const SN_LocalKeySet = "LocalKeySet";
pub const LN_LocalKeySet = "Microsoft Local Key set";
pub const NID_LocalKeySet = @as(c_int, 856);
pub const OBJ_LocalKeySet = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 17);
    break :blk @as(c_long, 2);
};
pub const OBJ_certTypes = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 22);
};
pub const LN_x509Certificate = "x509Certificate";
pub const NID_x509Certificate = @as(c_int, 158);
pub const OBJ_x509Certificate = blk: {
    _ = &OBJ_certTypes;
    break :blk @as(c_long, 1);
};
pub const LN_sdsiCertificate = "sdsiCertificate";
pub const NID_sdsiCertificate = @as(c_int, 159);
pub const OBJ_sdsiCertificate = blk: {
    _ = &OBJ_certTypes;
    break :blk @as(c_long, 2);
};
pub const OBJ_crlTypes = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 23);
};
pub const LN_x509Crl = "x509Crl";
pub const NID_x509Crl = @as(c_int, 160);
pub const OBJ_x509Crl = blk: {
    _ = &OBJ_crlTypes;
    break :blk @as(c_long, 1);
};
pub const SN_id_aa_CMSAlgorithmProtection = "id-aa-CMSAlgorithmProtection";
pub const NID_id_aa_CMSAlgorithmProtection = @as(c_int, 1263);
pub const OBJ_id_aa_CMSAlgorithmProtection = blk: {
    _ = &OBJ_pkcs9;
    break :blk @as(c_long, 52);
};
pub const OBJ_pkcs12 = blk: {
    _ = &OBJ_pkcs;
    break :blk @as(c_long, 12);
};
pub const OBJ_pkcs12_pbeids = blk: {
    _ = &OBJ_pkcs12;
    break :blk @as(c_long, 1);
};
pub const SN_pbe_WithSHA1And128BitRC4 = "PBE-SHA1-RC4-128";
pub const LN_pbe_WithSHA1And128BitRC4 = "pbeWithSHA1And128BitRC4";
pub const NID_pbe_WithSHA1And128BitRC4 = @as(c_int, 144);
pub const OBJ_pbe_WithSHA1And128BitRC4 = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 1);
};
pub const SN_pbe_WithSHA1And40BitRC4 = "PBE-SHA1-RC4-40";
pub const LN_pbe_WithSHA1And40BitRC4 = "pbeWithSHA1And40BitRC4";
pub const NID_pbe_WithSHA1And40BitRC4 = @as(c_int, 145);
pub const OBJ_pbe_WithSHA1And40BitRC4 = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 2);
};
pub const SN_pbe_WithSHA1And3_Key_TripleDES_CBC = "PBE-SHA1-3DES";
pub const LN_pbe_WithSHA1And3_Key_TripleDES_CBC = "pbeWithSHA1And3-KeyTripleDES-CBC";
pub const NID_pbe_WithSHA1And3_Key_TripleDES_CBC = @as(c_int, 146);
pub const OBJ_pbe_WithSHA1And3_Key_TripleDES_CBC = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 3);
};
pub const SN_pbe_WithSHA1And2_Key_TripleDES_CBC = "PBE-SHA1-2DES";
pub const LN_pbe_WithSHA1And2_Key_TripleDES_CBC = "pbeWithSHA1And2-KeyTripleDES-CBC";
pub const NID_pbe_WithSHA1And2_Key_TripleDES_CBC = @as(c_int, 147);
pub const OBJ_pbe_WithSHA1And2_Key_TripleDES_CBC = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 4);
};
pub const SN_pbe_WithSHA1And128BitRC2_CBC = "PBE-SHA1-RC2-128";
pub const LN_pbe_WithSHA1And128BitRC2_CBC = "pbeWithSHA1And128BitRC2-CBC";
pub const NID_pbe_WithSHA1And128BitRC2_CBC = @as(c_int, 148);
pub const OBJ_pbe_WithSHA1And128BitRC2_CBC = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 5);
};
pub const SN_pbe_WithSHA1And40BitRC2_CBC = "PBE-SHA1-RC2-40";
pub const LN_pbe_WithSHA1And40BitRC2_CBC = "pbeWithSHA1And40BitRC2-CBC";
pub const NID_pbe_WithSHA1And40BitRC2_CBC = @as(c_int, 149);
pub const OBJ_pbe_WithSHA1And40BitRC2_CBC = blk: {
    _ = &OBJ_pkcs12_pbeids;
    break :blk @as(c_long, 6);
};
pub const OBJ_pkcs12_Version1 = blk: {
    _ = &OBJ_pkcs12;
    break :blk @as(c_long, 10);
};
pub const OBJ_pkcs12_BagIds = blk: {
    _ = &OBJ_pkcs12_Version1;
    break :blk @as(c_long, 1);
};
pub const LN_keyBag = "keyBag";
pub const NID_keyBag = @as(c_int, 150);
pub const OBJ_keyBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 1);
};
pub const LN_pkcs8ShroudedKeyBag = "pkcs8ShroudedKeyBag";
pub const NID_pkcs8ShroudedKeyBag = @as(c_int, 151);
pub const OBJ_pkcs8ShroudedKeyBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 2);
};
pub const LN_certBag = "certBag";
pub const NID_certBag = @as(c_int, 152);
pub const OBJ_certBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 3);
};
pub const LN_crlBag = "crlBag";
pub const NID_crlBag = @as(c_int, 153);
pub const OBJ_crlBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 4);
};
pub const LN_secretBag = "secretBag";
pub const NID_secretBag = @as(c_int, 154);
pub const OBJ_secretBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 5);
};
pub const LN_safeContentsBag = "safeContentsBag";
pub const NID_safeContentsBag = @as(c_int, 155);
pub const OBJ_safeContentsBag = blk: {
    _ = &OBJ_pkcs12_BagIds;
    break :blk @as(c_long, 6);
};
pub const SN_md2 = "MD2";
pub const LN_md2 = "md2";
pub const NID_md2 = @as(c_int, 3);
pub const OBJ_md2 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 2);
};
pub const SN_md4 = "MD4";
pub const LN_md4 = "md4";
pub const NID_md4 = @as(c_int, 257);
pub const OBJ_md4 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 4);
};
pub const SN_md5 = "MD5";
pub const LN_md5 = "md5";
pub const NID_md5 = @as(c_int, 4);
pub const OBJ_md5 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 5);
};
pub const SN_md5_sha1 = "MD5-SHA1";
pub const LN_md5_sha1 = "md5-sha1";
pub const NID_md5_sha1 = @as(c_int, 114);
pub const LN_hmacWithMD5 = "hmacWithMD5";
pub const NID_hmacWithMD5 = @as(c_int, 797);
pub const OBJ_hmacWithMD5 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 6);
};
pub const LN_hmacWithSHA1 = "hmacWithSHA1";
pub const NID_hmacWithSHA1 = @as(c_int, 163);
pub const OBJ_hmacWithSHA1 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 7);
};
pub const SN_sm2 = "SM2";
pub const LN_sm2 = "sm2";
pub const NID_sm2 = @as(c_int, 1172);
pub const OBJ_sm2 = blk: {
    _ = &OBJ_sm_scheme;
    break :blk @as(c_long, 301);
};
pub const SN_sm3 = "SM3";
pub const LN_sm3 = "sm3";
pub const NID_sm3 = @as(c_int, 1143);
pub const OBJ_sm3 = blk: {
    _ = &OBJ_sm_scheme;
    break :blk @as(c_long, 401);
};
pub const SN_sm3WithRSAEncryption = "RSA-SM3";
pub const LN_sm3WithRSAEncryption = "sm3WithRSAEncryption";
pub const NID_sm3WithRSAEncryption = @as(c_int, 1144);
pub const OBJ_sm3WithRSAEncryption = blk: {
    _ = &OBJ_sm_scheme;
    break :blk @as(c_long, 504);
};
pub const SN_SM2_with_SM3 = "SM2-SM3";
pub const LN_SM2_with_SM3 = "SM2-with-SM3";
pub const NID_SM2_with_SM3 = @as(c_int, 1204);
pub const OBJ_SM2_with_SM3 = blk: {
    _ = &OBJ_sm_scheme;
    break :blk @as(c_long, 501);
};
pub const LN_hmacWithSM3 = "hmacWithSM3";
pub const NID_hmacWithSM3 = @as(c_int, 1281);
pub const OBJ_hmacWithSM3 = blk: {
    _ = &OBJ_sm3;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 1);
};
pub const LN_hmacWithSHA224 = "hmacWithSHA224";
pub const NID_hmacWithSHA224 = @as(c_int, 798);
pub const OBJ_hmacWithSHA224 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 8);
};
pub const LN_hmacWithSHA256 = "hmacWithSHA256";
pub const NID_hmacWithSHA256 = @as(c_int, 799);
pub const OBJ_hmacWithSHA256 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 9);
};
pub const LN_hmacWithSHA384 = "hmacWithSHA384";
pub const NID_hmacWithSHA384 = @as(c_int, 800);
pub const OBJ_hmacWithSHA384 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 10);
};
pub const LN_hmacWithSHA512 = "hmacWithSHA512";
pub const NID_hmacWithSHA512 = @as(c_int, 801);
pub const OBJ_hmacWithSHA512 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 11);
};
pub const LN_hmacWithSHA512_224 = "hmacWithSHA512-224";
pub const NID_hmacWithSHA512_224 = @as(c_int, 1193);
pub const OBJ_hmacWithSHA512_224 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 12);
};
pub const LN_hmacWithSHA512_256 = "hmacWithSHA512-256";
pub const NID_hmacWithSHA512_256 = @as(c_int, 1194);
pub const OBJ_hmacWithSHA512_256 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 13);
};
pub const SN_rc2_cbc = "RC2-CBC";
pub const LN_rc2_cbc = "rc2-cbc";
pub const NID_rc2_cbc = @as(c_int, 37);
pub const OBJ_rc2_cbc = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 2);
};
pub const SN_rc2_ecb = "RC2-ECB";
pub const LN_rc2_ecb = "rc2-ecb";
pub const NID_rc2_ecb = @as(c_int, 38);
pub const SN_rc2_cfb64 = "RC2-CFB";
pub const LN_rc2_cfb64 = "rc2-cfb";
pub const NID_rc2_cfb64 = @as(c_int, 39);
pub const SN_rc2_ofb64 = "RC2-OFB";
pub const LN_rc2_ofb64 = "rc2-ofb";
pub const NID_rc2_ofb64 = @as(c_int, 40);
pub const SN_rc2_40_cbc = "RC2-40-CBC";
pub const LN_rc2_40_cbc = "rc2-40-cbc";
pub const NID_rc2_40_cbc = @as(c_int, 98);
pub const SN_rc2_64_cbc = "RC2-64-CBC";
pub const LN_rc2_64_cbc = "rc2-64-cbc";
pub const NID_rc2_64_cbc = @as(c_int, 166);
pub const SN_rc4 = "RC4";
pub const LN_rc4 = "rc4";
pub const NID_rc4 = @as(c_int, 5);
pub const OBJ_rc4 = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 4);
};
pub const SN_rc4_40 = "RC4-40";
pub const LN_rc4_40 = "rc4-40";
pub const NID_rc4_40 = @as(c_int, 97);
pub const SN_des_ede3_cbc = "DES-EDE3-CBC";
pub const LN_des_ede3_cbc = "des-ede3-cbc";
pub const NID_des_ede3_cbc = @as(c_int, 44);
pub const OBJ_des_ede3_cbc = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 7);
};
pub const SN_rc5_cbc = "RC5-CBC";
pub const LN_rc5_cbc = "rc5-cbc";
pub const NID_rc5_cbc = @as(c_int, 120);
pub const OBJ_rc5_cbc = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 8);
};
pub const SN_rc5_ecb = "RC5-ECB";
pub const LN_rc5_ecb = "rc5-ecb";
pub const NID_rc5_ecb = @as(c_int, 121);
pub const SN_rc5_cfb64 = "RC5-CFB";
pub const LN_rc5_cfb64 = "rc5-cfb";
pub const NID_rc5_cfb64 = @as(c_int, 122);
pub const SN_rc5_ofb64 = "RC5-OFB";
pub const LN_rc5_ofb64 = "rc5-ofb";
pub const NID_rc5_ofb64 = @as(c_int, 123);
pub const SN_ms_ext_req = "msExtReq";
pub const LN_ms_ext_req = "Microsoft Extension Request";
pub const NID_ms_ext_req = @as(c_int, 171);
pub const OBJ_ms_ext_req = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 14);
};
pub const SN_ms_code_ind = "msCodeInd";
pub const LN_ms_code_ind = "Microsoft Individual Code Signing";
pub const NID_ms_code_ind = @as(c_int, 134);
pub const OBJ_ms_code_ind = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 21);
};
pub const SN_ms_code_com = "msCodeCom";
pub const LN_ms_code_com = "Microsoft Commercial Code Signing";
pub const NID_ms_code_com = @as(c_int, 135);
pub const OBJ_ms_code_com = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 22);
};
pub const SN_ms_ctl_sign = "msCTLSign";
pub const LN_ms_ctl_sign = "Microsoft Trust List Signing";
pub const NID_ms_ctl_sign = @as(c_int, 136);
pub const OBJ_ms_ctl_sign = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 10);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 1);
};
pub const SN_ms_sgc = "msSGC";
pub const LN_ms_sgc = "Microsoft Server Gated Crypto";
pub const NID_ms_sgc = @as(c_int, 137);
pub const OBJ_ms_sgc = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 10);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 3);
};
pub const SN_ms_efs = "msEFS";
pub const LN_ms_efs = "Microsoft Encrypted File System";
pub const NID_ms_efs = @as(c_int, 138);
pub const OBJ_ms_efs = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 10);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 4);
};
pub const SN_ms_smartcard_login = "msSmartcardLogin";
pub const LN_ms_smartcard_login = "Microsoft Smartcard Login";
pub const NID_ms_smartcard_login = @as(c_int, 648);
pub const OBJ_ms_smartcard_login = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 20);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 2);
};
pub const SN_ms_upn = "msUPN";
pub const LN_ms_upn = "Microsoft User Principal Name";
pub const NID_ms_upn = @as(c_int, 649);
pub const OBJ_ms_upn = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 20);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 3);
};
pub const SN_ms_ntds_sec_ext = "ms-ntds-sec-ext";
pub const LN_ms_ntds_sec_ext = "Microsoft NTDS CA Extension";
pub const NID_ms_ntds_sec_ext = @as(c_int, 1292);
pub const OBJ_ms_ntds_sec_ext = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 25);
    break :blk @as(c_long, 2);
};
pub const SN_ms_ntds_obj_sid = "ms-ntds-obj-sid";
pub const LN_ms_ntds_obj_sid = "Microsoft NTDS AD objectSid";
pub const NID_ms_ntds_obj_sid = @as(c_int, 1291);
pub const OBJ_ms_ntds_obj_sid = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 25);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_ms_cert_templ = "ms-cert-templ";
pub const LN_ms_cert_templ = "Microsoft certificate template";
pub const NID_ms_cert_templ = @as(c_int, 1293);
pub const OBJ_ms_cert_templ = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 21);
    break :blk @as(c_long, 7);
};
pub const SN_ms_app_policies = "ms-app-policies";
pub const LN_ms_app_policies = "Microsoft Application Policies Extension";
pub const NID_ms_app_policies = @as(c_int, 1294);
pub const OBJ_ms_app_policies = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 21);
    break :blk @as(c_long, 10);
};
pub const SN_idea_cbc = "IDEA-CBC";
pub const LN_idea_cbc = "idea-cbc";
pub const NID_idea_cbc = @as(c_int, 34);
pub const OBJ_idea_cbc = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 188);
    _ = @as(c_long, 7);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_idea_ecb = "IDEA-ECB";
pub const LN_idea_ecb = "idea-ecb";
pub const NID_idea_ecb = @as(c_int, 36);
pub const SN_idea_cfb64 = "IDEA-CFB";
pub const LN_idea_cfb64 = "idea-cfb";
pub const NID_idea_cfb64 = @as(c_int, 35);
pub const SN_idea_ofb64 = "IDEA-OFB";
pub const LN_idea_ofb64 = "idea-ofb";
pub const NID_idea_ofb64 = @as(c_int, 46);
pub const SN_bf_cbc = "BF-CBC";
pub const LN_bf_cbc = "bf-cbc";
pub const NID_bf_cbc = @as(c_int, 91);
pub const OBJ_bf_cbc = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 3029);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_bf_ecb = "BF-ECB";
pub const LN_bf_ecb = "bf-ecb";
pub const NID_bf_ecb = @as(c_int, 92);
pub const SN_bf_cfb64 = "BF-CFB";
pub const LN_bf_cfb64 = "bf-cfb";
pub const NID_bf_cfb64 = @as(c_int, 93);
pub const SN_bf_ofb64 = "BF-OFB";
pub const LN_bf_ofb64 = "bf-ofb";
pub const NID_bf_ofb64 = @as(c_int, 94);
pub const SN_id_pkix = "PKIX";
pub const NID_id_pkix = @as(c_int, 127);
pub const OBJ_id_pkix = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    _ = @as(c_long, 5);
    break :blk @as(c_long, 7);
};
pub const SN_id_pkix_mod = "id-pkix-mod";
pub const NID_id_pkix_mod = @as(c_int, 258);
pub const OBJ_id_pkix_mod = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 0);
};
pub const SN_id_pe = "id-pe";
pub const NID_id_pe = @as(c_int, 175);
pub const OBJ_id_pe = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 1);
};
pub const SN_id_qt = "id-qt";
pub const NID_id_qt = @as(c_int, 259);
pub const OBJ_id_qt = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 2);
};
pub const SN_id_kp = "id-kp";
pub const NID_id_kp = @as(c_int, 128);
pub const OBJ_id_kp = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 3);
};
pub const SN_id_it = "id-it";
pub const NID_id_it = @as(c_int, 260);
pub const OBJ_id_it = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 4);
};
pub const SN_id_pkip = "id-pkip";
pub const NID_id_pkip = @as(c_int, 261);
pub const OBJ_id_pkip = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 5);
};
pub const SN_id_alg = "id-alg";
pub const NID_id_alg = @as(c_int, 262);
pub const OBJ_id_alg = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 6);
};
pub const SN_id_cmc = "id-cmc";
pub const NID_id_cmc = @as(c_int, 263);
pub const OBJ_id_cmc = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 7);
};
pub const SN_id_on = "id-on";
pub const NID_id_on = @as(c_int, 264);
pub const OBJ_id_on = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 8);
};
pub const SN_id_pda = "id-pda";
pub const NID_id_pda = @as(c_int, 265);
pub const OBJ_id_pda = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 9);
};
pub const SN_id_aca = "id-aca";
pub const NID_id_aca = @as(c_int, 266);
pub const OBJ_id_aca = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 10);
};
pub const SN_id_qcs = "id-qcs";
pub const NID_id_qcs = @as(c_int, 267);
pub const OBJ_id_qcs = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 11);
};
pub const SN_id_cp = "id-cp";
pub const NID_id_cp = @as(c_int, 1238);
pub const OBJ_id_cp = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 14);
};
pub const SN_id_cct = "id-cct";
pub const NID_id_cct = @as(c_int, 268);
pub const OBJ_id_cct = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 12);
};
pub const SN_id_ppl = "id-ppl";
pub const NID_id_ppl = @as(c_int, 662);
pub const OBJ_id_ppl = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 21);
};
pub const SN_id_ad = "id-ad";
pub const NID_id_ad = @as(c_int, 176);
pub const OBJ_id_ad = blk: {
    _ = &OBJ_id_pkix;
    break :blk @as(c_long, 48);
};
pub const SN_id_pkix1_explicit_88 = "id-pkix1-explicit-88";
pub const NID_id_pkix1_explicit_88 = @as(c_int, 269);
pub const OBJ_id_pkix1_explicit_88 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 1);
};
pub const SN_id_pkix1_implicit_88 = "id-pkix1-implicit-88";
pub const NID_id_pkix1_implicit_88 = @as(c_int, 270);
pub const OBJ_id_pkix1_implicit_88 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 2);
};
pub const SN_id_pkix1_explicit_93 = "id-pkix1-explicit-93";
pub const NID_id_pkix1_explicit_93 = @as(c_int, 271);
pub const OBJ_id_pkix1_explicit_93 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 3);
};
pub const SN_id_pkix1_implicit_93 = "id-pkix1-implicit-93";
pub const NID_id_pkix1_implicit_93 = @as(c_int, 272);
pub const OBJ_id_pkix1_implicit_93 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 4);
};
pub const SN_id_mod_crmf = "id-mod-crmf";
pub const NID_id_mod_crmf = @as(c_int, 273);
pub const OBJ_id_mod_crmf = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 5);
};
pub const SN_id_mod_cmc = "id-mod-cmc";
pub const NID_id_mod_cmc = @as(c_int, 274);
pub const OBJ_id_mod_cmc = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 6);
};
pub const SN_id_mod_kea_profile_88 = "id-mod-kea-profile-88";
pub const NID_id_mod_kea_profile_88 = @as(c_int, 275);
pub const OBJ_id_mod_kea_profile_88 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 7);
};
pub const SN_id_mod_kea_profile_93 = "id-mod-kea-profile-93";
pub const NID_id_mod_kea_profile_93 = @as(c_int, 276);
pub const OBJ_id_mod_kea_profile_93 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 8);
};
pub const SN_id_mod_cmp = "id-mod-cmp";
pub const NID_id_mod_cmp = @as(c_int, 277);
pub const OBJ_id_mod_cmp = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 9);
};
pub const SN_id_mod_qualified_cert_88 = "id-mod-qualified-cert-88";
pub const NID_id_mod_qualified_cert_88 = @as(c_int, 278);
pub const OBJ_id_mod_qualified_cert_88 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 10);
};
pub const SN_id_mod_qualified_cert_93 = "id-mod-qualified-cert-93";
pub const NID_id_mod_qualified_cert_93 = @as(c_int, 279);
pub const OBJ_id_mod_qualified_cert_93 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 11);
};
pub const SN_id_mod_attribute_cert = "id-mod-attribute-cert";
pub const NID_id_mod_attribute_cert = @as(c_int, 280);
pub const OBJ_id_mod_attribute_cert = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 12);
};
pub const SN_id_mod_timestamp_protocol = "id-mod-timestamp-protocol";
pub const NID_id_mod_timestamp_protocol = @as(c_int, 281);
pub const OBJ_id_mod_timestamp_protocol = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 13);
};
pub const SN_id_mod_ocsp = "id-mod-ocsp";
pub const NID_id_mod_ocsp = @as(c_int, 282);
pub const OBJ_id_mod_ocsp = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 14);
};
pub const SN_id_mod_dvcs = "id-mod-dvcs";
pub const NID_id_mod_dvcs = @as(c_int, 283);
pub const OBJ_id_mod_dvcs = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 15);
};
pub const SN_id_mod_cmp2000 = "id-mod-cmp2000";
pub const NID_id_mod_cmp2000 = @as(c_int, 284);
pub const OBJ_id_mod_cmp2000 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 16);
};
pub const SN_id_mod_cmp2000_02 = "id-mod-cmp2000-02";
pub const NID_id_mod_cmp2000_02 = @as(c_int, 1251);
pub const OBJ_id_mod_cmp2000_02 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 50);
};
pub const SN_id_mod_cmp2021_88 = "id-mod-cmp2021-88";
pub const NID_id_mod_cmp2021_88 = @as(c_int, 1252);
pub const OBJ_id_mod_cmp2021_88 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 99);
};
pub const SN_id_mod_cmp2021_02 = "id-mod-cmp2021-02";
pub const NID_id_mod_cmp2021_02 = @as(c_int, 1253);
pub const OBJ_id_mod_cmp2021_02 = blk: {
    _ = &OBJ_id_pkix_mod;
    break :blk @as(c_long, 100);
};
pub const SN_info_access = "authorityInfoAccess";
pub const LN_info_access = "Authority Information Access";
pub const NID_info_access = @as(c_int, 177);
pub const OBJ_info_access = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 1);
};
pub const SN_biometricInfo = "biometricInfo";
pub const LN_biometricInfo = "Biometric Info";
pub const NID_biometricInfo = @as(c_int, 285);
pub const OBJ_biometricInfo = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 2);
};
pub const SN_qcStatements = "qcStatements";
pub const NID_qcStatements = @as(c_int, 286);
pub const OBJ_qcStatements = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 3);
};
pub const SN_ac_auditIdentity = "ac-auditIdentity";
pub const LN_ac_auditIdentity = "X509v3 Audit Identity";
pub const NID_ac_auditIdentity = @as(c_int, 287);
pub const OBJ_ac_auditIdentity = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 4);
};
pub const NID_ac_auditEntity = @as(c_int, 1323);
pub const OBJ_ac_auditEntity = OBJ_ac_auditIdentity;
pub const SN_ac_targeting = "ac-targeting";
pub const NID_ac_targeting = @as(c_int, 288);
pub const OBJ_ac_targeting = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 5);
};
pub const SN_aaControls = "aaControls";
pub const NID_aaControls = @as(c_int, 289);
pub const OBJ_aaControls = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 6);
};
pub const SN_sbgp_ipAddrBlock = "sbgp-ipAddrBlock";
pub const NID_sbgp_ipAddrBlock = @as(c_int, 290);
pub const OBJ_sbgp_ipAddrBlock = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 7);
};
pub const SN_sbgp_autonomousSysNum = "sbgp-autonomousSysNum";
pub const NID_sbgp_autonomousSysNum = @as(c_int, 291);
pub const OBJ_sbgp_autonomousSysNum = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 8);
};
pub const SN_sbgp_routerIdentifier = "sbgp-routerIdentifier";
pub const NID_sbgp_routerIdentifier = @as(c_int, 292);
pub const OBJ_sbgp_routerIdentifier = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 9);
};
pub const SN_ac_proxying = "ac-proxying";
pub const NID_ac_proxying = @as(c_int, 397);
pub const OBJ_ac_proxying = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 10);
};
pub const SN_sinfo_access = "subjectInfoAccess";
pub const LN_sinfo_access = "Subject Information Access";
pub const NID_sinfo_access = @as(c_int, 398);
pub const OBJ_sinfo_access = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 11);
};
pub const SN_proxyCertInfo = "proxyCertInfo";
pub const LN_proxyCertInfo = "Proxy Certificate Information";
pub const NID_proxyCertInfo = @as(c_int, 663);
pub const OBJ_proxyCertInfo = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 14);
};
pub const SN_tlsfeature = "tlsfeature";
pub const LN_tlsfeature = "TLS Feature";
pub const NID_tlsfeature = @as(c_int, 1020);
pub const OBJ_tlsfeature = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 24);
};
pub const SN_sbgp_ipAddrBlockv2 = "sbgp-ipAddrBlockv2";
pub const NID_sbgp_ipAddrBlockv2 = @as(c_int, 1239);
pub const OBJ_sbgp_ipAddrBlockv2 = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 28);
};
pub const SN_sbgp_autonomousSysNumv2 = "sbgp-autonomousSysNumv2";
pub const NID_sbgp_autonomousSysNumv2 = @as(c_int, 1240);
pub const OBJ_sbgp_autonomousSysNumv2 = blk: {
    _ = &OBJ_id_pe;
    break :blk @as(c_long, 29);
};
pub const SN_id_qt_cps = "id-qt-cps";
pub const LN_id_qt_cps = "Policy Qualifier CPS";
pub const NID_id_qt_cps = @as(c_int, 164);
pub const OBJ_id_qt_cps = blk: {
    _ = &OBJ_id_qt;
    break :blk @as(c_long, 1);
};
pub const SN_id_qt_unotice = "id-qt-unotice";
pub const LN_id_qt_unotice = "Policy Qualifier User Notice";
pub const NID_id_qt_unotice = @as(c_int, 165);
pub const OBJ_id_qt_unotice = blk: {
    _ = &OBJ_id_qt;
    break :blk @as(c_long, 2);
};
pub const SN_textNotice = "textNotice";
pub const NID_textNotice = @as(c_int, 293);
pub const OBJ_textNotice = blk: {
    _ = &OBJ_id_qt;
    break :blk @as(c_long, 3);
};
pub const SN_server_auth = "serverAuth";
pub const LN_server_auth = "TLS Web Server Authentication";
pub const NID_server_auth = @as(c_int, 129);
pub const OBJ_server_auth = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 1);
};
pub const SN_client_auth = "clientAuth";
pub const LN_client_auth = "TLS Web Client Authentication";
pub const NID_client_auth = @as(c_int, 130);
pub const OBJ_client_auth = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 2);
};
pub const SN_code_sign = "codeSigning";
pub const LN_code_sign = "Code Signing";
pub const NID_code_sign = @as(c_int, 131);
pub const OBJ_code_sign = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 3);
};
pub const SN_email_protect = "emailProtection";
pub const LN_email_protect = "E-mail Protection";
pub const NID_email_protect = @as(c_int, 132);
pub const OBJ_email_protect = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 4);
};
pub const SN_ipsecEndSystem = "ipsecEndSystem";
pub const LN_ipsecEndSystem = "IPSec End System";
pub const NID_ipsecEndSystem = @as(c_int, 294);
pub const OBJ_ipsecEndSystem = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 5);
};
pub const SN_ipsecTunnel = "ipsecTunnel";
pub const LN_ipsecTunnel = "IPSec Tunnel";
pub const NID_ipsecTunnel = @as(c_int, 295);
pub const OBJ_ipsecTunnel = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 6);
};
pub const SN_ipsecUser = "ipsecUser";
pub const LN_ipsecUser = "IPSec User";
pub const NID_ipsecUser = @as(c_int, 296);
pub const OBJ_ipsecUser = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 7);
};
pub const SN_time_stamp = "timeStamping";
pub const LN_time_stamp = "Time Stamping";
pub const NID_time_stamp = @as(c_int, 133);
pub const OBJ_time_stamp = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 8);
};
pub const SN_OCSP_sign = "OCSPSigning";
pub const LN_OCSP_sign = "OCSP Signing";
pub const NID_OCSP_sign = @as(c_int, 180);
pub const OBJ_OCSP_sign = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 9);
};
pub const SN_dvcs = "DVCS";
pub const LN_dvcs = "dvcs";
pub const NID_dvcs = @as(c_int, 297);
pub const OBJ_dvcs = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 10);
};
pub const SN_ipsec_IKE = "ipsecIKE";
pub const LN_ipsec_IKE = "ipsec Internet Key Exchange";
pub const NID_ipsec_IKE = @as(c_int, 1022);
pub const OBJ_ipsec_IKE = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 17);
};
pub const SN_capwapAC = "capwapAC";
pub const LN_capwapAC = "Ctrl/provision WAP Access";
pub const NID_capwapAC = @as(c_int, 1023);
pub const OBJ_capwapAC = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 18);
};
pub const SN_capwapWTP = "capwapWTP";
pub const LN_capwapWTP = "Ctrl/Provision WAP Termination";
pub const NID_capwapWTP = @as(c_int, 1024);
pub const OBJ_capwapWTP = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 19);
};
pub const SN_sshClient = "secureShellClient";
pub const LN_sshClient = "SSH Client";
pub const NID_sshClient = @as(c_int, 1025);
pub const OBJ_sshClient = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 21);
};
pub const SN_sshServer = "secureShellServer";
pub const LN_sshServer = "SSH Server";
pub const NID_sshServer = @as(c_int, 1026);
pub const OBJ_sshServer = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 22);
};
pub const SN_sendRouter = "sendRouter";
pub const LN_sendRouter = "Send Router";
pub const NID_sendRouter = @as(c_int, 1027);
pub const OBJ_sendRouter = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 23);
};
pub const SN_sendProxiedRouter = "sendProxiedRouter";
pub const LN_sendProxiedRouter = "Send Proxied Router";
pub const NID_sendProxiedRouter = @as(c_int, 1028);
pub const OBJ_sendProxiedRouter = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 24);
};
pub const SN_sendOwner = "sendOwner";
pub const LN_sendOwner = "Send Owner";
pub const NID_sendOwner = @as(c_int, 1029);
pub const OBJ_sendOwner = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 25);
};
pub const SN_sendProxiedOwner = "sendProxiedOwner";
pub const LN_sendProxiedOwner = "Send Proxied Owner";
pub const NID_sendProxiedOwner = @as(c_int, 1030);
pub const OBJ_sendProxiedOwner = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 26);
};
pub const SN_cmcCA = "cmcCA";
pub const LN_cmcCA = "CMC Certificate Authority";
pub const NID_cmcCA = @as(c_int, 1131);
pub const OBJ_cmcCA = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 27);
};
pub const SN_cmcRA = "cmcRA";
pub const LN_cmcRA = "CMC Registration Authority";
pub const NID_cmcRA = @as(c_int, 1132);
pub const OBJ_cmcRA = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 28);
};
pub const SN_cmcArchive = "cmcArchive";
pub const LN_cmcArchive = "CMC Archive Server";
pub const NID_cmcArchive = @as(c_int, 1219);
pub const OBJ_cmcArchive = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 29);
};
pub const SN_id_kp_bgpsec_router = "id-kp-bgpsec-router";
pub const LN_id_kp_bgpsec_router = "BGPsec Router";
pub const NID_id_kp_bgpsec_router = @as(c_int, 1220);
pub const OBJ_id_kp_bgpsec_router = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 30);
};
pub const SN_id_kp_BrandIndicatorforMessageIdentification = "id-kp-BrandIndicatorforMessageIdentification";
pub const LN_id_kp_BrandIndicatorforMessageIdentification = "Brand Indicator for Message Identification";
pub const NID_id_kp_BrandIndicatorforMessageIdentification = @as(c_int, 1221);
pub const OBJ_id_kp_BrandIndicatorforMessageIdentification = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 31);
};
pub const SN_cmKGA = "cmKGA";
pub const LN_cmKGA = "Certificate Management Key Generation Authority";
pub const NID_cmKGA = @as(c_int, 1222);
pub const OBJ_cmKGA = blk: {
    _ = &OBJ_id_kp;
    break :blk @as(c_long, 32);
};
pub const SN_id_it_caProtEncCert = "id-it-caProtEncCert";
pub const NID_id_it_caProtEncCert = @as(c_int, 298);
pub const OBJ_id_it_caProtEncCert = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 1);
};
pub const SN_id_it_signKeyPairTypes = "id-it-signKeyPairTypes";
pub const NID_id_it_signKeyPairTypes = @as(c_int, 299);
pub const OBJ_id_it_signKeyPairTypes = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 2);
};
pub const SN_id_it_encKeyPairTypes = "id-it-encKeyPairTypes";
pub const NID_id_it_encKeyPairTypes = @as(c_int, 300);
pub const OBJ_id_it_encKeyPairTypes = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 3);
};
pub const SN_id_it_preferredSymmAlg = "id-it-preferredSymmAlg";
pub const NID_id_it_preferredSymmAlg = @as(c_int, 301);
pub const OBJ_id_it_preferredSymmAlg = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 4);
};
pub const SN_id_it_caKeyUpdateInfo = "id-it-caKeyUpdateInfo";
pub const NID_id_it_caKeyUpdateInfo = @as(c_int, 302);
pub const OBJ_id_it_caKeyUpdateInfo = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 5);
};
pub const SN_id_it_currentCRL = "id-it-currentCRL";
pub const NID_id_it_currentCRL = @as(c_int, 303);
pub const OBJ_id_it_currentCRL = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 6);
};
pub const SN_id_it_unsupportedOIDs = "id-it-unsupportedOIDs";
pub const NID_id_it_unsupportedOIDs = @as(c_int, 304);
pub const OBJ_id_it_unsupportedOIDs = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 7);
};
pub const SN_id_it_subscriptionRequest = "id-it-subscriptionRequest";
pub const NID_id_it_subscriptionRequest = @as(c_int, 305);
pub const OBJ_id_it_subscriptionRequest = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 8);
};
pub const SN_id_it_subscriptionResponse = "id-it-subscriptionResponse";
pub const NID_id_it_subscriptionResponse = @as(c_int, 306);
pub const OBJ_id_it_subscriptionResponse = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 9);
};
pub const SN_id_it_keyPairParamReq = "id-it-keyPairParamReq";
pub const NID_id_it_keyPairParamReq = @as(c_int, 307);
pub const OBJ_id_it_keyPairParamReq = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 10);
};
pub const SN_id_it_keyPairParamRep = "id-it-keyPairParamRep";
pub const NID_id_it_keyPairParamRep = @as(c_int, 308);
pub const OBJ_id_it_keyPairParamRep = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 11);
};
pub const SN_id_it_revPassphrase = "id-it-revPassphrase";
pub const NID_id_it_revPassphrase = @as(c_int, 309);
pub const OBJ_id_it_revPassphrase = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 12);
};
pub const SN_id_it_implicitConfirm = "id-it-implicitConfirm";
pub const NID_id_it_implicitConfirm = @as(c_int, 310);
pub const OBJ_id_it_implicitConfirm = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 13);
};
pub const SN_id_it_confirmWaitTime = "id-it-confirmWaitTime";
pub const NID_id_it_confirmWaitTime = @as(c_int, 311);
pub const OBJ_id_it_confirmWaitTime = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 14);
};
pub const SN_id_it_origPKIMessage = "id-it-origPKIMessage";
pub const NID_id_it_origPKIMessage = @as(c_int, 312);
pub const OBJ_id_it_origPKIMessage = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 15);
};
pub const SN_id_it_suppLangTags = "id-it-suppLangTags";
pub const NID_id_it_suppLangTags = @as(c_int, 784);
pub const OBJ_id_it_suppLangTags = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 16);
};
pub const SN_id_it_caCerts = "id-it-caCerts";
pub const NID_id_it_caCerts = @as(c_int, 1223);
pub const OBJ_id_it_caCerts = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 17);
};
pub const SN_id_it_rootCaKeyUpdate = "id-it-rootCaKeyUpdate";
pub const NID_id_it_rootCaKeyUpdate = @as(c_int, 1224);
pub const OBJ_id_it_rootCaKeyUpdate = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 18);
};
pub const SN_id_it_certReqTemplate = "id-it-certReqTemplate";
pub const NID_id_it_certReqTemplate = @as(c_int, 1225);
pub const OBJ_id_it_certReqTemplate = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 19);
};
pub const SN_id_it_rootCaCert = "id-it-rootCaCert";
pub const NID_id_it_rootCaCert = @as(c_int, 1254);
pub const OBJ_id_it_rootCaCert = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 20);
};
pub const SN_id_it_certProfile = "id-it-certProfile";
pub const NID_id_it_certProfile = @as(c_int, 1255);
pub const OBJ_id_it_certProfile = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 21);
};
pub const SN_id_it_crlStatusList = "id-it-crlStatusList";
pub const NID_id_it_crlStatusList = @as(c_int, 1256);
pub const OBJ_id_it_crlStatusList = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 22);
};
pub const SN_id_it_crls = "id-it-crls";
pub const NID_id_it_crls = @as(c_int, 1257);
pub const OBJ_id_it_crls = blk: {
    _ = &OBJ_id_it;
    break :blk @as(c_long, 23);
};
pub const SN_id_regCtrl = "id-regCtrl";
pub const NID_id_regCtrl = @as(c_int, 313);
pub const OBJ_id_regCtrl = blk: {
    _ = &OBJ_id_pkip;
    break :blk @as(c_long, 1);
};
pub const SN_id_regInfo = "id-regInfo";
pub const NID_id_regInfo = @as(c_int, 314);
pub const OBJ_id_regInfo = blk: {
    _ = &OBJ_id_pkip;
    break :blk @as(c_long, 2);
};
pub const SN_id_regCtrl_regToken = "id-regCtrl-regToken";
pub const NID_id_regCtrl_regToken = @as(c_int, 315);
pub const OBJ_id_regCtrl_regToken = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 1);
};
pub const SN_id_regCtrl_authenticator = "id-regCtrl-authenticator";
pub const NID_id_regCtrl_authenticator = @as(c_int, 316);
pub const OBJ_id_regCtrl_authenticator = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 2);
};
pub const SN_id_regCtrl_pkiPublicationInfo = "id-regCtrl-pkiPublicationInfo";
pub const NID_id_regCtrl_pkiPublicationInfo = @as(c_int, 317);
pub const OBJ_id_regCtrl_pkiPublicationInfo = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 3);
};
pub const SN_id_regCtrl_pkiArchiveOptions = "id-regCtrl-pkiArchiveOptions";
pub const NID_id_regCtrl_pkiArchiveOptions = @as(c_int, 318);
pub const OBJ_id_regCtrl_pkiArchiveOptions = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 4);
};
pub const SN_id_regCtrl_oldCertID = "id-regCtrl-oldCertID";
pub const NID_id_regCtrl_oldCertID = @as(c_int, 319);
pub const OBJ_id_regCtrl_oldCertID = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 5);
};
pub const SN_id_regCtrl_protocolEncrKey = "id-regCtrl-protocolEncrKey";
pub const NID_id_regCtrl_protocolEncrKey = @as(c_int, 320);
pub const OBJ_id_regCtrl_protocolEncrKey = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 6);
};
pub const SN_id_regCtrl_altCertTemplate = "id-regCtrl-altCertTemplate";
pub const NID_id_regCtrl_altCertTemplate = @as(c_int, 1258);
pub const OBJ_id_regCtrl_altCertTemplate = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 7);
};
pub const SN_id_regCtrl_algId = "id-regCtrl-algId";
pub const NID_id_regCtrl_algId = @as(c_int, 1259);
pub const OBJ_id_regCtrl_algId = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 11);
};
pub const SN_id_regCtrl_rsaKeyLen = "id-regCtrl-rsaKeyLen";
pub const NID_id_regCtrl_rsaKeyLen = @as(c_int, 1260);
pub const OBJ_id_regCtrl_rsaKeyLen = blk: {
    _ = &OBJ_id_regCtrl;
    break :blk @as(c_long, 12);
};
pub const SN_id_regInfo_utf8Pairs = "id-regInfo-utf8Pairs";
pub const NID_id_regInfo_utf8Pairs = @as(c_int, 321);
pub const OBJ_id_regInfo_utf8Pairs = blk: {
    _ = &OBJ_id_regInfo;
    break :blk @as(c_long, 1);
};
pub const SN_id_regInfo_certReq = "id-regInfo-certReq";
pub const NID_id_regInfo_certReq = @as(c_int, 322);
pub const OBJ_id_regInfo_certReq = blk: {
    _ = &OBJ_id_regInfo;
    break :blk @as(c_long, 2);
};
pub const SN_id_alg_des40 = "id-alg-des40";
pub const NID_id_alg_des40 = @as(c_int, 323);
pub const OBJ_id_alg_des40 = blk: {
    _ = &OBJ_id_alg;
    break :blk @as(c_long, 1);
};
pub const SN_id_alg_noSignature = "id-alg-noSignature";
pub const NID_id_alg_noSignature = @as(c_int, 324);
pub const OBJ_id_alg_noSignature = blk: {
    _ = &OBJ_id_alg;
    break :blk @as(c_long, 2);
};
pub const SN_id_alg_dh_sig_hmac_sha1 = "id-alg-dh-sig-hmac-sha1";
pub const NID_id_alg_dh_sig_hmac_sha1 = @as(c_int, 325);
pub const OBJ_id_alg_dh_sig_hmac_sha1 = blk: {
    _ = &OBJ_id_alg;
    break :blk @as(c_long, 3);
};
pub const SN_id_alg_dh_pop = "id-alg-dh-pop";
pub const NID_id_alg_dh_pop = @as(c_int, 326);
pub const OBJ_id_alg_dh_pop = blk: {
    _ = &OBJ_id_alg;
    break :blk @as(c_long, 4);
};
pub const SN_id_cmc_statusInfo = "id-cmc-statusInfo";
pub const NID_id_cmc_statusInfo = @as(c_int, 327);
pub const OBJ_id_cmc_statusInfo = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 1);
};
pub const SN_id_cmc_identification = "id-cmc-identification";
pub const NID_id_cmc_identification = @as(c_int, 328);
pub const OBJ_id_cmc_identification = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 2);
};
pub const SN_id_cmc_identityProof = "id-cmc-identityProof";
pub const NID_id_cmc_identityProof = @as(c_int, 329);
pub const OBJ_id_cmc_identityProof = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 3);
};
pub const SN_id_cmc_dataReturn = "id-cmc-dataReturn";
pub const NID_id_cmc_dataReturn = @as(c_int, 330);
pub const OBJ_id_cmc_dataReturn = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 4);
};
pub const SN_id_cmc_transactionId = "id-cmc-transactionId";
pub const NID_id_cmc_transactionId = @as(c_int, 331);
pub const OBJ_id_cmc_transactionId = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 5);
};
pub const SN_id_cmc_senderNonce = "id-cmc-senderNonce";
pub const NID_id_cmc_senderNonce = @as(c_int, 332);
pub const OBJ_id_cmc_senderNonce = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 6);
};
pub const SN_id_cmc_recipientNonce = "id-cmc-recipientNonce";
pub const NID_id_cmc_recipientNonce = @as(c_int, 333);
pub const OBJ_id_cmc_recipientNonce = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 7);
};
pub const SN_id_cmc_addExtensions = "id-cmc-addExtensions";
pub const NID_id_cmc_addExtensions = @as(c_int, 334);
pub const OBJ_id_cmc_addExtensions = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 8);
};
pub const SN_id_cmc_encryptedPOP = "id-cmc-encryptedPOP";
pub const NID_id_cmc_encryptedPOP = @as(c_int, 335);
pub const OBJ_id_cmc_encryptedPOP = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 9);
};
pub const SN_id_cmc_decryptedPOP = "id-cmc-decryptedPOP";
pub const NID_id_cmc_decryptedPOP = @as(c_int, 336);
pub const OBJ_id_cmc_decryptedPOP = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 10);
};
pub const SN_id_cmc_lraPOPWitness = "id-cmc-lraPOPWitness";
pub const NID_id_cmc_lraPOPWitness = @as(c_int, 337);
pub const OBJ_id_cmc_lraPOPWitness = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 11);
};
pub const SN_id_cmc_getCert = "id-cmc-getCert";
pub const NID_id_cmc_getCert = @as(c_int, 338);
pub const OBJ_id_cmc_getCert = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 15);
};
pub const SN_id_cmc_getCRL = "id-cmc-getCRL";
pub const NID_id_cmc_getCRL = @as(c_int, 339);
pub const OBJ_id_cmc_getCRL = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 16);
};
pub const SN_id_cmc_revokeRequest = "id-cmc-revokeRequest";
pub const NID_id_cmc_revokeRequest = @as(c_int, 340);
pub const OBJ_id_cmc_revokeRequest = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 17);
};
pub const SN_id_cmc_regInfo = "id-cmc-regInfo";
pub const NID_id_cmc_regInfo = @as(c_int, 341);
pub const OBJ_id_cmc_regInfo = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 18);
};
pub const SN_id_cmc_responseInfo = "id-cmc-responseInfo";
pub const NID_id_cmc_responseInfo = @as(c_int, 342);
pub const OBJ_id_cmc_responseInfo = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 19);
};
pub const SN_id_cmc_queryPending = "id-cmc-queryPending";
pub const NID_id_cmc_queryPending = @as(c_int, 343);
pub const OBJ_id_cmc_queryPending = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 21);
};
pub const SN_id_cmc_popLinkRandom = "id-cmc-popLinkRandom";
pub const NID_id_cmc_popLinkRandom = @as(c_int, 344);
pub const OBJ_id_cmc_popLinkRandom = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 22);
};
pub const SN_id_cmc_popLinkWitness = "id-cmc-popLinkWitness";
pub const NID_id_cmc_popLinkWitness = @as(c_int, 345);
pub const OBJ_id_cmc_popLinkWitness = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 23);
};
pub const SN_id_cmc_confirmCertAcceptance = "id-cmc-confirmCertAcceptance";
pub const NID_id_cmc_confirmCertAcceptance = @as(c_int, 346);
pub const OBJ_id_cmc_confirmCertAcceptance = blk: {
    _ = &OBJ_id_cmc;
    break :blk @as(c_long, 24);
};
pub const SN_id_on_personalData = "id-on-personalData";
pub const NID_id_on_personalData = @as(c_int, 347);
pub const OBJ_id_on_personalData = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 1);
};
pub const SN_id_on_permanentIdentifier = "id-on-permanentIdentifier";
pub const LN_id_on_permanentIdentifier = "Permanent Identifier";
pub const NID_id_on_permanentIdentifier = @as(c_int, 858);
pub const OBJ_id_on_permanentIdentifier = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 3);
};
pub const SN_id_on_hardwareModuleName = "id-on-hardwareModuleName";
pub const LN_id_on_hardwareModuleName = "Hardware Module Name";
pub const NID_id_on_hardwareModuleName = @as(c_int, 1321);
pub const OBJ_id_on_hardwareModuleName = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 4);
};
pub const SN_XmppAddr = "id-on-xmppAddr";
pub const LN_XmppAddr = "XmppAddr";
pub const NID_XmppAddr = @as(c_int, 1209);
pub const OBJ_XmppAddr = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 5);
};
pub const SN_SRVName = "id-on-dnsSRV";
pub const LN_SRVName = "SRVName";
pub const NID_SRVName = @as(c_int, 1210);
pub const OBJ_SRVName = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 7);
};
pub const SN_NAIRealm = "id-on-NAIRealm";
pub const LN_NAIRealm = "NAIRealm";
pub const NID_NAIRealm = @as(c_int, 1211);
pub const OBJ_NAIRealm = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 8);
};
pub const SN_id_on_SmtpUTF8Mailbox = "id-on-SmtpUTF8Mailbox";
pub const LN_id_on_SmtpUTF8Mailbox = "Smtp UTF8 Mailbox";
pub const NID_id_on_SmtpUTF8Mailbox = @as(c_int, 1208);
pub const OBJ_id_on_SmtpUTF8Mailbox = blk: {
    _ = &OBJ_id_on;
    break :blk @as(c_long, 9);
};
pub const SN_id_pda_dateOfBirth = "id-pda-dateOfBirth";
pub const NID_id_pda_dateOfBirth = @as(c_int, 348);
pub const OBJ_id_pda_dateOfBirth = blk: {
    _ = &OBJ_id_pda;
    break :blk @as(c_long, 1);
};
pub const SN_id_pda_placeOfBirth = "id-pda-placeOfBirth";
pub const NID_id_pda_placeOfBirth = @as(c_int, 349);
pub const OBJ_id_pda_placeOfBirth = blk: {
    _ = &OBJ_id_pda;
    break :blk @as(c_long, 2);
};
pub const SN_id_pda_gender = "id-pda-gender";
pub const NID_id_pda_gender = @as(c_int, 351);
pub const OBJ_id_pda_gender = blk: {
    _ = &OBJ_id_pda;
    break :blk @as(c_long, 3);
};
pub const SN_id_pda_countryOfCitizenship = "id-pda-countryOfCitizenship";
pub const NID_id_pda_countryOfCitizenship = @as(c_int, 352);
pub const OBJ_id_pda_countryOfCitizenship = blk: {
    _ = &OBJ_id_pda;
    break :blk @as(c_long, 4);
};
pub const SN_id_pda_countryOfResidence = "id-pda-countryOfResidence";
pub const NID_id_pda_countryOfResidence = @as(c_int, 353);
pub const OBJ_id_pda_countryOfResidence = blk: {
    _ = &OBJ_id_pda;
    break :blk @as(c_long, 5);
};
pub const SN_id_aca_authenticationInfo = "id-aca-authenticationInfo";
pub const NID_id_aca_authenticationInfo = @as(c_int, 354);
pub const OBJ_id_aca_authenticationInfo = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 1);
};
pub const SN_id_aca_accessIdentity = "id-aca-accessIdentity";
pub const NID_id_aca_accessIdentity = @as(c_int, 355);
pub const OBJ_id_aca_accessIdentity = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 2);
};
pub const SN_id_aca_chargingIdentity = "id-aca-chargingIdentity";
pub const NID_id_aca_chargingIdentity = @as(c_int, 356);
pub const OBJ_id_aca_chargingIdentity = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 3);
};
pub const SN_id_aca_group = "id-aca-group";
pub const NID_id_aca_group = @as(c_int, 357);
pub const OBJ_id_aca_group = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 4);
};
pub const SN_id_aca_role = "id-aca-role";
pub const NID_id_aca_role = @as(c_int, 358);
pub const OBJ_id_aca_role = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 5);
};
pub const SN_id_aca_encAttrs = "id-aca-encAttrs";
pub const NID_id_aca_encAttrs = @as(c_int, 399);
pub const OBJ_id_aca_encAttrs = blk: {
    _ = &OBJ_id_aca;
    break :blk @as(c_long, 6);
};
pub const SN_id_qcs_pkixQCSyntax_v1 = "id-qcs-pkixQCSyntax-v1";
pub const NID_id_qcs_pkixQCSyntax_v1 = @as(c_int, 359);
pub const OBJ_id_qcs_pkixQCSyntax_v1 = blk: {
    _ = &OBJ_id_qcs;
    break :blk @as(c_long, 1);
};
pub const SN_ipAddr_asNumber = "ipAddr-asNumber";
pub const NID_ipAddr_asNumber = @as(c_int, 1241);
pub const OBJ_ipAddr_asNumber = blk: {
    _ = &OBJ_id_cp;
    break :blk @as(c_long, 2);
};
pub const SN_ipAddr_asNumberv2 = "ipAddr-asNumberv2";
pub const NID_ipAddr_asNumberv2 = @as(c_int, 1242);
pub const OBJ_ipAddr_asNumberv2 = blk: {
    _ = &OBJ_id_cp;
    break :blk @as(c_long, 3);
};
pub const SN_id_cct_crs = "id-cct-crs";
pub const NID_id_cct_crs = @as(c_int, 360);
pub const OBJ_id_cct_crs = blk: {
    _ = &OBJ_id_cct;
    break :blk @as(c_long, 1);
};
pub const SN_id_cct_PKIData = "id-cct-PKIData";
pub const NID_id_cct_PKIData = @as(c_int, 361);
pub const OBJ_id_cct_PKIData = blk: {
    _ = &OBJ_id_cct;
    break :blk @as(c_long, 2);
};
pub const SN_id_cct_PKIResponse = "id-cct-PKIResponse";
pub const NID_id_cct_PKIResponse = @as(c_int, 362);
pub const OBJ_id_cct_PKIResponse = blk: {
    _ = &OBJ_id_cct;
    break :blk @as(c_long, 3);
};
pub const SN_id_ppl_anyLanguage = "id-ppl-anyLanguage";
pub const LN_id_ppl_anyLanguage = "Any language";
pub const NID_id_ppl_anyLanguage = @as(c_int, 664);
pub const OBJ_id_ppl_anyLanguage = blk: {
    _ = &OBJ_id_ppl;
    break :blk @as(c_long, 0);
};
pub const SN_id_ppl_inheritAll = "id-ppl-inheritAll";
pub const LN_id_ppl_inheritAll = "Inherit all";
pub const NID_id_ppl_inheritAll = @as(c_int, 665);
pub const OBJ_id_ppl_inheritAll = blk: {
    _ = &OBJ_id_ppl;
    break :blk @as(c_long, 1);
};
pub const SN_Independent = "id-ppl-independent";
pub const LN_Independent = "Independent";
pub const NID_Independent = @as(c_int, 667);
pub const OBJ_Independent = blk: {
    _ = &OBJ_id_ppl;
    break :blk @as(c_long, 2);
};
pub const SN_ad_OCSP = "OCSP";
pub const LN_ad_OCSP = "OCSP";
pub const NID_ad_OCSP = @as(c_int, 178);
pub const OBJ_ad_OCSP = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 1);
};
pub const SN_ad_ca_issuers = "caIssuers";
pub const LN_ad_ca_issuers = "CA Issuers";
pub const NID_ad_ca_issuers = @as(c_int, 179);
pub const OBJ_ad_ca_issuers = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 2);
};
pub const SN_ad_timeStamping = "ad_timestamping";
pub const LN_ad_timeStamping = "AD Time Stamping";
pub const NID_ad_timeStamping = @as(c_int, 363);
pub const OBJ_ad_timeStamping = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 3);
};
pub const SN_ad_dvcs = "AD_DVCS";
pub const LN_ad_dvcs = "ad dvcs";
pub const NID_ad_dvcs = @as(c_int, 364);
pub const OBJ_ad_dvcs = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 4);
};
pub const SN_caRepository = "caRepository";
pub const LN_caRepository = "CA Repository";
pub const NID_caRepository = @as(c_int, 785);
pub const OBJ_caRepository = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 5);
};
pub const SN_rpkiManifest = "rpkiManifest";
pub const LN_rpkiManifest = "RPKI Manifest";
pub const NID_rpkiManifest = @as(c_int, 1243);
pub const OBJ_rpkiManifest = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 10);
};
pub const SN_signedObject = "signedObject";
pub const LN_signedObject = "Signed Object";
pub const NID_signedObject = @as(c_int, 1244);
pub const OBJ_signedObject = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 11);
};
pub const SN_rpkiNotify = "rpkiNotify";
pub const LN_rpkiNotify = "RPKI Notify";
pub const NID_rpkiNotify = @as(c_int, 1245);
pub const OBJ_rpkiNotify = blk: {
    _ = &OBJ_id_ad;
    break :blk @as(c_long, 13);
};
pub const OBJ_id_pkix_OCSP = OBJ_ad_OCSP;
pub const SN_id_pkix_OCSP_basic = "basicOCSPResponse";
pub const LN_id_pkix_OCSP_basic = "Basic OCSP Response";
pub const NID_id_pkix_OCSP_basic = @as(c_int, 365);
pub const OBJ_id_pkix_OCSP_basic = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 1);
};
pub const SN_id_pkix_OCSP_Nonce = "Nonce";
pub const LN_id_pkix_OCSP_Nonce = "OCSP Nonce";
pub const NID_id_pkix_OCSP_Nonce = @as(c_int, 366);
pub const OBJ_id_pkix_OCSP_Nonce = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 2);
};
pub const SN_id_pkix_OCSP_CrlID = "CrlID";
pub const LN_id_pkix_OCSP_CrlID = "OCSP CRL ID";
pub const NID_id_pkix_OCSP_CrlID = @as(c_int, 367);
pub const OBJ_id_pkix_OCSP_CrlID = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 3);
};
pub const SN_id_pkix_OCSP_acceptableResponses = "acceptableResponses";
pub const LN_id_pkix_OCSP_acceptableResponses = "Acceptable OCSP Responses";
pub const NID_id_pkix_OCSP_acceptableResponses = @as(c_int, 368);
pub const OBJ_id_pkix_OCSP_acceptableResponses = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 4);
};
pub const SN_id_pkix_OCSP_noCheck = "noCheck";
pub const LN_id_pkix_OCSP_noCheck = "OCSP No Check";
pub const NID_id_pkix_OCSP_noCheck = @as(c_int, 369);
pub const OBJ_id_pkix_OCSP_noCheck = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 5);
};
pub const SN_id_pkix_OCSP_archiveCutoff = "archiveCutoff";
pub const LN_id_pkix_OCSP_archiveCutoff = "OCSP Archive Cutoff";
pub const NID_id_pkix_OCSP_archiveCutoff = @as(c_int, 370);
pub const OBJ_id_pkix_OCSP_archiveCutoff = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 6);
};
pub const SN_id_pkix_OCSP_serviceLocator = "serviceLocator";
pub const LN_id_pkix_OCSP_serviceLocator = "OCSP Service Locator";
pub const NID_id_pkix_OCSP_serviceLocator = @as(c_int, 371);
pub const OBJ_id_pkix_OCSP_serviceLocator = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 7);
};
pub const SN_id_pkix_OCSP_extendedStatus = "extendedStatus";
pub const LN_id_pkix_OCSP_extendedStatus = "Extended OCSP Status";
pub const NID_id_pkix_OCSP_extendedStatus = @as(c_int, 372);
pub const OBJ_id_pkix_OCSP_extendedStatus = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 8);
};
pub const SN_id_pkix_OCSP_valid = "valid";
pub const NID_id_pkix_OCSP_valid = @as(c_int, 373);
pub const OBJ_id_pkix_OCSP_valid = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 9);
};
pub const SN_id_pkix_OCSP_path = "path";
pub const NID_id_pkix_OCSP_path = @as(c_int, 374);
pub const OBJ_id_pkix_OCSP_path = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 10);
};
pub const SN_id_pkix_OCSP_trustRoot = "trustRoot";
pub const LN_id_pkix_OCSP_trustRoot = "Trust Root";
pub const NID_id_pkix_OCSP_trustRoot = @as(c_int, 375);
pub const OBJ_id_pkix_OCSP_trustRoot = blk: {
    _ = &OBJ_id_pkix_OCSP;
    break :blk @as(c_long, 11);
};
pub const SN_algorithm = "algorithm";
pub const LN_algorithm = "algorithm";
pub const NID_algorithm = @as(c_int, 376);
pub const OBJ_algorithm = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 14);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 2);
};
pub const SN_md5WithRSA = "RSA-NP-MD5";
pub const LN_md5WithRSA = "md5WithRSA";
pub const NID_md5WithRSA = @as(c_int, 104);
pub const OBJ_md5WithRSA = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 3);
};
pub const SN_des_ecb = "DES-ECB";
pub const LN_des_ecb = "des-ecb";
pub const NID_des_ecb = @as(c_int, 29);
pub const OBJ_des_ecb = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 6);
};
pub const SN_des_cbc = "DES-CBC";
pub const LN_des_cbc = "des-cbc";
pub const NID_des_cbc = @as(c_int, 31);
pub const OBJ_des_cbc = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 7);
};
pub const SN_des_ofb64 = "DES-OFB";
pub const LN_des_ofb64 = "des-ofb";
pub const NID_des_ofb64 = @as(c_int, 45);
pub const OBJ_des_ofb64 = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 8);
};
pub const SN_des_cfb64 = "DES-CFB";
pub const LN_des_cfb64 = "des-cfb";
pub const NID_des_cfb64 = @as(c_int, 30);
pub const OBJ_des_cfb64 = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 9);
};
pub const SN_rsaSignature = "rsaSignature";
pub const NID_rsaSignature = @as(c_int, 377);
pub const OBJ_rsaSignature = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 11);
};
pub const SN_dsa_2 = "DSA-old";
pub const LN_dsa_2 = "dsaEncryption-old";
pub const NID_dsa_2 = @as(c_int, 67);
pub const OBJ_dsa_2 = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 12);
};
pub const SN_dsaWithSHA = "DSA-SHA";
pub const LN_dsaWithSHA = "dsaWithSHA";
pub const NID_dsaWithSHA = @as(c_int, 66);
pub const OBJ_dsaWithSHA = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 13);
};
pub const SN_shaWithRSAEncryption = "RSA-SHA";
pub const LN_shaWithRSAEncryption = "shaWithRSAEncryption";
pub const NID_shaWithRSAEncryption = @as(c_int, 42);
pub const OBJ_shaWithRSAEncryption = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 15);
};
pub const SN_des_ede_ecb = "DES-EDE";
pub const LN_des_ede_ecb = "des-ede";
pub const NID_des_ede_ecb = @as(c_int, 32);
pub const OBJ_des_ede_ecb = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 17);
};
pub const SN_des_ede3_ecb = "DES-EDE3";
pub const LN_des_ede3_ecb = "des-ede3";
pub const NID_des_ede3_ecb = @as(c_int, 33);
pub const SN_des_ede_cbc = "DES-EDE-CBC";
pub const LN_des_ede_cbc = "des-ede-cbc";
pub const NID_des_ede_cbc = @as(c_int, 43);
pub const SN_des_ede_cfb64 = "DES-EDE-CFB";
pub const LN_des_ede_cfb64 = "des-ede-cfb";
pub const NID_des_ede_cfb64 = @as(c_int, 60);
pub const SN_des_ede3_cfb64 = "DES-EDE3-CFB";
pub const LN_des_ede3_cfb64 = "des-ede3-cfb";
pub const NID_des_ede3_cfb64 = @as(c_int, 61);
pub const SN_des_ede_ofb64 = "DES-EDE-OFB";
pub const LN_des_ede_ofb64 = "des-ede-ofb";
pub const NID_des_ede_ofb64 = @as(c_int, 62);
pub const SN_des_ede3_ofb64 = "DES-EDE3-OFB";
pub const LN_des_ede3_ofb64 = "des-ede3-ofb";
pub const NID_des_ede3_ofb64 = @as(c_int, 63);
pub const SN_desx_cbc = "DESX-CBC";
pub const LN_desx_cbc = "desx-cbc";
pub const NID_desx_cbc = @as(c_int, 80);
pub const SN_sha = "SHA";
pub const LN_sha = "sha";
pub const NID_sha = @as(c_int, 41);
pub const OBJ_sha = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 18);
};
pub const SN_sha1 = "SHA1";
pub const LN_sha1 = "sha1";
pub const NID_sha1 = @as(c_int, 64);
pub const OBJ_sha1 = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 26);
};
pub const SN_dsaWithSHA1_2 = "DSA-SHA1-old";
pub const LN_dsaWithSHA1_2 = "dsaWithSHA1-old";
pub const NID_dsaWithSHA1_2 = @as(c_int, 70);
pub const OBJ_dsaWithSHA1_2 = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 27);
};
pub const SN_sha1WithRSA = "RSA-SHA1-2";
pub const LN_sha1WithRSA = "sha1WithRSA";
pub const NID_sha1WithRSA = @as(c_int, 115);
pub const OBJ_sha1WithRSA = blk: {
    _ = &OBJ_algorithm;
    break :blk @as(c_long, 29);
};
pub const SN_ripemd160 = "RIPEMD160";
pub const LN_ripemd160 = "ripemd160";
pub const NID_ripemd160 = @as(c_int, 117);
pub const OBJ_ripemd160 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_ripemd160WithRSA = "RSA-RIPEMD160";
pub const LN_ripemd160WithRSA = "ripemd160WithRSA";
pub const NID_ripemd160WithRSA = @as(c_int, 119);
pub const OBJ_ripemd160WithRSA = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_blake2bmac = "BLAKE2BMAC";
pub const LN_blake2bmac = "blake2bmac";
pub const NID_blake2bmac = @as(c_int, 1201);
pub const OBJ_blake2bmac = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1722);
    _ = @as(c_long, 12);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_blake2smac = "BLAKE2SMAC";
pub const LN_blake2smac = "blake2smac";
pub const NID_blake2smac = @as(c_int, 1202);
pub const OBJ_blake2smac = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1722);
    _ = @as(c_long, 12);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 2);
};
pub const SN_blake2b512 = "BLAKE2b512";
pub const LN_blake2b512 = "blake2b512";
pub const NID_blake2b512 = @as(c_int, 1056);
pub const OBJ_blake2b512 = blk: {
    _ = &OBJ_blake2bmac;
    break :blk @as(c_long, 16);
};
pub const SN_blake2s256 = "BLAKE2s256";
pub const LN_blake2s256 = "blake2s256";
pub const NID_blake2s256 = @as(c_int, 1057);
pub const OBJ_blake2s256 = blk: {
    _ = &OBJ_blake2smac;
    break :blk @as(c_long, 8);
};
pub const SN_sxnet = "SXNetID";
pub const LN_sxnet = "Strong Extranet ID";
pub const NID_sxnet = @as(c_int, 143);
pub const OBJ_sxnet = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 101);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 1);
};
pub const SN_X500 = "X500";
pub const LN_X500 = "directory services (X.500)";
pub const NID_X500 = @as(c_int, 11);
pub const OBJ_X500 = blk: {
    _ = @as(c_long, 2);
    break :blk @as(c_long, 5);
};
pub const SN_X509 = "X509";
pub const NID_X509 = @as(c_int, 12);
pub const OBJ_X509 = blk: {
    _ = &OBJ_X500;
    break :blk @as(c_long, 4);
};
pub const SN_commonName = "CN";
pub const LN_commonName = "commonName";
pub const NID_commonName = @as(c_int, 13);
pub const OBJ_commonName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 3);
};
pub const SN_surname = "SN";
pub const LN_surname = "surname";
pub const NID_surname = @as(c_int, 100);
pub const OBJ_surname = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 4);
};
pub const LN_serialNumber = "serialNumber";
pub const NID_serialNumber = @as(c_int, 105);
pub const OBJ_serialNumber = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 5);
};
pub const SN_countryName = "C";
pub const LN_countryName = "countryName";
pub const NID_countryName = @as(c_int, 14);
pub const OBJ_countryName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 6);
};
pub const SN_localityName = "L";
pub const LN_localityName = "localityName";
pub const NID_localityName = @as(c_int, 15);
pub const OBJ_localityName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 7);
};
pub const SN_stateOrProvinceName = "ST";
pub const LN_stateOrProvinceName = "stateOrProvinceName";
pub const NID_stateOrProvinceName = @as(c_int, 16);
pub const OBJ_stateOrProvinceName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 8);
};
pub const SN_streetAddress = "street";
pub const LN_streetAddress = "streetAddress";
pub const NID_streetAddress = @as(c_int, 660);
pub const OBJ_streetAddress = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 9);
};
pub const SN_organizationName = "O";
pub const LN_organizationName = "organizationName";
pub const NID_organizationName = @as(c_int, 17);
pub const OBJ_organizationName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 10);
};
pub const SN_organizationalUnitName = "OU";
pub const LN_organizationalUnitName = "organizationalUnitName";
pub const NID_organizationalUnitName = @as(c_int, 18);
pub const OBJ_organizationalUnitName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 11);
};
pub const SN_title = "title";
pub const LN_title = "title";
pub const NID_title = @as(c_int, 106);
pub const OBJ_title = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 12);
};
pub const LN_description = "description";
pub const NID_description = @as(c_int, 107);
pub const OBJ_description = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 13);
};
pub const LN_searchGuide = "searchGuide";
pub const NID_searchGuide = @as(c_int, 859);
pub const OBJ_searchGuide = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 14);
};
pub const LN_businessCategory = "businessCategory";
pub const NID_businessCategory = @as(c_int, 860);
pub const OBJ_businessCategory = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 15);
};
pub const LN_postalAddress = "postalAddress";
pub const NID_postalAddress = @as(c_int, 861);
pub const OBJ_postalAddress = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 16);
};
pub const LN_postalCode = "postalCode";
pub const NID_postalCode = @as(c_int, 661);
pub const OBJ_postalCode = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 17);
};
pub const LN_postOfficeBox = "postOfficeBox";
pub const NID_postOfficeBox = @as(c_int, 862);
pub const OBJ_postOfficeBox = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 18);
};
pub const LN_physicalDeliveryOfficeName = "physicalDeliveryOfficeName";
pub const NID_physicalDeliveryOfficeName = @as(c_int, 863);
pub const OBJ_physicalDeliveryOfficeName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 19);
};
pub const LN_telephoneNumber = "telephoneNumber";
pub const NID_telephoneNumber = @as(c_int, 864);
pub const OBJ_telephoneNumber = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 20);
};
pub const LN_telexNumber = "telexNumber";
pub const NID_telexNumber = @as(c_int, 865);
pub const OBJ_telexNumber = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 21);
};
pub const LN_teletexTerminalIdentifier = "teletexTerminalIdentifier";
pub const NID_teletexTerminalIdentifier = @as(c_int, 866);
pub const OBJ_teletexTerminalIdentifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 22);
};
pub const LN_facsimileTelephoneNumber = "facsimileTelephoneNumber";
pub const NID_facsimileTelephoneNumber = @as(c_int, 867);
pub const OBJ_facsimileTelephoneNumber = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 23);
};
pub const LN_x121Address = "x121Address";
pub const NID_x121Address = @as(c_int, 868);
pub const OBJ_x121Address = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 24);
};
pub const LN_internationaliSDNNumber = "internationaliSDNNumber";
pub const NID_internationaliSDNNumber = @as(c_int, 869);
pub const OBJ_internationaliSDNNumber = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 25);
};
pub const LN_registeredAddress = "registeredAddress";
pub const NID_registeredAddress = @as(c_int, 870);
pub const OBJ_registeredAddress = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 26);
};
pub const LN_destinationIndicator = "destinationIndicator";
pub const NID_destinationIndicator = @as(c_int, 871);
pub const OBJ_destinationIndicator = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 27);
};
pub const LN_preferredDeliveryMethod = "preferredDeliveryMethod";
pub const NID_preferredDeliveryMethod = @as(c_int, 872);
pub const OBJ_preferredDeliveryMethod = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 28);
};
pub const LN_presentationAddress = "presentationAddress";
pub const NID_presentationAddress = @as(c_int, 873);
pub const OBJ_presentationAddress = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 29);
};
pub const LN_supportedApplicationContext = "supportedApplicationContext";
pub const NID_supportedApplicationContext = @as(c_int, 874);
pub const OBJ_supportedApplicationContext = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 30);
};
pub const SN_member = "member";
pub const NID_member = @as(c_int, 875);
pub const OBJ_member = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 31);
};
pub const SN_owner = "owner";
pub const NID_owner = @as(c_int, 876);
pub const OBJ_owner = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 32);
};
pub const LN_roleOccupant = "roleOccupant";
pub const NID_roleOccupant = @as(c_int, 877);
pub const OBJ_roleOccupant = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 33);
};
pub const SN_seeAlso = "seeAlso";
pub const NID_seeAlso = @as(c_int, 878);
pub const OBJ_seeAlso = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 34);
};
pub const LN_userPassword = "userPassword";
pub const NID_userPassword = @as(c_int, 879);
pub const OBJ_userPassword = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 35);
};
pub const LN_userCertificate = "userCertificate";
pub const NID_userCertificate = @as(c_int, 880);
pub const OBJ_userCertificate = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 36);
};
pub const LN_cACertificate = "cACertificate";
pub const NID_cACertificate = @as(c_int, 881);
pub const OBJ_cACertificate = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 37);
};
pub const LN_authorityRevocationList = "authorityRevocationList";
pub const NID_authorityRevocationList = @as(c_int, 882);
pub const OBJ_authorityRevocationList = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 38);
};
pub const LN_certificateRevocationList = "certificateRevocationList";
pub const NID_certificateRevocationList = @as(c_int, 883);
pub const OBJ_certificateRevocationList = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 39);
};
pub const LN_crossCertificatePair = "crossCertificatePair";
pub const NID_crossCertificatePair = @as(c_int, 884);
pub const OBJ_crossCertificatePair = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 40);
};
pub const SN_name = "name";
pub const LN_name = "name";
pub const NID_name = @as(c_int, 173);
pub const OBJ_name = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 41);
};
pub const SN_givenName = "GN";
pub const LN_givenName = "givenName";
pub const NID_givenName = @as(c_int, 99);
pub const OBJ_givenName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 42);
};
pub const SN_initials = "initials";
pub const LN_initials = "initials";
pub const NID_initials = @as(c_int, 101);
pub const OBJ_initials = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 43);
};
pub const LN_generationQualifier = "generationQualifier";
pub const NID_generationQualifier = @as(c_int, 509);
pub const OBJ_generationQualifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 44);
};
pub const LN_x500UniqueIdentifier = "x500UniqueIdentifier";
pub const NID_x500UniqueIdentifier = @as(c_int, 503);
pub const OBJ_x500UniqueIdentifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 45);
};
pub const SN_dnQualifier = "dnQualifier";
pub const LN_dnQualifier = "dnQualifier";
pub const NID_dnQualifier = @as(c_int, 174);
pub const OBJ_dnQualifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 46);
};
pub const LN_enhancedSearchGuide = "enhancedSearchGuide";
pub const NID_enhancedSearchGuide = @as(c_int, 885);
pub const OBJ_enhancedSearchGuide = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 47);
};
pub const LN_protocolInformation = "protocolInformation";
pub const NID_protocolInformation = @as(c_int, 886);
pub const OBJ_protocolInformation = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 48);
};
pub const LN_distinguishedName = "distinguishedName";
pub const NID_distinguishedName = @as(c_int, 887);
pub const OBJ_distinguishedName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 49);
};
pub const LN_uniqueMember = "uniqueMember";
pub const NID_uniqueMember = @as(c_int, 888);
pub const OBJ_uniqueMember = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 50);
};
pub const LN_houseIdentifier = "houseIdentifier";
pub const NID_houseIdentifier = @as(c_int, 889);
pub const OBJ_houseIdentifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 51);
};
pub const LN_supportedAlgorithms = "supportedAlgorithms";
pub const NID_supportedAlgorithms = @as(c_int, 890);
pub const OBJ_supportedAlgorithms = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 52);
};
pub const LN_deltaRevocationList = "deltaRevocationList";
pub const NID_deltaRevocationList = @as(c_int, 891);
pub const OBJ_deltaRevocationList = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 53);
};
pub const SN_dmdName = "dmdName";
pub const NID_dmdName = @as(c_int, 892);
pub const OBJ_dmdName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 54);
};
pub const LN_pseudonym = "pseudonym";
pub const NID_pseudonym = @as(c_int, 510);
pub const OBJ_pseudonym = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 65);
};
pub const SN_role = "role";
pub const LN_role = "role";
pub const NID_role = @as(c_int, 400);
pub const OBJ_role = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 72);
};
pub const LN_organizationIdentifier = "organizationIdentifier";
pub const NID_organizationIdentifier = @as(c_int, 1089);
pub const OBJ_organizationIdentifier = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 97);
};
pub const SN_countryCode3c = "c3";
pub const LN_countryCode3c = "countryCode3c";
pub const NID_countryCode3c = @as(c_int, 1090);
pub const OBJ_countryCode3c = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 98);
};
pub const SN_countryCode3n = "n3";
pub const LN_countryCode3n = "countryCode3n";
pub const NID_countryCode3n = @as(c_int, 1091);
pub const OBJ_countryCode3n = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 99);
};
pub const LN_dnsName = "dnsName";
pub const NID_dnsName = @as(c_int, 1092);
pub const OBJ_dnsName = blk: {
    _ = &OBJ_X509;
    break :blk @as(c_long, 100);
};
pub const SN_X500algorithms = "X500algorithms";
pub const LN_X500algorithms = "directory services - algorithms";
pub const NID_X500algorithms = @as(c_int, 378);
pub const OBJ_X500algorithms = blk: {
    _ = &OBJ_X500;
    break :blk @as(c_long, 8);
};
pub const SN_rsa = "RSA";
pub const LN_rsa = "rsa";
pub const NID_rsa = @as(c_int, 19);
pub const OBJ_rsa = blk: {
    _ = &OBJ_X500algorithms;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_mdc2WithRSA = "RSA-MDC2";
pub const LN_mdc2WithRSA = "mdc2WithRSA";
pub const NID_mdc2WithRSA = @as(c_int, 96);
pub const OBJ_mdc2WithRSA = blk: {
    _ = &OBJ_X500algorithms;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 100);
};
pub const SN_mdc2 = "MDC2";
pub const LN_mdc2 = "mdc2";
pub const NID_mdc2 = @as(c_int, 95);
pub const OBJ_mdc2 = blk: {
    _ = &OBJ_X500algorithms;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 101);
};
pub const SN_id_ce = "id-ce";
pub const NID_id_ce = @as(c_int, 81);
pub const OBJ_id_ce = blk: {
    _ = &OBJ_X500;
    break :blk @as(c_long, 29);
};
pub const SN_subject_directory_attributes = "subjectDirectoryAttributes";
pub const LN_subject_directory_attributes = "X509v3 Subject Directory Attributes";
pub const NID_subject_directory_attributes = @as(c_int, 769);
pub const OBJ_subject_directory_attributes = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 9);
};
pub const SN_subject_key_identifier = "subjectKeyIdentifier";
pub const LN_subject_key_identifier = "X509v3 Subject Key Identifier";
pub const NID_subject_key_identifier = @as(c_int, 82);
pub const OBJ_subject_key_identifier = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 14);
};
pub const SN_key_usage = "keyUsage";
pub const LN_key_usage = "X509v3 Key Usage";
pub const NID_key_usage = @as(c_int, 83);
pub const OBJ_key_usage = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 15);
};
pub const SN_private_key_usage_period = "privateKeyUsagePeriod";
pub const LN_private_key_usage_period = "X509v3 Private Key Usage Period";
pub const NID_private_key_usage_period = @as(c_int, 84);
pub const OBJ_private_key_usage_period = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 16);
};
pub const SN_subject_alt_name = "subjectAltName";
pub const LN_subject_alt_name = "X509v3 Subject Alternative Name";
pub const NID_subject_alt_name = @as(c_int, 85);
pub const OBJ_subject_alt_name = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 17);
};
pub const SN_issuer_alt_name = "issuerAltName";
pub const LN_issuer_alt_name = "X509v3 Issuer Alternative Name";
pub const NID_issuer_alt_name = @as(c_int, 86);
pub const OBJ_issuer_alt_name = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 18);
};
pub const SN_basic_constraints = "basicConstraints";
pub const LN_basic_constraints = "X509v3 Basic Constraints";
pub const NID_basic_constraints = @as(c_int, 87);
pub const OBJ_basic_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 19);
};
pub const SN_crl_number = "crlNumber";
pub const LN_crl_number = "X509v3 CRL Number";
pub const NID_crl_number = @as(c_int, 88);
pub const OBJ_crl_number = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 20);
};
pub const SN_crl_reason = "CRLReason";
pub const LN_crl_reason = "X509v3 CRL Reason Code";
pub const NID_crl_reason = @as(c_int, 141);
pub const OBJ_crl_reason = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 21);
};
pub const SN_invalidity_date = "invalidityDate";
pub const LN_invalidity_date = "Invalidity Date";
pub const NID_invalidity_date = @as(c_int, 142);
pub const OBJ_invalidity_date = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 24);
};
pub const SN_delta_crl = "deltaCRL";
pub const LN_delta_crl = "X509v3 Delta CRL Indicator";
pub const NID_delta_crl = @as(c_int, 140);
pub const OBJ_delta_crl = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 27);
};
pub const SN_issuing_distribution_point = "issuingDistributionPoint";
pub const LN_issuing_distribution_point = "X509v3 Issuing Distribution Point";
pub const NID_issuing_distribution_point = @as(c_int, 770);
pub const OBJ_issuing_distribution_point = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 28);
};
pub const SN_certificate_issuer = "certificateIssuer";
pub const LN_certificate_issuer = "X509v3 Certificate Issuer";
pub const NID_certificate_issuer = @as(c_int, 771);
pub const OBJ_certificate_issuer = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 29);
};
pub const SN_name_constraints = "nameConstraints";
pub const LN_name_constraints = "X509v3 Name Constraints";
pub const NID_name_constraints = @as(c_int, 666);
pub const OBJ_name_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 30);
};
pub const SN_crl_distribution_points = "crlDistributionPoints";
pub const LN_crl_distribution_points = "X509v3 CRL Distribution Points";
pub const NID_crl_distribution_points = @as(c_int, 103);
pub const OBJ_crl_distribution_points = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 31);
};
pub const SN_certificate_policies = "certificatePolicies";
pub const LN_certificate_policies = "X509v3 Certificate Policies";
pub const NID_certificate_policies = @as(c_int, 89);
pub const OBJ_certificate_policies = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 32);
};
pub const SN_any_policy = "anyPolicy";
pub const LN_any_policy = "X509v3 Any Policy";
pub const NID_any_policy = @as(c_int, 746);
pub const OBJ_any_policy = blk: {
    _ = &OBJ_certificate_policies;
    break :blk @as(c_long, 0);
};
pub const SN_policy_mappings = "policyMappings";
pub const LN_policy_mappings = "X509v3 Policy Mappings";
pub const NID_policy_mappings = @as(c_int, 747);
pub const OBJ_policy_mappings = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 33);
};
pub const SN_authority_key_identifier = "authorityKeyIdentifier";
pub const LN_authority_key_identifier = "X509v3 Authority Key Identifier";
pub const NID_authority_key_identifier = @as(c_int, 90);
pub const OBJ_authority_key_identifier = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 35);
};
pub const SN_policy_constraints = "policyConstraints";
pub const LN_policy_constraints = "X509v3 Policy Constraints";
pub const NID_policy_constraints = @as(c_int, 401);
pub const OBJ_policy_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 36);
};
pub const SN_ext_key_usage = "extendedKeyUsage";
pub const LN_ext_key_usage = "X509v3 Extended Key Usage";
pub const NID_ext_key_usage = @as(c_int, 126);
pub const OBJ_ext_key_usage = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 37);
};
pub const SN_authority_attribute_identifier = "authorityAttributeIdentifier";
pub const LN_authority_attribute_identifier = "X509v3 Authority Attribute Identifier";
pub const NID_authority_attribute_identifier = @as(c_int, 1295);
pub const OBJ_authority_attribute_identifier = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 38);
};
pub const SN_role_spec_cert_identifier = "roleSpecCertIdentifier";
pub const LN_role_spec_cert_identifier = "X509v3 Role Specification Certificate Identifier";
pub const NID_role_spec_cert_identifier = @as(c_int, 1296);
pub const OBJ_role_spec_cert_identifier = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 39);
};
pub const SN_basic_att_constraints = "basicAttConstraints";
pub const LN_basic_att_constraints = "X509v3 Basic Attribute Certificate Constraints";
pub const NID_basic_att_constraints = @as(c_int, 1297);
pub const OBJ_basic_att_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 41);
};
pub const SN_delegated_name_constraints = "delegatedNameConstraints";
pub const LN_delegated_name_constraints = "X509v3 Delegated Name Constraints";
pub const NID_delegated_name_constraints = @as(c_int, 1298);
pub const OBJ_delegated_name_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 42);
};
pub const SN_time_specification = "timeSpecification";
pub const LN_time_specification = "X509v3 Time Specification";
pub const NID_time_specification = @as(c_int, 1299);
pub const OBJ_time_specification = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 43);
};
pub const SN_freshest_crl = "freshestCRL";
pub const LN_freshest_crl = "X509v3 Freshest CRL";
pub const NID_freshest_crl = @as(c_int, 857);
pub const OBJ_freshest_crl = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 46);
};
pub const SN_attribute_descriptor = "attributeDescriptor";
pub const LN_attribute_descriptor = "X509v3 Attribute Descriptor";
pub const NID_attribute_descriptor = @as(c_int, 1300);
pub const OBJ_attribute_descriptor = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 48);
};
pub const SN_user_notice = "userNotice";
pub const LN_user_notice = "X509v3 User Notice";
pub const NID_user_notice = @as(c_int, 1301);
pub const OBJ_user_notice = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 49);
};
pub const SN_soa_identifier = "sOAIdentifier";
pub const LN_soa_identifier = "X509v3 Source of Authority Identifier";
pub const NID_soa_identifier = @as(c_int, 1302);
pub const OBJ_soa_identifier = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 50);
};
pub const SN_acceptable_cert_policies = "acceptableCertPolicies";
pub const LN_acceptable_cert_policies = "X509v3 Acceptable Certification Policies";
pub const NID_acceptable_cert_policies = @as(c_int, 1303);
pub const OBJ_acceptable_cert_policies = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 52);
};
pub const SN_inhibit_any_policy = "inhibitAnyPolicy";
pub const LN_inhibit_any_policy = "X509v3 Inhibit Any Policy";
pub const NID_inhibit_any_policy = @as(c_int, 748);
pub const OBJ_inhibit_any_policy = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 54);
};
pub const SN_target_information = "targetInformation";
pub const LN_target_information = "X509v3 AC Targeting";
pub const NID_target_information = @as(c_int, 402);
pub const OBJ_target_information = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 55);
};
pub const SN_no_rev_avail = "noRevAvail";
pub const LN_no_rev_avail = "X509v3 No Revocation Available";
pub const NID_no_rev_avail = @as(c_int, 403);
pub const OBJ_no_rev_avail = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 56);
};
pub const SN_acceptable_privilege_policies = "acceptablePrivPolicies";
pub const LN_acceptable_privilege_policies = "X509v3 Acceptable Privilege Policies";
pub const NID_acceptable_privilege_policies = @as(c_int, 1304);
pub const OBJ_acceptable_privilege_policies = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 57);
};
pub const SN_indirect_issuer = "indirectIssuer";
pub const LN_indirect_issuer = "X509v3 Indirect Issuer";
pub const NID_indirect_issuer = @as(c_int, 1305);
pub const OBJ_indirect_issuer = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 61);
};
pub const SN_no_assertion = "noAssertion";
pub const LN_no_assertion = "X509v3 No Assertion";
pub const NID_no_assertion = @as(c_int, 1306);
pub const OBJ_no_assertion = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 62);
};
pub const SN_id_aa_issuing_distribution_point = "aAissuingDistributionPoint";
pub const LN_id_aa_issuing_distribution_point = "X509v3 Attribute Authority Issuing Distribution Point";
pub const NID_id_aa_issuing_distribution_point = @as(c_int, 1307);
pub const OBJ_id_aa_issuing_distribution_point = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 63);
};
pub const SN_issued_on_behalf_of = "issuedOnBehalfOf";
pub const LN_issued_on_behalf_of = "X509v3 Issued On Behalf Of";
pub const NID_issued_on_behalf_of = @as(c_int, 1308);
pub const OBJ_issued_on_behalf_of = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 64);
};
pub const SN_single_use = "singleUse";
pub const LN_single_use = "X509v3 Single Use";
pub const NID_single_use = @as(c_int, 1309);
pub const OBJ_single_use = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 65);
};
pub const SN_group_ac = "groupAC";
pub const LN_group_ac = "X509v3 Group Attribute Certificate";
pub const NID_group_ac = @as(c_int, 1310);
pub const OBJ_group_ac = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 66);
};
pub const SN_allowed_attribute_assignments = "allowedAttributeAssignments";
pub const LN_allowed_attribute_assignments = "X509v3 Allowed Attribute Assignments";
pub const NID_allowed_attribute_assignments = @as(c_int, 1311);
pub const OBJ_allowed_attribute_assignments = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 67);
};
pub const SN_attribute_mappings = "attributeMappings";
pub const LN_attribute_mappings = "X509v3 Attribute Mappings";
pub const NID_attribute_mappings = @as(c_int, 1312);
pub const OBJ_attribute_mappings = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 68);
};
pub const SN_holder_name_constraints = "holderNameConstraints";
pub const LN_holder_name_constraints = "X509v3 Holder Name Constraints";
pub const NID_holder_name_constraints = @as(c_int, 1313);
pub const OBJ_holder_name_constraints = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 69);
};
pub const SN_authorization_validation = "authorizationValidation";
pub const LN_authorization_validation = "X509v3 Authorization Validation";
pub const NID_authorization_validation = @as(c_int, 1314);
pub const OBJ_authorization_validation = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 70);
};
pub const SN_prot_restrict = "protRestrict";
pub const LN_prot_restrict = "X509v3 Protocol Restriction";
pub const NID_prot_restrict = @as(c_int, 1315);
pub const OBJ_prot_restrict = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 71);
};
pub const SN_subject_alt_public_key_info = "subjectAltPublicKeyInfo";
pub const LN_subject_alt_public_key_info = "X509v3 Subject Alternative Public Key Info";
pub const NID_subject_alt_public_key_info = @as(c_int, 1316);
pub const OBJ_subject_alt_public_key_info = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 72);
};
pub const SN_alt_signature_algorithm = "altSignatureAlgorithm";
pub const LN_alt_signature_algorithm = "X509v3 Alternative Signature Algorithm";
pub const NID_alt_signature_algorithm = @as(c_int, 1317);
pub const OBJ_alt_signature_algorithm = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 73);
};
pub const SN_alt_signature_value = "altSignatureValue";
pub const LN_alt_signature_value = "X509v3 Alternative Signature Value";
pub const NID_alt_signature_value = @as(c_int, 1318);
pub const OBJ_alt_signature_value = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 74);
};
pub const SN_associated_information = "associatedInformation";
pub const LN_associated_information = "X509v3 Associated Information";
pub const NID_associated_information = @as(c_int, 1319);
pub const OBJ_associated_information = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 75);
};
pub const SN_anyExtendedKeyUsage = "anyExtendedKeyUsage";
pub const LN_anyExtendedKeyUsage = "Any Extended Key Usage";
pub const NID_anyExtendedKeyUsage = @as(c_int, 910);
pub const OBJ_anyExtendedKeyUsage = blk: {
    _ = &OBJ_ext_key_usage;
    break :blk @as(c_long, 0);
};
pub const SN_netscape = "Netscape";
pub const LN_netscape = "Netscape Communications Corp.";
pub const NID_netscape = @as(c_int, 57);
pub const OBJ_netscape = blk: {
    _ = @as(c_long, 2);
    _ = @as(c_long, 16);
    _ = @as(c_long, 840);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 113730);
};
pub const SN_netscape_cert_extension = "nsCertExt";
pub const LN_netscape_cert_extension = "Netscape Certificate Extension";
pub const NID_netscape_cert_extension = @as(c_int, 58);
pub const OBJ_netscape_cert_extension = blk: {
    _ = &OBJ_netscape;
    break :blk @as(c_long, 1);
};
pub const SN_netscape_data_type = "nsDataType";
pub const LN_netscape_data_type = "Netscape Data Type";
pub const NID_netscape_data_type = @as(c_int, 59);
pub const OBJ_netscape_data_type = blk: {
    _ = &OBJ_netscape;
    break :blk @as(c_long, 2);
};
pub const SN_netscape_cert_type = "nsCertType";
pub const LN_netscape_cert_type = "Netscape Cert Type";
pub const NID_netscape_cert_type = @as(c_int, 71);
pub const OBJ_netscape_cert_type = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 1);
};
pub const SN_netscape_base_url = "nsBaseUrl";
pub const LN_netscape_base_url = "Netscape Base Url";
pub const NID_netscape_base_url = @as(c_int, 72);
pub const OBJ_netscape_base_url = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 2);
};
pub const SN_netscape_revocation_url = "nsRevocationUrl";
pub const LN_netscape_revocation_url = "Netscape Revocation Url";
pub const NID_netscape_revocation_url = @as(c_int, 73);
pub const OBJ_netscape_revocation_url = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 3);
};
pub const SN_netscape_ca_revocation_url = "nsCaRevocationUrl";
pub const LN_netscape_ca_revocation_url = "Netscape CA Revocation Url";
pub const NID_netscape_ca_revocation_url = @as(c_int, 74);
pub const OBJ_netscape_ca_revocation_url = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 4);
};
pub const SN_netscape_renewal_url = "nsRenewalUrl";
pub const LN_netscape_renewal_url = "Netscape Renewal Url";
pub const NID_netscape_renewal_url = @as(c_int, 75);
pub const OBJ_netscape_renewal_url = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 7);
};
pub const SN_netscape_ca_policy_url = "nsCaPolicyUrl";
pub const LN_netscape_ca_policy_url = "Netscape CA Policy Url";
pub const NID_netscape_ca_policy_url = @as(c_int, 76);
pub const OBJ_netscape_ca_policy_url = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 8);
};
pub const SN_netscape_ssl_server_name = "nsSslServerName";
pub const LN_netscape_ssl_server_name = "Netscape SSL Server Name";
pub const NID_netscape_ssl_server_name = @as(c_int, 77);
pub const OBJ_netscape_ssl_server_name = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 12);
};
pub const SN_netscape_comment = "nsComment";
pub const LN_netscape_comment = "Netscape Comment";
pub const NID_netscape_comment = @as(c_int, 78);
pub const OBJ_netscape_comment = blk: {
    _ = &OBJ_netscape_cert_extension;
    break :blk @as(c_long, 13);
};
pub const SN_netscape_cert_sequence = "nsCertSequence";
pub const LN_netscape_cert_sequence = "Netscape Certificate Sequence";
pub const NID_netscape_cert_sequence = @as(c_int, 79);
pub const OBJ_netscape_cert_sequence = blk: {
    _ = &OBJ_netscape_data_type;
    break :blk @as(c_long, 5);
};
pub const SN_ns_sgc = "nsSGC";
pub const LN_ns_sgc = "Netscape Server Gated Crypto";
pub const NID_ns_sgc = @as(c_int, 139);
pub const OBJ_ns_sgc = blk: {
    _ = &OBJ_netscape;
    _ = @as(c_long, 4);
    break :blk @as(c_long, 1);
};
pub const SN_org = "ORG";
pub const LN_org = "org";
pub const NID_org = @as(c_int, 379);
pub const OBJ_org = blk: {
    _ = &OBJ_iso;
    break :blk @as(c_long, 3);
};
pub const SN_dod = "DOD";
pub const LN_dod = "dod";
pub const NID_dod = @as(c_int, 380);
pub const OBJ_dod = blk: {
    _ = &OBJ_org;
    break :blk @as(c_long, 6);
};
pub const SN_iana = "IANA";
pub const LN_iana = "iana";
pub const NID_iana = @as(c_int, 381);
pub const OBJ_iana = blk: {
    _ = &OBJ_dod;
    break :blk @as(c_long, 1);
};
pub const OBJ_internet = OBJ_iana;
pub const SN_Directory = "directory";
pub const LN_Directory = "Directory";
pub const NID_Directory = @as(c_int, 382);
pub const OBJ_Directory = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 1);
};
pub const SN_Management = "mgmt";
pub const LN_Management = "Management";
pub const NID_Management = @as(c_int, 383);
pub const OBJ_Management = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 2);
};
pub const SN_Experimental = "experimental";
pub const LN_Experimental = "Experimental";
pub const NID_Experimental = @as(c_int, 384);
pub const OBJ_Experimental = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 3);
};
pub const SN_Private = "private";
pub const LN_Private = "Private";
pub const NID_Private = @as(c_int, 385);
pub const OBJ_Private = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 4);
};
pub const SN_Security = "security";
pub const LN_Security = "Security";
pub const NID_Security = @as(c_int, 386);
pub const OBJ_Security = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 5);
};
pub const SN_SNMPv2 = "snmpv2";
pub const LN_SNMPv2 = "SNMPv2";
pub const NID_SNMPv2 = @as(c_int, 387);
pub const OBJ_SNMPv2 = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 6);
};
pub const LN_Mail = "Mail";
pub const NID_Mail = @as(c_int, 388);
pub const OBJ_Mail = blk: {
    _ = &OBJ_internet;
    break :blk @as(c_long, 7);
};
pub const SN_Enterprises = "enterprises";
pub const LN_Enterprises = "Enterprises";
pub const NID_Enterprises = @as(c_int, 389);
pub const OBJ_Enterprises = blk: {
    _ = &OBJ_Private;
    break :blk @as(c_long, 1);
};
pub const SN_dcObject = "dcobject";
pub const LN_dcObject = "dcObject";
pub const NID_dcObject = @as(c_int, 390);
pub const OBJ_dcObject = blk: {
    _ = &OBJ_Enterprises;
    _ = @as(c_long, 1466);
    break :blk @as(c_long, 344);
};
pub const SN_id_kp_wisun_fan_device = "id-kp-wisun-fan-device";
pub const LN_id_kp_wisun_fan_device = "Wi-SUN Alliance Field Area Network (FAN)";
pub const NID_id_kp_wisun_fan_device = @as(c_int, 1322);
pub const OBJ_id_kp_wisun_fan_device = blk: {
    _ = &OBJ_Enterprises;
    _ = @as(c_long, 45605);
    break :blk @as(c_long, 1);
};
pub const SN_mime_mhs = "mime-mhs";
pub const LN_mime_mhs = "MIME MHS";
pub const NID_mime_mhs = @as(c_int, 504);
pub const OBJ_mime_mhs = blk: {
    _ = &OBJ_Mail;
    break :blk @as(c_long, 1);
};
pub const SN_mime_mhs_headings = "mime-mhs-headings";
pub const LN_mime_mhs_headings = "mime-mhs-headings";
pub const NID_mime_mhs_headings = @as(c_int, 505);
pub const OBJ_mime_mhs_headings = blk: {
    _ = &OBJ_mime_mhs;
    break :blk @as(c_long, 1);
};
pub const SN_mime_mhs_bodies = "mime-mhs-bodies";
pub const LN_mime_mhs_bodies = "mime-mhs-bodies";
pub const NID_mime_mhs_bodies = @as(c_int, 506);
pub const OBJ_mime_mhs_bodies = blk: {
    _ = &OBJ_mime_mhs;
    break :blk @as(c_long, 2);
};
pub const SN_id_hex_partial_message = "id-hex-partial-message";
pub const LN_id_hex_partial_message = "id-hex-partial-message";
pub const NID_id_hex_partial_message = @as(c_int, 507);
pub const OBJ_id_hex_partial_message = blk: {
    _ = &OBJ_mime_mhs_headings;
    break :blk @as(c_long, 1);
};
pub const SN_id_hex_multipart_message = "id-hex-multipart-message";
pub const LN_id_hex_multipart_message = "id-hex-multipart-message";
pub const NID_id_hex_multipart_message = @as(c_int, 508);
pub const OBJ_id_hex_multipart_message = blk: {
    _ = &OBJ_mime_mhs_headings;
    break :blk @as(c_long, 2);
};
pub const SN_zlib_compression = "ZLIB";
pub const LN_zlib_compression = "zlib compression";
pub const NID_zlib_compression = @as(c_int, 125);
pub const OBJ_zlib_compression = blk: {
    _ = &OBJ_id_smime_alg;
    break :blk @as(c_long, 8);
};
pub const OBJ_csor = blk: {
    _ = @as(c_long, 2);
    _ = @as(c_long, 16);
    _ = @as(c_long, 840);
    _ = @as(c_long, 1);
    _ = @as(c_long, 101);
    break :blk @as(c_long, 3);
};
pub const OBJ_nistAlgorithms = blk: {
    _ = &OBJ_csor;
    break :blk @as(c_long, 4);
};
pub const OBJ_aes = blk: {
    _ = &OBJ_nistAlgorithms;
    break :blk @as(c_long, 1);
};
pub const SN_aes_128_ecb = "AES-128-ECB";
pub const LN_aes_128_ecb = "aes-128-ecb";
pub const NID_aes_128_ecb = @as(c_int, 418);
pub const OBJ_aes_128_ecb = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 1);
};
pub const SN_aes_128_cbc = "AES-128-CBC";
pub const LN_aes_128_cbc = "aes-128-cbc";
pub const NID_aes_128_cbc = @as(c_int, 419);
pub const OBJ_aes_128_cbc = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 2);
};
pub const SN_aes_128_ofb128 = "AES-128-OFB";
pub const LN_aes_128_ofb128 = "aes-128-ofb";
pub const NID_aes_128_ofb128 = @as(c_int, 420);
pub const OBJ_aes_128_ofb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 3);
};
pub const SN_aes_128_cfb128 = "AES-128-CFB";
pub const LN_aes_128_cfb128 = "aes-128-cfb";
pub const NID_aes_128_cfb128 = @as(c_int, 421);
pub const OBJ_aes_128_cfb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 4);
};
pub const SN_id_aes128_wrap = "id-aes128-wrap";
pub const NID_id_aes128_wrap = @as(c_int, 788);
pub const OBJ_id_aes128_wrap = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 5);
};
pub const SN_aes_128_gcm = "id-aes128-GCM";
pub const LN_aes_128_gcm = "aes-128-gcm";
pub const NID_aes_128_gcm = @as(c_int, 895);
pub const OBJ_aes_128_gcm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 6);
};
pub const SN_aes_128_ccm = "id-aes128-CCM";
pub const LN_aes_128_ccm = "aes-128-ccm";
pub const NID_aes_128_ccm = @as(c_int, 896);
pub const OBJ_aes_128_ccm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 7);
};
pub const SN_id_aes128_wrap_pad = "id-aes128-wrap-pad";
pub const NID_id_aes128_wrap_pad = @as(c_int, 897);
pub const OBJ_id_aes128_wrap_pad = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 8);
};
pub const SN_aes_192_ecb = "AES-192-ECB";
pub const LN_aes_192_ecb = "aes-192-ecb";
pub const NID_aes_192_ecb = @as(c_int, 422);
pub const OBJ_aes_192_ecb = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 21);
};
pub const SN_aes_192_cbc = "AES-192-CBC";
pub const LN_aes_192_cbc = "aes-192-cbc";
pub const NID_aes_192_cbc = @as(c_int, 423);
pub const OBJ_aes_192_cbc = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 22);
};
pub const SN_aes_192_ofb128 = "AES-192-OFB";
pub const LN_aes_192_ofb128 = "aes-192-ofb";
pub const NID_aes_192_ofb128 = @as(c_int, 424);
pub const OBJ_aes_192_ofb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 23);
};
pub const SN_aes_192_cfb128 = "AES-192-CFB";
pub const LN_aes_192_cfb128 = "aes-192-cfb";
pub const NID_aes_192_cfb128 = @as(c_int, 425);
pub const OBJ_aes_192_cfb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 24);
};
pub const SN_id_aes192_wrap = "id-aes192-wrap";
pub const NID_id_aes192_wrap = @as(c_int, 789);
pub const OBJ_id_aes192_wrap = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 25);
};
pub const SN_aes_192_gcm = "id-aes192-GCM";
pub const LN_aes_192_gcm = "aes-192-gcm";
pub const NID_aes_192_gcm = @as(c_int, 898);
pub const OBJ_aes_192_gcm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 26);
};
pub const SN_aes_192_ccm = "id-aes192-CCM";
pub const LN_aes_192_ccm = "aes-192-ccm";
pub const NID_aes_192_ccm = @as(c_int, 899);
pub const OBJ_aes_192_ccm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 27);
};
pub const SN_id_aes192_wrap_pad = "id-aes192-wrap-pad";
pub const NID_id_aes192_wrap_pad = @as(c_int, 900);
pub const OBJ_id_aes192_wrap_pad = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 28);
};
pub const SN_aes_256_ecb = "AES-256-ECB";
pub const LN_aes_256_ecb = "aes-256-ecb";
pub const NID_aes_256_ecb = @as(c_int, 426);
pub const OBJ_aes_256_ecb = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 41);
};
pub const SN_aes_256_cbc = "AES-256-CBC";
pub const LN_aes_256_cbc = "aes-256-cbc";
pub const NID_aes_256_cbc = @as(c_int, 427);
pub const OBJ_aes_256_cbc = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 42);
};
pub const SN_aes_256_ofb128 = "AES-256-OFB";
pub const LN_aes_256_ofb128 = "aes-256-ofb";
pub const NID_aes_256_ofb128 = @as(c_int, 428);
pub const OBJ_aes_256_ofb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 43);
};
pub const SN_aes_256_cfb128 = "AES-256-CFB";
pub const LN_aes_256_cfb128 = "aes-256-cfb";
pub const NID_aes_256_cfb128 = @as(c_int, 429);
pub const OBJ_aes_256_cfb128 = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 44);
};
pub const SN_id_aes256_wrap = "id-aes256-wrap";
pub const NID_id_aes256_wrap = @as(c_int, 790);
pub const OBJ_id_aes256_wrap = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 45);
};
pub const SN_aes_256_gcm = "id-aes256-GCM";
pub const LN_aes_256_gcm = "aes-256-gcm";
pub const NID_aes_256_gcm = @as(c_int, 901);
pub const OBJ_aes_256_gcm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 46);
};
pub const SN_aes_256_ccm = "id-aes256-CCM";
pub const LN_aes_256_ccm = "aes-256-ccm";
pub const NID_aes_256_ccm = @as(c_int, 902);
pub const OBJ_aes_256_ccm = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 47);
};
pub const SN_id_aes256_wrap_pad = "id-aes256-wrap-pad";
pub const NID_id_aes256_wrap_pad = @as(c_int, 903);
pub const OBJ_id_aes256_wrap_pad = blk: {
    _ = &OBJ_aes;
    break :blk @as(c_long, 48);
};
pub const SN_aes_128_xts = "AES-128-XTS";
pub const LN_aes_128_xts = "aes-128-xts";
pub const NID_aes_128_xts = @as(c_int, 913);
pub const OBJ_aes_128_xts = blk: {
    _ = &OBJ_ieee_siswg;
    _ = @as(c_long, 0);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_aes_256_xts = "AES-256-XTS";
pub const LN_aes_256_xts = "aes-256-xts";
pub const NID_aes_256_xts = @as(c_int, 914);
pub const OBJ_aes_256_xts = blk: {
    _ = &OBJ_ieee_siswg;
    _ = @as(c_long, 0);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_aes_128_cfb1 = "AES-128-CFB1";
pub const LN_aes_128_cfb1 = "aes-128-cfb1";
pub const NID_aes_128_cfb1 = @as(c_int, 650);
pub const SN_aes_192_cfb1 = "AES-192-CFB1";
pub const LN_aes_192_cfb1 = "aes-192-cfb1";
pub const NID_aes_192_cfb1 = @as(c_int, 651);
pub const SN_aes_256_cfb1 = "AES-256-CFB1";
pub const LN_aes_256_cfb1 = "aes-256-cfb1";
pub const NID_aes_256_cfb1 = @as(c_int, 652);
pub const SN_aes_128_cfb8 = "AES-128-CFB8";
pub const LN_aes_128_cfb8 = "aes-128-cfb8";
pub const NID_aes_128_cfb8 = @as(c_int, 653);
pub const SN_aes_192_cfb8 = "AES-192-CFB8";
pub const LN_aes_192_cfb8 = "aes-192-cfb8";
pub const NID_aes_192_cfb8 = @as(c_int, 654);
pub const SN_aes_256_cfb8 = "AES-256-CFB8";
pub const LN_aes_256_cfb8 = "aes-256-cfb8";
pub const NID_aes_256_cfb8 = @as(c_int, 655);
pub const SN_aes_128_ctr = "AES-128-CTR";
pub const LN_aes_128_ctr = "aes-128-ctr";
pub const NID_aes_128_ctr = @as(c_int, 904);
pub const SN_aes_192_ctr = "AES-192-CTR";
pub const LN_aes_192_ctr = "aes-192-ctr";
pub const NID_aes_192_ctr = @as(c_int, 905);
pub const SN_aes_256_ctr = "AES-256-CTR";
pub const LN_aes_256_ctr = "aes-256-ctr";
pub const NID_aes_256_ctr = @as(c_int, 906);
pub const SN_aes_128_ocb = "AES-128-OCB";
pub const LN_aes_128_ocb = "aes-128-ocb";
pub const NID_aes_128_ocb = @as(c_int, 958);
pub const SN_aes_192_ocb = "AES-192-OCB";
pub const LN_aes_192_ocb = "aes-192-ocb";
pub const NID_aes_192_ocb = @as(c_int, 959);
pub const SN_aes_256_ocb = "AES-256-OCB";
pub const LN_aes_256_ocb = "aes-256-ocb";
pub const NID_aes_256_ocb = @as(c_int, 960);
pub const SN_des_cfb1 = "DES-CFB1";
pub const LN_des_cfb1 = "des-cfb1";
pub const NID_des_cfb1 = @as(c_int, 656);
pub const SN_des_cfb8 = "DES-CFB8";
pub const LN_des_cfb8 = "des-cfb8";
pub const NID_des_cfb8 = @as(c_int, 657);
pub const SN_des_ede3_cfb1 = "DES-EDE3-CFB1";
pub const LN_des_ede3_cfb1 = "des-ede3-cfb1";
pub const NID_des_ede3_cfb1 = @as(c_int, 658);
pub const SN_des_ede3_cfb8 = "DES-EDE3-CFB8";
pub const LN_des_ede3_cfb8 = "des-ede3-cfb8";
pub const NID_des_ede3_cfb8 = @as(c_int, 659);
pub const OBJ_nist_hashalgs = blk: {
    _ = &OBJ_nistAlgorithms;
    break :blk @as(c_long, 2);
};
pub const SN_sha256 = "SHA256";
pub const LN_sha256 = "sha256";
pub const NID_sha256 = @as(c_int, 672);
pub const OBJ_sha256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 1);
};
pub const SN_sha384 = "SHA384";
pub const LN_sha384 = "sha384";
pub const NID_sha384 = @as(c_int, 673);
pub const OBJ_sha384 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 2);
};
pub const SN_sha512 = "SHA512";
pub const LN_sha512 = "sha512";
pub const NID_sha512 = @as(c_int, 674);
pub const OBJ_sha512 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 3);
};
pub const SN_sha224 = "SHA224";
pub const LN_sha224 = "sha224";
pub const NID_sha224 = @as(c_int, 675);
pub const OBJ_sha224 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 4);
};
pub const SN_sha512_224 = "SHA512-224";
pub const LN_sha512_224 = "sha512-224";
pub const NID_sha512_224 = @as(c_int, 1094);
pub const OBJ_sha512_224 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 5);
};
pub const SN_sha512_256 = "SHA512-256";
pub const LN_sha512_256 = "sha512-256";
pub const NID_sha512_256 = @as(c_int, 1095);
pub const OBJ_sha512_256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 6);
};
pub const SN_sha3_224 = "SHA3-224";
pub const LN_sha3_224 = "sha3-224";
pub const NID_sha3_224 = @as(c_int, 1096);
pub const OBJ_sha3_224 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 7);
};
pub const SN_sha3_256 = "SHA3-256";
pub const LN_sha3_256 = "sha3-256";
pub const NID_sha3_256 = @as(c_int, 1097);
pub const OBJ_sha3_256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 8);
};
pub const SN_sha3_384 = "SHA3-384";
pub const LN_sha3_384 = "sha3-384";
pub const NID_sha3_384 = @as(c_int, 1098);
pub const OBJ_sha3_384 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 9);
};
pub const SN_sha3_512 = "SHA3-512";
pub const LN_sha3_512 = "sha3-512";
pub const NID_sha3_512 = @as(c_int, 1099);
pub const OBJ_sha3_512 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 10);
};
pub const SN_shake128 = "SHAKE128";
pub const LN_shake128 = "shake128";
pub const NID_shake128 = @as(c_int, 1100);
pub const OBJ_shake128 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 11);
};
pub const SN_shake256 = "SHAKE256";
pub const LN_shake256 = "shake256";
pub const NID_shake256 = @as(c_int, 1101);
pub const OBJ_shake256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 12);
};
pub const SN_hmac_sha3_224 = "id-hmacWithSHA3-224";
pub const LN_hmac_sha3_224 = "hmac-sha3-224";
pub const NID_hmac_sha3_224 = @as(c_int, 1102);
pub const OBJ_hmac_sha3_224 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 13);
};
pub const SN_hmac_sha3_256 = "id-hmacWithSHA3-256";
pub const LN_hmac_sha3_256 = "hmac-sha3-256";
pub const NID_hmac_sha3_256 = @as(c_int, 1103);
pub const OBJ_hmac_sha3_256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 14);
};
pub const SN_hmac_sha3_384 = "id-hmacWithSHA3-384";
pub const LN_hmac_sha3_384 = "hmac-sha3-384";
pub const NID_hmac_sha3_384 = @as(c_int, 1104);
pub const OBJ_hmac_sha3_384 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 15);
};
pub const SN_hmac_sha3_512 = "id-hmacWithSHA3-512";
pub const LN_hmac_sha3_512 = "hmac-sha3-512";
pub const NID_hmac_sha3_512 = @as(c_int, 1105);
pub const OBJ_hmac_sha3_512 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 16);
};
pub const SN_kmac128 = "KMAC128";
pub const LN_kmac128 = "kmac128";
pub const NID_kmac128 = @as(c_int, 1196);
pub const OBJ_kmac128 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 19);
};
pub const SN_kmac256 = "KMAC256";
pub const LN_kmac256 = "kmac256";
pub const NID_kmac256 = @as(c_int, 1197);
pub const OBJ_kmac256 = blk: {
    _ = &OBJ_nist_hashalgs;
    break :blk @as(c_long, 20);
};
pub const OBJ_dsa_with_sha2 = blk: {
    _ = &OBJ_nistAlgorithms;
    break :blk @as(c_long, 3);
};
pub const SN_dsa_with_SHA224 = "dsa_with_SHA224";
pub const NID_dsa_with_SHA224 = @as(c_int, 802);
pub const OBJ_dsa_with_SHA224 = blk: {
    _ = &OBJ_dsa_with_sha2;
    break :blk @as(c_long, 1);
};
pub const SN_dsa_with_SHA256 = "dsa_with_SHA256";
pub const NID_dsa_with_SHA256 = @as(c_int, 803);
pub const OBJ_dsa_with_SHA256 = blk: {
    _ = &OBJ_dsa_with_sha2;
    break :blk @as(c_long, 2);
};
pub const OBJ_sigAlgs = blk: {
    _ = &OBJ_nistAlgorithms;
    break :blk @as(c_long, 3);
};
pub const SN_dsa_with_SHA384 = "id-dsa-with-sha384";
pub const LN_dsa_with_SHA384 = "dsa_with_SHA384";
pub const NID_dsa_with_SHA384 = @as(c_int, 1106);
pub const OBJ_dsa_with_SHA384 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 3);
};
pub const SN_dsa_with_SHA512 = "id-dsa-with-sha512";
pub const LN_dsa_with_SHA512 = "dsa_with_SHA512";
pub const NID_dsa_with_SHA512 = @as(c_int, 1107);
pub const OBJ_dsa_with_SHA512 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 4);
};
pub const SN_dsa_with_SHA3_224 = "id-dsa-with-sha3-224";
pub const LN_dsa_with_SHA3_224 = "dsa_with_SHA3-224";
pub const NID_dsa_with_SHA3_224 = @as(c_int, 1108);
pub const OBJ_dsa_with_SHA3_224 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 5);
};
pub const SN_dsa_with_SHA3_256 = "id-dsa-with-sha3-256";
pub const LN_dsa_with_SHA3_256 = "dsa_with_SHA3-256";
pub const NID_dsa_with_SHA3_256 = @as(c_int, 1109);
pub const OBJ_dsa_with_SHA3_256 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 6);
};
pub const SN_dsa_with_SHA3_384 = "id-dsa-with-sha3-384";
pub const LN_dsa_with_SHA3_384 = "dsa_with_SHA3-384";
pub const NID_dsa_with_SHA3_384 = @as(c_int, 1110);
pub const OBJ_dsa_with_SHA3_384 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 7);
};
pub const SN_dsa_with_SHA3_512 = "id-dsa-with-sha3-512";
pub const LN_dsa_with_SHA3_512 = "dsa_with_SHA3-512";
pub const NID_dsa_with_SHA3_512 = @as(c_int, 1111);
pub const OBJ_dsa_with_SHA3_512 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 8);
};
pub const SN_ecdsa_with_SHA3_224 = "id-ecdsa-with-sha3-224";
pub const LN_ecdsa_with_SHA3_224 = "ecdsa_with_SHA3-224";
pub const NID_ecdsa_with_SHA3_224 = @as(c_int, 1112);
pub const OBJ_ecdsa_with_SHA3_224 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 9);
};
pub const SN_ecdsa_with_SHA3_256 = "id-ecdsa-with-sha3-256";
pub const LN_ecdsa_with_SHA3_256 = "ecdsa_with_SHA3-256";
pub const NID_ecdsa_with_SHA3_256 = @as(c_int, 1113);
pub const OBJ_ecdsa_with_SHA3_256 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 10);
};
pub const SN_ecdsa_with_SHA3_384 = "id-ecdsa-with-sha3-384";
pub const LN_ecdsa_with_SHA3_384 = "ecdsa_with_SHA3-384";
pub const NID_ecdsa_with_SHA3_384 = @as(c_int, 1114);
pub const OBJ_ecdsa_with_SHA3_384 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 11);
};
pub const SN_ecdsa_with_SHA3_512 = "id-ecdsa-with-sha3-512";
pub const LN_ecdsa_with_SHA3_512 = "ecdsa_with_SHA3-512";
pub const NID_ecdsa_with_SHA3_512 = @as(c_int, 1115);
pub const OBJ_ecdsa_with_SHA3_512 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 12);
};
pub const SN_RSA_SHA3_224 = "id-rsassa-pkcs1-v1_5-with-sha3-224";
pub const LN_RSA_SHA3_224 = "RSA-SHA3-224";
pub const NID_RSA_SHA3_224 = @as(c_int, 1116);
pub const OBJ_RSA_SHA3_224 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 13);
};
pub const SN_RSA_SHA3_256 = "id-rsassa-pkcs1-v1_5-with-sha3-256";
pub const LN_RSA_SHA3_256 = "RSA-SHA3-256";
pub const NID_RSA_SHA3_256 = @as(c_int, 1117);
pub const OBJ_RSA_SHA3_256 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 14);
};
pub const SN_RSA_SHA3_384 = "id-rsassa-pkcs1-v1_5-with-sha3-384";
pub const LN_RSA_SHA3_384 = "RSA-SHA3-384";
pub const NID_RSA_SHA3_384 = @as(c_int, 1118);
pub const OBJ_RSA_SHA3_384 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 15);
};
pub const SN_RSA_SHA3_512 = "id-rsassa-pkcs1-v1_5-with-sha3-512";
pub const LN_RSA_SHA3_512 = "RSA-SHA3-512";
pub const NID_RSA_SHA3_512 = @as(c_int, 1119);
pub const OBJ_RSA_SHA3_512 = blk: {
    _ = &OBJ_sigAlgs;
    break :blk @as(c_long, 16);
};
pub const SN_hold_instruction_code = "holdInstructionCode";
pub const LN_hold_instruction_code = "Hold Instruction Code";
pub const NID_hold_instruction_code = @as(c_int, 430);
pub const OBJ_hold_instruction_code = blk: {
    _ = &OBJ_id_ce;
    break :blk @as(c_long, 23);
};
pub const OBJ_holdInstruction = blk: {
    _ = &OBJ_X9_57;
    break :blk @as(c_long, 2);
};
pub const SN_hold_instruction_none = "holdInstructionNone";
pub const LN_hold_instruction_none = "Hold Instruction None";
pub const NID_hold_instruction_none = @as(c_int, 431);
pub const OBJ_hold_instruction_none = blk: {
    _ = &OBJ_holdInstruction;
    break :blk @as(c_long, 1);
};
pub const SN_hold_instruction_call_issuer = "holdInstructionCallIssuer";
pub const LN_hold_instruction_call_issuer = "Hold Instruction Call Issuer";
pub const NID_hold_instruction_call_issuer = @as(c_int, 432);
pub const OBJ_hold_instruction_call_issuer = blk: {
    _ = &OBJ_holdInstruction;
    break :blk @as(c_long, 2);
};
pub const SN_hold_instruction_reject = "holdInstructionReject";
pub const LN_hold_instruction_reject = "Hold Instruction Reject";
pub const NID_hold_instruction_reject = @as(c_int, 433);
pub const OBJ_hold_instruction_reject = blk: {
    _ = &OBJ_holdInstruction;
    break :blk @as(c_long, 3);
};
pub const SN_itu_t_identified_organization = "itu-t-identified-organization";
pub const NID_itu_t_identified_organization = @as(c_int, 1264);
pub const OBJ_itu_t_identified_organization = blk: {
    _ = &OBJ_itu_t;
    break :blk @as(c_long, 4);
};
pub const SN_etsi = "etsi";
pub const NID_etsi = @as(c_int, 1265);
pub const OBJ_etsi = blk: {
    _ = &OBJ_itu_t_identified_organization;
    break :blk @as(c_long, 0);
};
pub const SN_electronic_signature_standard = "electronic-signature-standard";
pub const NID_electronic_signature_standard = @as(c_int, 1266);
pub const OBJ_electronic_signature_standard = blk: {
    _ = &OBJ_etsi;
    break :blk @as(c_long, 1733);
};
pub const SN_ess_attributes = "ess-attributes";
pub const NID_ess_attributes = @as(c_int, 1267);
pub const OBJ_ess_attributes = blk: {
    _ = &OBJ_electronic_signature_standard;
    break :blk @as(c_long, 2);
};
pub const SN_id_aa_ets_mimeType = "id-aa-ets-mimeType";
pub const NID_id_aa_ets_mimeType = @as(c_int, 1268);
pub const OBJ_id_aa_ets_mimeType = blk: {
    _ = &OBJ_ess_attributes;
    break :blk @as(c_long, 1);
};
pub const SN_id_aa_ets_longTermValidation = "id-aa-ets-longTermValidation";
pub const NID_id_aa_ets_longTermValidation = @as(c_int, 1269);
pub const OBJ_id_aa_ets_longTermValidation = blk: {
    _ = &OBJ_ess_attributes;
    break :blk @as(c_long, 2);
};
pub const SN_id_aa_ets_SignaturePolicyDocument = "id-aa-ets-SignaturePolicyDocument";
pub const NID_id_aa_ets_SignaturePolicyDocument = @as(c_int, 1270);
pub const OBJ_id_aa_ets_SignaturePolicyDocument = blk: {
    _ = &OBJ_ess_attributes;
    break :blk @as(c_long, 3);
};
pub const SN_id_aa_ets_archiveTimestampV3 = "id-aa-ets-archiveTimestampV3";
pub const NID_id_aa_ets_archiveTimestampV3 = @as(c_int, 1271);
pub const OBJ_id_aa_ets_archiveTimestampV3 = blk: {
    _ = &OBJ_ess_attributes;
    break :blk @as(c_long, 4);
};
pub const SN_id_aa_ATSHashIndex = "id-aa-ATSHashIndex";
pub const NID_id_aa_ATSHashIndex = @as(c_int, 1272);
pub const OBJ_id_aa_ATSHashIndex = blk: {
    _ = &OBJ_ess_attributes;
    break :blk @as(c_long, 5);
};
pub const SN_cades = "cades";
pub const NID_cades = @as(c_int, 1273);
pub const OBJ_cades = blk: {
    _ = &OBJ_etsi;
    break :blk @as(c_long, 19122);
};
pub const SN_cades_attributes = "cades-attributes";
pub const NID_cades_attributes = @as(c_int, 1274);
pub const OBJ_cades_attributes = blk: {
    _ = &OBJ_cades;
    break :blk @as(c_long, 1);
};
pub const SN_id_aa_ets_signerAttrV2 = "id-aa-ets-signerAttrV2";
pub const NID_id_aa_ets_signerAttrV2 = @as(c_int, 1275);
pub const OBJ_id_aa_ets_signerAttrV2 = blk: {
    _ = &OBJ_cades_attributes;
    break :blk @as(c_long, 1);
};
pub const SN_id_aa_ets_sigPolicyStore = "id-aa-ets-sigPolicyStore";
pub const NID_id_aa_ets_sigPolicyStore = @as(c_int, 1276);
pub const OBJ_id_aa_ets_sigPolicyStore = blk: {
    _ = &OBJ_cades_attributes;
    break :blk @as(c_long, 3);
};
pub const SN_id_aa_ATSHashIndex_v2 = "id-aa-ATSHashIndex-v2";
pub const NID_id_aa_ATSHashIndex_v2 = @as(c_int, 1277);
pub const OBJ_id_aa_ATSHashIndex_v2 = blk: {
    _ = &OBJ_cades_attributes;
    break :blk @as(c_long, 4);
};
pub const SN_id_aa_ATSHashIndex_v3 = "id-aa-ATSHashIndex-v3";
pub const NID_id_aa_ATSHashIndex_v3 = @as(c_int, 1278);
pub const OBJ_id_aa_ATSHashIndex_v3 = blk: {
    _ = &OBJ_cades_attributes;
    break :blk @as(c_long, 5);
};
pub const SN_signedAssertion = "signedAssertion";
pub const NID_signedAssertion = @as(c_int, 1279);
pub const OBJ_signedAssertion = blk: {
    _ = &OBJ_cades_attributes;
    break :blk @as(c_long, 6);
};
pub const SN_data = "data";
pub const NID_data = @as(c_int, 434);
pub const OBJ_data = blk: {
    _ = &OBJ_itu_t;
    break :blk @as(c_long, 9);
};
pub const SN_pss = "pss";
pub const NID_pss = @as(c_int, 435);
pub const OBJ_pss = blk: {
    _ = &OBJ_data;
    break :blk @as(c_long, 2342);
};
pub const SN_ucl = "ucl";
pub const NID_ucl = @as(c_int, 436);
pub const OBJ_ucl = blk: {
    _ = &OBJ_pss;
    break :blk @as(c_long, 19200300);
};
pub const SN_pilot = "pilot";
pub const NID_pilot = @as(c_int, 437);
pub const OBJ_pilot = blk: {
    _ = &OBJ_ucl;
    break :blk @as(c_long, 100);
};
pub const LN_pilotAttributeType = "pilotAttributeType";
pub const NID_pilotAttributeType = @as(c_int, 438);
pub const OBJ_pilotAttributeType = blk: {
    _ = &OBJ_pilot;
    break :blk @as(c_long, 1);
};
pub const LN_pilotAttributeSyntax = "pilotAttributeSyntax";
pub const NID_pilotAttributeSyntax = @as(c_int, 439);
pub const OBJ_pilotAttributeSyntax = blk: {
    _ = &OBJ_pilot;
    break :blk @as(c_long, 3);
};
pub const LN_pilotObjectClass = "pilotObjectClass";
pub const NID_pilotObjectClass = @as(c_int, 440);
pub const OBJ_pilotObjectClass = blk: {
    _ = &OBJ_pilot;
    break :blk @as(c_long, 4);
};
pub const LN_pilotGroups = "pilotGroups";
pub const NID_pilotGroups = @as(c_int, 441);
pub const OBJ_pilotGroups = blk: {
    _ = &OBJ_pilot;
    break :blk @as(c_long, 10);
};
pub const LN_iA5StringSyntax = "iA5StringSyntax";
pub const NID_iA5StringSyntax = @as(c_int, 442);
pub const OBJ_iA5StringSyntax = blk: {
    _ = &OBJ_pilotAttributeSyntax;
    break :blk @as(c_long, 4);
};
pub const LN_caseIgnoreIA5StringSyntax = "caseIgnoreIA5StringSyntax";
pub const NID_caseIgnoreIA5StringSyntax = @as(c_int, 443);
pub const OBJ_caseIgnoreIA5StringSyntax = blk: {
    _ = &OBJ_pilotAttributeSyntax;
    break :blk @as(c_long, 5);
};
pub const LN_pilotObject = "pilotObject";
pub const NID_pilotObject = @as(c_int, 444);
pub const OBJ_pilotObject = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 3);
};
pub const LN_pilotPerson = "pilotPerson";
pub const NID_pilotPerson = @as(c_int, 445);
pub const OBJ_pilotPerson = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 4);
};
pub const SN_account = "account";
pub const NID_account = @as(c_int, 446);
pub const OBJ_account = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 5);
};
pub const SN_document = "document";
pub const NID_document = @as(c_int, 447);
pub const OBJ_document = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 6);
};
pub const SN_room = "room";
pub const NID_room = @as(c_int, 448);
pub const OBJ_room = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 7);
};
pub const LN_documentSeries = "documentSeries";
pub const NID_documentSeries = @as(c_int, 449);
pub const OBJ_documentSeries = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 9);
};
pub const SN_Domain = "domain";
pub const LN_Domain = "Domain";
pub const NID_Domain = @as(c_int, 392);
pub const OBJ_Domain = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 13);
};
pub const LN_rFC822localPart = "rFC822localPart";
pub const NID_rFC822localPart = @as(c_int, 450);
pub const OBJ_rFC822localPart = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 14);
};
pub const LN_dNSDomain = "dNSDomain";
pub const NID_dNSDomain = @as(c_int, 451);
pub const OBJ_dNSDomain = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 15);
};
pub const LN_domainRelatedObject = "domainRelatedObject";
pub const NID_domainRelatedObject = @as(c_int, 452);
pub const OBJ_domainRelatedObject = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 17);
};
pub const LN_friendlyCountry = "friendlyCountry";
pub const NID_friendlyCountry = @as(c_int, 453);
pub const OBJ_friendlyCountry = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 18);
};
pub const LN_simpleSecurityObject = "simpleSecurityObject";
pub const NID_simpleSecurityObject = @as(c_int, 454);
pub const OBJ_simpleSecurityObject = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 19);
};
pub const LN_pilotOrganization = "pilotOrganization";
pub const NID_pilotOrganization = @as(c_int, 455);
pub const OBJ_pilotOrganization = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 20);
};
pub const LN_pilotDSA = "pilotDSA";
pub const NID_pilotDSA = @as(c_int, 456);
pub const OBJ_pilotDSA = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 21);
};
pub const LN_qualityLabelledData = "qualityLabelledData";
pub const NID_qualityLabelledData = @as(c_int, 457);
pub const OBJ_qualityLabelledData = blk: {
    _ = &OBJ_pilotObjectClass;
    break :blk @as(c_long, 22);
};
pub const SN_userId = "UID";
pub const LN_userId = "userId";
pub const NID_userId = @as(c_int, 458);
pub const OBJ_userId = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 1);
};
pub const LN_textEncodedORAddress = "textEncodedORAddress";
pub const NID_textEncodedORAddress = @as(c_int, 459);
pub const OBJ_textEncodedORAddress = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 2);
};
pub const SN_rfc822Mailbox = "mail";
pub const LN_rfc822Mailbox = "rfc822Mailbox";
pub const NID_rfc822Mailbox = @as(c_int, 460);
pub const OBJ_rfc822Mailbox = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 3);
};
pub const SN_info = "info";
pub const NID_info = @as(c_int, 461);
pub const OBJ_info = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 4);
};
pub const LN_favouriteDrink = "favouriteDrink";
pub const NID_favouriteDrink = @as(c_int, 462);
pub const OBJ_favouriteDrink = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 5);
};
pub const LN_roomNumber = "roomNumber";
pub const NID_roomNumber = @as(c_int, 463);
pub const OBJ_roomNumber = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 6);
};
pub const SN_photo = "photo";
pub const NID_photo = @as(c_int, 464);
pub const OBJ_photo = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 7);
};
pub const LN_userClass = "userClass";
pub const NID_userClass = @as(c_int, 465);
pub const OBJ_userClass = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 8);
};
pub const SN_host = "host";
pub const NID_host = @as(c_int, 466);
pub const OBJ_host = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 9);
};
pub const SN_manager = "manager";
pub const NID_manager = @as(c_int, 467);
pub const OBJ_manager = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 10);
};
pub const LN_documentIdentifier = "documentIdentifier";
pub const NID_documentIdentifier = @as(c_int, 468);
pub const OBJ_documentIdentifier = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 11);
};
pub const LN_documentTitle = "documentTitle";
pub const NID_documentTitle = @as(c_int, 469);
pub const OBJ_documentTitle = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 12);
};
pub const LN_documentVersion = "documentVersion";
pub const NID_documentVersion = @as(c_int, 470);
pub const OBJ_documentVersion = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 13);
};
pub const LN_documentAuthor = "documentAuthor";
pub const NID_documentAuthor = @as(c_int, 471);
pub const OBJ_documentAuthor = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 14);
};
pub const LN_documentLocation = "documentLocation";
pub const NID_documentLocation = @as(c_int, 472);
pub const OBJ_documentLocation = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 15);
};
pub const LN_homeTelephoneNumber = "homeTelephoneNumber";
pub const NID_homeTelephoneNumber = @as(c_int, 473);
pub const OBJ_homeTelephoneNumber = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 20);
};
pub const SN_secretary = "secretary";
pub const NID_secretary = @as(c_int, 474);
pub const OBJ_secretary = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 21);
};
pub const LN_otherMailbox = "otherMailbox";
pub const NID_otherMailbox = @as(c_int, 475);
pub const OBJ_otherMailbox = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 22);
};
pub const LN_lastModifiedTime = "lastModifiedTime";
pub const NID_lastModifiedTime = @as(c_int, 476);
pub const OBJ_lastModifiedTime = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 23);
};
pub const LN_lastModifiedBy = "lastModifiedBy";
pub const NID_lastModifiedBy = @as(c_int, 477);
pub const OBJ_lastModifiedBy = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 24);
};
pub const SN_domainComponent = "DC";
pub const LN_domainComponent = "domainComponent";
pub const NID_domainComponent = @as(c_int, 391);
pub const OBJ_domainComponent = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 25);
};
pub const LN_aRecord = "aRecord";
pub const NID_aRecord = @as(c_int, 478);
pub const OBJ_aRecord = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 26);
};
pub const LN_pilotAttributeType27 = "pilotAttributeType27";
pub const NID_pilotAttributeType27 = @as(c_int, 479);
pub const OBJ_pilotAttributeType27 = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 27);
};
pub const LN_mXRecord = "mXRecord";
pub const NID_mXRecord = @as(c_int, 480);
pub const OBJ_mXRecord = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 28);
};
pub const LN_nSRecord = "nSRecord";
pub const NID_nSRecord = @as(c_int, 481);
pub const OBJ_nSRecord = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 29);
};
pub const LN_sOARecord = "sOARecord";
pub const NID_sOARecord = @as(c_int, 482);
pub const OBJ_sOARecord = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 30);
};
pub const LN_cNAMERecord = "cNAMERecord";
pub const NID_cNAMERecord = @as(c_int, 483);
pub const OBJ_cNAMERecord = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 31);
};
pub const LN_associatedDomain = "associatedDomain";
pub const NID_associatedDomain = @as(c_int, 484);
pub const OBJ_associatedDomain = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 37);
};
pub const LN_associatedName = "associatedName";
pub const NID_associatedName = @as(c_int, 485);
pub const OBJ_associatedName = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 38);
};
pub const LN_homePostalAddress = "homePostalAddress";
pub const NID_homePostalAddress = @as(c_int, 486);
pub const OBJ_homePostalAddress = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 39);
};
pub const LN_personalTitle = "personalTitle";
pub const NID_personalTitle = @as(c_int, 487);
pub const OBJ_personalTitle = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 40);
};
pub const LN_mobileTelephoneNumber = "mobileTelephoneNumber";
pub const NID_mobileTelephoneNumber = @as(c_int, 488);
pub const OBJ_mobileTelephoneNumber = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 41);
};
pub const LN_pagerTelephoneNumber = "pagerTelephoneNumber";
pub const NID_pagerTelephoneNumber = @as(c_int, 489);
pub const OBJ_pagerTelephoneNumber = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 42);
};
pub const LN_friendlyCountryName = "friendlyCountryName";
pub const NID_friendlyCountryName = @as(c_int, 490);
pub const OBJ_friendlyCountryName = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 43);
};
pub const SN_uniqueIdentifier = "uid";
pub const LN_uniqueIdentifier = "uniqueIdentifier";
pub const NID_uniqueIdentifier = @as(c_int, 102);
pub const OBJ_uniqueIdentifier = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 44);
};
pub const LN_organizationalStatus = "organizationalStatus";
pub const NID_organizationalStatus = @as(c_int, 491);
pub const OBJ_organizationalStatus = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 45);
};
pub const LN_janetMailbox = "janetMailbox";
pub const NID_janetMailbox = @as(c_int, 492);
pub const OBJ_janetMailbox = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 46);
};
pub const LN_mailPreferenceOption = "mailPreferenceOption";
pub const NID_mailPreferenceOption = @as(c_int, 493);
pub const OBJ_mailPreferenceOption = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 47);
};
pub const LN_buildingName = "buildingName";
pub const NID_buildingName = @as(c_int, 494);
pub const OBJ_buildingName = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 48);
};
pub const LN_dSAQuality = "dSAQuality";
pub const NID_dSAQuality = @as(c_int, 495);
pub const OBJ_dSAQuality = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 49);
};
pub const LN_singleLevelQuality = "singleLevelQuality";
pub const NID_singleLevelQuality = @as(c_int, 496);
pub const OBJ_singleLevelQuality = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 50);
};
pub const LN_subtreeMinimumQuality = "subtreeMinimumQuality";
pub const NID_subtreeMinimumQuality = @as(c_int, 497);
pub const OBJ_subtreeMinimumQuality = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 51);
};
pub const LN_subtreeMaximumQuality = "subtreeMaximumQuality";
pub const NID_subtreeMaximumQuality = @as(c_int, 498);
pub const OBJ_subtreeMaximumQuality = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 52);
};
pub const LN_personalSignature = "personalSignature";
pub const NID_personalSignature = @as(c_int, 499);
pub const OBJ_personalSignature = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 53);
};
pub const LN_dITRedirect = "dITRedirect";
pub const NID_dITRedirect = @as(c_int, 500);
pub const OBJ_dITRedirect = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 54);
};
pub const SN_audio = "audio";
pub const NID_audio = @as(c_int, 501);
pub const OBJ_audio = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 55);
};
pub const LN_documentPublisher = "documentPublisher";
pub const NID_documentPublisher = @as(c_int, 502);
pub const OBJ_documentPublisher = blk: {
    _ = &OBJ_pilotAttributeType;
    break :blk @as(c_long, 56);
};
pub const SN_id_set = "id-set";
pub const LN_id_set = "Secure Electronic Transactions";
pub const NID_id_set = @as(c_int, 512);
pub const OBJ_id_set = blk: {
    _ = &OBJ_international_organizations;
    break :blk @as(c_long, 42);
};
pub const SN_set_ctype = "set-ctype";
pub const LN_set_ctype = "content types";
pub const NID_set_ctype = @as(c_int, 513);
pub const OBJ_set_ctype = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 0);
};
pub const SN_set_msgExt = "set-msgExt";
pub const LN_set_msgExt = "message extensions";
pub const NID_set_msgExt = @as(c_int, 514);
pub const OBJ_set_msgExt = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 1);
};
pub const SN_set_attr = "set-attr";
pub const NID_set_attr = @as(c_int, 515);
pub const OBJ_set_attr = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 3);
};
pub const SN_set_policy = "set-policy";
pub const NID_set_policy = @as(c_int, 516);
pub const OBJ_set_policy = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 5);
};
pub const SN_set_certExt = "set-certExt";
pub const LN_set_certExt = "certificate extensions";
pub const NID_set_certExt = @as(c_int, 517);
pub const OBJ_set_certExt = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 7);
};
pub const SN_set_brand = "set-brand";
pub const NID_set_brand = @as(c_int, 518);
pub const OBJ_set_brand = blk: {
    _ = &OBJ_id_set;
    break :blk @as(c_long, 8);
};
pub const SN_setct_PANData = "setct-PANData";
pub const NID_setct_PANData = @as(c_int, 519);
pub const OBJ_setct_PANData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 0);
};
pub const SN_setct_PANToken = "setct-PANToken";
pub const NID_setct_PANToken = @as(c_int, 520);
pub const OBJ_setct_PANToken = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 1);
};
pub const SN_setct_PANOnly = "setct-PANOnly";
pub const NID_setct_PANOnly = @as(c_int, 521);
pub const OBJ_setct_PANOnly = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 2);
};
pub const SN_setct_OIData = "setct-OIData";
pub const NID_setct_OIData = @as(c_int, 522);
pub const OBJ_setct_OIData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 3);
};
pub const SN_setct_PI = "setct-PI";
pub const NID_setct_PI = @as(c_int, 523);
pub const OBJ_setct_PI = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 4);
};
pub const SN_setct_PIData = "setct-PIData";
pub const NID_setct_PIData = @as(c_int, 524);
pub const OBJ_setct_PIData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 5);
};
pub const SN_setct_PIDataUnsigned = "setct-PIDataUnsigned";
pub const NID_setct_PIDataUnsigned = @as(c_int, 525);
pub const OBJ_setct_PIDataUnsigned = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 6);
};
pub const SN_setct_HODInput = "setct-HODInput";
pub const NID_setct_HODInput = @as(c_int, 526);
pub const OBJ_setct_HODInput = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 7);
};
pub const SN_setct_AuthResBaggage = "setct-AuthResBaggage";
pub const NID_setct_AuthResBaggage = @as(c_int, 527);
pub const OBJ_setct_AuthResBaggage = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 8);
};
pub const SN_setct_AuthRevReqBaggage = "setct-AuthRevReqBaggage";
pub const NID_setct_AuthRevReqBaggage = @as(c_int, 528);
pub const OBJ_setct_AuthRevReqBaggage = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 9);
};
pub const SN_setct_AuthRevResBaggage = "setct-AuthRevResBaggage";
pub const NID_setct_AuthRevResBaggage = @as(c_int, 529);
pub const OBJ_setct_AuthRevResBaggage = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 10);
};
pub const SN_setct_CapTokenSeq = "setct-CapTokenSeq";
pub const NID_setct_CapTokenSeq = @as(c_int, 530);
pub const OBJ_setct_CapTokenSeq = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 11);
};
pub const SN_setct_PInitResData = "setct-PInitResData";
pub const NID_setct_PInitResData = @as(c_int, 531);
pub const OBJ_setct_PInitResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 12);
};
pub const SN_setct_PI_TBS = "setct-PI-TBS";
pub const NID_setct_PI_TBS = @as(c_int, 532);
pub const OBJ_setct_PI_TBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 13);
};
pub const SN_setct_PResData = "setct-PResData";
pub const NID_setct_PResData = @as(c_int, 533);
pub const OBJ_setct_PResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 14);
};
pub const SN_setct_AuthReqTBS = "setct-AuthReqTBS";
pub const NID_setct_AuthReqTBS = @as(c_int, 534);
pub const OBJ_setct_AuthReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 16);
};
pub const SN_setct_AuthResTBS = "setct-AuthResTBS";
pub const NID_setct_AuthResTBS = @as(c_int, 535);
pub const OBJ_setct_AuthResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 17);
};
pub const SN_setct_AuthResTBSX = "setct-AuthResTBSX";
pub const NID_setct_AuthResTBSX = @as(c_int, 536);
pub const OBJ_setct_AuthResTBSX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 18);
};
pub const SN_setct_AuthTokenTBS = "setct-AuthTokenTBS";
pub const NID_setct_AuthTokenTBS = @as(c_int, 537);
pub const OBJ_setct_AuthTokenTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 19);
};
pub const SN_setct_CapTokenData = "setct-CapTokenData";
pub const NID_setct_CapTokenData = @as(c_int, 538);
pub const OBJ_setct_CapTokenData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 20);
};
pub const SN_setct_CapTokenTBS = "setct-CapTokenTBS";
pub const NID_setct_CapTokenTBS = @as(c_int, 539);
pub const OBJ_setct_CapTokenTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 21);
};
pub const SN_setct_AcqCardCodeMsg = "setct-AcqCardCodeMsg";
pub const NID_setct_AcqCardCodeMsg = @as(c_int, 540);
pub const OBJ_setct_AcqCardCodeMsg = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 22);
};
pub const SN_setct_AuthRevReqTBS = "setct-AuthRevReqTBS";
pub const NID_setct_AuthRevReqTBS = @as(c_int, 541);
pub const OBJ_setct_AuthRevReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 23);
};
pub const SN_setct_AuthRevResData = "setct-AuthRevResData";
pub const NID_setct_AuthRevResData = @as(c_int, 542);
pub const OBJ_setct_AuthRevResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 24);
};
pub const SN_setct_AuthRevResTBS = "setct-AuthRevResTBS";
pub const NID_setct_AuthRevResTBS = @as(c_int, 543);
pub const OBJ_setct_AuthRevResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 25);
};
pub const SN_setct_CapReqTBS = "setct-CapReqTBS";
pub const NID_setct_CapReqTBS = @as(c_int, 544);
pub const OBJ_setct_CapReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 26);
};
pub const SN_setct_CapReqTBSX = "setct-CapReqTBSX";
pub const NID_setct_CapReqTBSX = @as(c_int, 545);
pub const OBJ_setct_CapReqTBSX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 27);
};
pub const SN_setct_CapResData = "setct-CapResData";
pub const NID_setct_CapResData = @as(c_int, 546);
pub const OBJ_setct_CapResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 28);
};
pub const SN_setct_CapRevReqTBS = "setct-CapRevReqTBS";
pub const NID_setct_CapRevReqTBS = @as(c_int, 547);
pub const OBJ_setct_CapRevReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 29);
};
pub const SN_setct_CapRevReqTBSX = "setct-CapRevReqTBSX";
pub const NID_setct_CapRevReqTBSX = @as(c_int, 548);
pub const OBJ_setct_CapRevReqTBSX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 30);
};
pub const SN_setct_CapRevResData = "setct-CapRevResData";
pub const NID_setct_CapRevResData = @as(c_int, 549);
pub const OBJ_setct_CapRevResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 31);
};
pub const SN_setct_CredReqTBS = "setct-CredReqTBS";
pub const NID_setct_CredReqTBS = @as(c_int, 550);
pub const OBJ_setct_CredReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 32);
};
pub const SN_setct_CredReqTBSX = "setct-CredReqTBSX";
pub const NID_setct_CredReqTBSX = @as(c_int, 551);
pub const OBJ_setct_CredReqTBSX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 33);
};
pub const SN_setct_CredResData = "setct-CredResData";
pub const NID_setct_CredResData = @as(c_int, 552);
pub const OBJ_setct_CredResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 34);
};
pub const SN_setct_CredRevReqTBS = "setct-CredRevReqTBS";
pub const NID_setct_CredRevReqTBS = @as(c_int, 553);
pub const OBJ_setct_CredRevReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 35);
};
pub const SN_setct_CredRevReqTBSX = "setct-CredRevReqTBSX";
pub const NID_setct_CredRevReqTBSX = @as(c_int, 554);
pub const OBJ_setct_CredRevReqTBSX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 36);
};
pub const SN_setct_CredRevResData = "setct-CredRevResData";
pub const NID_setct_CredRevResData = @as(c_int, 555);
pub const OBJ_setct_CredRevResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 37);
};
pub const SN_setct_PCertReqData = "setct-PCertReqData";
pub const NID_setct_PCertReqData = @as(c_int, 556);
pub const OBJ_setct_PCertReqData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 38);
};
pub const SN_setct_PCertResTBS = "setct-PCertResTBS";
pub const NID_setct_PCertResTBS = @as(c_int, 557);
pub const OBJ_setct_PCertResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 39);
};
pub const SN_setct_BatchAdminReqData = "setct-BatchAdminReqData";
pub const NID_setct_BatchAdminReqData = @as(c_int, 558);
pub const OBJ_setct_BatchAdminReqData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 40);
};
pub const SN_setct_BatchAdminResData = "setct-BatchAdminResData";
pub const NID_setct_BatchAdminResData = @as(c_int, 559);
pub const OBJ_setct_BatchAdminResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 41);
};
pub const SN_setct_CardCInitResTBS = "setct-CardCInitResTBS";
pub const NID_setct_CardCInitResTBS = @as(c_int, 560);
pub const OBJ_setct_CardCInitResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 42);
};
pub const SN_setct_MeAqCInitResTBS = "setct-MeAqCInitResTBS";
pub const NID_setct_MeAqCInitResTBS = @as(c_int, 561);
pub const OBJ_setct_MeAqCInitResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 43);
};
pub const SN_setct_RegFormResTBS = "setct-RegFormResTBS";
pub const NID_setct_RegFormResTBS = @as(c_int, 562);
pub const OBJ_setct_RegFormResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 44);
};
pub const SN_setct_CertReqData = "setct-CertReqData";
pub const NID_setct_CertReqData = @as(c_int, 563);
pub const OBJ_setct_CertReqData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 45);
};
pub const SN_setct_CertReqTBS = "setct-CertReqTBS";
pub const NID_setct_CertReqTBS = @as(c_int, 564);
pub const OBJ_setct_CertReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 46);
};
pub const SN_setct_CertResData = "setct-CertResData";
pub const NID_setct_CertResData = @as(c_int, 565);
pub const OBJ_setct_CertResData = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 47);
};
pub const SN_setct_CertInqReqTBS = "setct-CertInqReqTBS";
pub const NID_setct_CertInqReqTBS = @as(c_int, 566);
pub const OBJ_setct_CertInqReqTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 48);
};
pub const SN_setct_ErrorTBS = "setct-ErrorTBS";
pub const NID_setct_ErrorTBS = @as(c_int, 567);
pub const OBJ_setct_ErrorTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 49);
};
pub const SN_setct_PIDualSignedTBE = "setct-PIDualSignedTBE";
pub const NID_setct_PIDualSignedTBE = @as(c_int, 568);
pub const OBJ_setct_PIDualSignedTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 50);
};
pub const SN_setct_PIUnsignedTBE = "setct-PIUnsignedTBE";
pub const NID_setct_PIUnsignedTBE = @as(c_int, 569);
pub const OBJ_setct_PIUnsignedTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 51);
};
pub const SN_setct_AuthReqTBE = "setct-AuthReqTBE";
pub const NID_setct_AuthReqTBE = @as(c_int, 570);
pub const OBJ_setct_AuthReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 52);
};
pub const SN_setct_AuthResTBE = "setct-AuthResTBE";
pub const NID_setct_AuthResTBE = @as(c_int, 571);
pub const OBJ_setct_AuthResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 53);
};
pub const SN_setct_AuthResTBEX = "setct-AuthResTBEX";
pub const NID_setct_AuthResTBEX = @as(c_int, 572);
pub const OBJ_setct_AuthResTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 54);
};
pub const SN_setct_AuthTokenTBE = "setct-AuthTokenTBE";
pub const NID_setct_AuthTokenTBE = @as(c_int, 573);
pub const OBJ_setct_AuthTokenTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 55);
};
pub const SN_setct_CapTokenTBE = "setct-CapTokenTBE";
pub const NID_setct_CapTokenTBE = @as(c_int, 574);
pub const OBJ_setct_CapTokenTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 56);
};
pub const SN_setct_CapTokenTBEX = "setct-CapTokenTBEX";
pub const NID_setct_CapTokenTBEX = @as(c_int, 575);
pub const OBJ_setct_CapTokenTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 57);
};
pub const SN_setct_AcqCardCodeMsgTBE = "setct-AcqCardCodeMsgTBE";
pub const NID_setct_AcqCardCodeMsgTBE = @as(c_int, 576);
pub const OBJ_setct_AcqCardCodeMsgTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 58);
};
pub const SN_setct_AuthRevReqTBE = "setct-AuthRevReqTBE";
pub const NID_setct_AuthRevReqTBE = @as(c_int, 577);
pub const OBJ_setct_AuthRevReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 59);
};
pub const SN_setct_AuthRevResTBE = "setct-AuthRevResTBE";
pub const NID_setct_AuthRevResTBE = @as(c_int, 578);
pub const OBJ_setct_AuthRevResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 60);
};
pub const SN_setct_AuthRevResTBEB = "setct-AuthRevResTBEB";
pub const NID_setct_AuthRevResTBEB = @as(c_int, 579);
pub const OBJ_setct_AuthRevResTBEB = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 61);
};
pub const SN_setct_CapReqTBE = "setct-CapReqTBE";
pub const NID_setct_CapReqTBE = @as(c_int, 580);
pub const OBJ_setct_CapReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 62);
};
pub const SN_setct_CapReqTBEX = "setct-CapReqTBEX";
pub const NID_setct_CapReqTBEX = @as(c_int, 581);
pub const OBJ_setct_CapReqTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 63);
};
pub const SN_setct_CapResTBE = "setct-CapResTBE";
pub const NID_setct_CapResTBE = @as(c_int, 582);
pub const OBJ_setct_CapResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 64);
};
pub const SN_setct_CapRevReqTBE = "setct-CapRevReqTBE";
pub const NID_setct_CapRevReqTBE = @as(c_int, 583);
pub const OBJ_setct_CapRevReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 65);
};
pub const SN_setct_CapRevReqTBEX = "setct-CapRevReqTBEX";
pub const NID_setct_CapRevReqTBEX = @as(c_int, 584);
pub const OBJ_setct_CapRevReqTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 66);
};
pub const SN_setct_CapRevResTBE = "setct-CapRevResTBE";
pub const NID_setct_CapRevResTBE = @as(c_int, 585);
pub const OBJ_setct_CapRevResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 67);
};
pub const SN_setct_CredReqTBE = "setct-CredReqTBE";
pub const NID_setct_CredReqTBE = @as(c_int, 586);
pub const OBJ_setct_CredReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 68);
};
pub const SN_setct_CredReqTBEX = "setct-CredReqTBEX";
pub const NID_setct_CredReqTBEX = @as(c_int, 587);
pub const OBJ_setct_CredReqTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 69);
};
pub const SN_setct_CredResTBE = "setct-CredResTBE";
pub const NID_setct_CredResTBE = @as(c_int, 588);
pub const OBJ_setct_CredResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 70);
};
pub const SN_setct_CredRevReqTBE = "setct-CredRevReqTBE";
pub const NID_setct_CredRevReqTBE = @as(c_int, 589);
pub const OBJ_setct_CredRevReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 71);
};
pub const SN_setct_CredRevReqTBEX = "setct-CredRevReqTBEX";
pub const NID_setct_CredRevReqTBEX = @as(c_int, 590);
pub const OBJ_setct_CredRevReqTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 72);
};
pub const SN_setct_CredRevResTBE = "setct-CredRevResTBE";
pub const NID_setct_CredRevResTBE = @as(c_int, 591);
pub const OBJ_setct_CredRevResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 73);
};
pub const SN_setct_BatchAdminReqTBE = "setct-BatchAdminReqTBE";
pub const NID_setct_BatchAdminReqTBE = @as(c_int, 592);
pub const OBJ_setct_BatchAdminReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 74);
};
pub const SN_setct_BatchAdminResTBE = "setct-BatchAdminResTBE";
pub const NID_setct_BatchAdminResTBE = @as(c_int, 593);
pub const OBJ_setct_BatchAdminResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 75);
};
pub const SN_setct_RegFormReqTBE = "setct-RegFormReqTBE";
pub const NID_setct_RegFormReqTBE = @as(c_int, 594);
pub const OBJ_setct_RegFormReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 76);
};
pub const SN_setct_CertReqTBE = "setct-CertReqTBE";
pub const NID_setct_CertReqTBE = @as(c_int, 595);
pub const OBJ_setct_CertReqTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 77);
};
pub const SN_setct_CertReqTBEX = "setct-CertReqTBEX";
pub const NID_setct_CertReqTBEX = @as(c_int, 596);
pub const OBJ_setct_CertReqTBEX = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 78);
};
pub const SN_setct_CertResTBE = "setct-CertResTBE";
pub const NID_setct_CertResTBE = @as(c_int, 597);
pub const OBJ_setct_CertResTBE = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 79);
};
pub const SN_setct_CRLNotificationTBS = "setct-CRLNotificationTBS";
pub const NID_setct_CRLNotificationTBS = @as(c_int, 598);
pub const OBJ_setct_CRLNotificationTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 80);
};
pub const SN_setct_CRLNotificationResTBS = "setct-CRLNotificationResTBS";
pub const NID_setct_CRLNotificationResTBS = @as(c_int, 599);
pub const OBJ_setct_CRLNotificationResTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 81);
};
pub const SN_setct_BCIDistributionTBS = "setct-BCIDistributionTBS";
pub const NID_setct_BCIDistributionTBS = @as(c_int, 600);
pub const OBJ_setct_BCIDistributionTBS = blk: {
    _ = &OBJ_set_ctype;
    break :blk @as(c_long, 82);
};
pub const SN_setext_genCrypt = "setext-genCrypt";
pub const LN_setext_genCrypt = "generic cryptogram";
pub const NID_setext_genCrypt = @as(c_int, 601);
pub const OBJ_setext_genCrypt = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 1);
};
pub const SN_setext_miAuth = "setext-miAuth";
pub const LN_setext_miAuth = "merchant initiated auth";
pub const NID_setext_miAuth = @as(c_int, 602);
pub const OBJ_setext_miAuth = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 3);
};
pub const SN_setext_pinSecure = "setext-pinSecure";
pub const NID_setext_pinSecure = @as(c_int, 603);
pub const OBJ_setext_pinSecure = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 4);
};
pub const SN_setext_pinAny = "setext-pinAny";
pub const NID_setext_pinAny = @as(c_int, 604);
pub const OBJ_setext_pinAny = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 5);
};
pub const SN_setext_track2 = "setext-track2";
pub const NID_setext_track2 = @as(c_int, 605);
pub const OBJ_setext_track2 = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 7);
};
pub const SN_setext_cv = "setext-cv";
pub const LN_setext_cv = "additional verification";
pub const NID_setext_cv = @as(c_int, 606);
pub const OBJ_setext_cv = blk: {
    _ = &OBJ_set_msgExt;
    break :blk @as(c_long, 8);
};
pub const SN_set_policy_root = "set-policy-root";
pub const NID_set_policy_root = @as(c_int, 607);
pub const OBJ_set_policy_root = blk: {
    _ = &OBJ_set_policy;
    break :blk @as(c_long, 0);
};
pub const SN_setCext_hashedRoot = "setCext-hashedRoot";
pub const NID_setCext_hashedRoot = @as(c_int, 608);
pub const OBJ_setCext_hashedRoot = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 0);
};
pub const SN_setCext_certType = "setCext-certType";
pub const NID_setCext_certType = @as(c_int, 609);
pub const OBJ_setCext_certType = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 1);
};
pub const SN_setCext_merchData = "setCext-merchData";
pub const NID_setCext_merchData = @as(c_int, 610);
pub const OBJ_setCext_merchData = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 2);
};
pub const SN_setCext_cCertRequired = "setCext-cCertRequired";
pub const NID_setCext_cCertRequired = @as(c_int, 611);
pub const OBJ_setCext_cCertRequired = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 3);
};
pub const SN_setCext_tunneling = "setCext-tunneling";
pub const NID_setCext_tunneling = @as(c_int, 612);
pub const OBJ_setCext_tunneling = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 4);
};
pub const SN_setCext_setExt = "setCext-setExt";
pub const NID_setCext_setExt = @as(c_int, 613);
pub const OBJ_setCext_setExt = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 5);
};
pub const SN_setCext_setQualf = "setCext-setQualf";
pub const NID_setCext_setQualf = @as(c_int, 614);
pub const OBJ_setCext_setQualf = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 6);
};
pub const SN_setCext_PGWYcapabilities = "setCext-PGWYcapabilities";
pub const NID_setCext_PGWYcapabilities = @as(c_int, 615);
pub const OBJ_setCext_PGWYcapabilities = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 7);
};
pub const SN_setCext_TokenIdentifier = "setCext-TokenIdentifier";
pub const NID_setCext_TokenIdentifier = @as(c_int, 616);
pub const OBJ_setCext_TokenIdentifier = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 8);
};
pub const SN_setCext_Track2Data = "setCext-Track2Data";
pub const NID_setCext_Track2Data = @as(c_int, 617);
pub const OBJ_setCext_Track2Data = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 9);
};
pub const SN_setCext_TokenType = "setCext-TokenType";
pub const NID_setCext_TokenType = @as(c_int, 618);
pub const OBJ_setCext_TokenType = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 10);
};
pub const SN_setCext_IssuerCapabilities = "setCext-IssuerCapabilities";
pub const NID_setCext_IssuerCapabilities = @as(c_int, 619);
pub const OBJ_setCext_IssuerCapabilities = blk: {
    _ = &OBJ_set_certExt;
    break :blk @as(c_long, 11);
};
pub const SN_setAttr_Cert = "setAttr-Cert";
pub const NID_setAttr_Cert = @as(c_int, 620);
pub const OBJ_setAttr_Cert = blk: {
    _ = &OBJ_set_attr;
    break :blk @as(c_long, 0);
};
pub const SN_setAttr_PGWYcap = "setAttr-PGWYcap";
pub const LN_setAttr_PGWYcap = "payment gateway capabilities";
pub const NID_setAttr_PGWYcap = @as(c_int, 621);
pub const OBJ_setAttr_PGWYcap = blk: {
    _ = &OBJ_set_attr;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_TokenType = "setAttr-TokenType";
pub const NID_setAttr_TokenType = @as(c_int, 622);
pub const OBJ_setAttr_TokenType = blk: {
    _ = &OBJ_set_attr;
    break :blk @as(c_long, 2);
};
pub const SN_setAttr_IssCap = "setAttr-IssCap";
pub const LN_setAttr_IssCap = "issuer capabilities";
pub const NID_setAttr_IssCap = @as(c_int, 623);
pub const OBJ_setAttr_IssCap = blk: {
    _ = &OBJ_set_attr;
    break :blk @as(c_long, 3);
};
pub const SN_set_rootKeyThumb = "set-rootKeyThumb";
pub const NID_set_rootKeyThumb = @as(c_int, 624);
pub const OBJ_set_rootKeyThumb = blk: {
    _ = &OBJ_setAttr_Cert;
    break :blk @as(c_long, 0);
};
pub const SN_set_addPolicy = "set-addPolicy";
pub const NID_set_addPolicy = @as(c_int, 625);
pub const OBJ_set_addPolicy = blk: {
    _ = &OBJ_setAttr_Cert;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_Token_EMV = "setAttr-Token-EMV";
pub const NID_setAttr_Token_EMV = @as(c_int, 626);
pub const OBJ_setAttr_Token_EMV = blk: {
    _ = &OBJ_setAttr_TokenType;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_Token_B0Prime = "setAttr-Token-B0Prime";
pub const NID_setAttr_Token_B0Prime = @as(c_int, 627);
pub const OBJ_setAttr_Token_B0Prime = blk: {
    _ = &OBJ_setAttr_TokenType;
    break :blk @as(c_long, 2);
};
pub const SN_setAttr_IssCap_CVM = "setAttr-IssCap-CVM";
pub const NID_setAttr_IssCap_CVM = @as(c_int, 628);
pub const OBJ_setAttr_IssCap_CVM = blk: {
    _ = &OBJ_setAttr_IssCap;
    break :blk @as(c_long, 3);
};
pub const SN_setAttr_IssCap_T2 = "setAttr-IssCap-T2";
pub const NID_setAttr_IssCap_T2 = @as(c_int, 629);
pub const OBJ_setAttr_IssCap_T2 = blk: {
    _ = &OBJ_setAttr_IssCap;
    break :blk @as(c_long, 4);
};
pub const SN_setAttr_IssCap_Sig = "setAttr-IssCap-Sig";
pub const NID_setAttr_IssCap_Sig = @as(c_int, 630);
pub const OBJ_setAttr_IssCap_Sig = blk: {
    _ = &OBJ_setAttr_IssCap;
    break :blk @as(c_long, 5);
};
pub const SN_setAttr_GenCryptgrm = "setAttr-GenCryptgrm";
pub const LN_setAttr_GenCryptgrm = "generate cryptogram";
pub const NID_setAttr_GenCryptgrm = @as(c_int, 631);
pub const OBJ_setAttr_GenCryptgrm = blk: {
    _ = &OBJ_setAttr_IssCap_CVM;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_T2Enc = "setAttr-T2Enc";
pub const LN_setAttr_T2Enc = "encrypted track 2";
pub const NID_setAttr_T2Enc = @as(c_int, 632);
pub const OBJ_setAttr_T2Enc = blk: {
    _ = &OBJ_setAttr_IssCap_T2;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_T2cleartxt = "setAttr-T2cleartxt";
pub const LN_setAttr_T2cleartxt = "cleartext track 2";
pub const NID_setAttr_T2cleartxt = @as(c_int, 633);
pub const OBJ_setAttr_T2cleartxt = blk: {
    _ = &OBJ_setAttr_IssCap_T2;
    break :blk @as(c_long, 2);
};
pub const SN_setAttr_TokICCsig = "setAttr-TokICCsig";
pub const LN_setAttr_TokICCsig = "ICC or token signature";
pub const NID_setAttr_TokICCsig = @as(c_int, 634);
pub const OBJ_setAttr_TokICCsig = blk: {
    _ = &OBJ_setAttr_IssCap_Sig;
    break :blk @as(c_long, 1);
};
pub const SN_setAttr_SecDevSig = "setAttr-SecDevSig";
pub const LN_setAttr_SecDevSig = "secure device signature";
pub const NID_setAttr_SecDevSig = @as(c_int, 635);
pub const OBJ_setAttr_SecDevSig = blk: {
    _ = &OBJ_setAttr_IssCap_Sig;
    break :blk @as(c_long, 2);
};
pub const SN_set_brand_IATA_ATA = "set-brand-IATA-ATA";
pub const NID_set_brand_IATA_ATA = @as(c_int, 636);
pub const OBJ_set_brand_IATA_ATA = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 1);
};
pub const SN_set_brand_Diners = "set-brand-Diners";
pub const NID_set_brand_Diners = @as(c_int, 637);
pub const OBJ_set_brand_Diners = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 30);
};
pub const SN_set_brand_AmericanExpress = "set-brand-AmericanExpress";
pub const NID_set_brand_AmericanExpress = @as(c_int, 638);
pub const OBJ_set_brand_AmericanExpress = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 34);
};
pub const SN_set_brand_JCB = "set-brand-JCB";
pub const NID_set_brand_JCB = @as(c_int, 639);
pub const OBJ_set_brand_JCB = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 35);
};
pub const SN_set_brand_Visa = "set-brand-Visa";
pub const NID_set_brand_Visa = @as(c_int, 640);
pub const OBJ_set_brand_Visa = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 4);
};
pub const SN_set_brand_MasterCard = "set-brand-MasterCard";
pub const NID_set_brand_MasterCard = @as(c_int, 641);
pub const OBJ_set_brand_MasterCard = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 5);
};
pub const SN_set_brand_Novus = "set-brand-Novus";
pub const NID_set_brand_Novus = @as(c_int, 642);
pub const OBJ_set_brand_Novus = blk: {
    _ = &OBJ_set_brand;
    break :blk @as(c_long, 6011);
};
pub const SN_des_cdmf = "DES-CDMF";
pub const LN_des_cdmf = "des-cdmf";
pub const NID_des_cdmf = @as(c_int, 643);
pub const OBJ_des_cdmf = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 3);
    break :blk @as(c_long, 10);
};
pub const SN_rsaOAEPEncryptionSET = "rsaOAEPEncryptionSET";
pub const NID_rsaOAEPEncryptionSET = @as(c_int, 644);
pub const OBJ_rsaOAEPEncryptionSET = blk: {
    _ = &OBJ_rsadsi;
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 6);
};
pub const SN_ipsec3 = "Oakley-EC2N-3";
pub const LN_ipsec3 = "ipsec3";
pub const NID_ipsec3 = @as(c_int, 749);
pub const SN_ipsec4 = "Oakley-EC2N-4";
pub const LN_ipsec4 = "ipsec4";
pub const NID_ipsec4 = @as(c_int, 750);
pub const SN_whirlpool = "whirlpool";
pub const NID_whirlpool = @as(c_int, 804);
pub const OBJ_whirlpool = blk: {
    _ = &OBJ_iso;
    _ = @as(c_long, 0);
    _ = @as(c_long, 10118);
    _ = @as(c_long, 3);
    _ = @as(c_long, 0);
    break :blk @as(c_long, 55);
};
pub const SN_cryptopro = "cryptopro";
pub const NID_cryptopro = @as(c_int, 805);
pub const OBJ_cryptopro = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 2);
};
pub const SN_cryptocom = "cryptocom";
pub const NID_cryptocom = @as(c_int, 806);
pub const OBJ_cryptocom = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 9);
};
pub const SN_id_tc26 = "id-tc26";
pub const NID_id_tc26 = @as(c_int, 974);
pub const OBJ_id_tc26 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 7);
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3411_94_with_GostR3410_2001 = "id-GostR3411-94-with-GostR3410-2001";
pub const LN_id_GostR3411_94_with_GostR3410_2001 = "GOST R 34.11-94 with GOST R 34.10-2001";
pub const NID_id_GostR3411_94_with_GostR3410_2001 = @as(c_int, 807);
pub const OBJ_id_GostR3411_94_with_GostR3410_2001 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3411_94_with_GostR3410_94 = "id-GostR3411-94-with-GostR3410-94";
pub const LN_id_GostR3411_94_with_GostR3410_94 = "GOST R 34.11-94 with GOST R 34.10-94";
pub const NID_id_GostR3411_94_with_GostR3410_94 = @as(c_int, 808);
pub const OBJ_id_GostR3411_94_with_GostR3410_94 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 4);
};
pub const SN_id_GostR3411_94 = "md_gost94";
pub const LN_id_GostR3411_94 = "GOST R 34.11-94";
pub const NID_id_GostR3411_94 = @as(c_int, 809);
pub const OBJ_id_GostR3411_94 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 9);
};
pub const SN_id_HMACGostR3411_94 = "id-HMACGostR3411-94";
pub const LN_id_HMACGostR3411_94 = "HMAC GOST 34.11-94";
pub const NID_id_HMACGostR3411_94 = @as(c_int, 810);
pub const OBJ_id_HMACGostR3411_94 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 10);
};
pub const SN_id_GostR3410_2001 = "gost2001";
pub const LN_id_GostR3410_2001 = "GOST R 34.10-2001";
pub const NID_id_GostR3410_2001 = @as(c_int, 811);
pub const OBJ_id_GostR3410_2001 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 19);
};
pub const SN_id_GostR3410_94 = "gost94";
pub const LN_id_GostR3410_94 = "GOST R 34.10-94";
pub const NID_id_GostR3410_94 = @as(c_int, 812);
pub const OBJ_id_GostR3410_94 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 20);
};
pub const SN_id_Gost28147_89 = "gost89";
pub const LN_id_Gost28147_89 = "GOST 28147-89";
pub const NID_id_Gost28147_89 = @as(c_int, 813);
pub const OBJ_id_Gost28147_89 = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 21);
};
pub const SN_gost89_cnt = "gost89-cnt";
pub const NID_gost89_cnt = @as(c_int, 814);
pub const SN_gost89_cnt_12 = "gost89-cnt-12";
pub const NID_gost89_cnt_12 = @as(c_int, 975);
pub const SN_gost89_cbc = "gost89-cbc";
pub const NID_gost89_cbc = @as(c_int, 1009);
pub const SN_gost89_ecb = "gost89-ecb";
pub const NID_gost89_ecb = @as(c_int, 1010);
pub const SN_gost89_ctr = "gost89-ctr";
pub const NID_gost89_ctr = @as(c_int, 1011);
pub const SN_id_Gost28147_89_MAC = "gost-mac";
pub const LN_id_Gost28147_89_MAC = "GOST 28147-89 MAC";
pub const NID_id_Gost28147_89_MAC = @as(c_int, 815);
pub const OBJ_id_Gost28147_89_MAC = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 22);
};
pub const SN_gost_mac_12 = "gost-mac-12";
pub const NID_gost_mac_12 = @as(c_int, 976);
pub const SN_id_GostR3411_94_prf = "prf-gostr3411-94";
pub const LN_id_GostR3411_94_prf = "GOST R 34.11-94 PRF";
pub const NID_id_GostR3411_94_prf = @as(c_int, 816);
pub const OBJ_id_GostR3411_94_prf = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 23);
};
pub const SN_id_GostR3410_2001DH = "id-GostR3410-2001DH";
pub const LN_id_GostR3410_2001DH = "GOST R 34.10-2001 DH";
pub const NID_id_GostR3410_2001DH = @as(c_int, 817);
pub const OBJ_id_GostR3410_2001DH = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 98);
};
pub const SN_id_GostR3410_94DH = "id-GostR3410-94DH";
pub const LN_id_GostR3410_94DH = "GOST R 34.10-94 DH";
pub const NID_id_GostR3410_94DH = @as(c_int, 818);
pub const OBJ_id_GostR3410_94DH = blk: {
    _ = &OBJ_cryptopro;
    break :blk @as(c_long, 99);
};
pub const SN_id_Gost28147_89_CryptoPro_KeyMeshing = "id-Gost28147-89-CryptoPro-KeyMeshing";
pub const NID_id_Gost28147_89_CryptoPro_KeyMeshing = @as(c_int, 819);
pub const OBJ_id_Gost28147_89_CryptoPro_KeyMeshing = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 1);
};
pub const SN_id_Gost28147_89_None_KeyMeshing = "id-Gost28147-89-None-KeyMeshing";
pub const NID_id_Gost28147_89_None_KeyMeshing = @as(c_int, 820);
pub const OBJ_id_Gost28147_89_None_KeyMeshing = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 0);
};
pub const SN_id_GostR3411_94_TestParamSet = "id-GostR3411-94-TestParamSet";
pub const NID_id_GostR3411_94_TestParamSet = @as(c_int, 821);
pub const OBJ_id_GostR3411_94_TestParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 30);
    break :blk @as(c_long, 0);
};
pub const SN_id_GostR3411_94_CryptoProParamSet = "id-GostR3411-94-CryptoProParamSet";
pub const NID_id_GostR3411_94_CryptoProParamSet = @as(c_int, 822);
pub const OBJ_id_GostR3411_94_CryptoProParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 30);
    break :blk @as(c_long, 1);
};
pub const SN_id_Gost28147_89_TestParamSet = "id-Gost28147-89-TestParamSet";
pub const NID_id_Gost28147_89_TestParamSet = @as(c_int, 823);
pub const OBJ_id_Gost28147_89_TestParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 0);
};
pub const SN_id_Gost28147_89_CryptoPro_A_ParamSet = "id-Gost28147-89-CryptoPro-A-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_A_ParamSet = @as(c_int, 824);
pub const OBJ_id_Gost28147_89_CryptoPro_A_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 1);
};
pub const SN_id_Gost28147_89_CryptoPro_B_ParamSet = "id-Gost28147-89-CryptoPro-B-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_B_ParamSet = @as(c_int, 825);
pub const OBJ_id_Gost28147_89_CryptoPro_B_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 2);
};
pub const SN_id_Gost28147_89_CryptoPro_C_ParamSet = "id-Gost28147-89-CryptoPro-C-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_C_ParamSet = @as(c_int, 826);
pub const OBJ_id_Gost28147_89_CryptoPro_C_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 3);
};
pub const SN_id_Gost28147_89_CryptoPro_D_ParamSet = "id-Gost28147-89-CryptoPro-D-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_D_ParamSet = @as(c_int, 827);
pub const OBJ_id_Gost28147_89_CryptoPro_D_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 4);
};
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet = "id-Gost28147-89-CryptoPro-Oscar-1-1-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet = @as(c_int, 828);
pub const OBJ_id_Gost28147_89_CryptoPro_Oscar_1_1_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 5);
};
pub const SN_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet = "id-Gost28147-89-CryptoPro-Oscar-1-0-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet = @as(c_int, 829);
pub const OBJ_id_Gost28147_89_CryptoPro_Oscar_1_0_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 6);
};
pub const SN_id_Gost28147_89_CryptoPro_RIC_1_ParamSet = "id-Gost28147-89-CryptoPro-RIC-1-ParamSet";
pub const NID_id_Gost28147_89_CryptoPro_RIC_1_ParamSet = @as(c_int, 830);
pub const OBJ_id_Gost28147_89_CryptoPro_RIC_1_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 31);
    break :blk @as(c_long, 7);
};
pub const SN_id_GostR3410_94_TestParamSet = "id-GostR3410-94-TestParamSet";
pub const NID_id_GostR3410_94_TestParamSet = @as(c_int, 831);
pub const OBJ_id_GostR3410_94_TestParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 32);
    break :blk @as(c_long, 0);
};
pub const SN_id_GostR3410_94_CryptoPro_A_ParamSet = "id-GostR3410-94-CryptoPro-A-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_A_ParamSet = @as(c_int, 832);
pub const OBJ_id_GostR3410_94_CryptoPro_A_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 32);
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3410_94_CryptoPro_B_ParamSet = "id-GostR3410-94-CryptoPro-B-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_B_ParamSet = @as(c_int, 833);
pub const OBJ_id_GostR3410_94_CryptoPro_B_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 32);
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3410_94_CryptoPro_C_ParamSet = "id-GostR3410-94-CryptoPro-C-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_C_ParamSet = @as(c_int, 834);
pub const OBJ_id_GostR3410_94_CryptoPro_C_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 32);
    break :blk @as(c_long, 4);
};
pub const SN_id_GostR3410_94_CryptoPro_D_ParamSet = "id-GostR3410-94-CryptoPro-D-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_D_ParamSet = @as(c_int, 835);
pub const OBJ_id_GostR3410_94_CryptoPro_D_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 32);
    break :blk @as(c_long, 5);
};
pub const SN_id_GostR3410_94_CryptoPro_XchA_ParamSet = "id-GostR3410-94-CryptoPro-XchA-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_XchA_ParamSet = @as(c_int, 836);
pub const OBJ_id_GostR3410_94_CryptoPro_XchA_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 33);
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_94_CryptoPro_XchB_ParamSet = "id-GostR3410-94-CryptoPro-XchB-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_XchB_ParamSet = @as(c_int, 837);
pub const OBJ_id_GostR3410_94_CryptoPro_XchB_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 33);
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3410_94_CryptoPro_XchC_ParamSet = "id-GostR3410-94-CryptoPro-XchC-ParamSet";
pub const NID_id_GostR3410_94_CryptoPro_XchC_ParamSet = @as(c_int, 838);
pub const OBJ_id_GostR3410_94_CryptoPro_XchC_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 33);
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3410_2001_TestParamSet = "id-GostR3410-2001-TestParamSet";
pub const NID_id_GostR3410_2001_TestParamSet = @as(c_int, 839);
pub const OBJ_id_GostR3410_2001_TestParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 35);
    break :blk @as(c_long, 0);
};
pub const SN_id_GostR3410_2001_CryptoPro_A_ParamSet = "id-GostR3410-2001-CryptoPro-A-ParamSet";
pub const NID_id_GostR3410_2001_CryptoPro_A_ParamSet = @as(c_int, 840);
pub const OBJ_id_GostR3410_2001_CryptoPro_A_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 35);
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_2001_CryptoPro_B_ParamSet = "id-GostR3410-2001-CryptoPro-B-ParamSet";
pub const NID_id_GostR3410_2001_CryptoPro_B_ParamSet = @as(c_int, 841);
pub const OBJ_id_GostR3410_2001_CryptoPro_B_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 35);
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3410_2001_CryptoPro_C_ParamSet = "id-GostR3410-2001-CryptoPro-C-ParamSet";
pub const NID_id_GostR3410_2001_CryptoPro_C_ParamSet = @as(c_int, 842);
pub const OBJ_id_GostR3410_2001_CryptoPro_C_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 35);
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3410_2001_CryptoPro_XchA_ParamSet = "id-GostR3410-2001-CryptoPro-XchA-ParamSet";
pub const NID_id_GostR3410_2001_CryptoPro_XchA_ParamSet = @as(c_int, 843);
pub const OBJ_id_GostR3410_2001_CryptoPro_XchA_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 36);
    break :blk @as(c_long, 0);
};
pub const SN_id_GostR3410_2001_CryptoPro_XchB_ParamSet = "id-GostR3410-2001-CryptoPro-XchB-ParamSet";
pub const NID_id_GostR3410_2001_CryptoPro_XchB_ParamSet = @as(c_int, 844);
pub const OBJ_id_GostR3410_2001_CryptoPro_XchB_ParamSet = blk: {
    _ = &OBJ_cryptopro;
    _ = @as(c_long, 36);
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_94_a = "id-GostR3410-94-a";
pub const NID_id_GostR3410_94_a = @as(c_int, 845);
pub const OBJ_id_GostR3410_94_a = blk: {
    _ = &OBJ_id_GostR3410_94;
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_94_aBis = "id-GostR3410-94-aBis";
pub const NID_id_GostR3410_94_aBis = @as(c_int, 846);
pub const OBJ_id_GostR3410_94_aBis = blk: {
    _ = &OBJ_id_GostR3410_94;
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3410_94_b = "id-GostR3410-94-b";
pub const NID_id_GostR3410_94_b = @as(c_int, 847);
pub const OBJ_id_GostR3410_94_b = blk: {
    _ = &OBJ_id_GostR3410_94;
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3410_94_bBis = "id-GostR3410-94-bBis";
pub const NID_id_GostR3410_94_bBis = @as(c_int, 848);
pub const OBJ_id_GostR3410_94_bBis = blk: {
    _ = &OBJ_id_GostR3410_94;
    break :blk @as(c_long, 4);
};
pub const SN_id_Gost28147_89_cc = "id-Gost28147-89-cc";
pub const LN_id_Gost28147_89_cc = "GOST 28147-89 Cryptocom ParamSet";
pub const NID_id_Gost28147_89_cc = @as(c_int, 849);
pub const OBJ_id_Gost28147_89_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 6);
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_94_cc = "gost94cc";
pub const LN_id_GostR3410_94_cc = "GOST 34.10-94 Cryptocom";
pub const NID_id_GostR3410_94_cc = @as(c_int, 850);
pub const OBJ_id_GostR3410_94_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3410_2001_cc = "gost2001cc";
pub const LN_id_GostR3410_2001_cc = "GOST 34.10-2001 Cryptocom";
pub const NID_id_GostR3410_2001_cc = @as(c_int, 851);
pub const OBJ_id_GostR3410_2001_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    break :blk @as(c_long, 4);
};
pub const SN_id_GostR3411_94_with_GostR3410_94_cc = "id-GostR3411-94-with-GostR3410-94-cc";
pub const LN_id_GostR3411_94_with_GostR3410_94_cc = "GOST R 34.11-94 with GOST R 34.10-94 Cryptocom";
pub const NID_id_GostR3411_94_with_GostR3410_94_cc = @as(c_int, 852);
pub const OBJ_id_GostR3411_94_with_GostR3410_94_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 3);
};
pub const SN_id_GostR3411_94_with_GostR3410_2001_cc = "id-GostR3411-94-with-GostR3410-2001-cc";
pub const LN_id_GostR3411_94_with_GostR3410_2001_cc = "GOST R 34.11-94 with GOST R 34.10-2001 Cryptocom";
pub const NID_id_GostR3411_94_with_GostR3410_2001_cc = @as(c_int, 853);
pub const OBJ_id_GostR3411_94_with_GostR3410_2001_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 4);
};
pub const SN_id_GostR3410_2001_ParamSet_cc = "id-GostR3410-2001-ParamSet-cc";
pub const LN_id_GostR3410_2001_ParamSet_cc = "GOST R 3410-2001 Parameter Set Cryptocom";
pub const NID_id_GostR3410_2001_ParamSet_cc = @as(c_int, 854);
pub const OBJ_id_GostR3410_2001_ParamSet_cc = blk: {
    _ = &OBJ_cryptocom;
    _ = @as(c_long, 1);
    _ = @as(c_long, 8);
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_algorithms = "id-tc26-algorithms";
pub const NID_id_tc26_algorithms = @as(c_int, 977);
pub const OBJ_id_tc26_algorithms = blk: {
    _ = &OBJ_id_tc26;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_sign = "id-tc26-sign";
pub const NID_id_tc26_sign = @as(c_int, 978);
pub const OBJ_id_tc26_sign = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_2012_256 = "gost2012_256";
pub const LN_id_GostR3410_2012_256 = "GOST R 34.10-2012 with 256 bit modulus";
pub const NID_id_GostR3410_2012_256 = @as(c_int, 979);
pub const OBJ_id_GostR3410_2012_256 = blk: {
    _ = &OBJ_id_tc26_sign;
    break :blk @as(c_long, 1);
};
pub const SN_id_GostR3410_2012_512 = "gost2012_512";
pub const LN_id_GostR3410_2012_512 = "GOST R 34.10-2012 with 512 bit modulus";
pub const NID_id_GostR3410_2012_512 = @as(c_int, 980);
pub const OBJ_id_GostR3410_2012_512 = blk: {
    _ = &OBJ_id_tc26_sign;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_digest = "id-tc26-digest";
pub const NID_id_tc26_digest = @as(c_int, 981);
pub const OBJ_id_tc26_digest = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3411_2012_256 = "md_gost12_256";
pub const LN_id_GostR3411_2012_256 = "GOST R 34.11-2012 with 256 bit hash";
pub const NID_id_GostR3411_2012_256 = @as(c_int, 982);
pub const OBJ_id_GostR3411_2012_256 = blk: {
    _ = &OBJ_id_tc26_digest;
    break :blk @as(c_long, 2);
};
pub const SN_id_GostR3411_2012_512 = "md_gost12_512";
pub const LN_id_GostR3411_2012_512 = "GOST R 34.11-2012 with 512 bit hash";
pub const NID_id_GostR3411_2012_512 = @as(c_int, 983);
pub const OBJ_id_GostR3411_2012_512 = blk: {
    _ = &OBJ_id_tc26_digest;
    break :blk @as(c_long, 3);
};
pub const SN_id_tc26_signwithdigest = "id-tc26-signwithdigest";
pub const NID_id_tc26_signwithdigest = @as(c_int, 984);
pub const OBJ_id_tc26_signwithdigest = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 3);
};
pub const SN_id_tc26_signwithdigest_gost3410_2012_256 = "id-tc26-signwithdigest-gost3410-2012-256";
pub const LN_id_tc26_signwithdigest_gost3410_2012_256 = "GOST R 34.10-2012 with GOST R 34.11-2012 (256 bit)";
pub const NID_id_tc26_signwithdigest_gost3410_2012_256 = @as(c_int, 985);
pub const OBJ_id_tc26_signwithdigest_gost3410_2012_256 = blk: {
    _ = &OBJ_id_tc26_signwithdigest;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_signwithdigest_gost3410_2012_512 = "id-tc26-signwithdigest-gost3410-2012-512";
pub const LN_id_tc26_signwithdigest_gost3410_2012_512 = "GOST R 34.10-2012 with GOST R 34.11-2012 (512 bit)";
pub const NID_id_tc26_signwithdigest_gost3410_2012_512 = @as(c_int, 986);
pub const OBJ_id_tc26_signwithdigest_gost3410_2012_512 = blk: {
    _ = &OBJ_id_tc26_signwithdigest;
    break :blk @as(c_long, 3);
};
pub const SN_id_tc26_mac = "id-tc26-mac";
pub const NID_id_tc26_mac = @as(c_int, 987);
pub const OBJ_id_tc26_mac = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 4);
};
pub const SN_id_tc26_hmac_gost_3411_2012_256 = "id-tc26-hmac-gost-3411-2012-256";
pub const LN_id_tc26_hmac_gost_3411_2012_256 = "HMAC GOST 34.11-2012 256 bit";
pub const NID_id_tc26_hmac_gost_3411_2012_256 = @as(c_int, 988);
pub const OBJ_id_tc26_hmac_gost_3411_2012_256 = blk: {
    _ = &OBJ_id_tc26_mac;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_hmac_gost_3411_2012_512 = "id-tc26-hmac-gost-3411-2012-512";
pub const LN_id_tc26_hmac_gost_3411_2012_512 = "HMAC GOST 34.11-2012 512 bit";
pub const NID_id_tc26_hmac_gost_3411_2012_512 = @as(c_int, 989);
pub const OBJ_id_tc26_hmac_gost_3411_2012_512 = blk: {
    _ = &OBJ_id_tc26_mac;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_cipher = "id-tc26-cipher";
pub const NID_id_tc26_cipher = @as(c_int, 990);
pub const OBJ_id_tc26_cipher = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 5);
};
pub const SN_id_tc26_cipher_gostr3412_2015_magma = "id-tc26-cipher-gostr3412-2015-magma";
pub const NID_id_tc26_cipher_gostr3412_2015_magma = @as(c_int, 1173);
pub const OBJ_id_tc26_cipher_gostr3412_2015_magma = blk: {
    _ = &OBJ_id_tc26_cipher;
    break :blk @as(c_long, 1);
};
pub const SN_magma_ctr_acpkm = "magma-ctr-acpkm";
pub const NID_magma_ctr_acpkm = @as(c_int, 1174);
pub const OBJ_magma_ctr_acpkm = blk: {
    _ = &OBJ_id_tc26_cipher_gostr3412_2015_magma;
    break :blk @as(c_long, 1);
};
pub const SN_magma_ctr_acpkm_omac = "magma-ctr-acpkm-omac";
pub const NID_magma_ctr_acpkm_omac = @as(c_int, 1175);
pub const OBJ_magma_ctr_acpkm_omac = blk: {
    _ = &OBJ_id_tc26_cipher_gostr3412_2015_magma;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik = "id-tc26-cipher-gostr3412-2015-kuznyechik";
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik = @as(c_int, 1176);
pub const OBJ_id_tc26_cipher_gostr3412_2015_kuznyechik = blk: {
    _ = &OBJ_id_tc26_cipher;
    break :blk @as(c_long, 2);
};
pub const SN_kuznyechik_ctr_acpkm = "kuznyechik-ctr-acpkm";
pub const NID_kuznyechik_ctr_acpkm = @as(c_int, 1177);
pub const OBJ_kuznyechik_ctr_acpkm = blk: {
    _ = &OBJ_id_tc26_cipher_gostr3412_2015_kuznyechik;
    break :blk @as(c_long, 1);
};
pub const SN_kuznyechik_ctr_acpkm_omac = "kuznyechik-ctr-acpkm-omac";
pub const NID_kuznyechik_ctr_acpkm_omac = @as(c_int, 1178);
pub const OBJ_kuznyechik_ctr_acpkm_omac = blk: {
    _ = &OBJ_id_tc26_cipher_gostr3412_2015_kuznyechik;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_agreement = "id-tc26-agreement";
pub const NID_id_tc26_agreement = @as(c_int, 991);
pub const OBJ_id_tc26_agreement = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 6);
};
pub const SN_id_tc26_agreement_gost_3410_2012_256 = "id-tc26-agreement-gost-3410-2012-256";
pub const NID_id_tc26_agreement_gost_3410_2012_256 = @as(c_int, 992);
pub const OBJ_id_tc26_agreement_gost_3410_2012_256 = blk: {
    _ = &OBJ_id_tc26_agreement;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_agreement_gost_3410_2012_512 = "id-tc26-agreement-gost-3410-2012-512";
pub const NID_id_tc26_agreement_gost_3410_2012_512 = @as(c_int, 993);
pub const OBJ_id_tc26_agreement_gost_3410_2012_512 = blk: {
    _ = &OBJ_id_tc26_agreement;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_wrap = "id-tc26-wrap";
pub const NID_id_tc26_wrap = @as(c_int, 1179);
pub const OBJ_id_tc26_wrap = blk: {
    _ = &OBJ_id_tc26_algorithms;
    break :blk @as(c_long, 7);
};
pub const SN_id_tc26_wrap_gostr3412_2015_magma = "id-tc26-wrap-gostr3412-2015-magma";
pub const NID_id_tc26_wrap_gostr3412_2015_magma = @as(c_int, 1180);
pub const OBJ_id_tc26_wrap_gostr3412_2015_magma = blk: {
    _ = &OBJ_id_tc26_wrap;
    break :blk @as(c_long, 1);
};
pub const SN_magma_kexp15 = "magma-kexp15";
pub const NID_magma_kexp15 = @as(c_int, 1181);
pub const OBJ_magma_kexp15 = blk: {
    _ = &OBJ_id_tc26_wrap_gostr3412_2015_magma;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_wrap_gostr3412_2015_kuznyechik = "id-tc26-wrap-gostr3412-2015-kuznyechik";
pub const NID_id_tc26_wrap_gostr3412_2015_kuznyechik = @as(c_int, 1182);
pub const OBJ_id_tc26_wrap_gostr3412_2015_kuznyechik = blk: {
    _ = &OBJ_id_tc26_wrap;
    break :blk @as(c_long, 2);
};
pub const SN_kuznyechik_kexp15 = "kuznyechik-kexp15";
pub const NID_kuznyechik_kexp15 = @as(c_int, 1183);
pub const OBJ_kuznyechik_kexp15 = blk: {
    _ = &OBJ_id_tc26_wrap_gostr3412_2015_kuznyechik;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_constants = "id-tc26-constants";
pub const NID_id_tc26_constants = @as(c_int, 994);
pub const OBJ_id_tc26_constants = blk: {
    _ = &OBJ_id_tc26;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_sign_constants = "id-tc26-sign-constants";
pub const NID_id_tc26_sign_constants = @as(c_int, 995);
pub const OBJ_id_tc26_sign_constants = blk: {
    _ = &OBJ_id_tc26_constants;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_gost_3410_2012_256_constants = "id-tc26-gost-3410-2012-256-constants";
pub const NID_id_tc26_gost_3410_2012_256_constants = @as(c_int, 1147);
pub const OBJ_id_tc26_gost_3410_2012_256_constants = blk: {
    _ = &OBJ_id_tc26_sign_constants;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_gost_3410_2012_256_paramSetA = "id-tc26-gost-3410-2012-256-paramSetA";
pub const LN_id_tc26_gost_3410_2012_256_paramSetA = "GOST R 34.10-2012 (256 bit) ParamSet A";
pub const NID_id_tc26_gost_3410_2012_256_paramSetA = @as(c_int, 1148);
pub const OBJ_id_tc26_gost_3410_2012_256_paramSetA = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_256_constants;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_gost_3410_2012_256_paramSetB = "id-tc26-gost-3410-2012-256-paramSetB";
pub const LN_id_tc26_gost_3410_2012_256_paramSetB = "GOST R 34.10-2012 (256 bit) ParamSet B";
pub const NID_id_tc26_gost_3410_2012_256_paramSetB = @as(c_int, 1184);
pub const OBJ_id_tc26_gost_3410_2012_256_paramSetB = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_256_constants;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_gost_3410_2012_256_paramSetC = "id-tc26-gost-3410-2012-256-paramSetC";
pub const LN_id_tc26_gost_3410_2012_256_paramSetC = "GOST R 34.10-2012 (256 bit) ParamSet C";
pub const NID_id_tc26_gost_3410_2012_256_paramSetC = @as(c_int, 1185);
pub const OBJ_id_tc26_gost_3410_2012_256_paramSetC = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_256_constants;
    break :blk @as(c_long, 3);
};
pub const SN_id_tc26_gost_3410_2012_256_paramSetD = "id-tc26-gost-3410-2012-256-paramSetD";
pub const LN_id_tc26_gost_3410_2012_256_paramSetD = "GOST R 34.10-2012 (256 bit) ParamSet D";
pub const NID_id_tc26_gost_3410_2012_256_paramSetD = @as(c_int, 1186);
pub const OBJ_id_tc26_gost_3410_2012_256_paramSetD = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_256_constants;
    break :blk @as(c_long, 4);
};
pub const SN_id_tc26_gost_3410_2012_512_constants = "id-tc26-gost-3410-2012-512-constants";
pub const NID_id_tc26_gost_3410_2012_512_constants = @as(c_int, 996);
pub const OBJ_id_tc26_gost_3410_2012_512_constants = blk: {
    _ = &OBJ_id_tc26_sign_constants;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_gost_3410_2012_512_paramSetTest = "id-tc26-gost-3410-2012-512-paramSetTest";
pub const LN_id_tc26_gost_3410_2012_512_paramSetTest = "GOST R 34.10-2012 (512 bit) testing parameter set";
pub const NID_id_tc26_gost_3410_2012_512_paramSetTest = @as(c_int, 997);
pub const OBJ_id_tc26_gost_3410_2012_512_paramSetTest = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_512_constants;
    break :blk @as(c_long, 0);
};
pub const SN_id_tc26_gost_3410_2012_512_paramSetA = "id-tc26-gost-3410-2012-512-paramSetA";
pub const LN_id_tc26_gost_3410_2012_512_paramSetA = "GOST R 34.10-2012 (512 bit) ParamSet A";
pub const NID_id_tc26_gost_3410_2012_512_paramSetA = @as(c_int, 998);
pub const OBJ_id_tc26_gost_3410_2012_512_paramSetA = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_512_constants;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_gost_3410_2012_512_paramSetB = "id-tc26-gost-3410-2012-512-paramSetB";
pub const LN_id_tc26_gost_3410_2012_512_paramSetB = "GOST R 34.10-2012 (512 bit) ParamSet B";
pub const NID_id_tc26_gost_3410_2012_512_paramSetB = @as(c_int, 999);
pub const OBJ_id_tc26_gost_3410_2012_512_paramSetB = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_512_constants;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_gost_3410_2012_512_paramSetC = "id-tc26-gost-3410-2012-512-paramSetC";
pub const LN_id_tc26_gost_3410_2012_512_paramSetC = "GOST R 34.10-2012 (512 bit) ParamSet C";
pub const NID_id_tc26_gost_3410_2012_512_paramSetC = @as(c_int, 1149);
pub const OBJ_id_tc26_gost_3410_2012_512_paramSetC = blk: {
    _ = &OBJ_id_tc26_gost_3410_2012_512_constants;
    break :blk @as(c_long, 3);
};
pub const SN_id_tc26_digest_constants = "id-tc26-digest-constants";
pub const NID_id_tc26_digest_constants = @as(c_int, 1000);
pub const OBJ_id_tc26_digest_constants = blk: {
    _ = &OBJ_id_tc26_constants;
    break :blk @as(c_long, 2);
};
pub const SN_id_tc26_cipher_constants = "id-tc26-cipher-constants";
pub const NID_id_tc26_cipher_constants = @as(c_int, 1001);
pub const OBJ_id_tc26_cipher_constants = blk: {
    _ = &OBJ_id_tc26_constants;
    break :blk @as(c_long, 5);
};
pub const SN_id_tc26_gost_28147_constants = "id-tc26-gost-28147-constants";
pub const NID_id_tc26_gost_28147_constants = @as(c_int, 1002);
pub const OBJ_id_tc26_gost_28147_constants = blk: {
    _ = &OBJ_id_tc26_cipher_constants;
    break :blk @as(c_long, 1);
};
pub const SN_id_tc26_gost_28147_param_Z = "id-tc26-gost-28147-param-Z";
pub const LN_id_tc26_gost_28147_param_Z = "GOST 28147-89 TC26 parameter set";
pub const NID_id_tc26_gost_28147_param_Z = @as(c_int, 1003);
pub const OBJ_id_tc26_gost_28147_param_Z = blk: {
    _ = &OBJ_id_tc26_gost_28147_constants;
    break :blk @as(c_long, 1);
};
pub const SN_INN = "INN";
pub const LN_INN = "INN";
pub const NID_INN = @as(c_int, 1004);
pub const OBJ_INN = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 3);
    _ = @as(c_long, 131);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_OGRN = "OGRN";
pub const LN_OGRN = "OGRN";
pub const NID_OGRN = @as(c_int, 1005);
pub const OBJ_OGRN = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 1);
};
pub const SN_SNILS = "SNILS";
pub const LN_SNILS = "SNILS";
pub const NID_SNILS = @as(c_int, 1006);
pub const OBJ_SNILS = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 3);
};
pub const SN_OGRNIP = "OGRNIP";
pub const LN_OGRNIP = "OGRNIP";
pub const NID_OGRNIP = @as(c_int, 1226);
pub const OBJ_OGRNIP = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 5);
};
pub const SN_subjectSignTool = "subjectSignTool";
pub const LN_subjectSignTool = "Signing Tool of Subject";
pub const NID_subjectSignTool = @as(c_int, 1007);
pub const OBJ_subjectSignTool = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 111);
};
pub const SN_issuerSignTool = "issuerSignTool";
pub const LN_issuerSignTool = "Signing Tool of Issuer";
pub const NID_issuerSignTool = @as(c_int, 1008);
pub const OBJ_issuerSignTool = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 112);
};
pub const SN_classSignTool = "classSignTool";
pub const LN_classSignTool = "Class of Signing Tool";
pub const NID_classSignTool = @as(c_int, 1227);
pub const OBJ_classSignTool = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    break :blk @as(c_long, 113);
};
pub const SN_classSignToolKC1 = "classSignToolKC1";
pub const LN_classSignToolKC1 = "Class of Signing Tool KC1";
pub const NID_classSignToolKC1 = @as(c_int, 1228);
pub const OBJ_classSignToolKC1 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 1);
};
pub const SN_classSignToolKC2 = "classSignToolKC2";
pub const LN_classSignToolKC2 = "Class of Signing Tool KC2";
pub const NID_classSignToolKC2 = @as(c_int, 1229);
pub const OBJ_classSignToolKC2 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 2);
};
pub const SN_classSignToolKC3 = "classSignToolKC3";
pub const LN_classSignToolKC3 = "Class of Signing Tool KC3";
pub const NID_classSignToolKC3 = @as(c_int, 1230);
pub const OBJ_classSignToolKC3 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 3);
};
pub const SN_classSignToolKB1 = "classSignToolKB1";
pub const LN_classSignToolKB1 = "Class of Signing Tool KB1";
pub const NID_classSignToolKB1 = @as(c_int, 1231);
pub const OBJ_classSignToolKB1 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 4);
};
pub const SN_classSignToolKB2 = "classSignToolKB2";
pub const LN_classSignToolKB2 = "Class of Signing Tool KB2";
pub const NID_classSignToolKB2 = @as(c_int, 1232);
pub const OBJ_classSignToolKB2 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 5);
};
pub const SN_classSignToolKA1 = "classSignToolKA1";
pub const LN_classSignToolKA1 = "Class of Signing Tool KA1";
pub const NID_classSignToolKA1 = @as(c_int, 1233);
pub const OBJ_classSignToolKA1 = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 643);
    _ = @as(c_long, 100);
    _ = @as(c_long, 113);
    break :blk @as(c_long, 6);
};
pub const SN_kuznyechik_ecb = "kuznyechik-ecb";
pub const NID_kuznyechik_ecb = @as(c_int, 1012);
pub const SN_kuznyechik_ctr = "kuznyechik-ctr";
pub const NID_kuznyechik_ctr = @as(c_int, 1013);
pub const SN_kuznyechik_ofb = "kuznyechik-ofb";
pub const NID_kuznyechik_ofb = @as(c_int, 1014);
pub const SN_kuznyechik_cbc = "kuznyechik-cbc";
pub const NID_kuznyechik_cbc = @as(c_int, 1015);
pub const SN_kuznyechik_cfb = "kuznyechik-cfb";
pub const NID_kuznyechik_cfb = @as(c_int, 1016);
pub const SN_kuznyechik_mac = "kuznyechik-mac";
pub const NID_kuznyechik_mac = @as(c_int, 1017);
pub const SN_magma_ecb = "magma-ecb";
pub const NID_magma_ecb = @as(c_int, 1187);
pub const SN_magma_ctr = "magma-ctr";
pub const NID_magma_ctr = @as(c_int, 1188);
pub const SN_magma_ofb = "magma-ofb";
pub const NID_magma_ofb = @as(c_int, 1189);
pub const SN_magma_cbc = "magma-cbc";
pub const NID_magma_cbc = @as(c_int, 1190);
pub const SN_magma_cfb = "magma-cfb";
pub const NID_magma_cfb = @as(c_int, 1191);
pub const SN_magma_mac = "magma-mac";
pub const NID_magma_mac = @as(c_int, 1192);
pub const SN_camellia_128_cbc = "CAMELLIA-128-CBC";
pub const LN_camellia_128_cbc = "camellia-128-cbc";
pub const NID_camellia_128_cbc = @as(c_int, 751);
pub const OBJ_camellia_128_cbc = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_camellia_192_cbc = "CAMELLIA-192-CBC";
pub const LN_camellia_192_cbc = "camellia-192-cbc";
pub const NID_camellia_192_cbc = @as(c_int, 752);
pub const OBJ_camellia_192_cbc = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 3);
};
pub const SN_camellia_256_cbc = "CAMELLIA-256-CBC";
pub const LN_camellia_256_cbc = "camellia-256-cbc";
pub const NID_camellia_256_cbc = @as(c_int, 753);
pub const OBJ_camellia_256_cbc = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 4);
};
pub const SN_id_camellia128_wrap = "id-camellia128-wrap";
pub const NID_id_camellia128_wrap = @as(c_int, 907);
pub const OBJ_id_camellia128_wrap = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 2);
};
pub const SN_id_camellia192_wrap = "id-camellia192-wrap";
pub const NID_id_camellia192_wrap = @as(c_int, 908);
pub const OBJ_id_camellia192_wrap = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 3);
};
pub const SN_id_camellia256_wrap = "id-camellia256-wrap";
pub const NID_id_camellia256_wrap = @as(c_int, 909);
pub const OBJ_id_camellia256_wrap = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 392);
    _ = @as(c_long, 200011);
    _ = @as(c_long, 61);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    break :blk @as(c_long, 4);
};
pub const OBJ_ntt_ds = blk: {
    _ = @as(c_long, 0);
    _ = @as(c_long, 3);
    _ = @as(c_long, 4401);
    break :blk @as(c_long, 5);
};
pub const OBJ_camellia = blk: {
    _ = &OBJ_ntt_ds;
    _ = @as(c_long, 3);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 9);
};
pub const SN_camellia_128_ecb = "CAMELLIA-128-ECB";
pub const LN_camellia_128_ecb = "camellia-128-ecb";
pub const NID_camellia_128_ecb = @as(c_int, 754);
pub const OBJ_camellia_128_ecb = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 1);
};
pub const SN_camellia_128_ofb128 = "CAMELLIA-128-OFB";
pub const LN_camellia_128_ofb128 = "camellia-128-ofb";
pub const NID_camellia_128_ofb128 = @as(c_int, 766);
pub const OBJ_camellia_128_ofb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 3);
};
pub const SN_camellia_128_cfb128 = "CAMELLIA-128-CFB";
pub const LN_camellia_128_cfb128 = "camellia-128-cfb";
pub const NID_camellia_128_cfb128 = @as(c_int, 757);
pub const OBJ_camellia_128_cfb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 4);
};
pub const SN_camellia_128_gcm = "CAMELLIA-128-GCM";
pub const LN_camellia_128_gcm = "camellia-128-gcm";
pub const NID_camellia_128_gcm = @as(c_int, 961);
pub const OBJ_camellia_128_gcm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 6);
};
pub const SN_camellia_128_ccm = "CAMELLIA-128-CCM";
pub const LN_camellia_128_ccm = "camellia-128-ccm";
pub const NID_camellia_128_ccm = @as(c_int, 962);
pub const OBJ_camellia_128_ccm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 7);
};
pub const SN_camellia_128_ctr = "CAMELLIA-128-CTR";
pub const LN_camellia_128_ctr = "camellia-128-ctr";
pub const NID_camellia_128_ctr = @as(c_int, 963);
pub const OBJ_camellia_128_ctr = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 9);
};
pub const SN_camellia_128_cmac = "CAMELLIA-128-CMAC";
pub const LN_camellia_128_cmac = "camellia-128-cmac";
pub const NID_camellia_128_cmac = @as(c_int, 964);
pub const OBJ_camellia_128_cmac = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 10);
};
pub const SN_camellia_192_ecb = "CAMELLIA-192-ECB";
pub const LN_camellia_192_ecb = "camellia-192-ecb";
pub const NID_camellia_192_ecb = @as(c_int, 755);
pub const OBJ_camellia_192_ecb = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 21);
};
pub const SN_camellia_192_ofb128 = "CAMELLIA-192-OFB";
pub const LN_camellia_192_ofb128 = "camellia-192-ofb";
pub const NID_camellia_192_ofb128 = @as(c_int, 767);
pub const OBJ_camellia_192_ofb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 23);
};
pub const SN_camellia_192_cfb128 = "CAMELLIA-192-CFB";
pub const LN_camellia_192_cfb128 = "camellia-192-cfb";
pub const NID_camellia_192_cfb128 = @as(c_int, 758);
pub const OBJ_camellia_192_cfb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 24);
};
pub const SN_camellia_192_gcm = "CAMELLIA-192-GCM";
pub const LN_camellia_192_gcm = "camellia-192-gcm";
pub const NID_camellia_192_gcm = @as(c_int, 965);
pub const OBJ_camellia_192_gcm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 26);
};
pub const SN_camellia_192_ccm = "CAMELLIA-192-CCM";
pub const LN_camellia_192_ccm = "camellia-192-ccm";
pub const NID_camellia_192_ccm = @as(c_int, 966);
pub const OBJ_camellia_192_ccm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 27);
};
pub const SN_camellia_192_ctr = "CAMELLIA-192-CTR";
pub const LN_camellia_192_ctr = "camellia-192-ctr";
pub const NID_camellia_192_ctr = @as(c_int, 967);
pub const OBJ_camellia_192_ctr = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 29);
};
pub const SN_camellia_192_cmac = "CAMELLIA-192-CMAC";
pub const LN_camellia_192_cmac = "camellia-192-cmac";
pub const NID_camellia_192_cmac = @as(c_int, 968);
pub const OBJ_camellia_192_cmac = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 30);
};
pub const SN_camellia_256_ecb = "CAMELLIA-256-ECB";
pub const LN_camellia_256_ecb = "camellia-256-ecb";
pub const NID_camellia_256_ecb = @as(c_int, 756);
pub const OBJ_camellia_256_ecb = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 41);
};
pub const SN_camellia_256_ofb128 = "CAMELLIA-256-OFB";
pub const LN_camellia_256_ofb128 = "camellia-256-ofb";
pub const NID_camellia_256_ofb128 = @as(c_int, 768);
pub const OBJ_camellia_256_ofb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 43);
};
pub const SN_camellia_256_cfb128 = "CAMELLIA-256-CFB";
pub const LN_camellia_256_cfb128 = "camellia-256-cfb";
pub const NID_camellia_256_cfb128 = @as(c_int, 759);
pub const OBJ_camellia_256_cfb128 = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 44);
};
pub const SN_camellia_256_gcm = "CAMELLIA-256-GCM";
pub const LN_camellia_256_gcm = "camellia-256-gcm";
pub const NID_camellia_256_gcm = @as(c_int, 969);
pub const OBJ_camellia_256_gcm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 46);
};
pub const SN_camellia_256_ccm = "CAMELLIA-256-CCM";
pub const LN_camellia_256_ccm = "camellia-256-ccm";
pub const NID_camellia_256_ccm = @as(c_int, 970);
pub const OBJ_camellia_256_ccm = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 47);
};
pub const SN_camellia_256_ctr = "CAMELLIA-256-CTR";
pub const LN_camellia_256_ctr = "camellia-256-ctr";
pub const NID_camellia_256_ctr = @as(c_int, 971);
pub const OBJ_camellia_256_ctr = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 49);
};
pub const SN_camellia_256_cmac = "CAMELLIA-256-CMAC";
pub const LN_camellia_256_cmac = "camellia-256-cmac";
pub const NID_camellia_256_cmac = @as(c_int, 972);
pub const OBJ_camellia_256_cmac = blk: {
    _ = &OBJ_camellia;
    break :blk @as(c_long, 50);
};
pub const SN_camellia_128_cfb1 = "CAMELLIA-128-CFB1";
pub const LN_camellia_128_cfb1 = "camellia-128-cfb1";
pub const NID_camellia_128_cfb1 = @as(c_int, 760);
pub const SN_camellia_192_cfb1 = "CAMELLIA-192-CFB1";
pub const LN_camellia_192_cfb1 = "camellia-192-cfb1";
pub const NID_camellia_192_cfb1 = @as(c_int, 761);
pub const SN_camellia_256_cfb1 = "CAMELLIA-256-CFB1";
pub const LN_camellia_256_cfb1 = "camellia-256-cfb1";
pub const NID_camellia_256_cfb1 = @as(c_int, 762);
pub const SN_camellia_128_cfb8 = "CAMELLIA-128-CFB8";
pub const LN_camellia_128_cfb8 = "camellia-128-cfb8";
pub const NID_camellia_128_cfb8 = @as(c_int, 763);
pub const SN_camellia_192_cfb8 = "CAMELLIA-192-CFB8";
pub const LN_camellia_192_cfb8 = "camellia-192-cfb8";
pub const NID_camellia_192_cfb8 = @as(c_int, 764);
pub const SN_camellia_256_cfb8 = "CAMELLIA-256-CFB8";
pub const LN_camellia_256_cfb8 = "camellia-256-cfb8";
pub const NID_camellia_256_cfb8 = @as(c_int, 765);
pub const OBJ_aria = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    _ = @as(c_long, 410);
    _ = @as(c_long, 200046);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_aria_128_ecb = "ARIA-128-ECB";
pub const LN_aria_128_ecb = "aria-128-ecb";
pub const NID_aria_128_ecb = @as(c_int, 1065);
pub const OBJ_aria_128_ecb = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 1);
};
pub const SN_aria_128_cbc = "ARIA-128-CBC";
pub const LN_aria_128_cbc = "aria-128-cbc";
pub const NID_aria_128_cbc = @as(c_int, 1066);
pub const OBJ_aria_128_cbc = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 2);
};
pub const SN_aria_128_cfb128 = "ARIA-128-CFB";
pub const LN_aria_128_cfb128 = "aria-128-cfb";
pub const NID_aria_128_cfb128 = @as(c_int, 1067);
pub const OBJ_aria_128_cfb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 3);
};
pub const SN_aria_128_ofb128 = "ARIA-128-OFB";
pub const LN_aria_128_ofb128 = "aria-128-ofb";
pub const NID_aria_128_ofb128 = @as(c_int, 1068);
pub const OBJ_aria_128_ofb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 4);
};
pub const SN_aria_128_ctr = "ARIA-128-CTR";
pub const LN_aria_128_ctr = "aria-128-ctr";
pub const NID_aria_128_ctr = @as(c_int, 1069);
pub const OBJ_aria_128_ctr = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 5);
};
pub const SN_aria_192_ecb = "ARIA-192-ECB";
pub const LN_aria_192_ecb = "aria-192-ecb";
pub const NID_aria_192_ecb = @as(c_int, 1070);
pub const OBJ_aria_192_ecb = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 6);
};
pub const SN_aria_192_cbc = "ARIA-192-CBC";
pub const LN_aria_192_cbc = "aria-192-cbc";
pub const NID_aria_192_cbc = @as(c_int, 1071);
pub const OBJ_aria_192_cbc = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 7);
};
pub const SN_aria_192_cfb128 = "ARIA-192-CFB";
pub const LN_aria_192_cfb128 = "aria-192-cfb";
pub const NID_aria_192_cfb128 = @as(c_int, 1072);
pub const OBJ_aria_192_cfb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 8);
};
pub const SN_aria_192_ofb128 = "ARIA-192-OFB";
pub const LN_aria_192_ofb128 = "aria-192-ofb";
pub const NID_aria_192_ofb128 = @as(c_int, 1073);
pub const OBJ_aria_192_ofb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 9);
};
pub const SN_aria_192_ctr = "ARIA-192-CTR";
pub const LN_aria_192_ctr = "aria-192-ctr";
pub const NID_aria_192_ctr = @as(c_int, 1074);
pub const OBJ_aria_192_ctr = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 10);
};
pub const SN_aria_256_ecb = "ARIA-256-ECB";
pub const LN_aria_256_ecb = "aria-256-ecb";
pub const NID_aria_256_ecb = @as(c_int, 1075);
pub const OBJ_aria_256_ecb = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 11);
};
pub const SN_aria_256_cbc = "ARIA-256-CBC";
pub const LN_aria_256_cbc = "aria-256-cbc";
pub const NID_aria_256_cbc = @as(c_int, 1076);
pub const OBJ_aria_256_cbc = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 12);
};
pub const SN_aria_256_cfb128 = "ARIA-256-CFB";
pub const LN_aria_256_cfb128 = "aria-256-cfb";
pub const NID_aria_256_cfb128 = @as(c_int, 1077);
pub const OBJ_aria_256_cfb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 13);
};
pub const SN_aria_256_ofb128 = "ARIA-256-OFB";
pub const LN_aria_256_ofb128 = "aria-256-ofb";
pub const NID_aria_256_ofb128 = @as(c_int, 1078);
pub const OBJ_aria_256_ofb128 = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 14);
};
pub const SN_aria_256_ctr = "ARIA-256-CTR";
pub const LN_aria_256_ctr = "aria-256-ctr";
pub const NID_aria_256_ctr = @as(c_int, 1079);
pub const OBJ_aria_256_ctr = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 15);
};
pub const SN_aria_128_cfb1 = "ARIA-128-CFB1";
pub const LN_aria_128_cfb1 = "aria-128-cfb1";
pub const NID_aria_128_cfb1 = @as(c_int, 1080);
pub const SN_aria_192_cfb1 = "ARIA-192-CFB1";
pub const LN_aria_192_cfb1 = "aria-192-cfb1";
pub const NID_aria_192_cfb1 = @as(c_int, 1081);
pub const SN_aria_256_cfb1 = "ARIA-256-CFB1";
pub const LN_aria_256_cfb1 = "aria-256-cfb1";
pub const NID_aria_256_cfb1 = @as(c_int, 1082);
pub const SN_aria_128_cfb8 = "ARIA-128-CFB8";
pub const LN_aria_128_cfb8 = "aria-128-cfb8";
pub const NID_aria_128_cfb8 = @as(c_int, 1083);
pub const SN_aria_192_cfb8 = "ARIA-192-CFB8";
pub const LN_aria_192_cfb8 = "aria-192-cfb8";
pub const NID_aria_192_cfb8 = @as(c_int, 1084);
pub const SN_aria_256_cfb8 = "ARIA-256-CFB8";
pub const LN_aria_256_cfb8 = "aria-256-cfb8";
pub const NID_aria_256_cfb8 = @as(c_int, 1085);
pub const SN_aria_128_ccm = "ARIA-128-CCM";
pub const LN_aria_128_ccm = "aria-128-ccm";
pub const NID_aria_128_ccm = @as(c_int, 1120);
pub const OBJ_aria_128_ccm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 37);
};
pub const SN_aria_192_ccm = "ARIA-192-CCM";
pub const LN_aria_192_ccm = "aria-192-ccm";
pub const NID_aria_192_ccm = @as(c_int, 1121);
pub const OBJ_aria_192_ccm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 38);
};
pub const SN_aria_256_ccm = "ARIA-256-CCM";
pub const LN_aria_256_ccm = "aria-256-ccm";
pub const NID_aria_256_ccm = @as(c_int, 1122);
pub const OBJ_aria_256_ccm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 39);
};
pub const SN_aria_128_gcm = "ARIA-128-GCM";
pub const LN_aria_128_gcm = "aria-128-gcm";
pub const NID_aria_128_gcm = @as(c_int, 1123);
pub const OBJ_aria_128_gcm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 34);
};
pub const SN_aria_192_gcm = "ARIA-192-GCM";
pub const LN_aria_192_gcm = "aria-192-gcm";
pub const NID_aria_192_gcm = @as(c_int, 1124);
pub const OBJ_aria_192_gcm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 35);
};
pub const SN_aria_256_gcm = "ARIA-256-GCM";
pub const LN_aria_256_gcm = "aria-256-gcm";
pub const NID_aria_256_gcm = @as(c_int, 1125);
pub const OBJ_aria_256_gcm = blk: {
    _ = &OBJ_aria;
    break :blk @as(c_long, 36);
};
pub const SN_kisa = "KISA";
pub const LN_kisa = "kisa";
pub const NID_kisa = @as(c_int, 773);
pub const OBJ_kisa = blk: {
    _ = &OBJ_member_body;
    _ = @as(c_long, 410);
    break :blk @as(c_long, 200004);
};
pub const SN_seed_ecb = "SEED-ECB";
pub const LN_seed_ecb = "seed-ecb";
pub const NID_seed_ecb = @as(c_int, 776);
pub const OBJ_seed_ecb = blk: {
    _ = &OBJ_kisa;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 3);
};
pub const SN_seed_cbc = "SEED-CBC";
pub const LN_seed_cbc = "seed-cbc";
pub const NID_seed_cbc = @as(c_int, 777);
pub const OBJ_seed_cbc = blk: {
    _ = &OBJ_kisa;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 4);
};
pub const SN_seed_cfb128 = "SEED-CFB";
pub const LN_seed_cfb128 = "seed-cfb";
pub const NID_seed_cfb128 = @as(c_int, 779);
pub const OBJ_seed_cfb128 = blk: {
    _ = &OBJ_kisa;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 5);
};
pub const SN_seed_ofb128 = "SEED-OFB";
pub const LN_seed_ofb128 = "seed-ofb";
pub const NID_seed_ofb128 = @as(c_int, 778);
pub const OBJ_seed_ofb128 = blk: {
    _ = &OBJ_kisa;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 6);
};
pub const SN_sm4_ecb = "SM4-ECB";
pub const LN_sm4_ecb = "sm4-ecb";
pub const NID_sm4_ecb = @as(c_int, 1133);
pub const OBJ_sm4_ecb = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 1);
};
pub const SN_sm4_cbc = "SM4-CBC";
pub const LN_sm4_cbc = "sm4-cbc";
pub const NID_sm4_cbc = @as(c_int, 1134);
pub const OBJ_sm4_cbc = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 2);
};
pub const SN_sm4_ofb128 = "SM4-OFB";
pub const LN_sm4_ofb128 = "sm4-ofb";
pub const NID_sm4_ofb128 = @as(c_int, 1135);
pub const OBJ_sm4_ofb128 = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 3);
};
pub const SN_sm4_cfb128 = "SM4-CFB";
pub const LN_sm4_cfb128 = "sm4-cfb";
pub const NID_sm4_cfb128 = @as(c_int, 1137);
pub const OBJ_sm4_cfb128 = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 4);
};
pub const SN_sm4_cfb1 = "SM4-CFB1";
pub const LN_sm4_cfb1 = "sm4-cfb1";
pub const NID_sm4_cfb1 = @as(c_int, 1136);
pub const OBJ_sm4_cfb1 = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 5);
};
pub const SN_sm4_cfb8 = "SM4-CFB8";
pub const LN_sm4_cfb8 = "sm4-cfb8";
pub const NID_sm4_cfb8 = @as(c_int, 1138);
pub const OBJ_sm4_cfb8 = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 6);
};
pub const SN_sm4_ctr = "SM4-CTR";
pub const LN_sm4_ctr = "sm4-ctr";
pub const NID_sm4_ctr = @as(c_int, 1139);
pub const OBJ_sm4_ctr = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 7);
};
pub const SN_sm4_gcm = "SM4-GCM";
pub const LN_sm4_gcm = "sm4-gcm";
pub const NID_sm4_gcm = @as(c_int, 1248);
pub const OBJ_sm4_gcm = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 8);
};
pub const SN_sm4_ccm = "SM4-CCM";
pub const LN_sm4_ccm = "sm4-ccm";
pub const NID_sm4_ccm = @as(c_int, 1249);
pub const OBJ_sm4_ccm = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 9);
};
pub const SN_sm4_xts = "SM4-XTS";
pub const LN_sm4_xts = "sm4-xts";
pub const NID_sm4_xts = @as(c_int, 1290);
pub const OBJ_sm4_xts = blk: {
    _ = &OBJ_sm_scheme;
    _ = @as(c_long, 104);
    break :blk @as(c_long, 10);
};
pub const SN_hmac = "HMAC";
pub const LN_hmac = "hmac";
pub const NID_hmac = @as(c_int, 855);
pub const SN_cmac = "CMAC";
pub const LN_cmac = "cmac";
pub const NID_cmac = @as(c_int, 894);
pub const SN_rc4_hmac_md5 = "RC4-HMAC-MD5";
pub const LN_rc4_hmac_md5 = "rc4-hmac-md5";
pub const NID_rc4_hmac_md5 = @as(c_int, 915);
pub const SN_aes_128_cbc_hmac_sha1 = "AES-128-CBC-HMAC-SHA1";
pub const LN_aes_128_cbc_hmac_sha1 = "aes-128-cbc-hmac-sha1";
pub const NID_aes_128_cbc_hmac_sha1 = @as(c_int, 916);
pub const SN_aes_192_cbc_hmac_sha1 = "AES-192-CBC-HMAC-SHA1";
pub const LN_aes_192_cbc_hmac_sha1 = "aes-192-cbc-hmac-sha1";
pub const NID_aes_192_cbc_hmac_sha1 = @as(c_int, 917);
pub const SN_aes_256_cbc_hmac_sha1 = "AES-256-CBC-HMAC-SHA1";
pub const LN_aes_256_cbc_hmac_sha1 = "aes-256-cbc-hmac-sha1";
pub const NID_aes_256_cbc_hmac_sha1 = @as(c_int, 918);
pub const SN_aes_128_cbc_hmac_sha256 = "AES-128-CBC-HMAC-SHA256";
pub const LN_aes_128_cbc_hmac_sha256 = "aes-128-cbc-hmac-sha256";
pub const NID_aes_128_cbc_hmac_sha256 = @as(c_int, 948);
pub const SN_aes_192_cbc_hmac_sha256 = "AES-192-CBC-HMAC-SHA256";
pub const LN_aes_192_cbc_hmac_sha256 = "aes-192-cbc-hmac-sha256";
pub const NID_aes_192_cbc_hmac_sha256 = @as(c_int, 949);
pub const SN_aes_256_cbc_hmac_sha256 = "AES-256-CBC-HMAC-SHA256";
pub const LN_aes_256_cbc_hmac_sha256 = "aes-256-cbc-hmac-sha256";
pub const NID_aes_256_cbc_hmac_sha256 = @as(c_int, 950);
pub const SN_chacha20_poly1305 = "ChaCha20-Poly1305";
pub const LN_chacha20_poly1305 = "chacha20-poly1305";
pub const NID_chacha20_poly1305 = @as(c_int, 1018);
pub const SN_chacha20 = "ChaCha20";
pub const LN_chacha20 = "chacha20";
pub const NID_chacha20 = @as(c_int, 1019);
pub const SN_dhpublicnumber = "dhpublicnumber";
pub const LN_dhpublicnumber = "X9.42 DH";
pub const NID_dhpublicnumber = @as(c_int, 920);
pub const OBJ_dhpublicnumber = blk: {
    _ = &OBJ_ISO_US;
    _ = @as(c_long, 10046);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_brainpoolP160r1 = "brainpoolP160r1";
pub const NID_brainpoolP160r1 = @as(c_int, 921);
pub const OBJ_brainpoolP160r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_brainpoolP160t1 = "brainpoolP160t1";
pub const NID_brainpoolP160t1 = @as(c_int, 922);
pub const OBJ_brainpoolP160t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_brainpoolP192r1 = "brainpoolP192r1";
pub const NID_brainpoolP192r1 = @as(c_int, 923);
pub const OBJ_brainpoolP192r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 3);
};
pub const SN_brainpoolP192t1 = "brainpoolP192t1";
pub const NID_brainpoolP192t1 = @as(c_int, 924);
pub const OBJ_brainpoolP192t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 4);
};
pub const SN_brainpoolP224r1 = "brainpoolP224r1";
pub const NID_brainpoolP224r1 = @as(c_int, 925);
pub const OBJ_brainpoolP224r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 5);
};
pub const SN_brainpoolP224t1 = "brainpoolP224t1";
pub const NID_brainpoolP224t1 = @as(c_int, 926);
pub const OBJ_brainpoolP224t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 6);
};
pub const SN_brainpoolP256r1 = "brainpoolP256r1";
pub const NID_brainpoolP256r1 = @as(c_int, 927);
pub const OBJ_brainpoolP256r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 7);
};
pub const SN_brainpoolP256r1tls13 = "brainpoolP256r1tls13";
pub const NID_brainpoolP256r1tls13 = @as(c_int, 1285);
pub const SN_brainpoolP256t1 = "brainpoolP256t1";
pub const NID_brainpoolP256t1 = @as(c_int, 928);
pub const OBJ_brainpoolP256t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 8);
};
pub const SN_brainpoolP320r1 = "brainpoolP320r1";
pub const NID_brainpoolP320r1 = @as(c_int, 929);
pub const OBJ_brainpoolP320r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 9);
};
pub const SN_brainpoolP320t1 = "brainpoolP320t1";
pub const NID_brainpoolP320t1 = @as(c_int, 930);
pub const OBJ_brainpoolP320t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 10);
};
pub const SN_brainpoolP384r1 = "brainpoolP384r1";
pub const NID_brainpoolP384r1 = @as(c_int, 931);
pub const OBJ_brainpoolP384r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 11);
};
pub const SN_brainpoolP384r1tls13 = "brainpoolP384r1tls13";
pub const NID_brainpoolP384r1tls13 = @as(c_int, 1286);
pub const SN_brainpoolP384t1 = "brainpoolP384t1";
pub const NID_brainpoolP384t1 = @as(c_int, 932);
pub const OBJ_brainpoolP384t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 12);
};
pub const SN_brainpoolP512r1 = "brainpoolP512r1";
pub const NID_brainpoolP512r1 = @as(c_int, 933);
pub const OBJ_brainpoolP512r1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 13);
};
pub const SN_brainpoolP512r1tls13 = "brainpoolP512r1tls13";
pub const NID_brainpoolP512r1tls13 = @as(c_int, 1287);
pub const SN_brainpoolP512t1 = "brainpoolP512t1";
pub const NID_brainpoolP512t1 = @as(c_int, 934);
pub const OBJ_brainpoolP512t1 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 36);
    _ = @as(c_long, 3);
    _ = @as(c_long, 3);
    _ = @as(c_long, 2);
    _ = @as(c_long, 8);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 14);
};
pub const OBJ_x9_63_scheme = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 133);
    _ = @as(c_long, 16);
    _ = @as(c_long, 840);
    _ = @as(c_long, 63);
    break :blk @as(c_long, 0);
};
pub const OBJ_secg_scheme = blk: {
    _ = &OBJ_certicom_arc;
    break :blk @as(c_long, 1);
};
pub const SN_dhSinglePass_stdDH_sha1kdf_scheme = "dhSinglePass-stdDH-sha1kdf-scheme";
pub const NID_dhSinglePass_stdDH_sha1kdf_scheme = @as(c_int, 936);
pub const OBJ_dhSinglePass_stdDH_sha1kdf_scheme = blk: {
    _ = &OBJ_x9_63_scheme;
    break :blk @as(c_long, 2);
};
pub const SN_dhSinglePass_stdDH_sha224kdf_scheme = "dhSinglePass-stdDH-sha224kdf-scheme";
pub const NID_dhSinglePass_stdDH_sha224kdf_scheme = @as(c_int, 937);
pub const OBJ_dhSinglePass_stdDH_sha224kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 11);
    break :blk @as(c_long, 0);
};
pub const SN_dhSinglePass_stdDH_sha256kdf_scheme = "dhSinglePass-stdDH-sha256kdf-scheme";
pub const NID_dhSinglePass_stdDH_sha256kdf_scheme = @as(c_int, 938);
pub const OBJ_dhSinglePass_stdDH_sha256kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 11);
    break :blk @as(c_long, 1);
};
pub const SN_dhSinglePass_stdDH_sha384kdf_scheme = "dhSinglePass-stdDH-sha384kdf-scheme";
pub const NID_dhSinglePass_stdDH_sha384kdf_scheme = @as(c_int, 939);
pub const OBJ_dhSinglePass_stdDH_sha384kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 11);
    break :blk @as(c_long, 2);
};
pub const SN_dhSinglePass_stdDH_sha512kdf_scheme = "dhSinglePass-stdDH-sha512kdf-scheme";
pub const NID_dhSinglePass_stdDH_sha512kdf_scheme = @as(c_int, 940);
pub const OBJ_dhSinglePass_stdDH_sha512kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 11);
    break :blk @as(c_long, 3);
};
pub const SN_dhSinglePass_cofactorDH_sha1kdf_scheme = "dhSinglePass-cofactorDH-sha1kdf-scheme";
pub const NID_dhSinglePass_cofactorDH_sha1kdf_scheme = @as(c_int, 941);
pub const OBJ_dhSinglePass_cofactorDH_sha1kdf_scheme = blk: {
    _ = &OBJ_x9_63_scheme;
    break :blk @as(c_long, 3);
};
pub const SN_dhSinglePass_cofactorDH_sha224kdf_scheme = "dhSinglePass-cofactorDH-sha224kdf-scheme";
pub const NID_dhSinglePass_cofactorDH_sha224kdf_scheme = @as(c_int, 942);
pub const OBJ_dhSinglePass_cofactorDH_sha224kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 0);
};
pub const SN_dhSinglePass_cofactorDH_sha256kdf_scheme = "dhSinglePass-cofactorDH-sha256kdf-scheme";
pub const NID_dhSinglePass_cofactorDH_sha256kdf_scheme = @as(c_int, 943);
pub const OBJ_dhSinglePass_cofactorDH_sha256kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 1);
};
pub const SN_dhSinglePass_cofactorDH_sha384kdf_scheme = "dhSinglePass-cofactorDH-sha384kdf-scheme";
pub const NID_dhSinglePass_cofactorDH_sha384kdf_scheme = @as(c_int, 944);
pub const OBJ_dhSinglePass_cofactorDH_sha384kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 2);
};
pub const SN_dhSinglePass_cofactorDH_sha512kdf_scheme = "dhSinglePass-cofactorDH-sha512kdf-scheme";
pub const NID_dhSinglePass_cofactorDH_sha512kdf_scheme = @as(c_int, 945);
pub const OBJ_dhSinglePass_cofactorDH_sha512kdf_scheme = blk: {
    _ = &OBJ_secg_scheme;
    _ = @as(c_long, 14);
    break :blk @as(c_long, 3);
};
pub const SN_dh_std_kdf = "dh-std-kdf";
pub const NID_dh_std_kdf = @as(c_int, 946);
pub const SN_dh_cofactor_kdf = "dh-cofactor-kdf";
pub const NID_dh_cofactor_kdf = @as(c_int, 947);
pub const SN_ct_precert_scts = "ct_precert_scts";
pub const LN_ct_precert_scts = "CT Precertificate SCTs";
pub const NID_ct_precert_scts = @as(c_int, 951);
pub const OBJ_ct_precert_scts = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 11129);
    _ = @as(c_long, 2);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 2);
};
pub const SN_ct_precert_poison = "ct_precert_poison";
pub const LN_ct_precert_poison = "CT Precertificate Poison";
pub const NID_ct_precert_poison = @as(c_int, 952);
pub const OBJ_ct_precert_poison = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 11129);
    _ = @as(c_long, 2);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 3);
};
pub const SN_ct_precert_signer = "ct_precert_signer";
pub const LN_ct_precert_signer = "CT Precertificate Signer";
pub const NID_ct_precert_signer = @as(c_int, 953);
pub const OBJ_ct_precert_signer = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 11129);
    _ = @as(c_long, 2);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 4);
};
pub const SN_ct_cert_scts = "ct_cert_scts";
pub const LN_ct_cert_scts = "CT Certificate SCTs";
pub const NID_ct_cert_scts = @as(c_int, 954);
pub const OBJ_ct_cert_scts = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 11129);
    _ = @as(c_long, 2);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 5);
};
pub const SN_jurisdictionLocalityName = "jurisdictionL";
pub const LN_jurisdictionLocalityName = "jurisdictionLocalityName";
pub const NID_jurisdictionLocalityName = @as(c_int, 955);
pub const OBJ_jurisdictionLocalityName = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 60);
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_jurisdictionStateOrProvinceName = "jurisdictionST";
pub const LN_jurisdictionStateOrProvinceName = "jurisdictionStateOrProvinceName";
pub const NID_jurisdictionStateOrProvinceName = @as(c_int, 956);
pub const OBJ_jurisdictionStateOrProvinceName = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 60);
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_jurisdictionCountryName = "jurisdictionC";
pub const LN_jurisdictionCountryName = "jurisdictionCountryName";
pub const NID_jurisdictionCountryName = @as(c_int, 957);
pub const OBJ_jurisdictionCountryName = blk: {
    _ = &OBJ_ms_corp;
    _ = @as(c_long, 60);
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 3);
};
pub const SN_id_scrypt = "id-scrypt";
pub const LN_id_scrypt = "scrypt";
pub const NID_id_scrypt = @as(c_int, 973);
pub const OBJ_id_scrypt = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 4);
    _ = @as(c_long, 1);
    _ = @as(c_long, 11591);
    _ = @as(c_long, 4);
    break :blk @as(c_long, 11);
};
pub const SN_tls1_prf = "TLS1-PRF";
pub const LN_tls1_prf = "tls1-prf";
pub const NID_tls1_prf = @as(c_int, 1021);
pub const SN_hkdf = "HKDF";
pub const LN_hkdf = "hkdf";
pub const NID_hkdf = @as(c_int, 1036);
pub const SN_sshkdf = "SSHKDF";
pub const LN_sshkdf = "sshkdf";
pub const NID_sshkdf = @as(c_int, 1203);
pub const SN_sskdf = "SSKDF";
pub const LN_sskdf = "sskdf";
pub const NID_sskdf = @as(c_int, 1205);
pub const SN_x942kdf = "X942KDF";
pub const LN_x942kdf = "x942kdf";
pub const NID_x942kdf = @as(c_int, 1207);
pub const SN_x963kdf = "X963KDF";
pub const LN_x963kdf = "x963kdf";
pub const NID_x963kdf = @as(c_int, 1206);
pub const SN_id_pkinit = "id-pkinit";
pub const NID_id_pkinit = @as(c_int, 1031);
pub const OBJ_id_pkinit = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 6);
    _ = @as(c_long, 1);
    _ = @as(c_long, 5);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 3);
};
pub const SN_pkInitClientAuth = "pkInitClientAuth";
pub const LN_pkInitClientAuth = "PKINIT Client Auth";
pub const NID_pkInitClientAuth = @as(c_int, 1032);
pub const OBJ_pkInitClientAuth = blk: {
    _ = &OBJ_id_pkinit;
    break :blk @as(c_long, 4);
};
pub const SN_pkInitKDC = "pkInitKDC";
pub const LN_pkInitKDC = "Signing KDC Response";
pub const NID_pkInitKDC = @as(c_int, 1033);
pub const OBJ_pkInitKDC = blk: {
    _ = &OBJ_id_pkinit;
    break :blk @as(c_long, 5);
};
pub const SN_X25519 = "X25519";
pub const NID_X25519 = @as(c_int, 1034);
pub const OBJ_X25519 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 101);
    break :blk @as(c_long, 110);
};
pub const SN_X448 = "X448";
pub const NID_X448 = @as(c_int, 1035);
pub const OBJ_X448 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 101);
    break :blk @as(c_long, 111);
};
pub const SN_ED25519 = "ED25519";
pub const NID_ED25519 = @as(c_int, 1087);
pub const OBJ_ED25519 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 101);
    break :blk @as(c_long, 112);
};
pub const SN_ED448 = "ED448";
pub const NID_ED448 = @as(c_int, 1088);
pub const OBJ_ED448 = blk: {
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 101);
    break :blk @as(c_long, 113);
};
pub const SN_kx_rsa = "KxRSA";
pub const LN_kx_rsa = "kx-rsa";
pub const NID_kx_rsa = @as(c_int, 1037);
pub const SN_kx_ecdhe = "KxECDHE";
pub const LN_kx_ecdhe = "kx-ecdhe";
pub const NID_kx_ecdhe = @as(c_int, 1038);
pub const SN_kx_dhe = "KxDHE";
pub const LN_kx_dhe = "kx-dhe";
pub const NID_kx_dhe = @as(c_int, 1039);
pub const SN_kx_ecdhe_psk = "KxECDHE-PSK";
pub const LN_kx_ecdhe_psk = "kx-ecdhe-psk";
pub const NID_kx_ecdhe_psk = @as(c_int, 1040);
pub const SN_kx_dhe_psk = "KxDHE-PSK";
pub const LN_kx_dhe_psk = "kx-dhe-psk";
pub const NID_kx_dhe_psk = @as(c_int, 1041);
pub const SN_kx_rsa_psk = "KxRSA_PSK";
pub const LN_kx_rsa_psk = "kx-rsa-psk";
pub const NID_kx_rsa_psk = @as(c_int, 1042);
pub const SN_kx_psk = "KxPSK";
pub const LN_kx_psk = "kx-psk";
pub const NID_kx_psk = @as(c_int, 1043);
pub const SN_kx_srp = "KxSRP";
pub const LN_kx_srp = "kx-srp";
pub const NID_kx_srp = @as(c_int, 1044);
pub const SN_kx_gost = "KxGOST";
pub const LN_kx_gost = "kx-gost";
pub const NID_kx_gost = @as(c_int, 1045);
pub const SN_kx_gost18 = "KxGOST18";
pub const LN_kx_gost18 = "kx-gost18";
pub const NID_kx_gost18 = @as(c_int, 1218);
pub const SN_kx_any = "KxANY";
pub const LN_kx_any = "kx-any";
pub const NID_kx_any = @as(c_int, 1063);
pub const SN_auth_rsa = "AuthRSA";
pub const LN_auth_rsa = "auth-rsa";
pub const NID_auth_rsa = @as(c_int, 1046);
pub const SN_auth_ecdsa = "AuthECDSA";
pub const LN_auth_ecdsa = "auth-ecdsa";
pub const NID_auth_ecdsa = @as(c_int, 1047);
pub const SN_auth_psk = "AuthPSK";
pub const LN_auth_psk = "auth-psk";
pub const NID_auth_psk = @as(c_int, 1048);
pub const SN_auth_dss = "AuthDSS";
pub const LN_auth_dss = "auth-dss";
pub const NID_auth_dss = @as(c_int, 1049);
pub const SN_auth_gost01 = "AuthGOST01";
pub const LN_auth_gost01 = "auth-gost01";
pub const NID_auth_gost01 = @as(c_int, 1050);
pub const SN_auth_gost12 = "AuthGOST12";
pub const LN_auth_gost12 = "auth-gost12";
pub const NID_auth_gost12 = @as(c_int, 1051);
pub const SN_auth_srp = "AuthSRP";
pub const LN_auth_srp = "auth-srp";
pub const NID_auth_srp = @as(c_int, 1052);
pub const SN_auth_null = "AuthNULL";
pub const LN_auth_null = "auth-null";
pub const NID_auth_null = @as(c_int, 1053);
pub const SN_auth_any = "AuthANY";
pub const LN_auth_any = "auth-any";
pub const NID_auth_any = @as(c_int, 1064);
pub const SN_poly1305 = "Poly1305";
pub const LN_poly1305 = "poly1305";
pub const NID_poly1305 = @as(c_int, 1061);
pub const SN_siphash = "SipHash";
pub const LN_siphash = "siphash";
pub const NID_siphash = @as(c_int, 1062);
pub const SN_ffdhe2048 = "ffdhe2048";
pub const NID_ffdhe2048 = @as(c_int, 1126);
pub const SN_ffdhe3072 = "ffdhe3072";
pub const NID_ffdhe3072 = @as(c_int, 1127);
pub const SN_ffdhe4096 = "ffdhe4096";
pub const NID_ffdhe4096 = @as(c_int, 1128);
pub const SN_ffdhe6144 = "ffdhe6144";
pub const NID_ffdhe6144 = @as(c_int, 1129);
pub const SN_ffdhe8192 = "ffdhe8192";
pub const NID_ffdhe8192 = @as(c_int, 1130);
pub const SN_modp_1536 = "modp_1536";
pub const NID_modp_1536 = @as(c_int, 1212);
pub const SN_modp_2048 = "modp_2048";
pub const NID_modp_2048 = @as(c_int, 1213);
pub const SN_modp_3072 = "modp_3072";
pub const NID_modp_3072 = @as(c_int, 1214);
pub const SN_modp_4096 = "modp_4096";
pub const NID_modp_4096 = @as(c_int, 1215);
pub const SN_modp_6144 = "modp_6144";
pub const NID_modp_6144 = @as(c_int, 1216);
pub const SN_modp_8192 = "modp_8192";
pub const NID_modp_8192 = @as(c_int, 1217);
pub const SN_ISO_UA = "ISO-UA";
pub const NID_ISO_UA = @as(c_int, 1150);
pub const OBJ_ISO_UA = blk: {
    _ = &OBJ_member_body;
    break :blk @as(c_long, 804);
};
pub const SN_ua_pki = "ua-pki";
pub const NID_ua_pki = @as(c_int, 1151);
pub const OBJ_ua_pki = blk: {
    _ = &OBJ_ISO_UA;
    _ = @as(c_long, 2);
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_dstu28147 = "dstu28147";
pub const LN_dstu28147 = "DSTU Gost 28147-2009";
pub const NID_dstu28147 = @as(c_int, 1152);
pub const OBJ_dstu28147 = blk: {
    _ = &OBJ_ua_pki;
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_dstu28147_ofb = "dstu28147-ofb";
pub const LN_dstu28147_ofb = "DSTU Gost 28147-2009 OFB mode";
pub const NID_dstu28147_ofb = @as(c_int, 1153);
pub const OBJ_dstu28147_ofb = blk: {
    _ = &OBJ_dstu28147;
    break :blk @as(c_long, 2);
};
pub const SN_dstu28147_cfb = "dstu28147-cfb";
pub const LN_dstu28147_cfb = "DSTU Gost 28147-2009 CFB mode";
pub const NID_dstu28147_cfb = @as(c_int, 1154);
pub const OBJ_dstu28147_cfb = blk: {
    _ = &OBJ_dstu28147;
    break :blk @as(c_long, 3);
};
pub const SN_dstu28147_wrap = "dstu28147-wrap";
pub const LN_dstu28147_wrap = "DSTU Gost 28147-2009 key wrap";
pub const NID_dstu28147_wrap = @as(c_int, 1155);
pub const OBJ_dstu28147_wrap = blk: {
    _ = &OBJ_dstu28147;
    break :blk @as(c_long, 5);
};
pub const SN_hmacWithDstu34311 = "hmacWithDstu34311";
pub const LN_hmacWithDstu34311 = "HMAC DSTU Gost 34311-95";
pub const NID_hmacWithDstu34311 = @as(c_int, 1156);
pub const OBJ_hmacWithDstu34311 = blk: {
    _ = &OBJ_ua_pki;
    _ = @as(c_long, 1);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 2);
};
pub const SN_dstu34311 = "dstu34311";
pub const LN_dstu34311 = "DSTU Gost 34311-95";
pub const NID_dstu34311 = @as(c_int, 1157);
pub const OBJ_dstu34311 = blk: {
    _ = &OBJ_ua_pki;
    _ = @as(c_long, 1);
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_dstu4145le = "dstu4145le";
pub const LN_dstu4145le = "DSTU 4145-2002 little endian";
pub const NID_dstu4145le = @as(c_int, 1158);
pub const OBJ_dstu4145le = blk: {
    _ = &OBJ_ua_pki;
    _ = @as(c_long, 1);
    _ = @as(c_long, 3);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_dstu4145be = "dstu4145be";
pub const LN_dstu4145be = "DSTU 4145-2002 big endian";
pub const NID_dstu4145be = @as(c_int, 1159);
pub const OBJ_dstu4145be = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_uacurve0 = "uacurve0";
pub const LN_uacurve0 = "DSTU curve 0";
pub const NID_uacurve0 = @as(c_int, 1160);
pub const OBJ_uacurve0 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 0);
};
pub const SN_uacurve1 = "uacurve1";
pub const LN_uacurve1 = "DSTU curve 1";
pub const NID_uacurve1 = @as(c_int, 1161);
pub const OBJ_uacurve1 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 1);
};
pub const SN_uacurve2 = "uacurve2";
pub const LN_uacurve2 = "DSTU curve 2";
pub const NID_uacurve2 = @as(c_int, 1162);
pub const OBJ_uacurve2 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 2);
};
pub const SN_uacurve3 = "uacurve3";
pub const LN_uacurve3 = "DSTU curve 3";
pub const NID_uacurve3 = @as(c_int, 1163);
pub const OBJ_uacurve3 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 3);
};
pub const SN_uacurve4 = "uacurve4";
pub const LN_uacurve4 = "DSTU curve 4";
pub const NID_uacurve4 = @as(c_int, 1164);
pub const OBJ_uacurve4 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 4);
};
pub const SN_uacurve5 = "uacurve5";
pub const LN_uacurve5 = "DSTU curve 5";
pub const NID_uacurve5 = @as(c_int, 1165);
pub const OBJ_uacurve5 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 5);
};
pub const SN_uacurve6 = "uacurve6";
pub const LN_uacurve6 = "DSTU curve 6";
pub const NID_uacurve6 = @as(c_int, 1166);
pub const OBJ_uacurve6 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 6);
};
pub const SN_uacurve7 = "uacurve7";
pub const LN_uacurve7 = "DSTU curve 7";
pub const NID_uacurve7 = @as(c_int, 1167);
pub const OBJ_uacurve7 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 7);
};
pub const SN_uacurve8 = "uacurve8";
pub const LN_uacurve8 = "DSTU curve 8";
pub const NID_uacurve8 = @as(c_int, 1168);
pub const OBJ_uacurve8 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 8);
};
pub const SN_uacurve9 = "uacurve9";
pub const LN_uacurve9 = "DSTU curve 9";
pub const NID_uacurve9 = @as(c_int, 1169);
pub const OBJ_uacurve9 = blk: {
    _ = &OBJ_dstu4145le;
    _ = @as(c_long, 2);
    break :blk @as(c_long, 9);
};
pub const SN_aes_128_siv = "AES-128-SIV";
pub const LN_aes_128_siv = "aes-128-siv";
pub const NID_aes_128_siv = @as(c_int, 1198);
pub const SN_aes_192_siv = "AES-192-SIV";
pub const LN_aes_192_siv = "aes-192-siv";
pub const NID_aes_192_siv = @as(c_int, 1199);
pub const SN_aes_256_siv = "AES-256-SIV";
pub const LN_aes_256_siv = "aes-256-siv";
pub const NID_aes_256_siv = @as(c_int, 1200);
pub const SN_oracle = "oracle-organization";
pub const LN_oracle = "Oracle organization";
pub const NID_oracle = @as(c_int, 1282);
pub const OBJ_oracle = blk: {
    _ = &OBJ_joint_iso_itu_t;
    _ = @as(c_long, 16);
    _ = @as(c_long, 840);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 113894);
};
pub const SN_oracle_jdk_trustedkeyusage = "oracle-jdk-trustedkeyusage";
pub const LN_oracle_jdk_trustedkeyusage = "Trusted key usage (Oracle)";
pub const NID_oracle_jdk_trustedkeyusage = @as(c_int, 1283);
pub const OBJ_oracle_jdk_trustedkeyusage = blk: {
    _ = &OBJ_oracle;
    _ = @as(c_long, 746875);
    _ = @as(c_long, 1);
    break :blk @as(c_long, 1);
};
pub const SN_brotli = "brotli";
pub const LN_brotli = "Brotli compression";
pub const NID_brotli = @as(c_int, 1288);
pub const SN_zstd = "zstd";
pub const LN_zstd = "Zstandard compression";
pub const NID_zstd = @as(c_int, 1289);
pub const SN_id_tc26_cipher_gostr3412_2015_magma_ctracpkm = SN_magma_ctr_acpkm;
pub const NID_id_tc26_cipher_gostr3412_2015_magma_ctracpkm = NID_magma_ctr_acpkm;
pub const OBJ_id_tc26_cipher_gostr3412_2015_magma_ctracpkm = OBJ_magma_ctr_acpkm;
pub const SN_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac = SN_magma_ctr_acpkm_omac;
pub const NID_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac = NID_magma_ctr_acpkm_omac;
pub const OBJ_id_tc26_cipher_gostr3412_2015_magma_ctracpkm_omac = OBJ_magma_ctr_acpkm_omac;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm = SN_kuznyechik_ctr_acpkm;
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm = NID_kuznyechik_ctr_acpkm;
pub const OBJ_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm = OBJ_kuznyechik_ctr_acpkm;
pub const SN_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac = SN_kuznyechik_ctr_acpkm_omac;
pub const NID_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac = NID_kuznyechik_ctr_acpkm_omac;
pub const OBJ_id_tc26_cipher_gostr3412_2015_kuznyechik_ctracpkm_omac = OBJ_kuznyechik_ctr_acpkm_omac;
pub const SN_id_tc26_wrap_gostr3412_2015_magma_kexp15 = SN_magma_kexp15;
pub const NID_id_tc26_wrap_gostr3412_2015_magma_kexp15 = NID_magma_kexp15;
pub const OBJ_id_tc26_wrap_gostr3412_2015_magma_kexp15 = OBJ_magma_kexp15;
pub const SN_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15 = SN_kuznyechik_kexp15;
pub const NID_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15 = NID_kuznyechik_kexp15;
pub const OBJ_id_tc26_wrap_gostr3412_2015_kuznyechik_kexp15 = OBJ_kuznyechik_kexp15;
pub const SN_grasshopper_ecb = SN_kuznyechik_ecb;
pub const NID_grasshopper_ecb = NID_kuznyechik_ecb;
pub const SN_grasshopper_ctr = SN_kuznyechik_ctr;
pub const NID_grasshopper_ctr = NID_kuznyechik_ctr;
pub const SN_grasshopper_ofb = SN_kuznyechik_ofb;
pub const NID_grasshopper_ofb = NID_kuznyechik_ofb;
pub const SN_grasshopper_cbc = SN_kuznyechik_cbc;
pub const NID_grasshopper_cbc = NID_kuznyechik_cbc;
pub const SN_grasshopper_cfb = SN_kuznyechik_cfb;
pub const NID_grasshopper_cfb = NID_kuznyechik_cfb;
pub const SN_grasshopper_mac = SN_kuznyechik_mac;
pub const NID_grasshopper_mac = NID_kuznyechik_mac;
pub const OPENSSL_ASN1_H = "";
pub const HEADER_ASN1_H = "";
pub const OPENSSL_ASN1ERR_H = "";
pub const ASN1_R_ADDING_OBJECT = @as(c_int, 171);
pub const ASN1_R_ASN1_PARSE_ERROR = @as(c_int, 203);
pub const ASN1_R_ASN1_SIG_PARSE_ERROR = @as(c_int, 204);
pub const ASN1_R_AUX_ERROR = @as(c_int, 100);
pub const ASN1_R_BAD_OBJECT_HEADER = @as(c_int, 102);
pub const ASN1_R_BAD_TEMPLATE = @as(c_int, 230);
pub const ASN1_R_BMPSTRING_IS_WRONG_LENGTH = @as(c_int, 214);
pub const ASN1_R_BN_LIB = @as(c_int, 105);
pub const ASN1_R_BOOLEAN_IS_WRONG_LENGTH = @as(c_int, 106);
pub const ASN1_R_BUFFER_TOO_SMALL = @as(c_int, 107);
pub const ASN1_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER = @as(c_int, 108);
pub const ASN1_R_CONTEXT_NOT_INITIALISED = @as(c_int, 217);
pub const ASN1_R_DATA_IS_WRONG = @as(c_int, 109);
pub const ASN1_R_DECODE_ERROR = @as(c_int, 110);
pub const ASN1_R_DEPTH_EXCEEDED = @as(c_int, 174);
pub const ASN1_R_DIGEST_AND_KEY_TYPE_NOT_SUPPORTED = @as(c_int, 198);
pub const ASN1_R_ENCODE_ERROR = @as(c_int, 112);
pub const ASN1_R_ERROR_GETTING_TIME = @as(c_int, 173);
pub const ASN1_R_ERROR_LOADING_SECTION = @as(c_int, 172);
pub const ASN1_R_ERROR_SETTING_CIPHER_PARAMS = @as(c_int, 114);
pub const ASN1_R_EXPECTING_AN_INTEGER = @as(c_int, 115);
pub const ASN1_R_EXPECTING_AN_OBJECT = @as(c_int, 116);
pub const ASN1_R_EXPLICIT_LENGTH_MISMATCH = @as(c_int, 119);
pub const ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED = @as(c_int, 120);
pub const ASN1_R_FIELD_MISSING = @as(c_int, 121);
pub const ASN1_R_FIRST_NUM_TOO_LARGE = @as(c_int, 122);
pub const ASN1_R_GENERALIZEDTIME_IS_TOO_SHORT = @as(c_int, 232);
pub const ASN1_R_HEADER_TOO_LONG = @as(c_int, 123);
pub const ASN1_R_ILLEGAL_BITSTRING_FORMAT = @as(c_int, 175);
pub const ASN1_R_ILLEGAL_BOOLEAN = @as(c_int, 176);
pub const ASN1_R_ILLEGAL_CHARACTERS = @as(c_int, 124);
pub const ASN1_R_ILLEGAL_FORMAT = @as(c_int, 177);
pub const ASN1_R_ILLEGAL_HEX = @as(c_int, 178);
pub const ASN1_R_ILLEGAL_IMPLICIT_TAG = @as(c_int, 179);
pub const ASN1_R_ILLEGAL_INTEGER = @as(c_int, 180);
pub const ASN1_R_ILLEGAL_NEGATIVE_VALUE = @as(c_int, 226);
pub const ASN1_R_ILLEGAL_NESTED_TAGGING = @as(c_int, 181);
pub const ASN1_R_ILLEGAL_NULL = @as(c_int, 125);
pub const ASN1_R_ILLEGAL_NULL_VALUE = @as(c_int, 182);
pub const ASN1_R_ILLEGAL_OBJECT = @as(c_int, 183);
pub const ASN1_R_ILLEGAL_OPTIONAL_ANY = @as(c_int, 126);
pub const ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE = @as(c_int, 170);
pub const ASN1_R_ILLEGAL_PADDING = @as(c_int, 221);
pub const ASN1_R_ILLEGAL_TAGGED_ANY = @as(c_int, 127);
pub const ASN1_R_ILLEGAL_TIME_VALUE = @as(c_int, 184);
pub const ASN1_R_ILLEGAL_ZERO_CONTENT = @as(c_int, 222);
pub const ASN1_R_INTEGER_NOT_ASCII_FORMAT = @as(c_int, 185);
pub const ASN1_R_INTEGER_TOO_LARGE_FOR_LONG = @as(c_int, 128);
pub const ASN1_R_INVALID_BIT_STRING_BITS_LEFT = @as(c_int, 220);
pub const ASN1_R_INVALID_BMPSTRING_LENGTH = @as(c_int, 129);
pub const ASN1_R_INVALID_DIGIT = @as(c_int, 130);
pub const ASN1_R_INVALID_MIME_TYPE = @as(c_int, 205);
pub const ASN1_R_INVALID_MODIFIER = @as(c_int, 186);
pub const ASN1_R_INVALID_NUMBER = @as(c_int, 187);
pub const ASN1_R_INVALID_OBJECT_ENCODING = @as(c_int, 216);
pub const ASN1_R_INVALID_SCRYPT_PARAMETERS = @as(c_int, 227);
pub const ASN1_R_INVALID_SEPARATOR = @as(c_int, 131);
pub const ASN1_R_INVALID_STRING_TABLE_VALUE = @as(c_int, 218);
pub const ASN1_R_INVALID_UNIVERSALSTRING_LENGTH = @as(c_int, 133);
pub const ASN1_R_INVALID_UTF8STRING = @as(c_int, 134);
pub const ASN1_R_INVALID_VALUE = @as(c_int, 219);
pub const ASN1_R_LENGTH_TOO_LONG = @as(c_int, 231);
pub const ASN1_R_LIST_ERROR = @as(c_int, 188);
pub const ASN1_R_MIME_NO_CONTENT_TYPE = @as(c_int, 206);
pub const ASN1_R_MIME_PARSE_ERROR = @as(c_int, 207);
pub const ASN1_R_MIME_SIG_PARSE_ERROR = @as(c_int, 208);
pub const ASN1_R_MISSING_EOC = @as(c_int, 137);
pub const ASN1_R_MISSING_SECOND_NUMBER = @as(c_int, 138);
pub const ASN1_R_MISSING_VALUE = @as(c_int, 189);
pub const ASN1_R_MSTRING_NOT_UNIVERSAL = @as(c_int, 139);
pub const ASN1_R_MSTRING_WRONG_TAG = @as(c_int, 140);
pub const ASN1_R_NESTED_ASN1_STRING = @as(c_int, 197);
pub const ASN1_R_NESTED_TOO_DEEP = @as(c_int, 201);
pub const ASN1_R_NON_HEX_CHARACTERS = @as(c_int, 141);
pub const ASN1_R_NOT_ASCII_FORMAT = @as(c_int, 190);
pub const ASN1_R_NOT_ENOUGH_DATA = @as(c_int, 142);
pub const ASN1_R_NO_CONTENT_TYPE = @as(c_int, 209);
pub const ASN1_R_NO_MATCHING_CHOICE_TYPE = @as(c_int, 143);
pub const ASN1_R_NO_MULTIPART_BODY_FAILURE = @as(c_int, 210);
pub const ASN1_R_NO_MULTIPART_BOUNDARY = @as(c_int, 211);
pub const ASN1_R_NO_SIG_CONTENT_TYPE = @as(c_int, 212);
pub const ASN1_R_NULL_IS_WRONG_LENGTH = @as(c_int, 144);
pub const ASN1_R_OBJECT_NOT_ASCII_FORMAT = @as(c_int, 191);
pub const ASN1_R_ODD_NUMBER_OF_CHARS = @as(c_int, 145);
pub const ASN1_R_SECOND_NUMBER_TOO_LARGE = @as(c_int, 147);
pub const ASN1_R_SEQUENCE_LENGTH_MISMATCH = @as(c_int, 148);
pub const ASN1_R_SEQUENCE_NOT_CONSTRUCTED = @as(c_int, 149);
pub const ASN1_R_SEQUENCE_OR_SET_NEEDS_CONFIG = @as(c_int, 192);
pub const ASN1_R_SHORT_LINE = @as(c_int, 150);
pub const ASN1_R_SIG_INVALID_MIME_TYPE = @as(c_int, 213);
pub const ASN1_R_STREAMING_NOT_SUPPORTED = @as(c_int, 202);
pub const ASN1_R_STRING_TOO_LONG = @as(c_int, 151);
pub const ASN1_R_STRING_TOO_SHORT = @as(c_int, 152);
pub const ASN1_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD = @as(c_int, 154);
pub const ASN1_R_TIME_NOT_ASCII_FORMAT = @as(c_int, 193);
pub const ASN1_R_TOO_LARGE = @as(c_int, 223);
pub const ASN1_R_TOO_LONG = @as(c_int, 155);
pub const ASN1_R_TOO_SMALL = @as(c_int, 224);
pub const ASN1_R_TYPE_NOT_CONSTRUCTED = @as(c_int, 156);
pub const ASN1_R_TYPE_NOT_PRIMITIVE = @as(c_int, 195);
pub const ASN1_R_UNEXPECTED_EOC = @as(c_int, 159);
pub const ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH = @as(c_int, 215);
pub const ASN1_R_UNKNOWN_DIGEST = @as(c_int, 229);
pub const ASN1_R_UNKNOWN_FORMAT = @as(c_int, 160);
pub const ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM = @as(c_int, 161);
pub const ASN1_R_UNKNOWN_OBJECT_TYPE = @as(c_int, 162);
pub const ASN1_R_UNKNOWN_PUBLIC_KEY_TYPE = @as(c_int, 163);
pub const ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM = @as(c_int, 199);
pub const ASN1_R_UNKNOWN_TAG = @as(c_int, 194);
pub const ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE = @as(c_int, 164);
pub const ASN1_R_UNSUPPORTED_CIPHER = @as(c_int, 228);
pub const ASN1_R_UNSUPPORTED_PUBLIC_KEY_TYPE = @as(c_int, 167);
pub const ASN1_R_UNSUPPORTED_TYPE = @as(c_int, 196);
pub const ASN1_R_UTCTIME_IS_TOO_SHORT = @as(c_int, 233);
pub const ASN1_R_WRONG_INTEGER_TYPE = @as(c_int, 225);
pub const ASN1_R_WRONG_PUBLIC_KEY_TYPE = @as(c_int, 200);
pub const ASN1_R_WRONG_TAG = @as(c_int, 168);
pub const V_ASN1_UNIVERSAL = @as(c_int, 0x00);
pub const V_ASN1_APPLICATION = @as(c_int, 0x40);
pub const V_ASN1_CONTEXT_SPECIFIC = @as(c_int, 0x80);
pub const V_ASN1_PRIVATE = @as(c_int, 0xc0);
pub const V_ASN1_CONSTRUCTED = @as(c_int, 0x20);
pub const V_ASN1_PRIMITIVE_TAG = @as(c_int, 0x1f);
pub const V_ASN1_PRIMATIVE_TAG = V_ASN1_PRIMITIVE_TAG;
pub const V_ASN1_APP_CHOOSE = -@as(c_int, 2);
pub const V_ASN1_OTHER = -@as(c_int, 3);
pub const V_ASN1_ANY = -@as(c_int, 4);
pub const V_ASN1_UNDEF = -@as(c_int, 1);
pub const V_ASN1_EOC = @as(c_int, 0);
pub const V_ASN1_BOOLEAN = @as(c_int, 1);
pub const V_ASN1_INTEGER = @as(c_int, 2);
pub const V_ASN1_BIT_STRING = @as(c_int, 3);
pub const V_ASN1_OCTET_STRING = @as(c_int, 4);
pub const V_ASN1_NULL = @as(c_int, 5);
pub const V_ASN1_OBJECT = @as(c_int, 6);
pub const V_ASN1_OBJECT_DESCRIPTOR = @as(c_int, 7);
pub const V_ASN1_EXTERNAL = @as(c_int, 8);
pub const V_ASN1_REAL = @as(c_int, 9);
pub const V_ASN1_ENUMERATED = @as(c_int, 10);
pub const V_ASN1_UTF8STRING = @as(c_int, 12);
pub const V_ASN1_SEQUENCE = @as(c_int, 16);
pub const V_ASN1_SET = @as(c_int, 17);
pub const V_ASN1_NUMERICSTRING = @as(c_int, 18);
pub const V_ASN1_PRINTABLESTRING = @as(c_int, 19);
pub const V_ASN1_T61STRING = @as(c_int, 20);
pub const V_ASN1_TELETEXSTRING = @as(c_int, 20);
pub const V_ASN1_VIDEOTEXSTRING = @as(c_int, 21);
pub const V_ASN1_IA5STRING = @as(c_int, 22);
pub const V_ASN1_UTCTIME = @as(c_int, 23);
pub const V_ASN1_GENERALIZEDTIME = @as(c_int, 24);
pub const V_ASN1_GRAPHICSTRING = @as(c_int, 25);
pub const V_ASN1_ISO64STRING = @as(c_int, 26);
pub const V_ASN1_VISIBLESTRING = @as(c_int, 26);
pub const V_ASN1_GENERALSTRING = @as(c_int, 27);
pub const V_ASN1_UNIVERSALSTRING = @as(c_int, 28);
pub const V_ASN1_BMPSTRING = @as(c_int, 30);
pub const V_ASN1_NEG = @as(c_int, 0x100);
pub const V_ASN1_NEG_INTEGER = @as(c_int, 2) | V_ASN1_NEG;
pub const V_ASN1_NEG_ENUMERATED = @as(c_int, 10) | V_ASN1_NEG;
pub const B_ASN1_NUMERICSTRING = @as(c_int, 0x0001);
pub const B_ASN1_PRINTABLESTRING = @as(c_int, 0x0002);
pub const B_ASN1_T61STRING = @as(c_int, 0x0004);
pub const B_ASN1_TELETEXSTRING = @as(c_int, 0x0004);
pub const B_ASN1_VIDEOTEXSTRING = @as(c_int, 0x0008);
pub const B_ASN1_IA5STRING = @as(c_int, 0x0010);
pub const B_ASN1_GRAPHICSTRING = @as(c_int, 0x0020);
pub const B_ASN1_ISO64STRING = @as(c_int, 0x0040);
pub const B_ASN1_VISIBLESTRING = @as(c_int, 0x0040);
pub const B_ASN1_GENERALSTRING = @as(c_int, 0x0080);
pub const B_ASN1_UNIVERSALSTRING = @as(c_int, 0x0100);
pub const B_ASN1_OCTET_STRING = @as(c_int, 0x0200);
pub const B_ASN1_BIT_STRING = @as(c_int, 0x0400);
pub const B_ASN1_BMPSTRING = @as(c_int, 0x0800);
pub const B_ASN1_UNKNOWN = @as(c_int, 0x1000);
pub const B_ASN1_UTF8STRING = @as(c_int, 0x2000);
pub const B_ASN1_UTCTIME = @as(c_int, 0x4000);
pub const B_ASN1_GENERALIZEDTIME = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const B_ASN1_SEQUENCE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const MBSTRING_FLAG = @as(c_int, 0x1000);
pub const MBSTRING_UTF8 = MBSTRING_FLAG;
pub const MBSTRING_ASC = MBSTRING_FLAG | @as(c_int, 1);
pub const MBSTRING_BMP = MBSTRING_FLAG | @as(c_int, 2);
pub const MBSTRING_UNIV = MBSTRING_FLAG | @as(c_int, 4);
pub const SMIME_OLDMIME = @as(c_int, 0x400);
pub const SMIME_CRLFEOL = @as(c_int, 0x800);
pub const SMIME_STREAM = @as(c_int, 0x1000);
pub inline fn sk_X509_ALGOR_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_ALGOR_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_ALGOR_sk_type(sk));
}
pub inline fn sk_X509_ALGOR_value(sk: anytype, idx: anytype) [*c]X509_ALGOR {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_value(ossl_check_const_X509_ALGOR_sk_type(sk), idx));
}
pub const sk_X509_ALGOR_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:135:9
pub const sk_X509_ALGOR_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:136:9
pub const sk_X509_ALGOR_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:137:9
pub inline fn sk_X509_ALGOR_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_ALGOR_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_ALGOR_sk_type(sk), n);
}
pub inline fn sk_X509_ALGOR_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_ALGOR_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_ALGOR_sk_type(sk));
}
pub inline fn sk_X509_ALGOR_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_ALGOR_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_ALGOR_sk_type(sk));
}
pub inline fn sk_X509_ALGOR_delete(sk: anytype, i: anytype) [*c]X509_ALGOR {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_delete(ossl_check_X509_ALGOR_sk_type(sk), i));
}
pub inline fn sk_X509_ALGOR_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_ALGOR {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_delete_ptr(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr)));
}
pub inline fn sk_X509_ALGOR_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr));
}
pub inline fn sk_X509_ALGOR_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr));
}
pub inline fn sk_X509_ALGOR_pop(sk: anytype) [*c]X509_ALGOR {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_pop(ossl_check_X509_ALGOR_sk_type(sk)));
}
pub inline fn sk_X509_ALGOR_shift(sk: anytype) [*c]X509_ALGOR {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_shift(ossl_check_X509_ALGOR_sk_type(sk)));
}
pub inline fn sk_X509_ALGOR_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_freefunc_type(freefunc));
}
pub inline fn sk_X509_ALGOR_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr), idx);
}
pub inline fn sk_X509_ALGOR_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_ALGOR {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_ALGOR, OPENSSL_sk_set(ossl_check_X509_ALGOR_sk_type(sk), idx, ossl_check_X509_ALGOR_type(ptr)));
}
pub inline fn sk_X509_ALGOR_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr));
}
pub inline fn sk_X509_ALGOR_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr));
}
pub inline fn sk_X509_ALGOR_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_type(ptr), pnum);
}
pub inline fn sk_X509_ALGOR_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_ALGOR_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_ALGOR_sk_type(sk));
}
pub inline fn sk_X509_ALGOR_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_ALGOR_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_ALGOR_sk_type(sk));
}
pub const sk_X509_ALGOR_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:155:9
pub const sk_X509_ALGOR_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:156:9
pub inline fn sk_X509_ALGOR_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_ALGOR_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_ALGOR_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_ALGOR_sk_type(sk), ossl_check_X509_ALGOR_compfunc_type(cmp)));
}
pub const ASN1_STRING_FLAG_BITS_LEFT = @as(c_int, 0x08);
pub const ASN1_STRING_FLAG_NDEF = @as(c_int, 0x010);
pub const ASN1_STRING_FLAG_CONT = @as(c_int, 0x020);
pub const ASN1_STRING_FLAG_MSTRING = @as(c_int, 0x040);
pub const ASN1_STRING_FLAG_EMBED = @as(c_int, 0x080);
pub const ASN1_STRING_FLAG_X509_TIME = @as(c_int, 0x100);
pub const ASN1_LONG_UNDEF = @as(c_long, 0x7fffffff);
pub const STABLE_FLAGS_MALLOC = @as(c_int, 0x01);
pub const STABLE_FLAGS_CLEAR = STABLE_FLAGS_MALLOC;
pub const STABLE_NO_MASK = @as(c_int, 0x02);
pub const DIRSTRING_TYPE = ((B_ASN1_PRINTABLESTRING | B_ASN1_T61STRING) | B_ASN1_BMPSTRING) | B_ASN1_UTF8STRING;
pub const PKCS9STRING_TYPE = DIRSTRING_TYPE | B_ASN1_IA5STRING;
pub inline fn sk_ASN1_STRING_TABLE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_STRING_TABLE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_STRING_TABLE_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_TABLE_value(sk: anytype, idx: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_value(ossl_check_const_ASN1_STRING_TABLE_sk_type(sk), idx));
}
pub const sk_ASN1_STRING_TABLE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:237:9
pub const sk_ASN1_STRING_TABLE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:238:9
pub const sk_ASN1_STRING_TABLE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:239:9
pub inline fn sk_ASN1_STRING_TABLE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_STRING_TABLE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_STRING_TABLE_sk_type(sk), n);
}
pub inline fn sk_ASN1_STRING_TABLE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_STRING_TABLE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_STRING_TABLE_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_TABLE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_STRING_TABLE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_STRING_TABLE_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_TABLE_delete(sk: anytype, i: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_delete(ossl_check_ASN1_STRING_TABLE_sk_type(sk), i));
}
pub inline fn sk_ASN1_STRING_TABLE_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_delete_ptr(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr)));
}
pub inline fn sk_ASN1_STRING_TABLE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr));
}
pub inline fn sk_ASN1_STRING_TABLE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr));
}
pub inline fn sk_ASN1_STRING_TABLE_pop(sk: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_pop(ossl_check_ASN1_STRING_TABLE_sk_type(sk)));
}
pub inline fn sk_ASN1_STRING_TABLE_shift(sk: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_shift(ossl_check_ASN1_STRING_TABLE_sk_type(sk)));
}
pub inline fn sk_ASN1_STRING_TABLE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_STRING_TABLE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr), idx);
}
pub inline fn sk_ASN1_STRING_TABLE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_STRING_TABLE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING_TABLE, OPENSSL_sk_set(ossl_check_ASN1_STRING_TABLE_sk_type(sk), idx, ossl_check_ASN1_STRING_TABLE_type(ptr)));
}
pub inline fn sk_ASN1_STRING_TABLE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr));
}
pub inline fn sk_ASN1_STRING_TABLE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr));
}
pub inline fn sk_ASN1_STRING_TABLE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_type(ptr), pnum);
}
pub inline fn sk_ASN1_STRING_TABLE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_STRING_TABLE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_STRING_TABLE_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_TABLE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_STRING_TABLE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_STRING_TABLE_sk_type(sk));
}
pub const sk_ASN1_STRING_TABLE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:257:9
pub const sk_ASN1_STRING_TABLE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:258:9
pub inline fn sk_ASN1_STRING_TABLE_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_STRING_TABLE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_STRING_TABLE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_STRING_TABLE_sk_type(sk), ossl_check_ASN1_STRING_TABLE_compfunc_type(cmp)));
}
pub const ub_name = @import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const ub_common_name = @as(c_int, 64);
pub const ub_locality_name = @as(c_int, 128);
pub const ub_state_name = @as(c_int, 128);
pub const ub_organization_name = @as(c_int, 64);
pub const ub_organization_unit_name = @as(c_int, 64);
pub const ub_title = @as(c_int, 64);
pub const ub_email_address = @as(c_int, 128);
pub inline fn DECLARE_ASN1_FUNCTIONS_attr(attr: anytype, @"type": anytype) @TypeOf(DECLARE_ASN1_FUNCTIONS_name_attr(attr, @"type", @"type")) {
    _ = &attr;
    _ = &@"type";
    return DECLARE_ASN1_FUNCTIONS_name_attr(attr, @"type", @"type");
}
pub const DECLARE_ASN1_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:291:10
pub inline fn DECLARE_ASN1_ALLOC_FUNCTIONS_attr(attr: anytype, @"type": anytype) @TypeOf(DECLARE_ASN1_ALLOC_FUNCTIONS_name_attr(attr, @"type", @"type")) {
    _ = &attr;
    _ = &@"type";
    return DECLARE_ASN1_ALLOC_FUNCTIONS_name_attr(attr, @"type", @"type");
}
pub const DECLARE_ASN1_ALLOC_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:296:10
pub inline fn DECLARE_ASN1_FUNCTIONS_name_attr(attr: anytype, @"type": anytype, name: anytype) @TypeOf(DECLARE_ASN1_ALLOC_FUNCTIONS_name_attr(attr, @"type", name) ++ DECLARE_ASN1_ENCODE_FUNCTIONS_name_attr(attr, @"type", name)) {
    _ = &attr;
    _ = &@"type";
    _ = &name;
    return DECLARE_ASN1_ALLOC_FUNCTIONS_name_attr(attr, @"type", name) ++ DECLARE_ASN1_ENCODE_FUNCTIONS_name_attr(attr, @"type", name);
}
pub const DECLARE_ASN1_FUNCTIONS_name = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:302:10
pub inline fn DECLARE_ASN1_ENCODE_FUNCTIONS_attr(attr: anytype, @"type": anytype, itname: anytype, name: anytype) @TypeOf(DECLARE_ASN1_ENCODE_FUNCTIONS_only_attr(attr, @"type", name) ++ DECLARE_ASN1_ITEM_attr(attr, itname)) {
    _ = &attr;
    _ = &@"type";
    _ = &itname;
    _ = &name;
    return DECLARE_ASN1_ENCODE_FUNCTIONS_only_attr(attr, @"type", name) ++ DECLARE_ASN1_ITEM_attr(attr, itname);
}
pub const DECLARE_ASN1_ENCODE_FUNCTIONS = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:308:10
pub inline fn DECLARE_ASN1_ENCODE_FUNCTIONS_name_attr(attr: anytype, @"type": anytype, name: anytype) @TypeOf(DECLARE_ASN1_ENCODE_FUNCTIONS_attr(attr, @"type", name, name)) {
    _ = &attr;
    _ = &@"type";
    _ = &name;
    return DECLARE_ASN1_ENCODE_FUNCTIONS_attr(attr, @"type", name, name);
}
pub const DECLARE_ASN1_ENCODE_FUNCTIONS_name = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:313:10
pub const DECLARE_ASN1_ENCODE_FUNCTIONS_only_attr = @compileError("unable to translate macro: undefined identifier `d2i_`");
// /usr/include/openssl/asn1.h:316:10
pub const DECLARE_ASN1_ENCODE_FUNCTIONS_only = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:319:10
pub const DECLARE_ASN1_NDEF_FUNCTION_attr = @compileError("unable to translate macro: undefined identifier `i2d_`");
// /usr/include/openssl/asn1.h:322:10
pub const DECLARE_ASN1_NDEF_FUNCTION = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:324:10
pub const DECLARE_ASN1_ALLOC_FUNCTIONS_name_attr = @compileError("unable to translate macro: undefined identifier `_new`");
// /usr/include/openssl/asn1.h:327:10
pub const DECLARE_ASN1_ALLOC_FUNCTIONS_name = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:330:10
pub inline fn DECLARE_ASN1_DUP_FUNCTION_attr(attr: anytype, @"type": anytype) @TypeOf(DECLARE_ASN1_DUP_FUNCTION_name_attr(attr, @"type", @"type")) {
    _ = &attr;
    _ = &@"type";
    return DECLARE_ASN1_DUP_FUNCTION_name_attr(attr, @"type", @"type");
}
pub const DECLARE_ASN1_DUP_FUNCTION = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:335:10
pub const DECLARE_ASN1_DUP_FUNCTION_name_attr = @compileError("unable to translate macro: undefined identifier `_dup`");
// /usr/include/openssl/asn1.h:338:10
pub const DECLARE_ASN1_DUP_FUNCTION_name = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:340:10
pub inline fn DECLARE_ASN1_PRINT_FUNCTION_attr(attr: anytype, stname: anytype) @TypeOf(DECLARE_ASN1_PRINT_FUNCTION_fname_attr(attr, stname, stname)) {
    _ = &attr;
    _ = &stname;
    return DECLARE_ASN1_PRINT_FUNCTION_fname_attr(attr, stname, stname);
}
pub const DECLARE_ASN1_PRINT_FUNCTION = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:345:10
pub const DECLARE_ASN1_PRINT_FUNCTION_fname_attr = @compileError("unable to translate macro: undefined identifier `_print_ctx`");
// /usr/include/openssl/asn1.h:348:10
pub const DECLARE_ASN1_PRINT_FUNCTION_fname = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:351:10
pub const D2I_OF = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:354:10
pub const I2D_OF = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:355:10
pub const CHECKED_D2I_OF = @compileError("unable to translate C expr: expected ')' instead got 'A number'");
// /usr/include/openssl/asn1.h:357:10
pub const CHECKED_I2D_OF = @compileError("unable to translate C expr: expected ')' instead got 'A number'");
// /usr/include/openssl/asn1.h:359:10
pub const CHECKED_NEW_OF = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/asn1.h:361:10
pub const CHECKED_PTR_OF = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:363:10
pub const CHECKED_PPTR_OF = @compileError("unable to translate C expr: expected ')' instead got '*'");
// /usr/include/openssl/asn1.h:365:10
pub const TYPEDEF_D2I_OF = @compileError("unable to translate macro: undefined identifier `d2i_of_`");
// /usr/include/openssl/asn1.h:368:10
pub const TYPEDEF_I2D_OF = @compileError("unable to translate macro: undefined identifier `i2d_of_`");
// /usr/include/openssl/asn1.h:369:10
pub const TYPEDEF_D2I2D_OF = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/openssl/asn1.h:370:10
pub inline fn ASN1_ITEM_ptr(iptr: anytype) @TypeOf(iptr()) {
    _ = &iptr;
    return iptr();
}
pub const ASN1_ITEM_ref = @compileError("unable to translate macro: undefined identifier `_it`");
// /usr/include/openssl/asn1.h:424:10
pub const ASN1_ITEM_rptr = @compileError("unable to translate macro: undefined identifier `_it`");
// /usr/include/openssl/asn1.h:426:10
pub const DECLARE_ASN1_ITEM_attr = @compileError("unable to translate macro: undefined identifier `_it`");
// /usr/include/openssl/asn1.h:428:10
pub const DECLARE_ASN1_ITEM = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/asn1.h:430:10
pub const ASN1_STRFLGS_ESC_2253 = @as(c_int, 1);
pub const ASN1_STRFLGS_ESC_CTRL = @as(c_int, 2);
pub const ASN1_STRFLGS_ESC_MSB = @as(c_int, 4);
pub const ASN1_DTFLGS_TYPE_MASK = @as(c_ulong, 0x0F);
pub const ASN1_DTFLGS_RFC822 = @as(c_ulong, 0x00);
pub const ASN1_DTFLGS_ISO8601 = @as(c_ulong, 0x01);
pub const ASN1_STRFLGS_ESC_QUOTE = @as(c_int, 8);
pub const CHARTYPE_PRINTABLESTRING = @as(c_int, 0x10);
pub const CHARTYPE_FIRST_ESC_2253 = @as(c_int, 0x20);
pub const CHARTYPE_LAST_ESC_2253 = @as(c_int, 0x40);
pub const ASN1_STRFLGS_UTF8_CONVERT = @as(c_int, 0x10);
pub const ASN1_STRFLGS_IGNORE_TYPE = @as(c_int, 0x20);
pub const ASN1_STRFLGS_SHOW_TYPE = @as(c_int, 0x40);
pub const ASN1_STRFLGS_DUMP_ALL = @as(c_int, 0x80);
pub const ASN1_STRFLGS_DUMP_UNKNOWN = @as(c_int, 0x100);
pub const ASN1_STRFLGS_DUMP_DER = @as(c_int, 0x200);
pub const ASN1_STRFLGS_ESC_2254 = @as(c_int, 0x400);
pub const ASN1_STRFLGS_RFC2253 = ((((ASN1_STRFLGS_ESC_2253 | ASN1_STRFLGS_ESC_CTRL) | ASN1_STRFLGS_ESC_MSB) | ASN1_STRFLGS_UTF8_CONVERT) | ASN1_STRFLGS_DUMP_UNKNOWN) | ASN1_STRFLGS_DUMP_DER;
pub inline fn sk_ASN1_TYPE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_TYPE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_TYPE_sk_type(sk));
}
pub inline fn sk_ASN1_TYPE_value(sk: anytype, idx: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_value(ossl_check_const_ASN1_TYPE_sk_type(sk), idx));
}
pub const sk_ASN1_TYPE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:557:9
pub const sk_ASN1_TYPE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:558:9
pub const sk_ASN1_TYPE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:559:9
pub inline fn sk_ASN1_TYPE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_TYPE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_TYPE_sk_type(sk), n);
}
pub inline fn sk_ASN1_TYPE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_TYPE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_TYPE_sk_type(sk));
}
pub inline fn sk_ASN1_TYPE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_TYPE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_TYPE_sk_type(sk));
}
pub inline fn sk_ASN1_TYPE_delete(sk: anytype, i: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_delete(ossl_check_ASN1_TYPE_sk_type(sk), i));
}
pub inline fn sk_ASN1_TYPE_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_delete_ptr(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr)));
}
pub inline fn sk_ASN1_TYPE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr));
}
pub inline fn sk_ASN1_TYPE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr));
}
pub inline fn sk_ASN1_TYPE_pop(sk: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_pop(ossl_check_ASN1_TYPE_sk_type(sk)));
}
pub inline fn sk_ASN1_TYPE_shift(sk: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_shift(ossl_check_ASN1_TYPE_sk_type(sk)));
}
pub inline fn sk_ASN1_TYPE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_TYPE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr), idx);
}
pub inline fn sk_ASN1_TYPE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_TYPE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_TYPE, OPENSSL_sk_set(ossl_check_ASN1_TYPE_sk_type(sk), idx, ossl_check_ASN1_TYPE_type(ptr)));
}
pub inline fn sk_ASN1_TYPE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr));
}
pub inline fn sk_ASN1_TYPE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr));
}
pub inline fn sk_ASN1_TYPE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_type(ptr), pnum);
}
pub inline fn sk_ASN1_TYPE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_TYPE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_TYPE_sk_type(sk));
}
pub inline fn sk_ASN1_TYPE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_TYPE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_TYPE_sk_type(sk));
}
pub const sk_ASN1_TYPE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:577:9
pub const sk_ASN1_TYPE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:578:9
pub inline fn sk_ASN1_TYPE_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_TYPE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_TYPE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_TYPE_sk_type(sk), ossl_check_ASN1_TYPE_compfunc_type(cmp)));
}
pub const B_ASN1_TIME = B_ASN1_UTCTIME | B_ASN1_GENERALIZEDTIME;
pub const B_ASN1_PRINTABLE = ((((((((B_ASN1_NUMERICSTRING | B_ASN1_PRINTABLESTRING) | B_ASN1_T61STRING) | B_ASN1_IA5STRING) | B_ASN1_BIT_STRING) | B_ASN1_UNIVERSALSTRING) | B_ASN1_BMPSTRING) | B_ASN1_UTF8STRING) | B_ASN1_SEQUENCE) | B_ASN1_UNKNOWN;
pub const B_ASN1_DIRECTORYSTRING = (((B_ASN1_PRINTABLESTRING | B_ASN1_TELETEXSTRING) | B_ASN1_BMPSTRING) | B_ASN1_UNIVERSALSTRING) | B_ASN1_UTF8STRING;
pub const B_ASN1_DISPLAYTEXT = ((B_ASN1_IA5STRING | B_ASN1_VISIBLESTRING) | B_ASN1_BMPSTRING) | B_ASN1_UTF8STRING;
pub inline fn sk_ASN1_OBJECT_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_OBJECT_sk_type(sk));
}
pub inline fn sk_ASN1_OBJECT_value(sk: anytype, idx: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_value(ossl_check_const_ASN1_OBJECT_sk_type(sk), idx));
}
pub const sk_ASN1_OBJECT_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:637:9
pub const sk_ASN1_OBJECT_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:638:9
pub const sk_ASN1_OBJECT_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:639:9
pub inline fn sk_ASN1_OBJECT_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_OBJECT_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_OBJECT_sk_type(sk), n);
}
pub inline fn sk_ASN1_OBJECT_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_OBJECT_sk_type(sk));
}
pub inline fn sk_ASN1_OBJECT_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_OBJECT_sk_type(sk));
}
pub inline fn sk_ASN1_OBJECT_delete(sk: anytype, i: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_delete(ossl_check_ASN1_OBJECT_sk_type(sk), i));
}
pub inline fn sk_ASN1_OBJECT_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_delete_ptr(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr)));
}
pub inline fn sk_ASN1_OBJECT_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr));
}
pub inline fn sk_ASN1_OBJECT_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr));
}
pub inline fn sk_ASN1_OBJECT_pop(sk: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_pop(ossl_check_ASN1_OBJECT_sk_type(sk)));
}
pub inline fn sk_ASN1_OBJECT_shift(sk: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_shift(ossl_check_ASN1_OBJECT_sk_type(sk)));
}
pub inline fn sk_ASN1_OBJECT_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_OBJECT_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr), idx);
}
pub inline fn sk_ASN1_OBJECT_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_OBJECT {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_OBJECT, OPENSSL_sk_set(ossl_check_ASN1_OBJECT_sk_type(sk), idx, ossl_check_ASN1_OBJECT_type(ptr)));
}
pub inline fn sk_ASN1_OBJECT_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr));
}
pub inline fn sk_ASN1_OBJECT_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr));
}
pub inline fn sk_ASN1_OBJECT_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_type(ptr), pnum);
}
pub inline fn sk_ASN1_OBJECT_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_OBJECT_sk_type(sk));
}
pub inline fn sk_ASN1_OBJECT_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_OBJECT_sk_type(sk));
}
pub const sk_ASN1_OBJECT_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:657:9
pub const sk_ASN1_OBJECT_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:658:9
pub inline fn sk_ASN1_OBJECT_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_OBJECT_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_OBJECT_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_OBJECT_sk_type(sk), ossl_check_ASN1_OBJECT_compfunc_type(cmp)));
}
pub inline fn sk_ASN1_INTEGER_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_INTEGER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_INTEGER_sk_type(sk));
}
pub inline fn sk_ASN1_INTEGER_value(sk: anytype, idx: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_value(ossl_check_const_ASN1_INTEGER_sk_type(sk), idx));
}
pub const sk_ASN1_INTEGER_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:703:9
pub const sk_ASN1_INTEGER_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:704:9
pub const sk_ASN1_INTEGER_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:705:9
pub inline fn sk_ASN1_INTEGER_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_INTEGER_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_INTEGER_sk_type(sk), n);
}
pub inline fn sk_ASN1_INTEGER_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_INTEGER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_INTEGER_sk_type(sk));
}
pub inline fn sk_ASN1_INTEGER_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_INTEGER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_INTEGER_sk_type(sk));
}
pub inline fn sk_ASN1_INTEGER_delete(sk: anytype, i: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_delete(ossl_check_ASN1_INTEGER_sk_type(sk), i));
}
pub inline fn sk_ASN1_INTEGER_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_delete_ptr(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr)));
}
pub inline fn sk_ASN1_INTEGER_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr));
}
pub inline fn sk_ASN1_INTEGER_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr));
}
pub inline fn sk_ASN1_INTEGER_pop(sk: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_pop(ossl_check_ASN1_INTEGER_sk_type(sk)));
}
pub inline fn sk_ASN1_INTEGER_shift(sk: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_shift(ossl_check_ASN1_INTEGER_sk_type(sk)));
}
pub inline fn sk_ASN1_INTEGER_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_INTEGER_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr), idx);
}
pub inline fn sk_ASN1_INTEGER_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_INTEGER {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_INTEGER, OPENSSL_sk_set(ossl_check_ASN1_INTEGER_sk_type(sk), idx, ossl_check_ASN1_INTEGER_type(ptr)));
}
pub inline fn sk_ASN1_INTEGER_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr));
}
pub inline fn sk_ASN1_INTEGER_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr));
}
pub inline fn sk_ASN1_INTEGER_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_type(ptr), pnum);
}
pub inline fn sk_ASN1_INTEGER_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_INTEGER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_INTEGER_sk_type(sk));
}
pub inline fn sk_ASN1_INTEGER_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_INTEGER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_INTEGER_sk_type(sk));
}
pub const sk_ASN1_INTEGER_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:723:9
pub const sk_ASN1_INTEGER_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:724:9
pub inline fn sk_ASN1_INTEGER_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_INTEGER_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_INTEGER_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_INTEGER_sk_type(sk), ossl_check_ASN1_INTEGER_compfunc_type(cmp)));
}
pub inline fn sk_ASN1_UTF8STRING_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_UTF8STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_UTF8STRING_sk_type(sk));
}
pub inline fn sk_ASN1_UTF8STRING_value(sk: anytype, idx: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_value(ossl_check_const_ASN1_UTF8STRING_sk_type(sk), idx));
}
pub const sk_ASN1_UTF8STRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:765:9
pub const sk_ASN1_UTF8STRING_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:766:9
pub const sk_ASN1_UTF8STRING_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:767:9
pub inline fn sk_ASN1_UTF8STRING_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_UTF8STRING_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_UTF8STRING_sk_type(sk), n);
}
pub inline fn sk_ASN1_UTF8STRING_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_UTF8STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_UTF8STRING_sk_type(sk));
}
pub inline fn sk_ASN1_UTF8STRING_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_UTF8STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_UTF8STRING_sk_type(sk));
}
pub inline fn sk_ASN1_UTF8STRING_delete(sk: anytype, i: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_delete(ossl_check_ASN1_UTF8STRING_sk_type(sk), i));
}
pub inline fn sk_ASN1_UTF8STRING_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_delete_ptr(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr)));
}
pub inline fn sk_ASN1_UTF8STRING_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr));
}
pub inline fn sk_ASN1_UTF8STRING_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr));
}
pub inline fn sk_ASN1_UTF8STRING_pop(sk: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_pop(ossl_check_ASN1_UTF8STRING_sk_type(sk)));
}
pub inline fn sk_ASN1_UTF8STRING_shift(sk: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_shift(ossl_check_ASN1_UTF8STRING_sk_type(sk)));
}
pub inline fn sk_ASN1_UTF8STRING_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_UTF8STRING_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr), idx);
}
pub inline fn sk_ASN1_UTF8STRING_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_UTF8STRING {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_UTF8STRING, OPENSSL_sk_set(ossl_check_ASN1_UTF8STRING_sk_type(sk), idx, ossl_check_ASN1_UTF8STRING_type(ptr)));
}
pub inline fn sk_ASN1_UTF8STRING_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr));
}
pub inline fn sk_ASN1_UTF8STRING_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr));
}
pub inline fn sk_ASN1_UTF8STRING_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_type(ptr), pnum);
}
pub inline fn sk_ASN1_UTF8STRING_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_UTF8STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_UTF8STRING_sk_type(sk));
}
pub inline fn sk_ASN1_UTF8STRING_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_UTF8STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_UTF8STRING_sk_type(sk));
}
pub const sk_ASN1_UTF8STRING_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:785:9
pub const sk_ASN1_UTF8STRING_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:786:9
pub inline fn sk_ASN1_UTF8STRING_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_UTF8STRING_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_UTF8STRING_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_UTF8STRING_sk_type(sk), ossl_check_ASN1_UTF8STRING_compfunc_type(cmp)));
}
pub inline fn sk_ASN1_GENERALSTRING_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_GENERALSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_GENERALSTRING_sk_type(sk));
}
pub inline fn sk_ASN1_GENERALSTRING_value(sk: anytype, idx: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_value(ossl_check_const_ASN1_GENERALSTRING_sk_type(sk), idx));
}
pub const sk_ASN1_GENERALSTRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:802:9
pub const sk_ASN1_GENERALSTRING_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:803:9
pub const sk_ASN1_GENERALSTRING_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:804:9
pub inline fn sk_ASN1_GENERALSTRING_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_GENERALSTRING_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_GENERALSTRING_sk_type(sk), n);
}
pub inline fn sk_ASN1_GENERALSTRING_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_GENERALSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_GENERALSTRING_sk_type(sk));
}
pub inline fn sk_ASN1_GENERALSTRING_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_GENERALSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_GENERALSTRING_sk_type(sk));
}
pub inline fn sk_ASN1_GENERALSTRING_delete(sk: anytype, i: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_delete(ossl_check_ASN1_GENERALSTRING_sk_type(sk), i));
}
pub inline fn sk_ASN1_GENERALSTRING_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_delete_ptr(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr)));
}
pub inline fn sk_ASN1_GENERALSTRING_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr));
}
pub inline fn sk_ASN1_GENERALSTRING_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr));
}
pub inline fn sk_ASN1_GENERALSTRING_pop(sk: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_pop(ossl_check_ASN1_GENERALSTRING_sk_type(sk)));
}
pub inline fn sk_ASN1_GENERALSTRING_shift(sk: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_shift(ossl_check_ASN1_GENERALSTRING_sk_type(sk)));
}
pub inline fn sk_ASN1_GENERALSTRING_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_GENERALSTRING_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr), idx);
}
pub inline fn sk_ASN1_GENERALSTRING_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_GENERALSTRING {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_GENERALSTRING, OPENSSL_sk_set(ossl_check_ASN1_GENERALSTRING_sk_type(sk), idx, ossl_check_ASN1_GENERALSTRING_type(ptr)));
}
pub inline fn sk_ASN1_GENERALSTRING_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr));
}
pub inline fn sk_ASN1_GENERALSTRING_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr));
}
pub inline fn sk_ASN1_GENERALSTRING_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_type(ptr), pnum);
}
pub inline fn sk_ASN1_GENERALSTRING_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_GENERALSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_GENERALSTRING_sk_type(sk));
}
pub inline fn sk_ASN1_GENERALSTRING_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_GENERALSTRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_GENERALSTRING_sk_type(sk));
}
pub const sk_ASN1_GENERALSTRING_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:822:9
pub const sk_ASN1_GENERALSTRING_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:823:9
pub inline fn sk_ASN1_GENERALSTRING_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_GENERALSTRING_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_GENERALSTRING_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_GENERALSTRING_sk_type(sk), ossl_check_ASN1_GENERALSTRING_compfunc_type(cmp)));
}
pub const ASN1_dup_of = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:909:10
pub const M_ASN1_new_of = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:927:10
pub inline fn M_ASN1_free_of(x: anytype, @"type": anytype) @TypeOf(ASN1_item_free(CHECKED_PTR_OF(@"type", x), ASN1_ITEM_rptr(@"type"))) {
    _ = &x;
    _ = &@"type";
    return ASN1_item_free(CHECKED_PTR_OF(@"type", x), ASN1_ITEM_rptr(@"type"));
}
pub const ASN1_d2i_fp_of = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:934:11
pub const ASN1_i2d_fp_of = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/asn1.h:945:11
pub const ASN1_d2i_bio_of = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/asn1.h:958:11
pub const ASN1_i2d_bio_of = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/asn1.h:969:11
pub const ASN1_PCTX_FLAGS_SHOW_ABSENT = @as(c_int, 0x001);
pub const ASN1_PCTX_FLAGS_SHOW_SEQUENCE = @as(c_int, 0x002);
pub const ASN1_PCTX_FLAGS_SHOW_SSOF = @as(c_int, 0x004);
pub const ASN1_PCTX_FLAGS_SHOW_TYPE = @as(c_int, 0x008);
pub const ASN1_PCTX_FLAGS_NO_ANY_TYPE = @as(c_int, 0x010);
pub const ASN1_PCTX_FLAGS_NO_MSTRING_TYPE = @as(c_int, 0x020);
pub const ASN1_PCTX_FLAGS_NO_FIELD_NAME = @as(c_int, 0x040);
pub const ASN1_PCTX_FLAGS_SHOW_FIELD_STRUCT_NAME = @as(c_int, 0x080);
pub const ASN1_PCTX_FLAGS_NO_STRUCT_NAME = @as(c_int, 0x100);
pub inline fn DECLARE_ASN1_FUNCTIONS_fname(@"type": anytype, itname: anytype, name: anytype) @TypeOf(DECLARE_ASN1_ALLOC_FUNCTIONS_name(@"type", name) ++ DECLARE_ASN1_ENCODE_FUNCTIONS(@"type", itname, name)) {
    _ = &@"type";
    _ = &itname;
    _ = &name;
    return DECLARE_ASN1_ALLOC_FUNCTIONS_name(@"type", name) ++ DECLARE_ASN1_ENCODE_FUNCTIONS(@"type", itname, name);
}
pub inline fn DECLARE_ASN1_FUNCTIONS_const(@"type": anytype) @TypeOf(DECLARE_ASN1_FUNCTIONS(@"type")) {
    _ = &@"type";
    return DECLARE_ASN1_FUNCTIONS(@"type");
}
pub inline fn DECLARE_ASN1_ENCODE_FUNCTIONS_const(@"type": anytype, name: anytype) @TypeOf(DECLARE_ASN1_ENCODE_FUNCTIONS(@"type", name)) {
    _ = &@"type";
    _ = &name;
    return DECLARE_ASN1_ENCODE_FUNCTIONS(@"type", name);
}
pub inline fn I2D_OF_const(@"type": anytype) @TypeOf(I2D_OF(@"type")) {
    _ = &@"type";
    return I2D_OF(@"type");
}
pub inline fn ASN1_dup_of_const(@"type": anytype, i2d: anytype, d2i: anytype, x: anytype) @TypeOf(ASN1_dup_of(@"type", i2d, d2i, x)) {
    _ = &@"type";
    _ = &i2d;
    _ = &d2i;
    _ = &x;
    return ASN1_dup_of(@"type", i2d, d2i, x);
}
pub inline fn ASN1_i2d_fp_of_const(@"type": anytype, i2d: anytype, out: anytype, x: anytype) @TypeOf(ASN1_i2d_fp_of(@"type", i2d, out, x)) {
    _ = &@"type";
    _ = &i2d;
    _ = &out;
    _ = &x;
    return ASN1_i2d_fp_of(@"type", i2d, out, x);
}
pub inline fn ASN1_i2d_bio_of_const(@"type": anytype, i2d: anytype, out: anytype, x: anytype) @TypeOf(ASN1_i2d_bio_of(@"type", i2d, out, x)) {
    _ = &@"type";
    _ = &i2d;
    _ = &out;
    _ = &x;
    return ASN1_i2d_bio_of(@"type", i2d, out, x);
}
pub const OPENSSL_OBJECTSERR_H = "";
pub const OBJ_R_OID_EXISTS = @as(c_int, 102);
pub const OBJ_R_UNKNOWN_NID = @as(c_int, 101);
pub const OBJ_R_UNKNOWN_OBJECT_NAME = @as(c_int, 103);
pub const OBJ_NAME_TYPE_UNDEF = @as(c_int, 0x00);
pub const OBJ_NAME_TYPE_MD_METH = @as(c_int, 0x01);
pub const OBJ_NAME_TYPE_CIPHER_METH = @as(c_int, 0x02);
pub const OBJ_NAME_TYPE_PKEY_METH = @as(c_int, 0x03);
pub const OBJ_NAME_TYPE_COMP_METH = @as(c_int, 0x04);
pub const OBJ_NAME_TYPE_MAC_METH = @as(c_int, 0x05);
pub const OBJ_NAME_TYPE_KDF_METH = @as(c_int, 0x06);
pub const OBJ_NAME_TYPE_NUM = @as(c_int, 0x07);
pub const OBJ_NAME_ALIAS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const OBJ_BSEARCH_VALUE_ON_NOMATCH = @as(c_int, 0x01);
pub const OBJ_BSEARCH_FIRST_VALUE_ON_MATCH = @as(c_int, 0x02);
pub inline fn OBJ_create_and_add_object(a: anytype, b: anytype, c: anytype) @TypeOf(OBJ_create(a, b, c)) {
    _ = &a;
    _ = &b;
    _ = &c;
    return OBJ_create(a, b, c);
}
pub const _DECLARE_OBJ_BSEARCH_CMP_FN = @compileError("unable to translate macro: undefined identifier `_cmp_BSEARCH_CMP_FN`");
// /usr/include/openssl/objects.h:84:10
pub const DECLARE_OBJ_BSEARCH_CMP_FN = @compileError("unable to translate C expr: unexpected token 'static'");
// /usr/include/openssl/objects.h:89:10
pub const DECLARE_OBJ_BSEARCH_GLOBAL_CMP_FN = @compileError("unable to translate macro: undefined identifier `key`");
// /usr/include/openssl/objects.h:91:10
pub const IMPLEMENT_OBJ_BSEARCH_CMP_FN = @compileError("unable to translate macro: undefined identifier `_cmp_BSEARCH_CMP_FN`");
// /usr/include/openssl/objects.h:121:10
pub const IMPLEMENT_OBJ_BSEARCH_GLOBAL_CMP_FN = @compileError("unable to translate macro: undefined identifier `_cmp_BSEARCH_CMP_FN`");
// /usr/include/openssl/objects.h:135:10
pub const OBJ_bsearch = @compileError("unable to translate macro: undefined identifier `_type_1`");
// /usr/include/openssl/objects.h:149:10
pub const OBJ_bsearch_ex = @compileError("unable to translate macro: undefined identifier `_type_1`");
// /usr/include/openssl/objects.h:156:10
pub const OBJ_cleanup = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/objects.h:167:10
pub const SN_ac_auditEntity = SN_ac_auditIdentity;
pub const EVP_PK_RSA = @as(c_int, 0x0001);
pub const EVP_PK_DSA = @as(c_int, 0x0002);
pub const EVP_PK_DH = @as(c_int, 0x0004);
pub const EVP_PK_EC = @as(c_int, 0x0008);
pub const EVP_PKT_SIGN = @as(c_int, 0x0010);
pub const EVP_PKT_ENC = @as(c_int, 0x0020);
pub const EVP_PKT_EXCH = @as(c_int, 0x0040);
pub const EVP_PKS_RSA = @as(c_int, 0x0100);
pub const EVP_PKS_DSA = @as(c_int, 0x0200);
pub const EVP_PKS_EC = @as(c_int, 0x0400);
pub const EVP_PKEY_NONE = NID_undef;
pub const EVP_PKEY_RSA = NID_rsaEncryption;
pub const EVP_PKEY_RSA2 = NID_rsa;
pub const EVP_PKEY_RSA_PSS = NID_rsassaPss;
pub const EVP_PKEY_DSA = NID_dsa;
pub const EVP_PKEY_DSA1 = NID_dsa_2;
pub const EVP_PKEY_DSA2 = NID_dsaWithSHA;
pub const EVP_PKEY_DSA3 = NID_dsaWithSHA1;
pub const EVP_PKEY_DSA4 = NID_dsaWithSHA1_2;
pub const EVP_PKEY_DH = NID_dhKeyAgreement;
pub const EVP_PKEY_DHX = NID_dhpublicnumber;
pub const EVP_PKEY_EC = NID_X9_62_id_ecPublicKey;
pub const EVP_PKEY_SM2 = NID_sm2;
pub const EVP_PKEY_HMAC = NID_hmac;
pub const EVP_PKEY_CMAC = NID_cmac;
pub const EVP_PKEY_SCRYPT = NID_id_scrypt;
pub const EVP_PKEY_TLS1_PRF = NID_tls1_prf;
pub const EVP_PKEY_HKDF = NID_hkdf;
pub const EVP_PKEY_POLY1305 = NID_poly1305;
pub const EVP_PKEY_SIPHASH = NID_siphash;
pub const EVP_PKEY_X25519 = NID_X25519;
pub const EVP_PKEY_ED25519 = NID_ED25519;
pub const EVP_PKEY_X448 = NID_X448;
pub const EVP_PKEY_ED448 = NID_ED448;
pub const EVP_PKEY_KEYMGMT = -@as(c_int, 1);
pub const EVP_PKEY_KEY_PARAMETERS = OSSL_KEYMGMT_SELECT_ALL_PARAMETERS;
pub const EVP_PKEY_PRIVATE_KEY = EVP_PKEY_KEY_PARAMETERS | OSSL_KEYMGMT_SELECT_PRIVATE_KEY;
pub const EVP_PKEY_PUBLIC_KEY = EVP_PKEY_KEY_PARAMETERS | OSSL_KEYMGMT_SELECT_PUBLIC_KEY;
pub const EVP_PKEY_KEYPAIR = EVP_PKEY_PUBLIC_KEY | OSSL_KEYMGMT_SELECT_PRIVATE_KEY;
pub const EVP_PKEY_MO_SIGN = @as(c_int, 0x0001);
pub const EVP_PKEY_MO_VERIFY = @as(c_int, 0x0002);
pub const EVP_PKEY_MO_ENCRYPT = @as(c_int, 0x0004);
pub const EVP_PKEY_MO_DECRYPT = @as(c_int, 0x0008);
pub const EVP_MD_FLAG_ONESHOT = @as(c_int, 0x0001);
pub const EVP_MD_FLAG_XOF = @as(c_int, 0x0002);
pub const EVP_MD_FLAG_DIGALGID_MASK = @as(c_int, 0x0018);
pub const EVP_MD_FLAG_DIGALGID_NULL = @as(c_int, 0x0000);
pub const EVP_MD_FLAG_DIGALGID_ABSENT = @as(c_int, 0x0008);
pub const EVP_MD_FLAG_DIGALGID_CUSTOM = @as(c_int, 0x0018);
pub const EVP_MD_FLAG_FIPS = @as(c_int, 0x0400);
pub const EVP_MD_CTRL_DIGALGID = @as(c_int, 0x1);
pub const EVP_MD_CTRL_MICALG = @as(c_int, 0x2);
pub const EVP_MD_CTRL_XOF_LEN = @as(c_int, 0x3);
pub const EVP_MD_CTRL_TLSTREE = @as(c_int, 0x4);
pub const EVP_MD_CTRL_ALG_CTRL = @as(c_int, 0x1000);
pub const EVP_MD_CTX_FLAG_ONESHOT = @as(c_int, 0x0001);
pub const EVP_MD_CTX_FLAG_CLEANED = @as(c_int, 0x0002);
pub const EVP_MD_CTX_FLAG_REUSE = @as(c_int, 0x0004);
pub const EVP_MD_CTX_FLAG_NON_FIPS_ALLOW = @as(c_int, 0x0008);
pub const EVP_MD_CTX_FLAG_PAD_MASK = @as(c_int, 0xF0);
pub const EVP_MD_CTX_FLAG_PAD_PKCS1 = @as(c_int, 0x00);
pub const EVP_MD_CTX_FLAG_PAD_X931 = @as(c_int, 0x10);
pub const EVP_MD_CTX_FLAG_PAD_PSS = @as(c_int, 0x20);
pub const EVP_MD_CTX_FLAG_NO_INIT = @as(c_int, 0x0100);
pub const EVP_MD_CTX_FLAG_FINALISE = @as(c_int, 0x0200);
pub const EVP_CIPH_STREAM_CIPHER = @as(c_int, 0x0);
pub const EVP_CIPH_ECB_MODE = @as(c_int, 0x1);
pub const EVP_CIPH_CBC_MODE = @as(c_int, 0x2);
pub const EVP_CIPH_CFB_MODE = @as(c_int, 0x3);
pub const EVP_CIPH_OFB_MODE = @as(c_int, 0x4);
pub const EVP_CIPH_CTR_MODE = @as(c_int, 0x5);
pub const EVP_CIPH_GCM_MODE = @as(c_int, 0x6);
pub const EVP_CIPH_CCM_MODE = @as(c_int, 0x7);
pub const EVP_CIPH_XTS_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10001, .hex);
pub const EVP_CIPH_WRAP_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10002, .hex);
pub const EVP_CIPH_OCB_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10003, .hex);
pub const EVP_CIPH_SIV_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10004, .hex);
pub const EVP_CIPH_GCM_SIV_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10005, .hex);
pub const EVP_CIPH_MODE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xF0007, .hex);
pub const EVP_CIPH_VARIABLE_LENGTH = @as(c_int, 0x8);
pub const EVP_CIPH_CUSTOM_IV = @as(c_int, 0x10);
pub const EVP_CIPH_ALWAYS_CALL_INIT = @as(c_int, 0x20);
pub const EVP_CIPH_CTRL_INIT = @as(c_int, 0x40);
pub const EVP_CIPH_CUSTOM_KEY_LENGTH = @as(c_int, 0x80);
pub const EVP_CIPH_NO_PADDING = @as(c_int, 0x100);
pub const EVP_CIPH_RAND_KEY = @as(c_int, 0x200);
pub const EVP_CIPH_CUSTOM_COPY = @as(c_int, 0x400);
pub const EVP_CIPH_CUSTOM_IV_LENGTH = @as(c_int, 0x800);
pub const EVP_CIPH_FLAG_DEFAULT_ASN1 = @as(c_int, 0);
pub const EVP_CIPH_FLAG_LENGTH_BITS = @as(c_int, 0x2000);
pub const EVP_CIPH_FLAG_FIPS = @as(c_int, 0);
pub const EVP_CIPH_FLAG_NON_FIPS_ALLOW = @as(c_int, 0);
pub const EVP_CIPH_FLAG_CTS = @as(c_int, 0x4000);
pub const EVP_CIPH_FLAG_CUSTOM_CIPHER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100000, .hex);
pub const EVP_CIPH_FLAG_AEAD_CIPHER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x200000, .hex);
pub const EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x400000, .hex);
pub const EVP_CIPH_FLAG_PIPELINE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x800000, .hex);
pub const EVP_CIPH_FLAG_CUSTOM_ASN1 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000000, .hex);
pub const EVP_CIPH_FLAG_CIPHER_WITH_MAC = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x2000000, .hex);
pub const EVP_CIPH_FLAG_GET_WRAP_CIPHER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x4000000, .hex);
pub const EVP_CIPH_FLAG_INVERSE_CIPHER = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000000, .hex);
pub const EVP_CIPHER_CTX_FLAG_WRAP_ALLOW = @as(c_int, 0x1);
pub const EVP_CTRL_INIT = @as(c_int, 0x0);
pub const EVP_CTRL_SET_KEY_LENGTH = @as(c_int, 0x1);
pub const EVP_CTRL_GET_RC2_KEY_BITS = @as(c_int, 0x2);
pub const EVP_CTRL_SET_RC2_KEY_BITS = @as(c_int, 0x3);
pub const EVP_CTRL_GET_RC5_ROUNDS = @as(c_int, 0x4);
pub const EVP_CTRL_SET_RC5_ROUNDS = @as(c_int, 0x5);
pub const EVP_CTRL_RAND_KEY = @as(c_int, 0x6);
pub const EVP_CTRL_PBE_PRF_NID = @as(c_int, 0x7);
pub const EVP_CTRL_COPY = @as(c_int, 0x8);
pub const EVP_CTRL_AEAD_SET_IVLEN = @as(c_int, 0x9);
pub const EVP_CTRL_AEAD_GET_TAG = @as(c_int, 0x10);
pub const EVP_CTRL_AEAD_SET_TAG = @as(c_int, 0x11);
pub const EVP_CTRL_AEAD_SET_IV_FIXED = @as(c_int, 0x12);
pub const EVP_CTRL_GCM_SET_IVLEN = EVP_CTRL_AEAD_SET_IVLEN;
pub const EVP_CTRL_GCM_GET_TAG = EVP_CTRL_AEAD_GET_TAG;
pub const EVP_CTRL_GCM_SET_TAG = EVP_CTRL_AEAD_SET_TAG;
pub const EVP_CTRL_GCM_SET_IV_FIXED = EVP_CTRL_AEAD_SET_IV_FIXED;
pub const EVP_CTRL_GCM_IV_GEN = @as(c_int, 0x13);
pub const EVP_CTRL_CCM_SET_IVLEN = EVP_CTRL_AEAD_SET_IVLEN;
pub const EVP_CTRL_CCM_GET_TAG = EVP_CTRL_AEAD_GET_TAG;
pub const EVP_CTRL_CCM_SET_TAG = EVP_CTRL_AEAD_SET_TAG;
pub const EVP_CTRL_CCM_SET_IV_FIXED = EVP_CTRL_AEAD_SET_IV_FIXED;
pub const EVP_CTRL_CCM_SET_L = @as(c_int, 0x14);
pub const EVP_CTRL_CCM_SET_MSGLEN = @as(c_int, 0x15);
pub const EVP_CTRL_AEAD_TLS1_AAD = @as(c_int, 0x16);
pub const EVP_CTRL_AEAD_SET_MAC_KEY = @as(c_int, 0x17);
pub const EVP_CTRL_GCM_SET_IV_INV = @as(c_int, 0x18);
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_AAD = @as(c_int, 0x19);
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT = @as(c_int, 0x1a);
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_DECRYPT = @as(c_int, 0x1b);
pub const EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE = @as(c_int, 0x1c);
pub const EVP_CTRL_SSL3_MASTER_SECRET = @as(c_int, 0x1d);
pub const EVP_CTRL_SET_SBOX = @as(c_int, 0x1e);
pub const EVP_CTRL_SBOX_USED = @as(c_int, 0x1f);
pub const EVP_CTRL_KEY_MESH = @as(c_int, 0x20);
pub const EVP_CTRL_BLOCK_PADDING_MODE = @as(c_int, 0x21);
pub const EVP_CTRL_SET_PIPELINE_OUTPUT_BUFS = @as(c_int, 0x22);
pub const EVP_CTRL_SET_PIPELINE_INPUT_BUFS = @as(c_int, 0x23);
pub const EVP_CTRL_SET_PIPELINE_INPUT_LENS = @as(c_int, 0x24);
pub const EVP_CTRL_GET_IVLEN = @as(c_int, 0x25);
pub const EVP_CTRL_SET_SPEED = @as(c_int, 0x27);
pub const EVP_CTRL_PROCESS_UNPROTECTED = @as(c_int, 0x28);
pub const EVP_CTRL_GET_WRAP_CIPHER = @as(c_int, 0x29);
pub const EVP_CTRL_TLSTREE = @as(c_int, 0x2A);
pub const EVP_PADDING_PKCS7 = @as(c_int, 1);
pub const EVP_PADDING_ISO7816_4 = @as(c_int, 2);
pub const EVP_PADDING_ANSI923 = @as(c_int, 3);
pub const EVP_PADDING_ISO10126 = @as(c_int, 4);
pub const EVP_PADDING_ZERO = @as(c_int, 5);
pub const EVP_AEAD_TLS1_AAD_LEN = @as(c_int, 13);
pub const EVP_GCM_TLS_FIXED_IV_LEN = @as(c_int, 4);
pub const EVP_GCM_TLS_EXPLICIT_IV_LEN = @as(c_int, 8);
pub const EVP_GCM_TLS_TAG_LEN = @as(c_int, 16);
pub const EVP_CCM_TLS_FIXED_IV_LEN = @as(c_int, 4);
pub const EVP_CCM_TLS_EXPLICIT_IV_LEN = @as(c_int, 8);
pub const EVP_CCM_TLS_IV_LEN = @as(c_int, 12);
pub const EVP_CCM_TLS_TAG_LEN = @as(c_int, 16);
pub const EVP_CCM8_TLS_TAG_LEN = @as(c_int, 8);
pub const EVP_CHACHAPOLY_TLS_TAG_LEN = @as(c_int, 16);
pub inline fn EVP_PKEY_assign_RSA(pkey: anytype, rsa: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_RSA, rsa)) {
    _ = &pkey;
    _ = &rsa;
    return EVP_PKEY_assign(pkey, EVP_PKEY_RSA, rsa);
}
pub inline fn EVP_PKEY_assign_DSA(pkey: anytype, dsa: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_DSA, dsa)) {
    _ = &pkey;
    _ = &dsa;
    return EVP_PKEY_assign(pkey, EVP_PKEY_DSA, dsa);
}
pub inline fn EVP_PKEY_assign_DH(pkey: anytype, dh: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_DH, dh)) {
    _ = &pkey;
    _ = &dh;
    return EVP_PKEY_assign(pkey, EVP_PKEY_DH, dh);
}
pub inline fn EVP_PKEY_assign_EC_KEY(pkey: anytype, eckey: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_EC, eckey)) {
    _ = &pkey;
    _ = &eckey;
    return EVP_PKEY_assign(pkey, EVP_PKEY_EC, eckey);
}
pub inline fn EVP_PKEY_assign_SIPHASH(pkey: anytype, shkey: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_SIPHASH, shkey)) {
    _ = &pkey;
    _ = &shkey;
    return EVP_PKEY_assign(pkey, EVP_PKEY_SIPHASH, shkey);
}
pub inline fn EVP_PKEY_assign_POLY1305(pkey: anytype, polykey: anytype) @TypeOf(EVP_PKEY_assign(pkey, EVP_PKEY_POLY1305, polykey)) {
    _ = &pkey;
    _ = &polykey;
    return EVP_PKEY_assign(pkey, EVP_PKEY_POLY1305, polykey);
}
pub inline fn EVP_get_digestbynid(a: anytype) @TypeOf(EVP_get_digestbyname(OBJ_nid2sn(a))) {
    _ = &a;
    return EVP_get_digestbyname(OBJ_nid2sn(a));
}
pub inline fn EVP_get_digestbyobj(a: anytype) @TypeOf(EVP_get_digestbynid(OBJ_obj2nid(a))) {
    _ = &a;
    return EVP_get_digestbynid(OBJ_obj2nid(a));
}
pub inline fn EVP_get_cipherbynid(a: anytype) @TypeOf(EVP_get_cipherbyname(OBJ_nid2sn(a))) {
    _ = &a;
    return EVP_get_cipherbyname(OBJ_nid2sn(a));
}
pub inline fn EVP_get_cipherbyobj(a: anytype) @TypeOf(EVP_get_cipherbynid(OBJ_obj2nid(a))) {
    _ = &a;
    return EVP_get_cipherbynid(OBJ_obj2nid(a));
}
pub const EVP_MD_type = EVP_MD_get_type;
pub const EVP_MD_nid = EVP_MD_get_type;
pub const EVP_MD_name = EVP_MD_get0_name;
pub const EVP_MD_pkey_type = EVP_MD_get_pkey_type;
pub const EVP_MD_size = EVP_MD_get_size;
pub const EVP_MD_block_size = EVP_MD_get_block_size;
pub const EVP_MD_flags = EVP_MD_get_flags;
pub inline fn EVP_MD_CTX_get0_name(e: anytype) @TypeOf(EVP_MD_get0_name(EVP_MD_CTX_get0_md(e))) {
    _ = &e;
    return EVP_MD_get0_name(EVP_MD_CTX_get0_md(e));
}
pub inline fn EVP_MD_CTX_get_size(e: anytype) @TypeOf(EVP_MD_CTX_get_size_ex(e)) {
    _ = &e;
    return EVP_MD_CTX_get_size_ex(e);
}
pub const EVP_MD_CTX_size = EVP_MD_CTX_get_size_ex;
pub inline fn EVP_MD_CTX_get_block_size(e: anytype) @TypeOf(EVP_MD_get_block_size(EVP_MD_CTX_get0_md(e))) {
    _ = &e;
    return EVP_MD_get_block_size(EVP_MD_CTX_get0_md(e));
}
pub const EVP_MD_CTX_block_size = EVP_MD_CTX_get_block_size;
pub inline fn EVP_MD_CTX_get_type(e: anytype) @TypeOf(EVP_MD_get_type(EVP_MD_CTX_get0_md(e))) {
    _ = &e;
    return EVP_MD_get_type(EVP_MD_CTX_get0_md(e));
}
pub const EVP_MD_CTX_type = EVP_MD_CTX_get_type;
pub const EVP_MD_CTX_pkey_ctx = EVP_MD_CTX_get_pkey_ctx;
pub const EVP_MD_CTX_md_data = EVP_MD_CTX_get0_md_data;
pub const EVP_CIPHER_nid = EVP_CIPHER_get_nid;
pub const EVP_CIPHER_name = EVP_CIPHER_get0_name;
pub const EVP_CIPHER_block_size = EVP_CIPHER_get_block_size;
pub const EVP_CIPHER_key_length = EVP_CIPHER_get_key_length;
pub const EVP_CIPHER_iv_length = EVP_CIPHER_get_iv_length;
pub const EVP_CIPHER_flags = EVP_CIPHER_get_flags;
pub const EVP_CIPHER_mode = EVP_CIPHER_get_mode;
pub const EVP_CIPHER_type = EVP_CIPHER_get_type;
pub const EVP_CIPHER_CTX_encrypting = EVP_CIPHER_CTX_is_encrypting;
pub const EVP_CIPHER_CTX_nid = EVP_CIPHER_CTX_get_nid;
pub const EVP_CIPHER_CTX_block_size = EVP_CIPHER_CTX_get_block_size;
pub const EVP_CIPHER_CTX_key_length = EVP_CIPHER_CTX_get_key_length;
pub const EVP_CIPHER_CTX_iv_length = EVP_CIPHER_CTX_get_iv_length;
pub const EVP_CIPHER_CTX_tag_length = EVP_CIPHER_CTX_get_tag_length;
pub const EVP_CIPHER_CTX_num = EVP_CIPHER_CTX_get_num;
pub inline fn EVP_CIPHER_CTX_get0_name(c: anytype) @TypeOf(EVP_CIPHER_get0_name(EVP_CIPHER_CTX_get0_cipher(c))) {
    _ = &c;
    return EVP_CIPHER_get0_name(EVP_CIPHER_CTX_get0_cipher(c));
}
pub inline fn EVP_CIPHER_CTX_get_type(c: anytype) @TypeOf(EVP_CIPHER_get_type(EVP_CIPHER_CTX_get0_cipher(c))) {
    _ = &c;
    return EVP_CIPHER_get_type(EVP_CIPHER_CTX_get0_cipher(c));
}
pub const EVP_CIPHER_CTX_type = EVP_CIPHER_CTX_get_type;
pub inline fn EVP_CIPHER_CTX_flags(c: anytype) @TypeOf(EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(c))) {
    _ = &c;
    return EVP_CIPHER_get_flags(EVP_CIPHER_CTX_get0_cipher(c));
}
pub inline fn EVP_CIPHER_CTX_get_mode(c: anytype) @TypeOf(EVP_CIPHER_get_mode(EVP_CIPHER_CTX_get0_cipher(c))) {
    _ = &c;
    return EVP_CIPHER_get_mode(EVP_CIPHER_CTX_get0_cipher(c));
}
pub const EVP_CIPHER_CTX_mode = EVP_CIPHER_CTX_get_mode;
pub inline fn EVP_ENCODE_LENGTH(l: anytype) @TypeOf(((@import("std").zig.c_translation.MacroArithmetic.div(l + @as(c_int, 2), @as(c_int, 3)) * @as(c_int, 4)) + ((@import("std").zig.c_translation.MacroArithmetic.div(l, @as(c_int, 48)) + @as(c_int, 1)) * @as(c_int, 2))) + @as(c_int, 80)) {
    _ = &l;
    return ((@import("std").zig.c_translation.MacroArithmetic.div(l + @as(c_int, 2), @as(c_int, 3)) * @as(c_int, 4)) + ((@import("std").zig.c_translation.MacroArithmetic.div(l, @as(c_int, 48)) + @as(c_int, 1)) * @as(c_int, 2))) + @as(c_int, 80);
}
pub inline fn EVP_DECODE_LENGTH(l: anytype) @TypeOf((@import("std").zig.c_translation.MacroArithmetic.div(l + @as(c_int, 3), @as(c_int, 4)) * @as(c_int, 3)) + @as(c_int, 80)) {
    _ = &l;
    return (@import("std").zig.c_translation.MacroArithmetic.div(l + @as(c_int, 3), @as(c_int, 4)) * @as(c_int, 3)) + @as(c_int, 80);
}
pub inline fn EVP_SignInit_ex(a: anytype, b: anytype, c: anytype) @TypeOf(EVP_DigestInit_ex(a, b, c)) {
    _ = &a;
    _ = &b;
    _ = &c;
    return EVP_DigestInit_ex(a, b, c);
}
pub inline fn EVP_SignInit(a: anytype, b: anytype) @TypeOf(EVP_DigestInit(a, b)) {
    _ = &a;
    _ = &b;
    return EVP_DigestInit(a, b);
}
pub inline fn EVP_SignUpdate(a: anytype, b: anytype, c: anytype) @TypeOf(EVP_DigestUpdate(a, b, c)) {
    _ = &a;
    _ = &b;
    _ = &c;
    return EVP_DigestUpdate(a, b, c);
}
pub inline fn EVP_VerifyInit_ex(a: anytype, b: anytype, c: anytype) @TypeOf(EVP_DigestInit_ex(a, b, c)) {
    _ = &a;
    _ = &b;
    _ = &c;
    return EVP_DigestInit_ex(a, b, c);
}
pub inline fn EVP_VerifyInit(a: anytype, b: anytype) @TypeOf(EVP_DigestInit(a, b)) {
    _ = &a;
    _ = &b;
    return EVP_DigestInit(a, b);
}
pub inline fn EVP_VerifyUpdate(a: anytype, b: anytype, c: anytype) @TypeOf(EVP_DigestUpdate(a, b, c)) {
    _ = &a;
    _ = &b;
    _ = &c;
    return EVP_DigestUpdate(a, b, c);
}
pub inline fn EVP_OpenUpdate(a: anytype, b: anytype, c: anytype, d: anytype, e: anytype) @TypeOf(EVP_DecryptUpdate(a, b, c, d, e)) {
    _ = &a;
    _ = &b;
    _ = &c;
    _ = &d;
    _ = &e;
    return EVP_DecryptUpdate(a, b, c, d, e);
}
pub inline fn EVP_SealUpdate(a: anytype, b: anytype, c: anytype, d: anytype, e: anytype) @TypeOf(EVP_EncryptUpdate(a, b, c, d, e)) {
    _ = &a;
    _ = &b;
    _ = &c;
    _ = &d;
    _ = &e;
    return EVP_EncryptUpdate(a, b, c, d, e);
}
pub inline fn BIO_set_md(b: anytype, md: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_MD, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, md))) {
    _ = &b;
    _ = &md;
    return BIO_ctrl(b, BIO_C_SET_MD, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, md));
}
pub inline fn BIO_get_md(b: anytype, mdp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_MD, @as(c_int, 0), mdp)) {
    _ = &b;
    _ = &mdp;
    return BIO_ctrl(b, BIO_C_GET_MD, @as(c_int, 0), mdp);
}
pub inline fn BIO_get_md_ctx(b: anytype, mdcp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_MD_CTX, @as(c_int, 0), mdcp)) {
    _ = &b;
    _ = &mdcp;
    return BIO_ctrl(b, BIO_C_GET_MD_CTX, @as(c_int, 0), mdcp);
}
pub inline fn BIO_set_md_ctx(b: anytype, mdcp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_SET_MD_CTX, @as(c_int, 0), mdcp)) {
    _ = &b;
    _ = &mdcp;
    return BIO_ctrl(b, BIO_C_SET_MD_CTX, @as(c_int, 0), mdcp);
}
pub inline fn BIO_get_cipher_status(b: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_CIPHER_STATUS, @as(c_int, 0), NULL)) {
    _ = &b;
    return BIO_ctrl(b, BIO_C_GET_CIPHER_STATUS, @as(c_int, 0), NULL);
}
pub inline fn BIO_get_cipher_ctx(b: anytype, c_pp: anytype) @TypeOf(BIO_ctrl(b, BIO_C_GET_CIPHER_CTX, @as(c_int, 0), c_pp)) {
    _ = &b;
    _ = &c_pp;
    return BIO_ctrl(b, BIO_C_GET_CIPHER_CTX, @as(c_int, 0), c_pp);
}
pub inline fn EVP_add_cipher_alias(n: anytype, alias: anytype) @TypeOf(OBJ_NAME_add(alias, OBJ_NAME_TYPE_CIPHER_METH | OBJ_NAME_ALIAS, n)) {
    _ = &n;
    _ = &alias;
    return OBJ_NAME_add(alias, OBJ_NAME_TYPE_CIPHER_METH | OBJ_NAME_ALIAS, n);
}
pub inline fn EVP_add_digest_alias(n: anytype, alias: anytype) @TypeOf(OBJ_NAME_add(alias, OBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, n)) {
    _ = &n;
    _ = &alias;
    return OBJ_NAME_add(alias, OBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, n);
}
pub const EVP_delete_cipher_alias = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/openssl/evp.h:691:10
pub const EVP_delete_digest_alias = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/openssl/evp.h:693:10
pub inline fn EVP_MD_CTX_create() @TypeOf(EVP_MD_CTX_new()) {
    return EVP_MD_CTX_new();
}
pub inline fn EVP_MD_CTX_init(ctx: anytype) @TypeOf(EVP_MD_CTX_reset(ctx)) {
    _ = &ctx;
    return EVP_MD_CTX_reset(ctx);
}
pub inline fn EVP_MD_CTX_destroy(ctx: anytype) @TypeOf(EVP_MD_CTX_free(ctx)) {
    _ = &ctx;
    return EVP_MD_CTX_free(ctx);
}
pub inline fn EVP_CIPHER_CTX_init(c: anytype) @TypeOf(EVP_CIPHER_CTX_reset(c)) {
    _ = &c;
    return EVP_CIPHER_CTX_reset(c);
}
pub inline fn EVP_CIPHER_CTX_cleanup(c: anytype) @TypeOf(EVP_CIPHER_CTX_reset(c)) {
    _ = &c;
    return EVP_CIPHER_CTX_reset(c);
}
pub const EVP_des_cfb = EVP_des_cfb64;
pub const EVP_des_ede_cfb = EVP_des_ede_cfb64;
pub const EVP_des_ede3_cfb = EVP_des_ede3_cfb64;
pub const EVP_idea_cfb = EVP_idea_cfb64;
pub const EVP_rc2_cfb = EVP_rc2_cfb64;
pub const EVP_bf_cfb = EVP_bf_cfb64;
pub const EVP_cast5_cfb = EVP_cast5_cfb64;
pub const EVP_aes_128_cfb = EVP_aes_128_cfb128;
pub const EVP_aes_192_cfb = EVP_aes_192_cfb128;
pub const EVP_aes_256_cfb = EVP_aes_256_cfb128;
pub const EVP_aria_128_cfb = EVP_aria_128_cfb128;
pub const EVP_aria_192_cfb = EVP_aria_192_cfb128;
pub const EVP_aria_256_cfb = EVP_aria_256_cfb128;
pub const EVP_camellia_128_cfb = EVP_camellia_128_cfb128;
pub const EVP_camellia_192_cfb = EVP_camellia_192_cfb128;
pub const EVP_camellia_256_cfb = EVP_camellia_256_cfb128;
pub const EVP_seed_cfb = EVP_seed_cfb128;
pub const EVP_sm4_cfb = EVP_sm4_cfb128;
pub inline fn OPENSSL_add_all_algorithms_conf() @TypeOf(OPENSSL_init_crypto((OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS) | OPENSSL_INIT_LOAD_CONFIG, NULL)) {
    return OPENSSL_init_crypto((OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS) | OPENSSL_INIT_LOAD_CONFIG, NULL);
}
pub inline fn OPENSSL_add_all_algorithms_noconf() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);
}
pub inline fn OpenSSL_add_all_algorithms() @TypeOf(OPENSSL_add_all_algorithms_noconf()) {
    return OPENSSL_add_all_algorithms_noconf();
}
pub inline fn OpenSSL_add_all_ciphers() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS, NULL);
}
pub inline fn OpenSSL_add_all_digests() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_DIGESTS, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_DIGESTS, NULL);
}
pub const EVP_cleanup = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/evp.h:1181:11
pub const EVP_RAND_STATE_UNINITIALISED = @as(c_int, 0);
pub const EVP_RAND_STATE_READY = @as(c_int, 1);
pub const EVP_RAND_STATE_ERROR = @as(c_int, 2);
pub const EVP_PKEY_id = EVP_PKEY_get_id;
pub const EVP_PKEY_base_id = EVP_PKEY_get_base_id;
pub const EVP_PKEY_bits = EVP_PKEY_get_bits;
pub const EVP_PKEY_security_bits = EVP_PKEY_get_security_bits;
pub const EVP_PKEY_size = EVP_PKEY_get_size;
pub inline fn EVP_PKEY_set1_tls_encodedpoint(pkey: anytype, pt: anytype, ptlen: anytype) @TypeOf(EVP_PKEY_set1_encoded_public_key(pkey, pt, ptlen)) {
    _ = &pkey;
    _ = &pt;
    _ = &ptlen;
    return EVP_PKEY_set1_encoded_public_key(pkey, pt, ptlen);
}
pub inline fn EVP_PKEY_get1_tls_encodedpoint(pkey: anytype, ppt: anytype) @TypeOf(EVP_PKEY_get1_encoded_public_key(pkey, ppt)) {
    _ = &pkey;
    _ = &ppt;
    return EVP_PKEY_get1_encoded_public_key(pkey, ppt);
}
pub const EVP_PBE_TYPE_OUTER = @as(c_int, 0x0);
pub const EVP_PBE_TYPE_PRF = @as(c_int, 0x1);
pub const EVP_PBE_TYPE_KDF = @as(c_int, 0x2);
pub const ASN1_PKEY_ALIAS = @as(c_int, 0x1);
pub const ASN1_PKEY_DYNAMIC = @as(c_int, 0x2);
pub const ASN1_PKEY_SIGPARAM_NULL = @as(c_int, 0x4);
pub const ASN1_PKEY_CTRL_PKCS7_SIGN = @as(c_int, 0x1);
pub const ASN1_PKEY_CTRL_PKCS7_ENCRYPT = @as(c_int, 0x2);
pub const ASN1_PKEY_CTRL_DEFAULT_MD_NID = @as(c_int, 0x3);
pub const ASN1_PKEY_CTRL_CMS_SIGN = @as(c_int, 0x5);
pub const ASN1_PKEY_CTRL_CMS_ENVELOPE = @as(c_int, 0x7);
pub const ASN1_PKEY_CTRL_CMS_RI_TYPE = @as(c_int, 0x8);
pub const ASN1_PKEY_CTRL_SET1_TLS_ENCPT = @as(c_int, 0x9);
pub const ASN1_PKEY_CTRL_GET1_TLS_ENCPT = @as(c_int, 0xa);
pub const ASN1_PKEY_CTRL_CMS_IS_RI_TYPE_SUPPORTED = @as(c_int, 0xb);
pub const EVP_PKEY_OP_UNDEFINED = @as(c_int, 0);
pub const EVP_PKEY_OP_PARAMGEN = @as(c_int, 1) << @as(c_int, 1);
pub const EVP_PKEY_OP_KEYGEN = @as(c_int, 1) << @as(c_int, 2);
pub const EVP_PKEY_OP_FROMDATA = @as(c_int, 1) << @as(c_int, 3);
pub const EVP_PKEY_OP_SIGN = @as(c_int, 1) << @as(c_int, 4);
pub const EVP_PKEY_OP_VERIFY = @as(c_int, 1) << @as(c_int, 5);
pub const EVP_PKEY_OP_VERIFYRECOVER = @as(c_int, 1) << @as(c_int, 6);
pub const EVP_PKEY_OP_SIGNCTX = @as(c_int, 1) << @as(c_int, 7);
pub const EVP_PKEY_OP_VERIFYCTX = @as(c_int, 1) << @as(c_int, 8);
pub const EVP_PKEY_OP_ENCRYPT = @as(c_int, 1) << @as(c_int, 9);
pub const EVP_PKEY_OP_DECRYPT = @as(c_int, 1) << @as(c_int, 10);
pub const EVP_PKEY_OP_DERIVE = @as(c_int, 1) << @as(c_int, 11);
pub const EVP_PKEY_OP_ENCAPSULATE = @as(c_int, 1) << @as(c_int, 12);
pub const EVP_PKEY_OP_DECAPSULATE = @as(c_int, 1) << @as(c_int, 13);
pub const EVP_PKEY_OP_SIGNMSG = @as(c_int, 1) << @as(c_int, 14);
pub const EVP_PKEY_OP_VERIFYMSG = @as(c_int, 1) << @as(c_int, 15);
pub const EVP_PKEY_OP_ALL = (@as(c_int, 1) << @as(c_int, 16)) - @as(c_int, 1);
pub const EVP_PKEY_OP_TYPE_SIG = (((((EVP_PKEY_OP_SIGN | EVP_PKEY_OP_SIGNMSG) | EVP_PKEY_OP_VERIFY) | EVP_PKEY_OP_VERIFYMSG) | EVP_PKEY_OP_VERIFYRECOVER) | EVP_PKEY_OP_SIGNCTX) | EVP_PKEY_OP_VERIFYCTX;
pub const EVP_PKEY_OP_TYPE_CRYPT = EVP_PKEY_OP_ENCRYPT | EVP_PKEY_OP_DECRYPT;
pub const EVP_PKEY_OP_TYPE_DERIVE = EVP_PKEY_OP_DERIVE;
pub const EVP_PKEY_OP_TYPE_DATA = EVP_PKEY_OP_FROMDATA;
pub const EVP_PKEY_OP_TYPE_KEM = EVP_PKEY_OP_ENCAPSULATE | EVP_PKEY_OP_DECAPSULATE;
pub const EVP_PKEY_OP_TYPE_GEN = EVP_PKEY_OP_PARAMGEN | EVP_PKEY_OP_KEYGEN;
pub const EVP_PKEY_OP_TYPE_NOGEN = EVP_PKEY_OP_ALL & ~EVP_PKEY_OP_TYPE_GEN;
pub const EVP_PKEY_CTRL_MD = @as(c_int, 1);
pub const EVP_PKEY_CTRL_PEER_KEY = @as(c_int, 2);
pub const EVP_PKEY_CTRL_SET_MAC_KEY = @as(c_int, 6);
pub const EVP_PKEY_CTRL_DIGESTINIT = @as(c_int, 7);
pub const EVP_PKEY_CTRL_SET_IV = @as(c_int, 8);
pub const EVP_PKEY_CTRL_PKCS7_ENCRYPT = @as(c_int, 3);
pub const EVP_PKEY_CTRL_PKCS7_DECRYPT = @as(c_int, 4);
pub const EVP_PKEY_CTRL_PKCS7_SIGN = @as(c_int, 5);
pub const EVP_PKEY_CTRL_CMS_ENCRYPT = @as(c_int, 9);
pub const EVP_PKEY_CTRL_CMS_DECRYPT = @as(c_int, 10);
pub const EVP_PKEY_CTRL_CMS_SIGN = @as(c_int, 11);
pub const EVP_PKEY_CTRL_CIPHER = @as(c_int, 12);
pub const EVP_PKEY_CTRL_GET_MD = @as(c_int, 13);
pub const EVP_PKEY_CTRL_SET_DIGEST_SIZE = @as(c_int, 14);
pub const EVP_PKEY_CTRL_SET1_ID = @as(c_int, 15);
pub const EVP_PKEY_CTRL_GET1_ID = @as(c_int, 16);
pub const EVP_PKEY_CTRL_GET1_ID_LEN = @as(c_int, 17);
pub const EVP_PKEY_ALG_CTRL = @as(c_int, 0x1000);
pub const EVP_PKEY_FLAG_AUTOARGLEN = @as(c_int, 2);
pub const EVP_PKEY_FLAG_SIGCTX_CUSTOM = @as(c_int, 4);
pub inline fn EVP_PKEY_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_EVP_PKEY, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_EVP_PKEY, l, p, newf, dupf, freef);
}
pub const OPENSSL_EC_H = "";
pub const HEADER_EC_H = "";
pub const OPENSSL_EC_EXPLICIT_CURVE = @as(c_int, 0x000);
pub const OPENSSL_EC_NAMED_CURVE = @as(c_int, 0x001);
pub const EVP_PKEY_CTRL_EC_PARAMGEN_CURVE_NID = EVP_PKEY_ALG_CTRL + @as(c_int, 1);
pub const EVP_PKEY_CTRL_EC_PARAM_ENC = EVP_PKEY_ALG_CTRL + @as(c_int, 2);
pub const EVP_PKEY_CTRL_EC_ECDH_COFACTOR = EVP_PKEY_ALG_CTRL + @as(c_int, 3);
pub const EVP_PKEY_CTRL_EC_KDF_TYPE = EVP_PKEY_ALG_CTRL + @as(c_int, 4);
pub const EVP_PKEY_CTRL_EC_KDF_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 5);
pub const EVP_PKEY_CTRL_GET_EC_KDF_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 6);
pub const EVP_PKEY_CTRL_EC_KDF_OUTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 7);
pub const EVP_PKEY_CTRL_GET_EC_KDF_OUTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 8);
pub const EVP_PKEY_CTRL_EC_KDF_UKM = EVP_PKEY_ALG_CTRL + @as(c_int, 9);
pub const EVP_PKEY_CTRL_GET_EC_KDF_UKM = EVP_PKEY_ALG_CTRL + @as(c_int, 10);
pub const EVP_PKEY_ECDH_KDF_NONE = @as(c_int, 1);
pub const EVP_PKEY_ECDH_KDF_X9_63 = @as(c_int, 2);
pub const EVP_PKEY_ECDH_KDF_X9_62 = EVP_PKEY_ECDH_KDF_X9_63;
pub const OPENSSL_ECERR_H = "";
pub const EC_R_ASN1_ERROR = @as(c_int, 115);
pub const EC_R_BAD_SIGNATURE = @as(c_int, 156);
pub const EC_R_BIGNUM_OUT_OF_RANGE = @as(c_int, 144);
pub const EC_R_BUFFER_TOO_SMALL = @as(c_int, 100);
pub const EC_R_CANNOT_INVERT = @as(c_int, 165);
pub const EC_R_COORDINATES_OUT_OF_RANGE = @as(c_int, 146);
pub const EC_R_CURVE_DOES_NOT_SUPPORT_ECDH = @as(c_int, 160);
pub const EC_R_CURVE_DOES_NOT_SUPPORT_ECDSA = @as(c_int, 170);
pub const EC_R_CURVE_DOES_NOT_SUPPORT_SIGNING = @as(c_int, 159);
pub const EC_R_DECODE_ERROR = @as(c_int, 142);
pub const EC_R_DISCRIMINANT_IS_ZERO = @as(c_int, 118);
pub const EC_R_EC_GROUP_NEW_BY_NAME_FAILURE = @as(c_int, 119);
pub const EC_R_EXPLICIT_PARAMS_NOT_SUPPORTED = @as(c_int, 127);
pub const EC_R_FAILED_MAKING_PUBLIC_KEY = @as(c_int, 166);
pub const EC_R_FIELD_TOO_LARGE = @as(c_int, 143);
pub const EC_R_GF2M_NOT_SUPPORTED = @as(c_int, 147);
pub const EC_R_GROUP2PKPARAMETERS_FAILURE = @as(c_int, 120);
pub const EC_R_I2D_ECPKPARAMETERS_FAILURE = @as(c_int, 121);
pub const EC_R_INCOMPATIBLE_OBJECTS = @as(c_int, 101);
pub const EC_R_INVALID_A = @as(c_int, 168);
pub const EC_R_INVALID_ARGUMENT = @as(c_int, 112);
pub const EC_R_INVALID_B = @as(c_int, 169);
pub const EC_R_INVALID_COFACTOR = @as(c_int, 171);
pub const EC_R_INVALID_COMPRESSED_POINT = @as(c_int, 110);
pub const EC_R_INVALID_COMPRESSION_BIT = @as(c_int, 109);
pub const EC_R_INVALID_CURVE = @as(c_int, 141);
pub const EC_R_INVALID_DIGEST = @as(c_int, 151);
pub const EC_R_INVALID_DIGEST_TYPE = @as(c_int, 138);
pub const EC_R_INVALID_ENCODING = @as(c_int, 102);
pub const EC_R_INVALID_FIELD = @as(c_int, 103);
pub const EC_R_INVALID_FORM = @as(c_int, 104);
pub const EC_R_INVALID_GENERATOR = @as(c_int, 173);
pub const EC_R_INVALID_GROUP_ORDER = @as(c_int, 122);
pub const EC_R_INVALID_KEY = @as(c_int, 116);
pub const EC_R_INVALID_LENGTH = @as(c_int, 117);
pub const EC_R_INVALID_NAMED_GROUP_CONVERSION = @as(c_int, 174);
pub const EC_R_INVALID_OUTPUT_LENGTH = @as(c_int, 161);
pub const EC_R_INVALID_P = @as(c_int, 172);
pub const EC_R_INVALID_PEER_KEY = @as(c_int, 133);
pub const EC_R_INVALID_PENTANOMIAL_BASIS = @as(c_int, 132);
pub const EC_R_INVALID_PRIVATE_KEY = @as(c_int, 123);
pub const EC_R_INVALID_SEED = @as(c_int, 175);
pub const EC_R_INVALID_TRINOMIAL_BASIS = @as(c_int, 137);
pub const EC_R_KDF_PARAMETER_ERROR = @as(c_int, 148);
pub const EC_R_KEYS_NOT_SET = @as(c_int, 140);
pub const EC_R_LADDER_POST_FAILURE = @as(c_int, 136);
pub const EC_R_LADDER_PRE_FAILURE = @as(c_int, 153);
pub const EC_R_LADDER_STEP_FAILURE = @as(c_int, 162);
pub const EC_R_MISSING_OID = @as(c_int, 167);
pub const EC_R_MISSING_PARAMETERS = @as(c_int, 124);
pub const EC_R_MISSING_PRIVATE_KEY = @as(c_int, 125);
pub const EC_R_NEED_NEW_SETUP_VALUES = @as(c_int, 157);
pub const EC_R_NOT_A_NIST_PRIME = @as(c_int, 135);
pub const EC_R_NOT_IMPLEMENTED = @as(c_int, 126);
pub const EC_R_NOT_INITIALIZED = @as(c_int, 111);
pub const EC_R_NO_PARAMETERS_SET = @as(c_int, 139);
pub const EC_R_NO_PRIVATE_VALUE = @as(c_int, 154);
pub const EC_R_OPERATION_NOT_SUPPORTED = @as(c_int, 152);
pub const EC_R_PASSED_NULL_PARAMETER = @as(c_int, 134);
pub const EC_R_PEER_KEY_ERROR = @as(c_int, 149);
pub const EC_R_POINT_ARITHMETIC_FAILURE = @as(c_int, 155);
pub const EC_R_POINT_AT_INFINITY = @as(c_int, 106);
pub const EC_R_POINT_COORDINATES_BLIND_FAILURE = @as(c_int, 163);
pub const EC_R_POINT_IS_NOT_ON_CURVE = @as(c_int, 107);
pub const EC_R_RANDOM_NUMBER_GENERATION_FAILED = @as(c_int, 158);
pub const EC_R_SHARED_INFO_ERROR = @as(c_int, 150);
pub const EC_R_SLOT_FULL = @as(c_int, 108);
pub const EC_R_TOO_MANY_RETRIES = @as(c_int, 176);
pub const EC_R_UNDEFINED_GENERATOR = @as(c_int, 113);
pub const EC_R_UNDEFINED_ORDER = @as(c_int, 128);
pub const EC_R_UNKNOWN_COFACTOR = @as(c_int, 164);
pub const EC_R_UNKNOWN_GROUP = @as(c_int, 129);
pub const EC_R_UNKNOWN_ORDER = @as(c_int, 114);
pub const EC_R_UNSUPPORTED_FIELD = @as(c_int, 131);
pub const EC_R_WRONG_CURVE_PARAMETERS = @as(c_int, 145);
pub const EC_R_WRONG_ORDER = @as(c_int, 130);
pub const OPENSSL_ECC_MAX_FIELD_BITS = @as(c_int, 661);
pub inline fn d2i_ECPKParameters_bio(bp: anytype, x: anytype) @TypeOf(ASN1_d2i_bio_of(EC_GROUP, NULL, d2i_ECPKParameters, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_d2i_bio_of(EC_GROUP, NULL, d2i_ECPKParameters, bp, x);
}
pub inline fn i2d_ECPKParameters_bio(bp: anytype, x: anytype) @TypeOf(ASN1_i2d_bio_of(EC_GROUP, i2d_ECPKParameters, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_i2d_bio_of(EC_GROUP, i2d_ECPKParameters, bp, x);
}
pub const d2i_ECPKParameters_fp = @compileError("unable to translate C expr: expected ')' instead got '*'");
// /usr/include/openssl/ec.h:938:11
pub inline fn i2d_ECPKParameters_fp(fp: anytype, x: anytype) @TypeOf(ASN1_i2d_fp(@import("std").zig.c_translation.cast([*c]i2d_of_void, i2d_ECPKParameters), fp, @import("std").zig.c_translation.cast(?*anyopaque, x))) {
    _ = &fp;
    _ = &x;
    return ASN1_i2d_fp(@import("std").zig.c_translation.cast([*c]i2d_of_void, i2d_ECPKParameters), fp, @import("std").zig.c_translation.cast(?*anyopaque, x));
}
pub const EC_PKEY_NO_PARAMETERS = @as(c_int, 0x001);
pub const EC_PKEY_NO_PUBKEY = @as(c_int, 0x002);
pub const EC_FLAG_SM2_RANGE = @as(c_int, 0x0004);
pub const EC_FLAG_COFACTOR_ECDH = @as(c_int, 0x1000);
pub const EC_FLAG_CHECK_NAMED_GROUP = @as(c_int, 0x2000);
pub const EC_FLAG_CHECK_NAMED_GROUP_NIST = @as(c_int, 0x4000);
pub const EC_FLAG_CHECK_NAMED_GROUP_MASK = EC_FLAG_CHECK_NAMED_GROUP | EC_FLAG_CHECK_NAMED_GROUP_NIST;
pub const EC_FLAG_NON_FIPS_ALLOW = @as(c_int, 0x0000);
pub const EC_FLAG_FIPS_CHECKED = @as(c_int, 0x0000);
pub inline fn EC_KEY_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_EC_KEY, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_EC_KEY, l, p, newf, dupf, freef);
}
pub inline fn EVP_EC_gen(curve: anytype) @TypeOf(EVP_PKEY_Q_keygen(NULL, NULL, "EC", @import("std").zig.c_translation.cast([*c]u8, strstr(curve, "")))) {
    _ = &curve;
    return EVP_PKEY_Q_keygen(NULL, NULL, "EC", @import("std").zig.c_translation.cast([*c]u8, strstr(curve, "")));
}
pub inline fn ECParameters_dup(x: anytype) @TypeOf(ASN1_dup_of(EC_KEY, i2d_ECParameters, d2i_ECParameters, x)) {
    _ = &x;
    return ASN1_dup_of(EC_KEY, i2d_ECParameters, d2i_ECParameters, x);
}
pub const OPENSSL_RSA_H = "";
pub const HEADER_RSA_H = "";
pub const OPENSSL_RSAERR_H = "";
pub const RSA_R_ALGORITHM_MISMATCH = @as(c_int, 100);
pub const RSA_R_BAD_E_VALUE = @as(c_int, 101);
pub const RSA_R_BAD_FIXED_HEADER_DECRYPT = @as(c_int, 102);
pub const RSA_R_BAD_PAD_BYTE_COUNT = @as(c_int, 103);
pub const RSA_R_BAD_SIGNATURE = @as(c_int, 104);
pub const RSA_R_BLOCK_TYPE_IS_NOT_01 = @as(c_int, 106);
pub const RSA_R_BLOCK_TYPE_IS_NOT_02 = @as(c_int, 107);
pub const RSA_R_DATA_GREATER_THAN_MOD_LEN = @as(c_int, 108);
pub const RSA_R_DATA_TOO_LARGE = @as(c_int, 109);
pub const RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE = @as(c_int, 110);
pub const RSA_R_DATA_TOO_LARGE_FOR_MODULUS = @as(c_int, 132);
pub const RSA_R_DATA_TOO_SMALL = @as(c_int, 111);
pub const RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE = @as(c_int, 122);
pub const RSA_R_DIGEST_DOES_NOT_MATCH = @as(c_int, 158);
pub const RSA_R_DIGEST_NOT_ALLOWED = @as(c_int, 145);
pub const RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY = @as(c_int, 112);
pub const RSA_R_DMP1_NOT_CONGRUENT_TO_D = @as(c_int, 124);
pub const RSA_R_DMQ1_NOT_CONGRUENT_TO_D = @as(c_int, 125);
pub const RSA_R_D_E_NOT_CONGRUENT_TO_1 = @as(c_int, 123);
pub const RSA_R_FIRST_OCTET_INVALID = @as(c_int, 133);
pub const RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE = @as(c_int, 144);
pub const RSA_R_INVALID_DIGEST = @as(c_int, 157);
pub const RSA_R_INVALID_DIGEST_LENGTH = @as(c_int, 143);
pub const RSA_R_INVALID_HEADER = @as(c_int, 137);
pub const RSA_R_INVALID_KEYPAIR = @as(c_int, 171);
pub const RSA_R_INVALID_KEY_LENGTH = @as(c_int, 173);
pub const RSA_R_INVALID_LABEL = @as(c_int, 160);
pub const RSA_R_INVALID_LENGTH = @as(c_int, 181);
pub const RSA_R_INVALID_MESSAGE_LENGTH = @as(c_int, 131);
pub const RSA_R_INVALID_MGF1_MD = @as(c_int, 156);
pub const RSA_R_INVALID_MODULUS = @as(c_int, 174);
pub const RSA_R_INVALID_MULTI_PRIME_KEY = @as(c_int, 167);
pub const RSA_R_INVALID_OAEP_PARAMETERS = @as(c_int, 161);
pub const RSA_R_INVALID_PADDING = @as(c_int, 138);
pub const RSA_R_INVALID_PADDING_MODE = @as(c_int, 141);
pub const RSA_R_INVALID_PSS_PARAMETERS = @as(c_int, 149);
pub const RSA_R_INVALID_PSS_SALTLEN = @as(c_int, 146);
pub const RSA_R_INVALID_REQUEST = @as(c_int, 175);
pub const RSA_R_INVALID_SALT_LENGTH = @as(c_int, 150);
pub const RSA_R_INVALID_STRENGTH = @as(c_int, 176);
pub const RSA_R_INVALID_TRAILER = @as(c_int, 139);
pub const RSA_R_INVALID_X931_DIGEST = @as(c_int, 142);
pub const RSA_R_IQMP_NOT_INVERSE_OF_Q = @as(c_int, 126);
pub const RSA_R_KEY_PRIME_NUM_INVALID = @as(c_int, 165);
pub const RSA_R_KEY_SIZE_TOO_SMALL = @as(c_int, 120);
pub const RSA_R_LAST_OCTET_INVALID = @as(c_int, 134);
pub const RSA_R_MGF1_DIGEST_NOT_ALLOWED = @as(c_int, 152);
pub const RSA_R_MISSING_PRIVATE_KEY = @as(c_int, 179);
pub const RSA_R_MODULUS_TOO_LARGE = @as(c_int, 105);
pub const RSA_R_MP_COEFFICIENT_NOT_INVERSE_OF_R = @as(c_int, 168);
pub const RSA_R_MP_EXPONENT_NOT_CONGRUENT_TO_D = @as(c_int, 169);
pub const RSA_R_MP_R_NOT_PRIME = @as(c_int, 170);
pub const RSA_R_NO_PUBLIC_EXPONENT = @as(c_int, 140);
pub const RSA_R_NULL_BEFORE_BLOCK_MISSING = @as(c_int, 113);
pub const RSA_R_N_DOES_NOT_EQUAL_PRODUCT_OF_PRIMES = @as(c_int, 172);
pub const RSA_R_N_DOES_NOT_EQUAL_P_Q = @as(c_int, 127);
pub const RSA_R_OAEP_DECODING_ERROR = @as(c_int, 121);
pub const RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE = @as(c_int, 148);
pub const RSA_R_PADDING_CHECK_FAILED = @as(c_int, 114);
pub const RSA_R_PAIRWISE_TEST_FAILURE = @as(c_int, 177);
pub const RSA_R_PKCS_DECODING_ERROR = @as(c_int, 159);
pub const RSA_R_PSS_SALTLEN_TOO_SMALL = @as(c_int, 164);
pub const RSA_R_PUB_EXPONENT_OUT_OF_RANGE = @as(c_int, 178);
pub const RSA_R_P_NOT_PRIME = @as(c_int, 128);
pub const RSA_R_Q_NOT_PRIME = @as(c_int, 129);
pub const RSA_R_RANDOMNESS_SOURCE_STRENGTH_INSUFFICIENT = @as(c_int, 180);
pub const RSA_R_RSA_OPERATIONS_NOT_SUPPORTED = @as(c_int, 130);
pub const RSA_R_SLEN_CHECK_FAILED = @as(c_int, 136);
pub const RSA_R_SLEN_RECOVERY_FAILED = @as(c_int, 135);
pub const RSA_R_SSLV3_ROLLBACK_ATTACK = @as(c_int, 115);
pub const RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD = @as(c_int, 116);
pub const RSA_R_UNKNOWN_ALGORITHM_TYPE = @as(c_int, 117);
pub const RSA_R_UNKNOWN_DIGEST = @as(c_int, 166);
pub const RSA_R_UNKNOWN_MASK_DIGEST = @as(c_int, 151);
pub const RSA_R_UNKNOWN_PADDING_TYPE = @as(c_int, 118);
pub const RSA_R_UNSUPPORTED_ENCRYPTION_TYPE = @as(c_int, 162);
pub const RSA_R_UNSUPPORTED_LABEL_SOURCE = @as(c_int, 163);
pub const RSA_R_UNSUPPORTED_MASK_ALGORITHM = @as(c_int, 153);
pub const RSA_R_UNSUPPORTED_MASK_PARAMETER = @as(c_int, 154);
pub const RSA_R_UNSUPPORTED_SIGNATURE_TYPE = @as(c_int, 155);
pub const RSA_R_VALUE_MISSING = @as(c_int, 147);
pub const RSA_R_WRONG_SIGNATURE_LENGTH = @as(c_int, 119);
pub const OPENSSL_RSA_MAX_MODULUS_BITS = @as(c_int, 16384);
pub const RSA_3 = @as(c_long, 0x3);
pub const RSA_F4 = @as(c_long, 0x10001);
pub const OPENSSL_RSA_FIPS_MIN_MODULUS_BITS = @as(c_int, 2048);
pub const OPENSSL_RSA_SMALL_MODULUS_BITS = @as(c_int, 3072);
pub const OPENSSL_RSA_MAX_PUBEXP_BITS = @as(c_int, 64);
pub const RSA_ASN1_VERSION_DEFAULT = @as(c_int, 0);
pub const RSA_ASN1_VERSION_MULTI = @as(c_int, 1);
pub const RSA_DEFAULT_PRIME_NUM = @as(c_int, 2);
pub const RSA_METHOD_FLAG_NO_CHECK = @as(c_int, 0x0001);
pub const RSA_FLAG_CACHE_PUBLIC = @as(c_int, 0x0002);
pub const RSA_FLAG_CACHE_PRIVATE = @as(c_int, 0x0004);
pub const RSA_FLAG_BLINDING = @as(c_int, 0x0008);
pub const RSA_FLAG_THREAD_SAFE = @as(c_int, 0x0010);
pub const RSA_FLAG_EXT_PKEY = @as(c_int, 0x0020);
pub const RSA_FLAG_NO_BLINDING = @as(c_int, 0x0080);
pub const RSA_FLAG_NO_CONSTTIME = @as(c_int, 0x0000);
pub const RSA_FLAG_NO_EXP_CONSTTIME = RSA_FLAG_NO_CONSTTIME;
pub const RSA_FLAG_TYPE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xF000, .hex);
pub const RSA_FLAG_TYPE_RSA = @as(c_int, 0x0000);
pub const RSA_FLAG_TYPE_RSASSAPSS = @as(c_int, 0x1000);
pub const RSA_FLAG_TYPE_RSAESOAEP = @as(c_int, 0x2000);
pub const RSA_PSS_SALTLEN_DIGEST = -@as(c_int, 1);
pub const RSA_PSS_SALTLEN_AUTO = -@as(c_int, 2);
pub const RSA_PSS_SALTLEN_MAX = -@as(c_int, 3);
pub const RSA_PSS_SALTLEN_AUTO_DIGEST_MAX = -@as(c_int, 4);
pub const RSA_PSS_SALTLEN_MAX_SIGN = -@as(c_int, 2);
pub const EVP_PKEY_CTRL_RSA_PADDING = EVP_PKEY_ALG_CTRL + @as(c_int, 1);
pub const EVP_PKEY_CTRL_RSA_PSS_SALTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 2);
pub const EVP_PKEY_CTRL_RSA_KEYGEN_BITS = EVP_PKEY_ALG_CTRL + @as(c_int, 3);
pub const EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP = EVP_PKEY_ALG_CTRL + @as(c_int, 4);
pub const EVP_PKEY_CTRL_RSA_MGF1_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 5);
pub const EVP_PKEY_CTRL_GET_RSA_PADDING = EVP_PKEY_ALG_CTRL + @as(c_int, 6);
pub const EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 7);
pub const EVP_PKEY_CTRL_GET_RSA_MGF1_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 8);
pub const EVP_PKEY_CTRL_RSA_OAEP_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 9);
pub const EVP_PKEY_CTRL_RSA_OAEP_LABEL = EVP_PKEY_ALG_CTRL + @as(c_int, 10);
pub const EVP_PKEY_CTRL_GET_RSA_OAEP_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 11);
pub const EVP_PKEY_CTRL_GET_RSA_OAEP_LABEL = EVP_PKEY_ALG_CTRL + @as(c_int, 12);
pub const EVP_PKEY_CTRL_RSA_KEYGEN_PRIMES = EVP_PKEY_ALG_CTRL + @as(c_int, 13);
pub const EVP_PKEY_CTRL_RSA_IMPLICIT_REJECTION = EVP_PKEY_ALG_CTRL + @as(c_int, 14);
pub const RSA_PKCS1_PADDING = @as(c_int, 1);
pub const RSA_NO_PADDING = @as(c_int, 3);
pub const RSA_PKCS1_OAEP_PADDING = @as(c_int, 4);
pub const RSA_X931_PADDING = @as(c_int, 5);
pub const RSA_PKCS1_PSS_PADDING = @as(c_int, 6);
pub const RSA_PKCS1_WITH_TLS_PADDING = @as(c_int, 7);
pub const RSA_PKCS1_NO_IMPLICIT_REJECT_PADDING = @as(c_int, 8);
pub const RSA_PKCS1_PADDING_SIZE = @as(c_int, 11);
pub inline fn RSA_set_app_data(s: anytype, arg: anytype) @TypeOf(RSA_set_ex_data(s, @as(c_int, 0), arg)) {
    _ = &s;
    _ = &arg;
    return RSA_set_ex_data(s, @as(c_int, 0), arg);
}
pub inline fn RSA_get_app_data(s: anytype) @TypeOf(RSA_get_ex_data(s, @as(c_int, 0))) {
    _ = &s;
    return RSA_get_ex_data(s, @as(c_int, 0));
}
pub inline fn EVP_RSA_gen(bits: anytype) @TypeOf(EVP_PKEY_Q_keygen(NULL, NULL, "RSA", @import("std").zig.c_translation.cast(usize, @as(c_int, 0) + bits))) {
    _ = &bits;
    return EVP_PKEY_Q_keygen(NULL, NULL, "RSA", @import("std").zig.c_translation.cast(usize, @as(c_int, 0) + bits));
}
pub inline fn RSA_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_RSA, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_RSA, l, p, newf, dupf, freef);
}
pub const RSA_FLAG_FIPS_METHOD = @as(c_int, 0x0400);
pub const RSA_FLAG_NON_FIPS_ALLOW = @as(c_int, 0x0400);
pub const RSA_FLAG_CHECKED = @as(c_int, 0x0800);
pub const OPENSSL_DSA_H = "";
pub const HEADER_DSA_H = "";
pub const OPENSSL_DH_H = "";
pub const HEADER_DH_H = "";
pub const DH_PARAMGEN_TYPE_GENERATOR = @as(c_int, 0);
pub const DH_PARAMGEN_TYPE_FIPS_186_2 = @as(c_int, 1);
pub const DH_PARAMGEN_TYPE_FIPS_186_4 = @as(c_int, 2);
pub const DH_PARAMGEN_TYPE_GROUP = @as(c_int, 3);
pub const EVP_PKEY_CTRL_DH_PARAMGEN_PRIME_LEN = EVP_PKEY_ALG_CTRL + @as(c_int, 1);
pub const EVP_PKEY_CTRL_DH_PARAMGEN_GENERATOR = EVP_PKEY_ALG_CTRL + @as(c_int, 2);
pub const EVP_PKEY_CTRL_DH_RFC5114 = EVP_PKEY_ALG_CTRL + @as(c_int, 3);
pub const EVP_PKEY_CTRL_DH_PARAMGEN_SUBPRIME_LEN = EVP_PKEY_ALG_CTRL + @as(c_int, 4);
pub const EVP_PKEY_CTRL_DH_PARAMGEN_TYPE = EVP_PKEY_ALG_CTRL + @as(c_int, 5);
pub const EVP_PKEY_CTRL_DH_KDF_TYPE = EVP_PKEY_ALG_CTRL + @as(c_int, 6);
pub const EVP_PKEY_CTRL_DH_KDF_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 7);
pub const EVP_PKEY_CTRL_GET_DH_KDF_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 8);
pub const EVP_PKEY_CTRL_DH_KDF_OUTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 9);
pub const EVP_PKEY_CTRL_GET_DH_KDF_OUTLEN = EVP_PKEY_ALG_CTRL + @as(c_int, 10);
pub const EVP_PKEY_CTRL_DH_KDF_UKM = EVP_PKEY_ALG_CTRL + @as(c_int, 11);
pub const EVP_PKEY_CTRL_GET_DH_KDF_UKM = EVP_PKEY_ALG_CTRL + @as(c_int, 12);
pub const EVP_PKEY_CTRL_DH_KDF_OID = EVP_PKEY_ALG_CTRL + @as(c_int, 13);
pub const EVP_PKEY_CTRL_GET_DH_KDF_OID = EVP_PKEY_ALG_CTRL + @as(c_int, 14);
pub const EVP_PKEY_CTRL_DH_NID = EVP_PKEY_ALG_CTRL + @as(c_int, 15);
pub const EVP_PKEY_CTRL_DH_PAD = EVP_PKEY_ALG_CTRL + @as(c_int, 16);
pub const EVP_PKEY_DH_KDF_NONE = @as(c_int, 1);
pub const EVP_PKEY_DH_KDF_X9_42 = @as(c_int, 2);
pub const OPENSSL_DHERR_H = "";
pub const DH_R_BAD_FFC_PARAMETERS = @as(c_int, 127);
pub const DH_R_BAD_GENERATOR = @as(c_int, 101);
pub const DH_R_BN_DECODE_ERROR = @as(c_int, 109);
pub const DH_R_BN_ERROR = @as(c_int, 106);
pub const DH_R_CHECK_INVALID_J_VALUE = @as(c_int, 115);
pub const DH_R_CHECK_INVALID_Q_VALUE = @as(c_int, 116);
pub const DH_R_CHECK_PUBKEY_INVALID = @as(c_int, 122);
pub const DH_R_CHECK_PUBKEY_TOO_LARGE = @as(c_int, 123);
pub const DH_R_CHECK_PUBKEY_TOO_SMALL = @as(c_int, 124);
pub const DH_R_CHECK_P_NOT_PRIME = @as(c_int, 117);
pub const DH_R_CHECK_P_NOT_SAFE_PRIME = @as(c_int, 118);
pub const DH_R_CHECK_Q_NOT_PRIME = @as(c_int, 119);
pub const DH_R_DECODE_ERROR = @as(c_int, 104);
pub const DH_R_INVALID_PARAMETER_NAME = @as(c_int, 110);
pub const DH_R_INVALID_PARAMETER_NID = @as(c_int, 114);
pub const DH_R_INVALID_PUBKEY = @as(c_int, 102);
pub const DH_R_INVALID_SECRET = @as(c_int, 128);
pub const DH_R_INVALID_SIZE = @as(c_int, 129);
pub const DH_R_KDF_PARAMETER_ERROR = @as(c_int, 112);
pub const DH_R_KEYS_NOT_SET = @as(c_int, 108);
pub const DH_R_MISSING_PUBKEY = @as(c_int, 125);
pub const DH_R_MODULUS_TOO_LARGE = @as(c_int, 103);
pub const DH_R_MODULUS_TOO_SMALL = @as(c_int, 126);
pub const DH_R_NOT_SUITABLE_GENERATOR = @as(c_int, 120);
pub const DH_R_NO_PARAMETERS_SET = @as(c_int, 107);
pub const DH_R_NO_PRIVATE_VALUE = @as(c_int, 100);
pub const DH_R_PARAMETER_ENCODING_ERROR = @as(c_int, 105);
pub const DH_R_PEER_KEY_ERROR = @as(c_int, 111);
pub const DH_R_Q_TOO_LARGE = @as(c_int, 130);
pub const DH_R_SHARED_INFO_ERROR = @as(c_int, 113);
pub const DH_R_UNABLE_TO_CHECK_GENERATOR = @as(c_int, 121);
pub const OPENSSL_DH_MAX_MODULUS_BITS = @as(c_int, 10000);
pub const OPENSSL_DH_CHECK_MAX_MODULUS_BITS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 32768, .decimal);
pub const OPENSSL_DH_FIPS_MIN_MODULUS_BITS = @as(c_int, 1024);
pub const DH_FLAG_CACHE_MONT_P = @as(c_int, 0x01);
pub const DH_FLAG_TYPE_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xF000, .hex);
pub const DH_FLAG_TYPE_DH = @as(c_int, 0x0000);
pub const DH_FLAG_TYPE_DHX = @as(c_int, 0x1000);
pub const DH_FLAG_NO_EXP_CONSTTIME = @as(c_int, 0x00);
pub const DH_FLAG_FIPS_METHOD = @as(c_int, 0x0400);
pub const DH_FLAG_NON_FIPS_ALLOW = @as(c_int, 0x0400);
pub const DH_GENERATOR_2 = @as(c_int, 2);
pub const DH_GENERATOR_3 = @as(c_int, 3);
pub const DH_GENERATOR_5 = @as(c_int, 5);
pub const DH_CHECK_P_NOT_PRIME = @as(c_int, 0x01);
pub const DH_CHECK_P_NOT_SAFE_PRIME = @as(c_int, 0x02);
pub const DH_UNABLE_TO_CHECK_GENERATOR = @as(c_int, 0x04);
pub const DH_NOT_SUITABLE_GENERATOR = @as(c_int, 0x08);
pub const DH_CHECK_Q_NOT_PRIME = @as(c_int, 0x10);
pub const DH_CHECK_INVALID_Q_VALUE = @as(c_int, 0x20);
pub const DH_CHECK_INVALID_J_VALUE = @as(c_int, 0x40);
pub const DH_MODULUS_TOO_SMALL = @as(c_int, 0x80);
pub const DH_MODULUS_TOO_LARGE = @as(c_int, 0x100);
pub const DH_CHECK_PUBKEY_TOO_SMALL = @as(c_int, 0x01);
pub const DH_CHECK_PUBKEY_TOO_LARGE = @as(c_int, 0x02);
pub const DH_CHECK_PUBKEY_INVALID = @as(c_int, 0x04);
pub const DH_CHECK_P_NOT_STRONG_PRIME = DH_CHECK_P_NOT_SAFE_PRIME;
pub const d2i_DHparams_fp = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/dh.h:177:12
pub inline fn i2d_DHparams_fp(fp: anytype, x: anytype) @TypeOf(ASN1_i2d_fp(i2d_DHparams, fp, @import("std").zig.c_translation.cast([*c]u8, x))) {
    _ = &fp;
    _ = &x;
    return ASN1_i2d_fp(i2d_DHparams, fp, @import("std").zig.c_translation.cast([*c]u8, x));
}
pub inline fn d2i_DHparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_d2i_bio_of(DH, DH_new, d2i_DHparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_d2i_bio_of(DH, DH_new, d2i_DHparams, bp, x);
}
pub inline fn i2d_DHparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_i2d_bio_of(DH, i2d_DHparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_i2d_bio_of(DH, i2d_DHparams, bp, x);
}
pub const d2i_DHxparams_fp = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/dh.h:189:12
pub inline fn i2d_DHxparams_fp(fp: anytype, x: anytype) @TypeOf(ASN1_i2d_fp(i2d_DHxparams, fp, @import("std").zig.c_translation.cast([*c]u8, x))) {
    _ = &fp;
    _ = &x;
    return ASN1_i2d_fp(i2d_DHxparams, fp, @import("std").zig.c_translation.cast([*c]u8, x));
}
pub inline fn d2i_DHxparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_d2i_bio_of(DH, DH_new, d2i_DHxparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_d2i_bio_of(DH, DH_new, d2i_DHxparams, bp, x);
}
pub inline fn i2d_DHxparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_i2d_bio_of(DH, i2d_DHxparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_i2d_bio_of(DH, i2d_DHxparams, bp, x);
}
pub inline fn DH_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DH, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DH, l, p, newf, dupf, freef);
}
pub const OPENSSL_DSAERR_H = "";
pub const DSA_R_BAD_FFC_PARAMETERS = @as(c_int, 114);
pub const DSA_R_BAD_Q_VALUE = @as(c_int, 102);
pub const DSA_R_BN_DECODE_ERROR = @as(c_int, 108);
pub const DSA_R_BN_ERROR = @as(c_int, 109);
pub const DSA_R_DECODE_ERROR = @as(c_int, 104);
pub const DSA_R_INVALID_DIGEST_TYPE = @as(c_int, 106);
pub const DSA_R_INVALID_PARAMETERS = @as(c_int, 112);
pub const DSA_R_MISSING_PARAMETERS = @as(c_int, 101);
pub const DSA_R_MISSING_PRIVATE_KEY = @as(c_int, 111);
pub const DSA_R_MODULUS_TOO_LARGE = @as(c_int, 103);
pub const DSA_R_NO_PARAMETERS_SET = @as(c_int, 107);
pub const DSA_R_PARAMETER_ENCODING_ERROR = @as(c_int, 105);
pub const DSA_R_P_NOT_PRIME = @as(c_int, 115);
pub const DSA_R_Q_NOT_PRIME = @as(c_int, 113);
pub const DSA_R_SEED_LEN_SMALL = @as(c_int, 110);
pub const DSA_R_TOO_MANY_RETRIES = @as(c_int, 116);
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_BITS = EVP_PKEY_ALG_CTRL + @as(c_int, 1);
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_Q_BITS = EVP_PKEY_ALG_CTRL + @as(c_int, 2);
pub const EVP_PKEY_CTRL_DSA_PARAMGEN_MD = EVP_PKEY_ALG_CTRL + @as(c_int, 3);
pub const OPENSSL_DSA_MAX_MODULUS_BITS = @as(c_int, 10000);
pub const OPENSSL_DSA_FIPS_MIN_MODULUS_BITS = @as(c_int, 1024);
pub const DSA_FLAG_NO_EXP_CONSTTIME = @as(c_int, 0x00);
pub const DSA_FLAG_CACHE_MONT_P = @as(c_int, 0x01);
pub const DSA_FLAG_FIPS_METHOD = @as(c_int, 0x0400);
pub const DSA_FLAG_NON_FIPS_ALLOW = @as(c_int, 0x0400);
pub const DSA_FLAG_FIPS_CHECKED = @as(c_int, 0x0800);
pub const d2i_DSAparams_fp = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/dsa.h:106:12
pub inline fn i2d_DSAparams_fp(fp: anytype, x: anytype) @TypeOf(ASN1_i2d_fp(i2d_DSAparams, fp, @import("std").zig.c_translation.cast([*c]u8, x))) {
    _ = &fp;
    _ = &x;
    return ASN1_i2d_fp(i2d_DSAparams, fp, @import("std").zig.c_translation.cast([*c]u8, x));
}
pub inline fn d2i_DSAparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_d2i_bio_of(DSA, DSA_new, d2i_DSAparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_d2i_bio_of(DSA, DSA_new, d2i_DSAparams, bp, x);
}
pub inline fn i2d_DSAparams_bio(bp: anytype, x: anytype) @TypeOf(ASN1_i2d_bio_of(DSA, i2d_DSAparams, bp, x)) {
    _ = &bp;
    _ = &x;
    return ASN1_i2d_bio_of(DSA, i2d_DSAparams, bp, x);
}
pub inline fn DSA_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DSA, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_DSA, l, p, newf, dupf, freef);
}
pub const DSS_prime_checks = @as(c_int, 64);
pub inline fn DSA_is_prime(n: anytype, callback: anytype, cb_arg: anytype) @TypeOf(BN_is_prime(n, DSS_prime_checks, callback, NULL, cb_arg)) {
    _ = &n;
    _ = &callback;
    _ = &cb_arg;
    return BN_is_prime(n, DSS_prime_checks, callback, NULL, cb_arg);
}
pub const OPENSSL_SHA_H = "";
pub const HEADER_SHA_H = "";
pub const SHA_DIGEST_LENGTH = @as(c_int, 20);
pub const SHA_LONG = c_uint;
pub const SHA_LBLOCK = @as(c_int, 16);
pub const SHA_CBLOCK = SHA_LBLOCK * @as(c_int, 4);
pub const SHA_LAST_BLOCK = SHA_CBLOCK - @as(c_int, 8);
pub const SHA256_CBLOCK = SHA_LBLOCK * @as(c_int, 4);
pub const SHA256_192_DIGEST_LENGTH = @as(c_int, 24);
pub const SHA224_DIGEST_LENGTH = @as(c_int, 28);
pub const SHA256_DIGEST_LENGTH = @as(c_int, 32);
pub const SHA384_DIGEST_LENGTH = @as(c_int, 48);
pub const SHA512_DIGEST_LENGTH = @as(c_int, 64);
pub const SHA512_CBLOCK = SHA_LBLOCK * @as(c_int, 8);
pub const SHA_LONG64 = c_ulonglong;
pub const OPENSSL_X509ERR_H = "";
pub const X509_R_AKID_MISMATCH = @as(c_int, 110);
pub const X509_R_BAD_SELECTOR = @as(c_int, 133);
pub const X509_R_BAD_X509_FILETYPE = @as(c_int, 100);
pub const X509_R_BASE64_DECODE_ERROR = @as(c_int, 118);
pub const X509_R_CANT_CHECK_DH_KEY = @as(c_int, 114);
pub const X509_R_CERTIFICATE_VERIFICATION_FAILED = @as(c_int, 139);
pub const X509_R_CERT_ALREADY_IN_HASH_TABLE = @as(c_int, 101);
pub const X509_R_CRL_ALREADY_DELTA = @as(c_int, 127);
pub const X509_R_CRL_VERIFY_FAILURE = @as(c_int, 131);
pub const X509_R_DUPLICATE_ATTRIBUTE = @as(c_int, 140);
pub const X509_R_ERROR_GETTING_MD_BY_NID = @as(c_int, 141);
pub const X509_R_ERROR_USING_SIGINF_SET = @as(c_int, 142);
pub const X509_R_IDP_MISMATCH = @as(c_int, 128);
pub const X509_R_INVALID_ATTRIBUTES = @as(c_int, 138);
pub const X509_R_INVALID_DIRECTORY = @as(c_int, 113);
pub const X509_R_INVALID_DISTPOINT = @as(c_int, 143);
pub const X509_R_INVALID_FIELD_NAME = @as(c_int, 119);
pub const X509_R_INVALID_TRUST = @as(c_int, 123);
pub const X509_R_ISSUER_MISMATCH = @as(c_int, 129);
pub const X509_R_KEY_TYPE_MISMATCH = @as(c_int, 115);
pub const X509_R_KEY_VALUES_MISMATCH = @as(c_int, 116);
pub const X509_R_LOADING_CERT_DIR = @as(c_int, 103);
pub const X509_R_LOADING_DEFAULTS = @as(c_int, 104);
pub const X509_R_METHOD_NOT_SUPPORTED = @as(c_int, 124);
pub const X509_R_NAME_TOO_LONG = @as(c_int, 134);
pub const X509_R_NEWER_CRL_NOT_NEWER = @as(c_int, 132);
pub const X509_R_NO_CERTIFICATE_FOUND = @as(c_int, 135);
pub const X509_R_NO_CERTIFICATE_OR_CRL_FOUND = @as(c_int, 136);
pub const X509_R_NO_CERT_SET_FOR_US_TO_VERIFY = @as(c_int, 105);
pub const X509_R_NO_CRL_FOUND = @as(c_int, 137);
pub const X509_R_NO_CRL_NUMBER = @as(c_int, 130);
pub const X509_R_PUBLIC_KEY_DECODE_ERROR = @as(c_int, 125);
pub const X509_R_PUBLIC_KEY_ENCODE_ERROR = @as(c_int, 126);
pub const X509_R_SHOULD_RETRY = @as(c_int, 106);
pub const X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN = @as(c_int, 107);
pub const X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY = @as(c_int, 108);
pub const X509_R_UNKNOWN_KEY_TYPE = @as(c_int, 117);
pub const X509_R_UNKNOWN_NID = @as(c_int, 109);
pub const X509_R_UNKNOWN_PURPOSE_ID = @as(c_int, 121);
pub const X509_R_UNKNOWN_SIGID_ALGS = @as(c_int, 144);
pub const X509_R_UNKNOWN_TRUST_ID = @as(c_int, 120);
pub const X509_R_UNSUPPORTED_ALGORITHM = @as(c_int, 111);
pub const X509_R_UNSUPPORTED_VERSION = @as(c_int, 145);
pub const X509_R_WRONG_LOOKUP_TYPE = @as(c_int, 112);
pub const X509_R_WRONG_TYPE = @as(c_int, 122);
pub inline fn sk_X509_NAME_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_NAME_sk_type(sk));
}
pub inline fn sk_X509_NAME_value(sk: anytype, idx: anytype) [*c]X509_NAME {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_value(ossl_check_const_X509_NAME_sk_type(sk), idx));
}
pub const sk_X509_NAME_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:55:9
pub const sk_X509_NAME_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:56:9
pub const sk_X509_NAME_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:57:9
pub inline fn sk_X509_NAME_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_NAME_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_NAME_sk_type(sk), n);
}
pub inline fn sk_X509_NAME_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_NAME_sk_type(sk));
}
pub inline fn sk_X509_NAME_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_NAME_sk_type(sk));
}
pub inline fn sk_X509_NAME_delete(sk: anytype, i: anytype) [*c]X509_NAME {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_delete(ossl_check_X509_NAME_sk_type(sk), i));
}
pub inline fn sk_X509_NAME_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_NAME {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_delete_ptr(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr)));
}
pub inline fn sk_X509_NAME_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr));
}
pub inline fn sk_X509_NAME_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr));
}
pub inline fn sk_X509_NAME_pop(sk: anytype) [*c]X509_NAME {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_pop(ossl_check_X509_NAME_sk_type(sk)));
}
pub inline fn sk_X509_NAME_shift(sk: anytype) [*c]X509_NAME {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_shift(ossl_check_X509_NAME_sk_type(sk)));
}
pub inline fn sk_X509_NAME_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_freefunc_type(freefunc));
}
pub inline fn sk_X509_NAME_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr), idx);
}
pub inline fn sk_X509_NAME_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_NAME {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_NAME, OPENSSL_sk_set(ossl_check_X509_NAME_sk_type(sk), idx, ossl_check_X509_NAME_type(ptr)));
}
pub inline fn sk_X509_NAME_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr));
}
pub inline fn sk_X509_NAME_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr));
}
pub inline fn sk_X509_NAME_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_type(ptr), pnum);
}
pub inline fn sk_X509_NAME_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_NAME_sk_type(sk));
}
pub inline fn sk_X509_NAME_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_NAME_sk_type(sk));
}
pub const sk_X509_NAME_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:75:9
pub const sk_X509_NAME_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:76:9
pub inline fn sk_X509_NAME_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_NAME_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_NAME_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_NAME_sk_type(sk), ossl_check_X509_NAME_compfunc_type(cmp)));
}
pub inline fn sk_X509_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_sk_type(sk));
}
pub inline fn sk_X509_value(sk: anytype, idx: anytype) [*c]X509 {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_value(ossl_check_const_X509_sk_type(sk), idx));
}
pub const sk_X509_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:81:9
pub const sk_X509_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:82:9
pub const sk_X509_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:83:9
pub inline fn sk_X509_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_sk_type(sk), n);
}
pub inline fn sk_X509_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_sk_type(sk));
}
pub inline fn sk_X509_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_sk_type(sk));
}
pub inline fn sk_X509_delete(sk: anytype, i: anytype) [*c]X509 {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_delete(ossl_check_X509_sk_type(sk), i));
}
pub inline fn sk_X509_delete_ptr(sk: anytype, ptr: anytype) [*c]X509 {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_delete_ptr(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr)));
}
pub inline fn sk_X509_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr));
}
pub inline fn sk_X509_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr));
}
pub inline fn sk_X509_pop(sk: anytype) [*c]X509 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_pop(ossl_check_X509_sk_type(sk)));
}
pub inline fn sk_X509_shift(sk: anytype) [*c]X509 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_shift(ossl_check_X509_sk_type(sk)));
}
pub inline fn sk_X509_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_sk_type(sk), ossl_check_X509_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_sk_type(sk), ossl_check_X509_freefunc_type(freefunc));
}
pub inline fn sk_X509_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr), idx);
}
pub inline fn sk_X509_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509 {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509, OPENSSL_sk_set(ossl_check_X509_sk_type(sk), idx, ossl_check_X509_type(ptr)));
}
pub inline fn sk_X509_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr));
}
pub inline fn sk_X509_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr));
}
pub inline fn sk_X509_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_sk_type(sk), ossl_check_X509_type(ptr), pnum);
}
pub inline fn sk_X509_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_sk_type(sk));
}
pub inline fn sk_X509_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_sk_type(sk));
}
pub const sk_X509_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:101:9
pub const sk_X509_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:102:9
pub inline fn sk_X509_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_sk_type(sk), ossl_check_X509_compfunc_type(cmp)));
}
pub inline fn sk_X509_REVOKED_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_REVOKED_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_REVOKED_sk_type(sk));
}
pub inline fn sk_X509_REVOKED_value(sk: anytype, idx: anytype) [*c]X509_REVOKED {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_value(ossl_check_const_X509_REVOKED_sk_type(sk), idx));
}
pub const sk_X509_REVOKED_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:107:9
pub const sk_X509_REVOKED_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:108:9
pub const sk_X509_REVOKED_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:109:9
pub inline fn sk_X509_REVOKED_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_REVOKED_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_REVOKED_sk_type(sk), n);
}
pub inline fn sk_X509_REVOKED_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_REVOKED_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_REVOKED_sk_type(sk));
}
pub inline fn sk_X509_REVOKED_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_REVOKED_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_REVOKED_sk_type(sk));
}
pub inline fn sk_X509_REVOKED_delete(sk: anytype, i: anytype) [*c]X509_REVOKED {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_delete(ossl_check_X509_REVOKED_sk_type(sk), i));
}
pub inline fn sk_X509_REVOKED_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_REVOKED {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_delete_ptr(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr)));
}
pub inline fn sk_X509_REVOKED_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr));
}
pub inline fn sk_X509_REVOKED_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr));
}
pub inline fn sk_X509_REVOKED_pop(sk: anytype) [*c]X509_REVOKED {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_pop(ossl_check_X509_REVOKED_sk_type(sk)));
}
pub inline fn sk_X509_REVOKED_shift(sk: anytype) [*c]X509_REVOKED {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_shift(ossl_check_X509_REVOKED_sk_type(sk)));
}
pub inline fn sk_X509_REVOKED_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_freefunc_type(freefunc));
}
pub inline fn sk_X509_REVOKED_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr), idx);
}
pub inline fn sk_X509_REVOKED_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_REVOKED {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_REVOKED, OPENSSL_sk_set(ossl_check_X509_REVOKED_sk_type(sk), idx, ossl_check_X509_REVOKED_type(ptr)));
}
pub inline fn sk_X509_REVOKED_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr));
}
pub inline fn sk_X509_REVOKED_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr));
}
pub inline fn sk_X509_REVOKED_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_type(ptr), pnum);
}
pub inline fn sk_X509_REVOKED_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_REVOKED_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_REVOKED_sk_type(sk));
}
pub inline fn sk_X509_REVOKED_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_REVOKED_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_REVOKED_sk_type(sk));
}
pub const sk_X509_REVOKED_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:127:9
pub const sk_X509_REVOKED_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:128:9
pub inline fn sk_X509_REVOKED_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_REVOKED_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_REVOKED_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_REVOKED_sk_type(sk), ossl_check_X509_REVOKED_compfunc_type(cmp)));
}
pub inline fn sk_X509_CRL_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_CRL_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_CRL_sk_type(sk));
}
pub inline fn sk_X509_CRL_value(sk: anytype, idx: anytype) [*c]X509_CRL {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_value(ossl_check_const_X509_CRL_sk_type(sk), idx));
}
pub const sk_X509_CRL_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:133:9
pub const sk_X509_CRL_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:134:9
pub const sk_X509_CRL_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:135:9
pub inline fn sk_X509_CRL_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_CRL_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_CRL_sk_type(sk), n);
}
pub inline fn sk_X509_CRL_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_CRL_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_CRL_sk_type(sk));
}
pub inline fn sk_X509_CRL_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_CRL_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_CRL_sk_type(sk));
}
pub inline fn sk_X509_CRL_delete(sk: anytype, i: anytype) [*c]X509_CRL {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_delete(ossl_check_X509_CRL_sk_type(sk), i));
}
pub inline fn sk_X509_CRL_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_CRL {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_delete_ptr(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr)));
}
pub inline fn sk_X509_CRL_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr));
}
pub inline fn sk_X509_CRL_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr));
}
pub inline fn sk_X509_CRL_pop(sk: anytype) [*c]X509_CRL {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_pop(ossl_check_X509_CRL_sk_type(sk)));
}
pub inline fn sk_X509_CRL_shift(sk: anytype) [*c]X509_CRL {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_shift(ossl_check_X509_CRL_sk_type(sk)));
}
pub inline fn sk_X509_CRL_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_freefunc_type(freefunc));
}
pub inline fn sk_X509_CRL_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr), idx);
}
pub inline fn sk_X509_CRL_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_CRL {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_CRL, OPENSSL_sk_set(ossl_check_X509_CRL_sk_type(sk), idx, ossl_check_X509_CRL_type(ptr)));
}
pub inline fn sk_X509_CRL_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr));
}
pub inline fn sk_X509_CRL_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr));
}
pub inline fn sk_X509_CRL_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_type(ptr), pnum);
}
pub inline fn sk_X509_CRL_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_CRL_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_CRL_sk_type(sk));
}
pub inline fn sk_X509_CRL_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_CRL_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_CRL_sk_type(sk));
}
pub const sk_X509_CRL_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:153:9
pub const sk_X509_CRL_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:154:9
pub inline fn sk_X509_CRL_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_CRL_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_CRL_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_CRL_sk_type(sk), ossl_check_X509_CRL_compfunc_type(cmp)));
}
pub const X509_SIG_INFO_VALID = @as(c_int, 0x1);
pub const X509_SIG_INFO_TLS = @as(c_int, 0x2);
pub const X509_FILETYPE_PEM = @as(c_int, 1);
pub const X509_FILETYPE_ASN1 = @as(c_int, 2);
pub const X509_FILETYPE_DEFAULT = @as(c_int, 3);
pub const X509v3_KU_DIGITAL_SIGNATURE = @as(c_int, 0x0080);
pub const X509v3_KU_NON_REPUDIATION = @as(c_int, 0x0040);
pub const X509v3_KU_KEY_ENCIPHERMENT = @as(c_int, 0x0020);
pub const X509v3_KU_DATA_ENCIPHERMENT = @as(c_int, 0x0010);
pub const X509v3_KU_KEY_AGREEMENT = @as(c_int, 0x0008);
pub const X509v3_KU_KEY_CERT_SIGN = @as(c_int, 0x0004);
pub const X509v3_KU_CRL_SIGN = @as(c_int, 0x0002);
pub const X509v3_KU_ENCIPHER_ONLY = @as(c_int, 0x0001);
pub const X509v3_KU_DECIPHER_ONLY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const X509v3_KU_UNDEF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff, .hex);
pub inline fn sk_X509_NAME_ENTRY_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_NAME_ENTRY_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_NAME_ENTRY_sk_type(sk));
}
pub inline fn sk_X509_NAME_ENTRY_value(sk: anytype, idx: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_value(ossl_check_const_X509_NAME_ENTRY_sk_type(sk), idx));
}
pub const sk_X509_NAME_ENTRY_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:206:9
pub const sk_X509_NAME_ENTRY_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:207:9
pub const sk_X509_NAME_ENTRY_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:208:9
pub inline fn sk_X509_NAME_ENTRY_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_NAME_ENTRY_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_NAME_ENTRY_sk_type(sk), n);
}
pub inline fn sk_X509_NAME_ENTRY_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_NAME_ENTRY_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_NAME_ENTRY_sk_type(sk));
}
pub inline fn sk_X509_NAME_ENTRY_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_NAME_ENTRY_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_NAME_ENTRY_sk_type(sk));
}
pub inline fn sk_X509_NAME_ENTRY_delete(sk: anytype, i: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_delete(ossl_check_X509_NAME_ENTRY_sk_type(sk), i));
}
pub inline fn sk_X509_NAME_ENTRY_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_delete_ptr(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr)));
}
pub inline fn sk_X509_NAME_ENTRY_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr));
}
pub inline fn sk_X509_NAME_ENTRY_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr));
}
pub inline fn sk_X509_NAME_ENTRY_pop(sk: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_pop(ossl_check_X509_NAME_ENTRY_sk_type(sk)));
}
pub inline fn sk_X509_NAME_ENTRY_shift(sk: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_shift(ossl_check_X509_NAME_ENTRY_sk_type(sk)));
}
pub inline fn sk_X509_NAME_ENTRY_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_freefunc_type(freefunc));
}
pub inline fn sk_X509_NAME_ENTRY_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr), idx);
}
pub inline fn sk_X509_NAME_ENTRY_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_NAME_ENTRY {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_NAME_ENTRY, OPENSSL_sk_set(ossl_check_X509_NAME_ENTRY_sk_type(sk), idx, ossl_check_X509_NAME_ENTRY_type(ptr)));
}
pub inline fn sk_X509_NAME_ENTRY_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr));
}
pub inline fn sk_X509_NAME_ENTRY_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr));
}
pub inline fn sk_X509_NAME_ENTRY_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_type(ptr), pnum);
}
pub inline fn sk_X509_NAME_ENTRY_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_NAME_ENTRY_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_NAME_ENTRY_sk_type(sk));
}
pub inline fn sk_X509_NAME_ENTRY_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_NAME_ENTRY_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_NAME_ENTRY_sk_type(sk));
}
pub const sk_X509_NAME_ENTRY_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:226:9
pub const sk_X509_NAME_ENTRY_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:227:9
pub inline fn sk_X509_NAME_ENTRY_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_NAME_ENTRY_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_NAME_ENTRY_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_NAME_ENTRY_sk_type(sk), ossl_check_X509_NAME_ENTRY_compfunc_type(cmp)));
}
pub const X509_EX_V_NETSCAPE_HACK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const X509_EX_V_INIT = @as(c_int, 0x0001);
pub inline fn sk_X509_EXTENSION_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_EXTENSION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_EXTENSION_sk_type(sk));
}
pub inline fn sk_X509_EXTENSION_value(sk: anytype, idx: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_value(ossl_check_const_X509_EXTENSION_sk_type(sk), idx));
}
pub const sk_X509_EXTENSION_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:237:9
pub const sk_X509_EXTENSION_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:238:9
pub const sk_X509_EXTENSION_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:239:9
pub inline fn sk_X509_EXTENSION_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_EXTENSION_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_EXTENSION_sk_type(sk), n);
}
pub inline fn sk_X509_EXTENSION_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_EXTENSION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_EXTENSION_sk_type(sk));
}
pub inline fn sk_X509_EXTENSION_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_EXTENSION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_EXTENSION_sk_type(sk));
}
pub inline fn sk_X509_EXTENSION_delete(sk: anytype, i: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_delete(ossl_check_X509_EXTENSION_sk_type(sk), i));
}
pub inline fn sk_X509_EXTENSION_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_delete_ptr(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr)));
}
pub inline fn sk_X509_EXTENSION_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr));
}
pub inline fn sk_X509_EXTENSION_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr));
}
pub inline fn sk_X509_EXTENSION_pop(sk: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_pop(ossl_check_X509_EXTENSION_sk_type(sk)));
}
pub inline fn sk_X509_EXTENSION_shift(sk: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_shift(ossl_check_X509_EXTENSION_sk_type(sk)));
}
pub inline fn sk_X509_EXTENSION_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_freefunc_type(freefunc));
}
pub inline fn sk_X509_EXTENSION_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr), idx);
}
pub inline fn sk_X509_EXTENSION_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_EXTENSION {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_EXTENSION, OPENSSL_sk_set(ossl_check_X509_EXTENSION_sk_type(sk), idx, ossl_check_X509_EXTENSION_type(ptr)));
}
pub inline fn sk_X509_EXTENSION_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr));
}
pub inline fn sk_X509_EXTENSION_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr));
}
pub inline fn sk_X509_EXTENSION_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_type(ptr), pnum);
}
pub inline fn sk_X509_EXTENSION_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_EXTENSION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_EXTENSION_sk_type(sk));
}
pub inline fn sk_X509_EXTENSION_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_EXTENSION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_EXTENSION_sk_type(sk));
}
pub const sk_X509_EXTENSION_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:257:9
pub const sk_X509_EXTENSION_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:258:9
pub inline fn sk_X509_EXTENSION_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_EXTENSION_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_EXTENSION_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_EXTENSION_sk_type(sk), ossl_check_X509_EXTENSION_compfunc_type(cmp)));
}
pub inline fn sk_X509_ATTRIBUTE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_ATTRIBUTE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_ATTRIBUTE_sk_type(sk));
}
pub inline fn sk_X509_ATTRIBUTE_value(sk: anytype, idx: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_value(ossl_check_const_X509_ATTRIBUTE_sk_type(sk), idx));
}
pub const sk_X509_ATTRIBUTE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:266:9
pub const sk_X509_ATTRIBUTE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:267:9
pub const sk_X509_ATTRIBUTE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:268:9
pub inline fn sk_X509_ATTRIBUTE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_ATTRIBUTE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_ATTRIBUTE_sk_type(sk), n);
}
pub inline fn sk_X509_ATTRIBUTE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_ATTRIBUTE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_ATTRIBUTE_sk_type(sk));
}
pub inline fn sk_X509_ATTRIBUTE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_ATTRIBUTE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_ATTRIBUTE_sk_type(sk));
}
pub inline fn sk_X509_ATTRIBUTE_delete(sk: anytype, i: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_delete(ossl_check_X509_ATTRIBUTE_sk_type(sk), i));
}
pub inline fn sk_X509_ATTRIBUTE_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_delete_ptr(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr)));
}
pub inline fn sk_X509_ATTRIBUTE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr));
}
pub inline fn sk_X509_ATTRIBUTE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr));
}
pub inline fn sk_X509_ATTRIBUTE_pop(sk: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_pop(ossl_check_X509_ATTRIBUTE_sk_type(sk)));
}
pub inline fn sk_X509_ATTRIBUTE_shift(sk: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_shift(ossl_check_X509_ATTRIBUTE_sk_type(sk)));
}
pub inline fn sk_X509_ATTRIBUTE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_freefunc_type(freefunc));
}
pub inline fn sk_X509_ATTRIBUTE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr), idx);
}
pub inline fn sk_X509_ATTRIBUTE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_ATTRIBUTE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_ATTRIBUTE, OPENSSL_sk_set(ossl_check_X509_ATTRIBUTE_sk_type(sk), idx, ossl_check_X509_ATTRIBUTE_type(ptr)));
}
pub inline fn sk_X509_ATTRIBUTE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr));
}
pub inline fn sk_X509_ATTRIBUTE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr));
}
pub inline fn sk_X509_ATTRIBUTE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_type(ptr), pnum);
}
pub inline fn sk_X509_ATTRIBUTE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_ATTRIBUTE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_ATTRIBUTE_sk_type(sk));
}
pub inline fn sk_X509_ATTRIBUTE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_ATTRIBUTE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_ATTRIBUTE_sk_type(sk));
}
pub const sk_X509_ATTRIBUTE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:286:9
pub const sk_X509_ATTRIBUTE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:287:9
pub inline fn sk_X509_ATTRIBUTE_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_ATTRIBUTE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_ATTRIBUTE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_ATTRIBUTE_sk_type(sk), ossl_check_X509_ATTRIBUTE_compfunc_type(cmp)));
}
pub const X509_FLAG_COMPAT = @as(c_int, 0);
pub const X509_FLAG_NO_HEADER = @as(c_long, 1);
pub const X509_FLAG_NO_VERSION = @as(c_long, 1) << @as(c_int, 1);
pub const X509_FLAG_NO_SERIAL = @as(c_long, 1) << @as(c_int, 2);
pub const X509_FLAG_NO_SIGNAME = @as(c_long, 1) << @as(c_int, 3);
pub const X509_FLAG_NO_ISSUER = @as(c_long, 1) << @as(c_int, 4);
pub const X509_FLAG_NO_VALIDITY = @as(c_long, 1) << @as(c_int, 5);
pub const X509_FLAG_NO_SUBJECT = @as(c_long, 1) << @as(c_int, 6);
pub const X509_FLAG_NO_PUBKEY = @as(c_long, 1) << @as(c_int, 7);
pub const X509_FLAG_NO_EXTENSIONS = @as(c_long, 1) << @as(c_int, 8);
pub const X509_FLAG_NO_SIGDUMP = @as(c_long, 1) << @as(c_int, 9);
pub const X509_FLAG_NO_AUX = @as(c_long, 1) << @as(c_int, 10);
pub const X509_FLAG_NO_ATTRIBUTES = @as(c_long, 1) << @as(c_int, 11);
pub const X509_FLAG_NO_IDS = @as(c_long, 1) << @as(c_int, 12);
pub const X509_FLAG_EXTENSIONS_ONLY_KID = @as(c_long, 1) << @as(c_int, 13);
pub const XN_FLAG_SEP_MASK = @as(c_int, 0xf) << @as(c_int, 16);
pub const XN_FLAG_COMPAT = @as(c_int, 0);
pub const XN_FLAG_SEP_COMMA_PLUS = @as(c_int, 1) << @as(c_int, 16);
pub const XN_FLAG_SEP_CPLUS_SPC = @as(c_int, 2) << @as(c_int, 16);
pub const XN_FLAG_SEP_SPLUS_SPC = @as(c_int, 3) << @as(c_int, 16);
pub const XN_FLAG_SEP_MULTILINE = @as(c_int, 4) << @as(c_int, 16);
pub const XN_FLAG_DN_REV = @as(c_int, 1) << @as(c_int, 20);
pub const XN_FLAG_FN_MASK = @as(c_int, 0x3) << @as(c_int, 21);
pub const XN_FLAG_FN_SN = @as(c_int, 0);
pub const XN_FLAG_FN_LN = @as(c_int, 1) << @as(c_int, 21);
pub const XN_FLAG_FN_OID = @as(c_int, 2) << @as(c_int, 21);
pub const XN_FLAG_FN_NONE = @as(c_int, 3) << @as(c_int, 21);
pub const XN_FLAG_SPC_EQ = @as(c_int, 1) << @as(c_int, 23);
pub const XN_FLAG_DUMP_UNKNOWN_FIELDS = @as(c_int, 1) << @as(c_int, 24);
pub const XN_FLAG_FN_ALIGN = @as(c_int, 1) << @as(c_int, 25);
pub const XN_FLAG_RFC2253 = (((ASN1_STRFLGS_RFC2253 | XN_FLAG_SEP_COMMA_PLUS) | XN_FLAG_DN_REV) | XN_FLAG_FN_SN) | XN_FLAG_DUMP_UNKNOWN_FIELDS;
pub const XN_FLAG_ONELINE = (((ASN1_STRFLGS_RFC2253 | ASN1_STRFLGS_ESC_QUOTE) | XN_FLAG_SEP_CPLUS_SPC) | XN_FLAG_SPC_EQ) | XN_FLAG_FN_SN;
pub const XN_FLAG_MULTILINE = ((((ASN1_STRFLGS_ESC_CTRL | ASN1_STRFLGS_ESC_MSB) | XN_FLAG_SEP_MULTILINE) | XN_FLAG_SPC_EQ) | XN_FLAG_FN_LN) | XN_FLAG_FN_ALIGN;
pub inline fn sk_X509_INFO_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_INFO_sk_type(sk));
}
pub inline fn sk_X509_INFO_value(sk: anytype, idx: anytype) [*c]X509_INFO {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_value(ossl_check_const_X509_INFO_sk_type(sk), idx));
}
pub const sk_X509_INFO_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:401:9
pub const sk_X509_INFO_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:402:9
pub const sk_X509_INFO_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:403:9
pub inline fn sk_X509_INFO_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_INFO_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_INFO_sk_type(sk), n);
}
pub inline fn sk_X509_INFO_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_INFO_sk_type(sk));
}
pub inline fn sk_X509_INFO_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_INFO_sk_type(sk));
}
pub inline fn sk_X509_INFO_delete(sk: anytype, i: anytype) [*c]X509_INFO {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_delete(ossl_check_X509_INFO_sk_type(sk), i));
}
pub inline fn sk_X509_INFO_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_INFO {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_delete_ptr(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr)));
}
pub inline fn sk_X509_INFO_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr));
}
pub inline fn sk_X509_INFO_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr));
}
pub inline fn sk_X509_INFO_pop(sk: anytype) [*c]X509_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_pop(ossl_check_X509_INFO_sk_type(sk)));
}
pub inline fn sk_X509_INFO_shift(sk: anytype) [*c]X509_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_shift(ossl_check_X509_INFO_sk_type(sk)));
}
pub inline fn sk_X509_INFO_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_freefunc_type(freefunc));
}
pub inline fn sk_X509_INFO_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr), idx);
}
pub inline fn sk_X509_INFO_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_INFO {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_INFO, OPENSSL_sk_set(ossl_check_X509_INFO_sk_type(sk), idx, ossl_check_X509_INFO_type(ptr)));
}
pub inline fn sk_X509_INFO_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr));
}
pub inline fn sk_X509_INFO_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr));
}
pub inline fn sk_X509_INFO_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_type(ptr), pnum);
}
pub inline fn sk_X509_INFO_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_INFO_sk_type(sk));
}
pub inline fn sk_X509_INFO_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_INFO_sk_type(sk));
}
pub const sk_X509_INFO_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:421:9
pub const sk_X509_INFO_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509.h:422:9
pub inline fn sk_X509_INFO_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_INFO_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_INFO_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_INFO_sk_type(sk), ossl_check_X509_INFO_compfunc_type(cmp)));
}
pub const OPENSSL_X509_VFY_H = "";
pub const HEADER_X509_VFY_H = "";
pub const OPENSSL_LHASH_H = "";
pub const HEADER_LHASH_H = "";
pub const DECLARE_LHASH_HASH_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_HASH`");
// /usr/include/openssl/lhash.h:56:10
pub const IMPLEMENT_LHASH_HASH_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_HASH`");
// /usr/include/openssl/lhash.h:58:10
pub const LHASH_HASH_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_HASH`");
// /usr/include/openssl/lhash.h:62:10
pub const DECLARE_LHASH_COMP_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_COMP`");
// /usr/include/openssl/lhash.h:65:10
pub const IMPLEMENT_LHASH_COMP_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_COMP`");
// /usr/include/openssl/lhash.h:67:10
pub const LHASH_COMP_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_COMP`");
// /usr/include/openssl/lhash.h:72:10
pub const DECLARE_LHASH_DOALL_ARG_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_DOALL_ARG`");
// /usr/include/openssl/lhash.h:75:10
pub const IMPLEMENT_LHASH_DOALL_ARG_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_DOALL_ARG`");
// /usr/include/openssl/lhash.h:77:10
pub const LHASH_DOALL_ARG_FN = @compileError("unable to translate macro: undefined identifier `_LHASH_DOALL_ARG`");
// /usr/include/openssl/lhash.h:82:10
pub const LH_LOAD_MULT = @as(c_int, 256);
pub const _LHASH = OPENSSL_LHASH;
pub const LHASH_NODE = OPENSSL_LH_NODE;
pub const lh_error = OPENSSL_LH_error;
pub const lh_new = OPENSSL_LH_new;
pub const lh_free = OPENSSL_LH_free;
pub const lh_insert = OPENSSL_LH_insert;
pub const lh_delete = OPENSSL_LH_delete;
pub const lh_retrieve = OPENSSL_LH_retrieve;
pub const lh_doall = OPENSSL_LH_doall;
pub const lh_doall_arg = OPENSSL_LH_doall_arg;
pub const lh_strhash = OPENSSL_LH_strhash;
pub const lh_num_items = OPENSSL_LH_num_items;
pub const lh_stats = OPENSSL_LH_stats;
pub const lh_node_stats = OPENSSL_LH_node_stats;
pub const lh_node_usage_stats = OPENSSL_LH_node_usage_stats;
pub const lh_stats_bio = OPENSSL_LH_stats_bio;
pub const lh_node_stats_bio = OPENSSL_LH_node_stats_bio;
pub const lh_node_usage_stats_bio = OPENSSL_LH_node_usage_stats_bio;
pub const LHASH_OF = @compileError("unable to translate macro: undefined identifier `lhash_st_`");
// /usr/include/openssl/lhash.h:149:10
pub const DEFINE_LHASH_OF_INTERNAL = @compileError("unable to translate macro: undefined identifier `lh_`");
// /usr/include/openssl/lhash.h:152:10
pub const DEFINE_LHASH_OF_DEPRECATED = @compileError("unable to translate macro: undefined identifier `lh_`");
// /usr/include/openssl/lhash.h:217:11
pub const DEFINE_LHASH_OF_EX = @compileError("unable to translate macro: undefined identifier `lh_`");
// /usr/include/openssl/lhash.h:237:10
pub const DEFINE_LHASH_OF = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/openssl/lhash.h:332:10
pub const IMPLEMENT_LHASH_DOALL_ARG_CONST = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/lhash.h:337:9
pub inline fn IMPLEMENT_LHASH_DOALL_ARG(@"type": anytype, argtype: anytype) @TypeOf(int_implement_lhash_doall(@"type", argtype, @"type")) {
    _ = &@"type";
    _ = &argtype;
    return int_implement_lhash_doall(@"type", argtype, @"type");
}
pub const int_implement_lhash_doall = @compileError("unable to translate macro: undefined identifier `lh_`");
// /usr/include/openssl/lhash.h:343:9
pub const lh_OPENSSL_STRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/lhash.h:363:9
pub inline fn lh_OPENSSL_STRING_free(lh: anytype) @TypeOf(OPENSSL_LH_free(ossl_check_OPENSSL_STRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_free(ossl_check_OPENSSL_STRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_STRING_flush(lh: anytype) @TypeOf(OPENSSL_LH_flush(ossl_check_OPENSSL_STRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_flush(ossl_check_OPENSSL_STRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_STRING_insert(lh: anytype, ptr: anytype) [*c]OPENSSL_STRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_STRING, OPENSSL_LH_insert(ossl_check_OPENSSL_STRING_lh_type(lh), ossl_check_OPENSSL_STRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_STRING_delete(lh: anytype, ptr: anytype) [*c]OPENSSL_STRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_STRING, OPENSSL_LH_delete(ossl_check_OPENSSL_STRING_lh_type(lh), ossl_check_const_OPENSSL_STRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_STRING_retrieve(lh: anytype, ptr: anytype) [*c]OPENSSL_STRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_STRING, OPENSSL_LH_retrieve(ossl_check_OPENSSL_STRING_lh_type(lh), ossl_check_const_OPENSSL_STRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_STRING_error(lh: anytype) @TypeOf(OPENSSL_LH_error(ossl_check_OPENSSL_STRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_error(ossl_check_OPENSSL_STRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_STRING_num_items(lh: anytype) @TypeOf(OPENSSL_LH_num_items(ossl_check_OPENSSL_STRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_num_items(ossl_check_OPENSSL_STRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_STRING_node_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_STRING_node_usage_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_usage_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_usage_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_STRING_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_stats_bio(ossl_check_const_OPENSSL_STRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_STRING_get_down_load(lh: anytype) @TypeOf(OPENSSL_LH_get_down_load(ossl_check_OPENSSL_STRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_get_down_load(ossl_check_OPENSSL_STRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_STRING_set_down_load(lh: anytype, dl: anytype) @TypeOf(OPENSSL_LH_set_down_load(ossl_check_OPENSSL_STRING_lh_type(lh), dl)) {
    _ = &lh;
    _ = &dl;
    return OPENSSL_LH_set_down_load(ossl_check_OPENSSL_STRING_lh_type(lh), dl);
}
pub inline fn lh_OPENSSL_STRING_doall(lh: anytype, dfn: anytype) @TypeOf(OPENSSL_LH_doall(ossl_check_OPENSSL_STRING_lh_type(lh), ossl_check_OPENSSL_STRING_lh_doallfunc_type(dfn))) {
    _ = &lh;
    _ = &dfn;
    return OPENSSL_LH_doall(ossl_check_OPENSSL_STRING_lh_type(lh), ossl_check_OPENSSL_STRING_lh_doallfunc_type(dfn));
}
pub const lh_OPENSSL_CSTRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/lhash.h:378:9
pub inline fn lh_OPENSSL_CSTRING_free(lh: anytype) @TypeOf(OPENSSL_LH_free(ossl_check_OPENSSL_CSTRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_free(ossl_check_OPENSSL_CSTRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_CSTRING_flush(lh: anytype) @TypeOf(OPENSSL_LH_flush(ossl_check_OPENSSL_CSTRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_flush(ossl_check_OPENSSL_CSTRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_CSTRING_insert(lh: anytype, ptr: anytype) [*c]OPENSSL_CSTRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_CSTRING, OPENSSL_LH_insert(ossl_check_OPENSSL_CSTRING_lh_type(lh), ossl_check_OPENSSL_CSTRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_CSTRING_delete(lh: anytype, ptr: anytype) [*c]OPENSSL_CSTRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_CSTRING, OPENSSL_LH_delete(ossl_check_OPENSSL_CSTRING_lh_type(lh), ossl_check_const_OPENSSL_CSTRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_CSTRING_retrieve(lh: anytype, ptr: anytype) [*c]OPENSSL_CSTRING {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OPENSSL_CSTRING, OPENSSL_LH_retrieve(ossl_check_OPENSSL_CSTRING_lh_type(lh), ossl_check_const_OPENSSL_CSTRING_lh_plain_type(ptr)));
}
pub inline fn lh_OPENSSL_CSTRING_error(lh: anytype) @TypeOf(OPENSSL_LH_error(ossl_check_OPENSSL_CSTRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_error(ossl_check_OPENSSL_CSTRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_CSTRING_num_items(lh: anytype) @TypeOf(OPENSSL_LH_num_items(ossl_check_OPENSSL_CSTRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_num_items(ossl_check_OPENSSL_CSTRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_CSTRING_node_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_CSTRING_node_usage_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_usage_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_usage_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_CSTRING_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_stats_bio(ossl_check_const_OPENSSL_CSTRING_lh_type(lh), out);
}
pub inline fn lh_OPENSSL_CSTRING_get_down_load(lh: anytype) @TypeOf(OPENSSL_LH_get_down_load(ossl_check_OPENSSL_CSTRING_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_get_down_load(ossl_check_OPENSSL_CSTRING_lh_type(lh));
}
pub inline fn lh_OPENSSL_CSTRING_set_down_load(lh: anytype, dl: anytype) @TypeOf(OPENSSL_LH_set_down_load(ossl_check_OPENSSL_CSTRING_lh_type(lh), dl)) {
    _ = &lh;
    _ = &dl;
    return OPENSSL_LH_set_down_load(ossl_check_OPENSSL_CSTRING_lh_type(lh), dl);
}
pub inline fn lh_OPENSSL_CSTRING_doall(lh: anytype, dfn: anytype) @TypeOf(OPENSSL_LH_doall(ossl_check_OPENSSL_CSTRING_lh_type(lh), ossl_check_OPENSSL_CSTRING_lh_doallfunc_type(dfn))) {
    _ = &lh;
    _ = &dfn;
    return OPENSSL_LH_doall(ossl_check_OPENSSL_CSTRING_lh_type(lh), ossl_check_OPENSSL_CSTRING_lh_doallfunc_type(dfn));
}
pub const X509_LU_RETRY = -@as(c_int, 1);
pub const X509_LU_FAIL = @as(c_int, 0);
pub inline fn sk_X509_LOOKUP_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_LOOKUP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_LOOKUP_sk_type(sk));
}
pub inline fn sk_X509_LOOKUP_value(sk: anytype, idx: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_value(ossl_check_const_X509_LOOKUP_sk_type(sk), idx));
}
pub const sk_X509_LOOKUP_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:71:9
pub const sk_X509_LOOKUP_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:72:9
pub const sk_X509_LOOKUP_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:73:9
pub inline fn sk_X509_LOOKUP_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_LOOKUP_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_LOOKUP_sk_type(sk), n);
}
pub inline fn sk_X509_LOOKUP_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_LOOKUP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_LOOKUP_sk_type(sk));
}
pub inline fn sk_X509_LOOKUP_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_LOOKUP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_LOOKUP_sk_type(sk));
}
pub inline fn sk_X509_LOOKUP_delete(sk: anytype, i: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_delete(ossl_check_X509_LOOKUP_sk_type(sk), i));
}
pub inline fn sk_X509_LOOKUP_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_delete_ptr(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr)));
}
pub inline fn sk_X509_LOOKUP_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr));
}
pub inline fn sk_X509_LOOKUP_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr));
}
pub inline fn sk_X509_LOOKUP_pop(sk: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_pop(ossl_check_X509_LOOKUP_sk_type(sk)));
}
pub inline fn sk_X509_LOOKUP_shift(sk: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_shift(ossl_check_X509_LOOKUP_sk_type(sk)));
}
pub inline fn sk_X509_LOOKUP_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_freefunc_type(freefunc));
}
pub inline fn sk_X509_LOOKUP_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr), idx);
}
pub inline fn sk_X509_LOOKUP_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_LOOKUP {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_LOOKUP, OPENSSL_sk_set(ossl_check_X509_LOOKUP_sk_type(sk), idx, ossl_check_X509_LOOKUP_type(ptr)));
}
pub inline fn sk_X509_LOOKUP_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr));
}
pub inline fn sk_X509_LOOKUP_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr));
}
pub inline fn sk_X509_LOOKUP_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_type(ptr), pnum);
}
pub inline fn sk_X509_LOOKUP_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_LOOKUP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_LOOKUP_sk_type(sk));
}
pub inline fn sk_X509_LOOKUP_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_LOOKUP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_LOOKUP_sk_type(sk));
}
pub const sk_X509_LOOKUP_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:91:9
pub const sk_X509_LOOKUP_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:92:9
pub inline fn sk_X509_LOOKUP_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_LOOKUP_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_LOOKUP_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_LOOKUP_sk_type(sk), ossl_check_X509_LOOKUP_compfunc_type(cmp)));
}
pub inline fn sk_X509_OBJECT_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_OBJECT_sk_type(sk));
}
pub inline fn sk_X509_OBJECT_value(sk: anytype, idx: anytype) [*c]X509_OBJECT {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_value(ossl_check_const_X509_OBJECT_sk_type(sk), idx));
}
pub const sk_X509_OBJECT_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:97:9
pub const sk_X509_OBJECT_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:98:9
pub const sk_X509_OBJECT_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:99:9
pub inline fn sk_X509_OBJECT_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_OBJECT_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_OBJECT_sk_type(sk), n);
}
pub inline fn sk_X509_OBJECT_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_OBJECT_sk_type(sk));
}
pub inline fn sk_X509_OBJECT_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_OBJECT_sk_type(sk));
}
pub inline fn sk_X509_OBJECT_delete(sk: anytype, i: anytype) [*c]X509_OBJECT {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_delete(ossl_check_X509_OBJECT_sk_type(sk), i));
}
pub inline fn sk_X509_OBJECT_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_OBJECT {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_delete_ptr(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr)));
}
pub inline fn sk_X509_OBJECT_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr));
}
pub inline fn sk_X509_OBJECT_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr));
}
pub inline fn sk_X509_OBJECT_pop(sk: anytype) [*c]X509_OBJECT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_pop(ossl_check_X509_OBJECT_sk_type(sk)));
}
pub inline fn sk_X509_OBJECT_shift(sk: anytype) [*c]X509_OBJECT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_shift(ossl_check_X509_OBJECT_sk_type(sk)));
}
pub inline fn sk_X509_OBJECT_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_freefunc_type(freefunc));
}
pub inline fn sk_X509_OBJECT_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr), idx);
}
pub inline fn sk_X509_OBJECT_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_OBJECT {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_OBJECT, OPENSSL_sk_set(ossl_check_X509_OBJECT_sk_type(sk), idx, ossl_check_X509_OBJECT_type(ptr)));
}
pub inline fn sk_X509_OBJECT_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr));
}
pub inline fn sk_X509_OBJECT_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr));
}
pub inline fn sk_X509_OBJECT_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_type(ptr), pnum);
}
pub inline fn sk_X509_OBJECT_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_OBJECT_sk_type(sk));
}
pub inline fn sk_X509_OBJECT_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_OBJECT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_OBJECT_sk_type(sk));
}
pub const sk_X509_OBJECT_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:117:9
pub const sk_X509_OBJECT_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:118:9
pub inline fn sk_X509_OBJECT_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_OBJECT_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_OBJECT_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_OBJECT_sk_type(sk), ossl_check_X509_OBJECT_compfunc_type(cmp)));
}
pub inline fn sk_X509_VERIFY_PARAM_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_VERIFY_PARAM_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_VERIFY_PARAM_sk_type(sk));
}
pub inline fn sk_X509_VERIFY_PARAM_value(sk: anytype, idx: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_value(ossl_check_const_X509_VERIFY_PARAM_sk_type(sk), idx));
}
pub const sk_X509_VERIFY_PARAM_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:123:9
pub const sk_X509_VERIFY_PARAM_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:124:9
pub const sk_X509_VERIFY_PARAM_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:125:9
pub inline fn sk_X509_VERIFY_PARAM_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_VERIFY_PARAM_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_VERIFY_PARAM_sk_type(sk), n);
}
pub inline fn sk_X509_VERIFY_PARAM_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_VERIFY_PARAM_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_VERIFY_PARAM_sk_type(sk));
}
pub inline fn sk_X509_VERIFY_PARAM_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_VERIFY_PARAM_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_VERIFY_PARAM_sk_type(sk));
}
pub inline fn sk_X509_VERIFY_PARAM_delete(sk: anytype, i: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_delete(ossl_check_X509_VERIFY_PARAM_sk_type(sk), i));
}
pub inline fn sk_X509_VERIFY_PARAM_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_delete_ptr(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr)));
}
pub inline fn sk_X509_VERIFY_PARAM_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr));
}
pub inline fn sk_X509_VERIFY_PARAM_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr));
}
pub inline fn sk_X509_VERIFY_PARAM_pop(sk: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_pop(ossl_check_X509_VERIFY_PARAM_sk_type(sk)));
}
pub inline fn sk_X509_VERIFY_PARAM_shift(sk: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_shift(ossl_check_X509_VERIFY_PARAM_sk_type(sk)));
}
pub inline fn sk_X509_VERIFY_PARAM_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_freefunc_type(freefunc));
}
pub inline fn sk_X509_VERIFY_PARAM_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr), idx);
}
pub inline fn sk_X509_VERIFY_PARAM_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_VERIFY_PARAM {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_VERIFY_PARAM, OPENSSL_sk_set(ossl_check_X509_VERIFY_PARAM_sk_type(sk), idx, ossl_check_X509_VERIFY_PARAM_type(ptr)));
}
pub inline fn sk_X509_VERIFY_PARAM_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr));
}
pub inline fn sk_X509_VERIFY_PARAM_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr));
}
pub inline fn sk_X509_VERIFY_PARAM_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_type(ptr), pnum);
}
pub inline fn sk_X509_VERIFY_PARAM_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_VERIFY_PARAM_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_VERIFY_PARAM_sk_type(sk));
}
pub inline fn sk_X509_VERIFY_PARAM_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_VERIFY_PARAM_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_VERIFY_PARAM_sk_type(sk));
}
pub const sk_X509_VERIFY_PARAM_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:143:9
pub const sk_X509_VERIFY_PARAM_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:144:9
pub inline fn sk_X509_VERIFY_PARAM_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_VERIFY_PARAM_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_VERIFY_PARAM_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_VERIFY_PARAM_sk_type(sk), ossl_check_X509_VERIFY_PARAM_compfunc_type(cmp)));
}
pub inline fn sk_X509_TRUST_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_TRUST_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_TRUST_sk_type(sk));
}
pub inline fn sk_X509_TRUST_value(sk: anytype, idx: anytype) [*c]X509_TRUST {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_value(ossl_check_const_X509_TRUST_sk_type(sk), idx));
}
pub const sk_X509_TRUST_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:160:9
pub const sk_X509_TRUST_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:161:9
pub const sk_X509_TRUST_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:162:9
pub inline fn sk_X509_TRUST_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_TRUST_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_TRUST_sk_type(sk), n);
}
pub inline fn sk_X509_TRUST_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_TRUST_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_TRUST_sk_type(sk));
}
pub inline fn sk_X509_TRUST_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_TRUST_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_TRUST_sk_type(sk));
}
pub inline fn sk_X509_TRUST_delete(sk: anytype, i: anytype) [*c]X509_TRUST {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_delete(ossl_check_X509_TRUST_sk_type(sk), i));
}
pub inline fn sk_X509_TRUST_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_TRUST {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_delete_ptr(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr)));
}
pub inline fn sk_X509_TRUST_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr));
}
pub inline fn sk_X509_TRUST_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr));
}
pub inline fn sk_X509_TRUST_pop(sk: anytype) [*c]X509_TRUST {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_pop(ossl_check_X509_TRUST_sk_type(sk)));
}
pub inline fn sk_X509_TRUST_shift(sk: anytype) [*c]X509_TRUST {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_shift(ossl_check_X509_TRUST_sk_type(sk)));
}
pub inline fn sk_X509_TRUST_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_freefunc_type(freefunc));
}
pub inline fn sk_X509_TRUST_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr), idx);
}
pub inline fn sk_X509_TRUST_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_TRUST {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_TRUST, OPENSSL_sk_set(ossl_check_X509_TRUST_sk_type(sk), idx, ossl_check_X509_TRUST_type(ptr)));
}
pub inline fn sk_X509_TRUST_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr));
}
pub inline fn sk_X509_TRUST_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr));
}
pub inline fn sk_X509_TRUST_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_type(ptr), pnum);
}
pub inline fn sk_X509_TRUST_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_TRUST_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_TRUST_sk_type(sk));
}
pub inline fn sk_X509_TRUST_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_TRUST_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_TRUST_sk_type(sk));
}
pub const sk_X509_TRUST_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:180:9
pub const sk_X509_TRUST_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509_vfy.h:181:9
pub inline fn sk_X509_TRUST_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_TRUST_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_TRUST_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_TRUST_sk_type(sk), ossl_check_X509_TRUST_compfunc_type(cmp)));
}
pub const X509_TRUST_DEFAULT = @as(c_int, 0);
pub const X509_TRUST_COMPAT = @as(c_int, 1);
pub const X509_TRUST_SSL_CLIENT = @as(c_int, 2);
pub const X509_TRUST_SSL_SERVER = @as(c_int, 3);
pub const X509_TRUST_EMAIL = @as(c_int, 4);
pub const X509_TRUST_OBJECT_SIGN = @as(c_int, 5);
pub const X509_TRUST_OCSP_SIGN = @as(c_int, 6);
pub const X509_TRUST_OCSP_REQUEST = @as(c_int, 7);
pub const X509_TRUST_TSA = @as(c_int, 8);
pub const X509_TRUST_MIN = @as(c_int, 1);
pub const X509_TRUST_MAX = @as(c_int, 8);
pub const X509_TRUST_DYNAMIC = @as(c_uint, 1) << @as(c_int, 0);
pub const X509_TRUST_DYNAMIC_NAME = @as(c_uint, 1) << @as(c_int, 1);
pub const X509_TRUST_NO_SS_COMPAT = @as(c_uint, 1) << @as(c_int, 2);
pub const X509_TRUST_DO_SS_COMPAT = @as(c_uint, 1) << @as(c_int, 3);
pub const X509_TRUST_OK_ANY_EKU = @as(c_uint, 1) << @as(c_int, 4);
pub const X509_TRUST_TRUSTED = @as(c_int, 1);
pub const X509_TRUST_REJECTED = @as(c_int, 2);
pub const X509_TRUST_UNTRUSTED = @as(c_int, 3);
pub inline fn X509_STORE_CTX_set_app_data(ctx: anytype, data: anytype) @TypeOf(X509_STORE_CTX_set_ex_data(ctx, @as(c_int, 0), data)) {
    _ = &ctx;
    _ = &data;
    return X509_STORE_CTX_set_ex_data(ctx, @as(c_int, 0), data);
}
pub inline fn X509_STORE_CTX_get_app_data(ctx: anytype) @TypeOf(X509_STORE_CTX_get_ex_data(ctx, @as(c_int, 0))) {
    _ = &ctx;
    return X509_STORE_CTX_get_ex_data(ctx, @as(c_int, 0));
}
pub const X509_L_FILE_LOAD = @as(c_int, 1);
pub const X509_L_ADD_DIR = @as(c_int, 2);
pub const X509_L_ADD_STORE = @as(c_int, 3);
pub const X509_L_LOAD_STORE = @as(c_int, 4);
pub inline fn X509_LOOKUP_load_file(x: anytype, name: anytype, @"type": anytype) @TypeOf(X509_LOOKUP_ctrl(x, X509_L_FILE_LOAD, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL)) {
    _ = &x;
    _ = &name;
    _ = &@"type";
    return X509_LOOKUP_ctrl(x, X509_L_FILE_LOAD, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL);
}
pub inline fn X509_LOOKUP_add_dir(x: anytype, name: anytype, @"type": anytype) @TypeOf(X509_LOOKUP_ctrl(x, X509_L_ADD_DIR, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL)) {
    _ = &x;
    _ = &name;
    _ = &@"type";
    return X509_LOOKUP_ctrl(x, X509_L_ADD_DIR, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL);
}
pub inline fn X509_LOOKUP_add_store(x: anytype, name: anytype) @TypeOf(X509_LOOKUP_ctrl(x, X509_L_ADD_STORE, name, @as(c_int, 0), NULL)) {
    _ = &x;
    _ = &name;
    return X509_LOOKUP_ctrl(x, X509_L_ADD_STORE, name, @as(c_int, 0), NULL);
}
pub inline fn X509_LOOKUP_load_store(x: anytype, name: anytype) @TypeOf(X509_LOOKUP_ctrl(x, X509_L_LOAD_STORE, name, @as(c_int, 0), NULL)) {
    _ = &x;
    _ = &name;
    return X509_LOOKUP_ctrl(x, X509_L_LOAD_STORE, name, @as(c_int, 0), NULL);
}
pub inline fn X509_LOOKUP_load_file_ex(x: anytype, name: anytype, @"type": anytype, libctx: anytype, propq: anytype) @TypeOf(X509_LOOKUP_ctrl_ex(x, X509_L_FILE_LOAD, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL, libctx, propq)) {
    _ = &x;
    _ = &name;
    _ = &@"type";
    _ = &libctx;
    _ = &propq;
    return X509_LOOKUP_ctrl_ex(x, X509_L_FILE_LOAD, name, @import("std").zig.c_translation.cast(c_long, @"type"), NULL, libctx, propq);
}
pub inline fn X509_LOOKUP_load_store_ex(x: anytype, name: anytype, libctx: anytype, propq: anytype) @TypeOf(X509_LOOKUP_ctrl_ex(x, X509_L_LOAD_STORE, name, @as(c_int, 0), NULL, libctx, propq)) {
    _ = &x;
    _ = &name;
    _ = &libctx;
    _ = &propq;
    return X509_LOOKUP_ctrl_ex(x, X509_L_LOAD_STORE, name, @as(c_int, 0), NULL, libctx, propq);
}
pub inline fn X509_LOOKUP_add_store_ex(x: anytype, name: anytype, libctx: anytype, propq: anytype) @TypeOf(X509_LOOKUP_ctrl_ex(x, X509_L_ADD_STORE, name, @as(c_int, 0), NULL, libctx, propq)) {
    _ = &x;
    _ = &name;
    _ = &libctx;
    _ = &propq;
    return X509_LOOKUP_ctrl_ex(x, X509_L_ADD_STORE, name, @as(c_int, 0), NULL, libctx, propq);
}
pub const X509_V_OK = @as(c_int, 0);
pub const X509_V_ERR_UNSPECIFIED = @as(c_int, 1);
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT = @as(c_int, 2);
pub const X509_V_ERR_UNABLE_TO_GET_CRL = @as(c_int, 3);
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE = @as(c_int, 4);
pub const X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE = @as(c_int, 5);
pub const X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY = @as(c_int, 6);
pub const X509_V_ERR_CERT_SIGNATURE_FAILURE = @as(c_int, 7);
pub const X509_V_ERR_CRL_SIGNATURE_FAILURE = @as(c_int, 8);
pub const X509_V_ERR_CERT_NOT_YET_VALID = @as(c_int, 9);
pub const X509_V_ERR_CERT_HAS_EXPIRED = @as(c_int, 10);
pub const X509_V_ERR_CRL_NOT_YET_VALID = @as(c_int, 11);
pub const X509_V_ERR_CRL_HAS_EXPIRED = @as(c_int, 12);
pub const X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD = @as(c_int, 13);
pub const X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD = @as(c_int, 14);
pub const X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD = @as(c_int, 15);
pub const X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD = @as(c_int, 16);
pub const X509_V_ERR_OUT_OF_MEM = @as(c_int, 17);
pub const X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT = @as(c_int, 18);
pub const X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN = @as(c_int, 19);
pub const X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY = @as(c_int, 20);
pub const X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE = @as(c_int, 21);
pub const X509_V_ERR_CERT_CHAIN_TOO_LONG = @as(c_int, 22);
pub const X509_V_ERR_CERT_REVOKED = @as(c_int, 23);
pub const X509_V_ERR_NO_ISSUER_PUBLIC_KEY = @as(c_int, 24);
pub const X509_V_ERR_PATH_LENGTH_EXCEEDED = @as(c_int, 25);
pub const X509_V_ERR_INVALID_PURPOSE = @as(c_int, 26);
pub const X509_V_ERR_CERT_UNTRUSTED = @as(c_int, 27);
pub const X509_V_ERR_CERT_REJECTED = @as(c_int, 28);
pub const X509_V_ERR_SUBJECT_ISSUER_MISMATCH = @as(c_int, 29);
pub const X509_V_ERR_AKID_SKID_MISMATCH = @as(c_int, 30);
pub const X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH = @as(c_int, 31);
pub const X509_V_ERR_KEYUSAGE_NO_CERTSIGN = @as(c_int, 32);
pub const X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER = @as(c_int, 33);
pub const X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION = @as(c_int, 34);
pub const X509_V_ERR_KEYUSAGE_NO_CRL_SIGN = @as(c_int, 35);
pub const X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = @as(c_int, 36);
pub const X509_V_ERR_INVALID_NON_CA = @as(c_int, 37);
pub const X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED = @as(c_int, 38);
pub const X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = @as(c_int, 39);
pub const X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = @as(c_int, 40);
pub const X509_V_ERR_INVALID_EXTENSION = @as(c_int, 41);
pub const X509_V_ERR_INVALID_POLICY_EXTENSION = @as(c_int, 42);
pub const X509_V_ERR_NO_EXPLICIT_POLICY = @as(c_int, 43);
pub const X509_V_ERR_DIFFERENT_CRL_SCOPE = @as(c_int, 44);
pub const X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE = @as(c_int, 45);
pub const X509_V_ERR_UNNESTED_RESOURCE = @as(c_int, 46);
pub const X509_V_ERR_PERMITTED_VIOLATION = @as(c_int, 47);
pub const X509_V_ERR_EXCLUDED_VIOLATION = @as(c_int, 48);
pub const X509_V_ERR_SUBTREE_MINMAX = @as(c_int, 49);
pub const X509_V_ERR_APPLICATION_VERIFICATION = @as(c_int, 50);
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = @as(c_int, 51);
pub const X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = @as(c_int, 52);
pub const X509_V_ERR_UNSUPPORTED_NAME_SYNTAX = @as(c_int, 53);
pub const X509_V_ERR_CRL_PATH_VALIDATION_ERROR = @as(c_int, 54);
pub const X509_V_ERR_PATH_LOOP = @as(c_int, 55);
pub const X509_V_ERR_SUITE_B_INVALID_VERSION = @as(c_int, 56);
pub const X509_V_ERR_SUITE_B_INVALID_ALGORITHM = @as(c_int, 57);
pub const X509_V_ERR_SUITE_B_INVALID_CURVE = @as(c_int, 58);
pub const X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = @as(c_int, 59);
pub const X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED = @as(c_int, 60);
pub const X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = @as(c_int, 61);
pub const X509_V_ERR_HOSTNAME_MISMATCH = @as(c_int, 62);
pub const X509_V_ERR_EMAIL_MISMATCH = @as(c_int, 63);
pub const X509_V_ERR_IP_ADDRESS_MISMATCH = @as(c_int, 64);
pub const X509_V_ERR_DANE_NO_MATCH = @as(c_int, 65);
pub const X509_V_ERR_EE_KEY_TOO_SMALL = @as(c_int, 66);
pub const X509_V_ERR_CA_KEY_TOO_SMALL = @as(c_int, 67);
pub const X509_V_ERR_CA_MD_TOO_WEAK = @as(c_int, 68);
pub const X509_V_ERR_INVALID_CALL = @as(c_int, 69);
pub const X509_V_ERR_STORE_LOOKUP = @as(c_int, 70);
pub const X509_V_ERR_NO_VALID_SCTS = @as(c_int, 71);
pub const X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION = @as(c_int, 72);
pub const X509_V_ERR_OCSP_VERIFY_NEEDED = @as(c_int, 73);
pub const X509_V_ERR_OCSP_VERIFY_FAILED = @as(c_int, 74);
pub const X509_V_ERR_OCSP_CERT_UNKNOWN = @as(c_int, 75);
pub const X509_V_ERR_UNSUPPORTED_SIGNATURE_ALGORITHM = @as(c_int, 76);
pub const X509_V_ERR_SIGNATURE_ALGORITHM_MISMATCH = @as(c_int, 77);
pub const X509_V_ERR_SIGNATURE_ALGORITHM_INCONSISTENCY = @as(c_int, 78);
pub const X509_V_ERR_INVALID_CA = @as(c_int, 79);
pub const X509_V_ERR_PATHLEN_INVALID_FOR_NON_CA = @as(c_int, 80);
pub const X509_V_ERR_PATHLEN_WITHOUT_KU_KEY_CERT_SIGN = @as(c_int, 81);
pub const X509_V_ERR_KU_KEY_CERT_SIGN_INVALID_FOR_NON_CA = @as(c_int, 82);
pub const X509_V_ERR_ISSUER_NAME_EMPTY = @as(c_int, 83);
pub const X509_V_ERR_SUBJECT_NAME_EMPTY = @as(c_int, 84);
pub const X509_V_ERR_MISSING_AUTHORITY_KEY_IDENTIFIER = @as(c_int, 85);
pub const X509_V_ERR_MISSING_SUBJECT_KEY_IDENTIFIER = @as(c_int, 86);
pub const X509_V_ERR_EMPTY_SUBJECT_ALT_NAME = @as(c_int, 87);
pub const X509_V_ERR_EMPTY_SUBJECT_SAN_NOT_CRITICAL = @as(c_int, 88);
pub const X509_V_ERR_CA_BCONS_NOT_CRITICAL = @as(c_int, 89);
pub const X509_V_ERR_AUTHORITY_KEY_IDENTIFIER_CRITICAL = @as(c_int, 90);
pub const X509_V_ERR_SUBJECT_KEY_IDENTIFIER_CRITICAL = @as(c_int, 91);
pub const X509_V_ERR_CA_CERT_MISSING_KEY_USAGE = @as(c_int, 92);
pub const X509_V_ERR_EXTENSIONS_REQUIRE_VERSION_3 = @as(c_int, 93);
pub const X509_V_ERR_EC_KEY_EXPLICIT_PARAMS = @as(c_int, 94);
pub const X509_V_ERR_RPK_UNTRUSTED = @as(c_int, 95);
pub const X509_V_FLAG_CB_ISSUER_CHECK = @as(c_int, 0x0);
pub const X509_V_FLAG_USE_CHECK_TIME = @as(c_int, 0x2);
pub const X509_V_FLAG_CRL_CHECK = @as(c_int, 0x4);
pub const X509_V_FLAG_CRL_CHECK_ALL = @as(c_int, 0x8);
pub const X509_V_FLAG_IGNORE_CRITICAL = @as(c_int, 0x10);
pub const X509_V_FLAG_X509_STRICT = @as(c_int, 0x20);
pub const X509_V_FLAG_ALLOW_PROXY_CERTS = @as(c_int, 0x40);
pub const X509_V_FLAG_POLICY_CHECK = @as(c_int, 0x80);
pub const X509_V_FLAG_EXPLICIT_POLICY = @as(c_int, 0x100);
pub const X509_V_FLAG_INHIBIT_ANY = @as(c_int, 0x200);
pub const X509_V_FLAG_INHIBIT_MAP = @as(c_int, 0x400);
pub const X509_V_FLAG_NOTIFY_POLICY = @as(c_int, 0x800);
pub const X509_V_FLAG_EXTENDED_CRL_SUPPORT = @as(c_int, 0x1000);
pub const X509_V_FLAG_USE_DELTAS = @as(c_int, 0x2000);
pub const X509_V_FLAG_CHECK_SS_SIGNATURE = @as(c_int, 0x4000);
pub const X509_V_FLAG_TRUSTED_FIRST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const X509_V_FLAG_SUITEB_128_LOS_ONLY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const X509_V_FLAG_SUITEB_192_LOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000, .hex);
pub const X509_V_FLAG_SUITEB_128_LOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x30000, .hex);
pub const X509_V_FLAG_PARTIAL_CHAIN = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000, .hex);
pub const X509_V_FLAG_NO_ALT_CHAINS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100000, .hex);
pub const X509_V_FLAG_NO_CHECK_TIME = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x200000, .hex);
pub const X509_VP_FLAG_DEFAULT = @as(c_int, 0x1);
pub const X509_VP_FLAG_OVERWRITE = @as(c_int, 0x2);
pub const X509_VP_FLAG_RESET_FLAGS = @as(c_int, 0x4);
pub const X509_VP_FLAG_LOCKED = @as(c_int, 0x8);
pub const X509_VP_FLAG_ONCE = @as(c_int, 0x10);
pub const X509_V_FLAG_POLICY_MASK = ((X509_V_FLAG_POLICY_CHECK | X509_V_FLAG_EXPLICIT_POLICY) | X509_V_FLAG_INHIBIT_ANY) | X509_V_FLAG_INHIBIT_MAP;
pub inline fn X509_STORE_set_verify_func(ctx: anytype, func: anytype) @TypeOf(X509_STORE_set_verify(ctx, func)) {
    _ = &ctx;
    _ = &func;
    return X509_STORE_set_verify(ctx, func);
}
pub inline fn X509_STORE_set_verify_cb_func(ctx: anytype, func: anytype) @TypeOf(X509_STORE_set_verify_cb(ctx, func)) {
    _ = &ctx;
    _ = &func;
    return X509_STORE_set_verify_cb(ctx, func);
}
pub inline fn X509_STORE_set_lookup_crls_cb(ctx: anytype, func: anytype) @TypeOf(X509_STORE_set_lookup_crls(ctx, func)) {
    _ = &ctx;
    _ = &func;
    return X509_STORE_set_lookup_crls(ctx, func);
}
pub inline fn X509_STORE_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE, l, p, newf, dupf, freef);
}
pub const X509_STORE_CTX_get_chain = X509_STORE_CTX_get0_chain;
pub const X509_STORE_CTX_set_chain = X509_STORE_CTX_set0_untrusted;
pub const X509_STORE_CTX_trusted_stack = X509_STORE_CTX_set0_trusted_stack;
pub const X509_STORE_get_by_subject = X509_STORE_CTX_get_by_subject;
pub const X509_STORE_get1_certs = X509_STORE_CTX_get1_certs;
pub const X509_STORE_get1_crls = X509_STORE_CTX_get1_crls;
pub const X509_STORE_get1_cert = X509_STORE_CTX_get1_certs;
pub const X509_STORE_get1_crl = X509_STORE_CTX_get1_crls;
pub inline fn X509_STORE_CTX_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, l, p, newf, dupf, freef);
}
pub const DANE_FLAG_NO_DANE_EE_NAMECHECKS = @as(c_long, 1) << @as(c_int, 0);
pub const X509_PCY_TREE_FAILURE = -@as(c_int, 2);
pub const X509_PCY_TREE_INVALID = -@as(c_int, 1);
pub const X509_PCY_TREE_INTERNAL = @as(c_int, 0);
pub const X509_PCY_TREE_VALID = @as(c_int, 1);
pub const X509_PCY_TREE_EMPTY = @as(c_int, 2);
pub const X509_PCY_TREE_EXPLICIT = @as(c_int, 4);
pub const OPENSSL_PKCS7_H = "";
pub const HEADER_PKCS7_H = "";
pub const OPENSSL_PKCS7ERR_H = "";
pub const PKCS7_R_CERTIFICATE_VERIFY_ERROR = @as(c_int, 117);
pub const PKCS7_R_CIPHER_HAS_NO_OBJECT_IDENTIFIER = @as(c_int, 144);
pub const PKCS7_R_CIPHER_NOT_INITIALIZED = @as(c_int, 116);
pub const PKCS7_R_CONTENT_AND_DATA_PRESENT = @as(c_int, 118);
pub const PKCS7_R_CTRL_ERROR = @as(c_int, 152);
pub const PKCS7_R_DECRYPT_ERROR = @as(c_int, 119);
pub const PKCS7_R_DIGEST_FAILURE = @as(c_int, 101);
pub const PKCS7_R_ENCRYPTION_CTRL_FAILURE = @as(c_int, 149);
pub const PKCS7_R_ENCRYPTION_NOT_SUPPORTED_FOR_THIS_KEY_TYPE = @as(c_int, 150);
pub const PKCS7_R_ERROR_ADDING_RECIPIENT = @as(c_int, 120);
pub const PKCS7_R_ERROR_SETTING_CIPHER = @as(c_int, 121);
pub const PKCS7_R_INVALID_NULL_POINTER = @as(c_int, 143);
pub const PKCS7_R_INVALID_SIGNED_DATA_TYPE = @as(c_int, 155);
pub const PKCS7_R_NO_CONTENT = @as(c_int, 122);
pub const PKCS7_R_NO_DEFAULT_DIGEST = @as(c_int, 151);
pub const PKCS7_R_NO_MATCHING_DIGEST_TYPE_FOUND = @as(c_int, 154);
pub const PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE = @as(c_int, 115);
pub const PKCS7_R_NO_SIGNATURES_ON_DATA = @as(c_int, 123);
pub const PKCS7_R_NO_SIGNERS = @as(c_int, 142);
pub const PKCS7_R_OPERATION_NOT_SUPPORTED_ON_THIS_TYPE = @as(c_int, 104);
pub const PKCS7_R_PKCS7_ADD_SIGNATURE_ERROR = @as(c_int, 124);
pub const PKCS7_R_PKCS7_ADD_SIGNER_ERROR = @as(c_int, 153);
pub const PKCS7_R_PKCS7_DATASIGN = @as(c_int, 145);
pub const PKCS7_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE = @as(c_int, 127);
pub const PKCS7_R_SIGNATURE_FAILURE = @as(c_int, 105);
pub const PKCS7_R_SIGNER_CERTIFICATE_NOT_FOUND = @as(c_int, 128);
pub const PKCS7_R_SIGNING_CTRL_FAILURE = @as(c_int, 147);
pub const PKCS7_R_SIGNING_NOT_SUPPORTED_FOR_THIS_KEY_TYPE = @as(c_int, 148);
pub const PKCS7_R_SMIME_TEXT_ERROR = @as(c_int, 129);
pub const PKCS7_R_UNABLE_TO_FIND_CERTIFICATE = @as(c_int, 106);
pub const PKCS7_R_UNABLE_TO_FIND_MEM_BIO = @as(c_int, 107);
pub const PKCS7_R_UNABLE_TO_FIND_MESSAGE_DIGEST = @as(c_int, 108);
pub const PKCS7_R_UNKNOWN_DIGEST_TYPE = @as(c_int, 109);
pub const PKCS7_R_UNKNOWN_OPERATION = @as(c_int, 110);
pub const PKCS7_R_UNSUPPORTED_CIPHER_TYPE = @as(c_int, 111);
pub const PKCS7_R_UNSUPPORTED_CONTENT_TYPE = @as(c_int, 112);
pub const PKCS7_R_WRONG_CONTENT_TYPE = @as(c_int, 113);
pub const PKCS7_R_WRONG_PKCS7_TYPE = @as(c_int, 114);
pub inline fn sk_PKCS7_SIGNER_INFO_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_PKCS7_SIGNER_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_PKCS7_SIGNER_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_SIGNER_INFO_value(sk: anytype, idx: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_value(ossl_check_const_PKCS7_SIGNER_INFO_sk_type(sk), idx));
}
pub const sk_PKCS7_SIGNER_INFO_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:72:9
pub const sk_PKCS7_SIGNER_INFO_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:73:9
pub const sk_PKCS7_SIGNER_INFO_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:74:9
pub inline fn sk_PKCS7_SIGNER_INFO_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), n);
}
pub inline fn sk_PKCS7_SIGNER_INFO_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_SIGNER_INFO_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_SIGNER_INFO_delete(sk: anytype, i: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_delete(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), i));
}
pub inline fn sk_PKCS7_SIGNER_INFO_delete_ptr(sk: anytype, ptr: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_delete_ptr(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr)));
}
pub inline fn sk_PKCS7_SIGNER_INFO_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr));
}
pub inline fn sk_PKCS7_SIGNER_INFO_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr));
}
pub inline fn sk_PKCS7_SIGNER_INFO_pop(sk: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_pop(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk)));
}
pub inline fn sk_PKCS7_SIGNER_INFO_shift(sk: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_shift(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk)));
}
pub inline fn sk_PKCS7_SIGNER_INFO_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_freefunc_type(freefunc));
}
pub inline fn sk_PKCS7_SIGNER_INFO_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr), idx);
}
pub inline fn sk_PKCS7_SIGNER_INFO_set(sk: anytype, idx: anytype, ptr: anytype) [*c]PKCS7_SIGNER_INFO {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7_SIGNER_INFO, OPENSSL_sk_set(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), idx, ossl_check_PKCS7_SIGNER_INFO_type(ptr)));
}
pub inline fn sk_PKCS7_SIGNER_INFO_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr));
}
pub inline fn sk_PKCS7_SIGNER_INFO_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr));
}
pub inline fn sk_PKCS7_SIGNER_INFO_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_type(ptr), pnum);
}
pub inline fn sk_PKCS7_SIGNER_INFO_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_SIGNER_INFO_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_SIGNER_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_SIGNER_INFO_sk_type(sk));
}
pub const sk_PKCS7_SIGNER_INFO_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:92:9
pub const sk_PKCS7_SIGNER_INFO_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:93:9
pub inline fn sk_PKCS7_SIGNER_INFO_set_cmp_func(sk: anytype, cmp: anytype) sk_PKCS7_SIGNER_INFO_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_PKCS7_SIGNER_INFO_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_PKCS7_SIGNER_INFO_sk_type(sk), ossl_check_PKCS7_SIGNER_INFO_compfunc_type(cmp)));
}
pub inline fn sk_PKCS7_RECIP_INFO_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_PKCS7_RECIP_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_PKCS7_RECIP_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_RECIP_INFO_value(sk: anytype, idx: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_value(ossl_check_const_PKCS7_RECIP_INFO_sk_type(sk), idx));
}
pub const sk_PKCS7_RECIP_INFO_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:108:9
pub const sk_PKCS7_RECIP_INFO_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:109:9
pub const sk_PKCS7_RECIP_INFO_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:110:9
pub inline fn sk_PKCS7_RECIP_INFO_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), n);
}
pub inline fn sk_PKCS7_RECIP_INFO_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_PKCS7_RECIP_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_PKCS7_RECIP_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_RECIP_INFO_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_PKCS7_RECIP_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_PKCS7_RECIP_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_RECIP_INFO_delete(sk: anytype, i: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_delete(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), i));
}
pub inline fn sk_PKCS7_RECIP_INFO_delete_ptr(sk: anytype, ptr: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_delete_ptr(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr)));
}
pub inline fn sk_PKCS7_RECIP_INFO_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr));
}
pub inline fn sk_PKCS7_RECIP_INFO_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr));
}
pub inline fn sk_PKCS7_RECIP_INFO_pop(sk: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_pop(ossl_check_PKCS7_RECIP_INFO_sk_type(sk)));
}
pub inline fn sk_PKCS7_RECIP_INFO_shift(sk: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_shift(ossl_check_PKCS7_RECIP_INFO_sk_type(sk)));
}
pub inline fn sk_PKCS7_RECIP_INFO_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_freefunc_type(freefunc));
}
pub inline fn sk_PKCS7_RECIP_INFO_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr), idx);
}
pub inline fn sk_PKCS7_RECIP_INFO_set(sk: anytype, idx: anytype, ptr: anytype) [*c]PKCS7_RECIP_INFO {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7_RECIP_INFO, OPENSSL_sk_set(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), idx, ossl_check_PKCS7_RECIP_INFO_type(ptr)));
}
pub inline fn sk_PKCS7_RECIP_INFO_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr));
}
pub inline fn sk_PKCS7_RECIP_INFO_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr));
}
pub inline fn sk_PKCS7_RECIP_INFO_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_type(ptr), pnum);
}
pub inline fn sk_PKCS7_RECIP_INFO_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_PKCS7_RECIP_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_PKCS7_RECIP_INFO_sk_type(sk));
}
pub inline fn sk_PKCS7_RECIP_INFO_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_RECIP_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_RECIP_INFO_sk_type(sk));
}
pub const sk_PKCS7_RECIP_INFO_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:128:9
pub const sk_PKCS7_RECIP_INFO_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:129:9
pub inline fn sk_PKCS7_RECIP_INFO_set_cmp_func(sk: anytype, cmp: anytype) sk_PKCS7_RECIP_INFO_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_PKCS7_RECIP_INFO_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_PKCS7_RECIP_INFO_sk_type(sk), ossl_check_PKCS7_RECIP_INFO_compfunc_type(cmp)));
}
pub const PKCS7_S_HEADER = @as(c_int, 0);
pub const PKCS7_S_BODY = @as(c_int, 1);
pub const PKCS7_S_TAIL = @as(c_int, 2);
pub inline fn sk_PKCS7_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_PKCS7_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_PKCS7_sk_type(sk));
}
pub inline fn sk_PKCS7_value(sk: anytype, idx: anytype) [*c]PKCS7 {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_value(ossl_check_const_PKCS7_sk_type(sk), idx));
}
pub const sk_PKCS7_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:223:9
pub const sk_PKCS7_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:224:9
pub const sk_PKCS7_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:225:9
pub inline fn sk_PKCS7_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_PKCS7_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_PKCS7_sk_type(sk), n);
}
pub inline fn sk_PKCS7_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_PKCS7_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_PKCS7_sk_type(sk));
}
pub inline fn sk_PKCS7_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_PKCS7_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_PKCS7_sk_type(sk));
}
pub inline fn sk_PKCS7_delete(sk: anytype, i: anytype) [*c]PKCS7 {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_delete(ossl_check_PKCS7_sk_type(sk), i));
}
pub inline fn sk_PKCS7_delete_ptr(sk: anytype, ptr: anytype) [*c]PKCS7 {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_delete_ptr(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr)));
}
pub inline fn sk_PKCS7_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr));
}
pub inline fn sk_PKCS7_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr));
}
pub inline fn sk_PKCS7_pop(sk: anytype) [*c]PKCS7 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_pop(ossl_check_PKCS7_sk_type(sk)));
}
pub inline fn sk_PKCS7_shift(sk: anytype) [*c]PKCS7 {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_shift(ossl_check_PKCS7_sk_type(sk)));
}
pub inline fn sk_PKCS7_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_freefunc_type(freefunc));
}
pub inline fn sk_PKCS7_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr), idx);
}
pub inline fn sk_PKCS7_set(sk: anytype, idx: anytype, ptr: anytype) [*c]PKCS7 {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PKCS7, OPENSSL_sk_set(ossl_check_PKCS7_sk_type(sk), idx, ossl_check_PKCS7_type(ptr)));
}
pub inline fn sk_PKCS7_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr));
}
pub inline fn sk_PKCS7_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr));
}
pub inline fn sk_PKCS7_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_type(ptr), pnum);
}
pub inline fn sk_PKCS7_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_PKCS7_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_PKCS7_sk_type(sk));
}
pub inline fn sk_PKCS7_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_PKCS7_sk_type(sk));
}
pub const sk_PKCS7_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:243:9
pub const sk_PKCS7_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/pkcs7.h:244:9
pub inline fn sk_PKCS7_set_cmp_func(sk: anytype, cmp: anytype) sk_PKCS7_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_PKCS7_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_PKCS7_sk_type(sk), ossl_check_PKCS7_compfunc_type(cmp)));
}
pub const PKCS7_OP_SET_DETACHED_SIGNATURE = @as(c_int, 1);
pub const PKCS7_OP_GET_DETACHED_SIGNATURE = @as(c_int, 2);
pub inline fn PKCS7_get_signed_attributes(si: anytype) @TypeOf(si.*.auth_attr) {
    _ = &si;
    return si.*.auth_attr;
}
pub inline fn PKCS7_get_attributes(si: anytype) @TypeOf(si.*.unauth_attr) {
    _ = &si;
    return si.*.unauth_attr;
}
pub inline fn PKCS7_type_is_signed(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_signed) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_signed;
}
pub inline fn PKCS7_type_is_encrypted(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_encrypted) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_encrypted;
}
pub inline fn PKCS7_type_is_enveloped(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_enveloped) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_enveloped;
}
pub inline fn PKCS7_type_is_signedAndEnveloped(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_signedAndEnveloped) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_signedAndEnveloped;
}
pub inline fn PKCS7_type_is_data(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_data) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_data;
}
pub inline fn PKCS7_type_is_digest(a: anytype) @TypeOf(OBJ_obj2nid(a.*.type) == NID_pkcs7_digest) {
    _ = &a;
    return OBJ_obj2nid(a.*.type) == NID_pkcs7_digest;
}
pub inline fn PKCS7_set_detached(p: anytype, v: anytype) @TypeOf(PKCS7_ctrl(p, PKCS7_OP_SET_DETACHED_SIGNATURE, v, NULL)) {
    _ = &p;
    _ = &v;
    return PKCS7_ctrl(p, PKCS7_OP_SET_DETACHED_SIGNATURE, v, NULL);
}
pub inline fn PKCS7_get_detached(p: anytype) @TypeOf(PKCS7_ctrl(p, PKCS7_OP_GET_DETACHED_SIGNATURE, @as(c_int, 0), NULL)) {
    _ = &p;
    return PKCS7_ctrl(p, PKCS7_OP_GET_DETACHED_SIGNATURE, @as(c_int, 0), NULL);
}
pub inline fn PKCS7_is_detached(p7: anytype) @TypeOf((PKCS7_type_is_signed(p7) != 0) and (PKCS7_get_detached(p7) != 0)) {
    _ = &p7;
    return (PKCS7_type_is_signed(p7) != 0) and (PKCS7_get_detached(p7) != 0);
}
pub const PKCS7_TEXT = @as(c_int, 0x1);
pub const PKCS7_NOCERTS = @as(c_int, 0x2);
pub const PKCS7_NOSIGS = @as(c_int, 0x4);
pub const PKCS7_NOCHAIN = @as(c_int, 0x8);
pub const PKCS7_NOINTERN = @as(c_int, 0x10);
pub const PKCS7_NOVERIFY = @as(c_int, 0x20);
pub const PKCS7_DETACHED = @as(c_int, 0x40);
pub const PKCS7_BINARY = @as(c_int, 0x80);
pub const PKCS7_NOATTR = @as(c_int, 0x100);
pub const PKCS7_NOSMIMECAP = @as(c_int, 0x200);
pub const PKCS7_NOOLDMIMETYPE = @as(c_int, 0x400);
pub const PKCS7_CRLFEOL = @as(c_int, 0x800);
pub const PKCS7_STREAM = @as(c_int, 0x1000);
pub const PKCS7_NOCRL = @as(c_int, 0x2000);
pub const PKCS7_PARTIAL = @as(c_int, 0x4000);
pub const PKCS7_REUSE_DIGEST = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub const PKCS7_NO_DUAL_CONTENT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const SMIME_TEXT = PKCS7_TEXT;
pub const SMIME_NOCERTS = PKCS7_NOCERTS;
pub const SMIME_NOSIGS = PKCS7_NOSIGS;
pub const SMIME_NOCHAIN = PKCS7_NOCHAIN;
pub const SMIME_NOINTERN = PKCS7_NOINTERN;
pub const SMIME_NOVERIFY = PKCS7_NOVERIFY;
pub const SMIME_DETACHED = PKCS7_DETACHED;
pub const SMIME_BINARY = PKCS7_BINARY;
pub const SMIME_NOATTR = PKCS7_NOATTR;
pub const SMIME_ASCIICRLF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000, .hex);
pub const X509_EXT_PACK_UNKNOWN = @as(c_int, 1);
pub const X509_EXT_PACK_STRING = @as(c_int, 2);
pub inline fn X509_extract_key(x: anytype) @TypeOf(X509_get_pubkey(x)) {
    _ = &x;
    return X509_get_pubkey(x);
}
pub inline fn X509_REQ_extract_key(a: anytype) @TypeOf(X509_REQ_get_pubkey(a)) {
    _ = &a;
    return X509_REQ_get_pubkey(a);
}
pub inline fn X509_name_cmp(a: anytype, b: anytype) @TypeOf(X509_NAME_cmp(a, b)) {
    _ = &a;
    _ = &b;
    return X509_NAME_cmp(a, b);
}
pub const OPENSSL_HTTP_H = "";
pub const OPENSSL_CONF_H = "";
pub const HEADER_CONF_H = "";
pub const OPENSSL_CONFERR_H = "";
pub const CONF_R_ERROR_LOADING_DSO = @as(c_int, 110);
pub const CONF_R_INVALID_PRAGMA = @as(c_int, 122);
pub const CONF_R_LIST_CANNOT_BE_NULL = @as(c_int, 115);
pub const CONF_R_MANDATORY_BRACES_IN_VARIABLE_EXPANSION = @as(c_int, 123);
pub const CONF_R_MISSING_CLOSE_SQUARE_BRACKET = @as(c_int, 100);
pub const CONF_R_MISSING_EQUAL_SIGN = @as(c_int, 101);
pub const CONF_R_MISSING_INIT_FUNCTION = @as(c_int, 112);
pub const CONF_R_MODULE_INITIALIZATION_ERROR = @as(c_int, 109);
pub const CONF_R_NO_CLOSE_BRACE = @as(c_int, 102);
pub const CONF_R_NO_CONF = @as(c_int, 105);
pub const CONF_R_NO_CONF_OR_ENVIRONMENT_VARIABLE = @as(c_int, 106);
pub const CONF_R_NO_SECTION = @as(c_int, 107);
pub const CONF_R_NO_SUCH_FILE = @as(c_int, 114);
pub const CONF_R_NO_VALUE = @as(c_int, 108);
pub const CONF_R_NUMBER_TOO_LARGE = @as(c_int, 121);
pub const CONF_R_OPENSSL_CONF_REFERENCES_MISSING_SECTION = @as(c_int, 124);
pub const CONF_R_RECURSIVE_DIRECTORY_INCLUDE = @as(c_int, 111);
pub const CONF_R_RECURSIVE_SECTION_REFERENCE = @as(c_int, 126);
pub const CONF_R_RELATIVE_PATH = @as(c_int, 125);
pub const CONF_R_SSL_COMMAND_SECTION_EMPTY = @as(c_int, 117);
pub const CONF_R_SSL_COMMAND_SECTION_NOT_FOUND = @as(c_int, 118);
pub const CONF_R_SSL_SECTION_EMPTY = @as(c_int, 119);
pub const CONF_R_SSL_SECTION_NOT_FOUND = @as(c_int, 120);
pub const CONF_R_UNABLE_TO_CREATE_NEW_SECTION = @as(c_int, 103);
pub const CONF_R_UNKNOWN_MODULE_NAME = @as(c_int, 113);
pub const CONF_R_VARIABLE_EXPANSION_TOO_LONG = @as(c_int, 116);
pub const CONF_R_VARIABLE_HAS_NO_VALUE = @as(c_int, 104);
pub inline fn sk_CONF_VALUE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_CONF_VALUE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_CONF_VALUE_sk_type(sk));
}
pub inline fn sk_CONF_VALUE_value(sk: anytype, idx: anytype) [*c]CONF_VALUE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_value(ossl_check_const_CONF_VALUE_sk_type(sk), idx));
}
pub const sk_CONF_VALUE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/conf.h:47:9
pub const sk_CONF_VALUE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/conf.h:48:9
pub const sk_CONF_VALUE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/conf.h:49:9
pub inline fn sk_CONF_VALUE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_CONF_VALUE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_CONF_VALUE_sk_type(sk), n);
}
pub inline fn sk_CONF_VALUE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_CONF_VALUE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_CONF_VALUE_sk_type(sk));
}
pub inline fn sk_CONF_VALUE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_CONF_VALUE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_CONF_VALUE_sk_type(sk));
}
pub inline fn sk_CONF_VALUE_delete(sk: anytype, i: anytype) [*c]CONF_VALUE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_delete(ossl_check_CONF_VALUE_sk_type(sk), i));
}
pub inline fn sk_CONF_VALUE_delete_ptr(sk: anytype, ptr: anytype) [*c]CONF_VALUE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_delete_ptr(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr)));
}
pub inline fn sk_CONF_VALUE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr));
}
pub inline fn sk_CONF_VALUE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr));
}
pub inline fn sk_CONF_VALUE_pop(sk: anytype) [*c]CONF_VALUE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_pop(ossl_check_CONF_VALUE_sk_type(sk)));
}
pub inline fn sk_CONF_VALUE_shift(sk: anytype) [*c]CONF_VALUE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_shift(ossl_check_CONF_VALUE_sk_type(sk)));
}
pub inline fn sk_CONF_VALUE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_freefunc_type(freefunc));
}
pub inline fn sk_CONF_VALUE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr), idx);
}
pub inline fn sk_CONF_VALUE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]CONF_VALUE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_sk_set(ossl_check_CONF_VALUE_sk_type(sk), idx, ossl_check_CONF_VALUE_type(ptr)));
}
pub inline fn sk_CONF_VALUE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr));
}
pub inline fn sk_CONF_VALUE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr));
}
pub inline fn sk_CONF_VALUE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_type(ptr), pnum);
}
pub inline fn sk_CONF_VALUE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_CONF_VALUE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_CONF_VALUE_sk_type(sk));
}
pub inline fn sk_CONF_VALUE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_CONF_VALUE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_CONF_VALUE_sk_type(sk));
}
pub const sk_CONF_VALUE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/conf.h:67:9
pub const sk_CONF_VALUE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/conf.h:68:9
pub inline fn sk_CONF_VALUE_set_cmp_func(sk: anytype, cmp: anytype) sk_CONF_VALUE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_CONF_VALUE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_CONF_VALUE_sk_type(sk), ossl_check_CONF_VALUE_compfunc_type(cmp)));
}
pub const lh_CONF_VALUE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/conf.h:71:9
pub inline fn lh_CONF_VALUE_free(lh: anytype) @TypeOf(OPENSSL_LH_free(ossl_check_CONF_VALUE_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_free(ossl_check_CONF_VALUE_lh_type(lh));
}
pub inline fn lh_CONF_VALUE_flush(lh: anytype) @TypeOf(OPENSSL_LH_flush(ossl_check_CONF_VALUE_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_flush(ossl_check_CONF_VALUE_lh_type(lh));
}
pub inline fn lh_CONF_VALUE_insert(lh: anytype, ptr: anytype) [*c]CONF_VALUE {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_LH_insert(ossl_check_CONF_VALUE_lh_type(lh), ossl_check_CONF_VALUE_lh_plain_type(ptr)));
}
pub inline fn lh_CONF_VALUE_delete(lh: anytype, ptr: anytype) [*c]CONF_VALUE {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_LH_delete(ossl_check_CONF_VALUE_lh_type(lh), ossl_check_const_CONF_VALUE_lh_plain_type(ptr)));
}
pub inline fn lh_CONF_VALUE_retrieve(lh: anytype, ptr: anytype) [*c]CONF_VALUE {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CONF_VALUE, OPENSSL_LH_retrieve(ossl_check_CONF_VALUE_lh_type(lh), ossl_check_const_CONF_VALUE_lh_plain_type(ptr)));
}
pub inline fn lh_CONF_VALUE_error(lh: anytype) @TypeOf(OPENSSL_LH_error(ossl_check_CONF_VALUE_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_error(ossl_check_CONF_VALUE_lh_type(lh));
}
pub inline fn lh_CONF_VALUE_num_items(lh: anytype) @TypeOf(OPENSSL_LH_num_items(ossl_check_CONF_VALUE_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_num_items(ossl_check_CONF_VALUE_lh_type(lh));
}
pub inline fn lh_CONF_VALUE_node_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out);
}
pub inline fn lh_CONF_VALUE_node_usage_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_usage_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_usage_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out);
}
pub inline fn lh_CONF_VALUE_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_stats_bio(ossl_check_const_CONF_VALUE_lh_type(lh), out);
}
pub inline fn lh_CONF_VALUE_get_down_load(lh: anytype) @TypeOf(OPENSSL_LH_get_down_load(ossl_check_CONF_VALUE_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_get_down_load(ossl_check_CONF_VALUE_lh_type(lh));
}
pub inline fn lh_CONF_VALUE_set_down_load(lh: anytype, dl: anytype) @TypeOf(OPENSSL_LH_set_down_load(ossl_check_CONF_VALUE_lh_type(lh), dl)) {
    _ = &lh;
    _ = &dl;
    return OPENSSL_LH_set_down_load(ossl_check_CONF_VALUE_lh_type(lh), dl);
}
pub inline fn lh_CONF_VALUE_doall(lh: anytype, dfn: anytype) @TypeOf(OPENSSL_LH_doall(ossl_check_CONF_VALUE_lh_type(lh), ossl_check_CONF_VALUE_lh_doallfunc_type(dfn))) {
    _ = &lh;
    _ = &dfn;
    return OPENSSL_LH_doall(ossl_check_CONF_VALUE_lh_type(lh), ossl_check_CONF_VALUE_lh_doallfunc_type(dfn));
}
pub const OPENSSL_CONFTYPES_H = "";
pub const CONF_MFLAGS_IGNORE_ERRORS = @as(c_int, 0x1);
pub const CONF_MFLAGS_IGNORE_RETURN_CODES = @as(c_int, 0x2);
pub const CONF_MFLAGS_SILENT = @as(c_int, 0x4);
pub const CONF_MFLAGS_NO_DSO = @as(c_int, 0x8);
pub const CONF_MFLAGS_IGNORE_MISSING_FILE = @as(c_int, 0x10);
pub const CONF_MFLAGS_DEFAULT_SECTION = @as(c_int, 0x20);
pub inline fn OPENSSL_no_config() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_NO_LOAD_CONFIG, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_NO_LOAD_CONFIG, NULL);
}
pub inline fn NCONF_get_number(c: anytype, g: anytype, n: anytype, r: anytype) @TypeOf(NCONF_get_number_e(c, g, n, r)) {
    _ = &c;
    _ = &g;
    _ = &n;
    _ = &r;
    return NCONF_get_number_e(c, g, n, r);
}
pub const CONF_modules_free = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/conf.h:187:10
pub const OSSL_HTTP_NAME = "http";
pub const OSSL_HTTPS_NAME = "https";
pub const OSSL_HTTP_PREFIX = OSSL_HTTP_NAME ++ "://";
pub const OSSL_HTTPS_PREFIX = OSSL_HTTPS_NAME ++ "://";
pub const OSSL_HTTP_PORT = "80";
pub const OSSL_HTTPS_PORT = "443";
pub const OPENSSL_NO_PROXY = "NO_PROXY";
pub const OPENSSL_HTTP_PROXY = "HTTP_PROXY";
pub const OPENSSL_HTTPS_PROXY = "HTTPS_PROXY";
pub const OSSL_HTTP_DEFAULT_MAX_LINE_LEN = @as(c_int, 4) * @as(c_int, 1024);
pub const OSSL_HTTP_DEFAULT_MAX_RESP_LEN = @as(c_int, 100) * @as(c_int, 1024);
pub const OSSL_HTTP_DEFAULT_MAX_CRL_LEN = (@as(c_int, 32) * @as(c_int, 1024)) * @as(c_int, 1024);
pub const OSSL_HTTP_DEFAULT_MAX_RESP_HDR_LINES = @as(c_int, 256);
pub inline fn X509_http_nbio(rctx: anytype, pcert: anytype) @TypeOf(OSSL_HTTP_REQ_CTX_nbio_d2i(rctx, pcert, ASN1_ITEM_rptr(X509))) {
    _ = &rctx;
    _ = &pcert;
    return OSSL_HTTP_REQ_CTX_nbio_d2i(rctx, pcert, ASN1_ITEM_rptr(X509));
}
pub inline fn X509_CRL_http_nbio(rctx: anytype, pcrl: anytype) @TypeOf(OSSL_HTTP_REQ_CTX_nbio_d2i(rctx, pcrl, ASN1_ITEM_rptr(X509_CRL))) {
    _ = &rctx;
    _ = &pcrl;
    return OSSL_HTTP_REQ_CTX_nbio_d2i(rctx, pcrl, ASN1_ITEM_rptr(X509_CRL));
}
pub inline fn X509_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509, l, p, newf, dupf, freef);
}
pub const X509_VERSION_1 = @as(c_int, 0);
pub const X509_VERSION_2 = @as(c_int, 1);
pub const X509_VERSION_3 = @as(c_int, 2);
pub const X509_get_notBefore = X509_getm_notBefore;
pub const X509_get_notAfter = X509_getm_notAfter;
pub const X509_set_notBefore = X509_set1_notBefore;
pub const X509_set_notAfter = X509_set1_notAfter;
pub const X509_REQ_VERSION_1 = @as(c_int, 0);
pub const X509_CRL_VERSION_1 = @as(c_int, 0);
pub const X509_CRL_VERSION_2 = @as(c_int, 1);
pub const X509_CRL_set_lastUpdate = X509_CRL_set1_lastUpdate;
pub const X509_CRL_set_nextUpdate = X509_CRL_set1_nextUpdate;
pub const X509_ADD_FLAG_DEFAULT = @as(c_int, 0);
pub const X509_ADD_FLAG_UP_REF = @as(c_int, 0x1);
pub const X509_ADD_FLAG_PREPEND = @as(c_int, 0x2);
pub const X509_ADD_FLAG_NO_DUP = @as(c_int, 0x4);
pub const X509_ADD_FLAG_NO_SS = @as(c_int, 0x8);
pub inline fn X509_NAME_hash(x: anytype) @TypeOf(X509_NAME_hash_ex(x, NULL, NULL, NULL)) {
    _ = &x;
    return X509_NAME_hash_ex(x, NULL, NULL, NULL);
}
pub const OPENSSL_PEM_H = "";
pub const HEADER_PEM_H = "";
pub const OPENSSL_PEMERR_H = "";
pub const PEM_R_BAD_BASE64_DECODE = @as(c_int, 100);
pub const PEM_R_BAD_DECRYPT = @as(c_int, 101);
pub const PEM_R_BAD_END_LINE = @as(c_int, 102);
pub const PEM_R_BAD_IV_CHARS = @as(c_int, 103);
pub const PEM_R_BAD_MAGIC_NUMBER = @as(c_int, 116);
pub const PEM_R_BAD_PASSWORD_READ = @as(c_int, 104);
pub const PEM_R_BAD_VERSION_NUMBER = @as(c_int, 117);
pub const PEM_R_BIO_WRITE_FAILURE = @as(c_int, 118);
pub const PEM_R_CIPHER_IS_NULL = @as(c_int, 127);
pub const PEM_R_ERROR_CONVERTING_PRIVATE_KEY = @as(c_int, 115);
pub const PEM_R_EXPECTING_DSS_KEY_BLOB = @as(c_int, 131);
pub const PEM_R_EXPECTING_PRIVATE_KEY_BLOB = @as(c_int, 119);
pub const PEM_R_EXPECTING_PUBLIC_KEY_BLOB = @as(c_int, 120);
pub const PEM_R_EXPECTING_RSA_KEY_BLOB = @as(c_int, 132);
pub const PEM_R_HEADER_TOO_LONG = @as(c_int, 128);
pub const PEM_R_INCONSISTENT_HEADER = @as(c_int, 121);
pub const PEM_R_KEYBLOB_HEADER_PARSE_ERROR = @as(c_int, 122);
pub const PEM_R_KEYBLOB_TOO_SHORT = @as(c_int, 123);
pub const PEM_R_MISSING_DEK_IV = @as(c_int, 129);
pub const PEM_R_NOT_DEK_INFO = @as(c_int, 105);
pub const PEM_R_NOT_ENCRYPTED = @as(c_int, 106);
pub const PEM_R_NOT_PROC_TYPE = @as(c_int, 107);
pub const PEM_R_NO_START_LINE = @as(c_int, 108);
pub const PEM_R_PROBLEMS_GETTING_PASSWORD = @as(c_int, 109);
pub const PEM_R_PVK_DATA_TOO_SHORT = @as(c_int, 124);
pub const PEM_R_PVK_TOO_SHORT = @as(c_int, 125);
pub const PEM_R_READ_KEY = @as(c_int, 111);
pub const PEM_R_SHORT_HEADER = @as(c_int, 112);
pub const PEM_R_UNEXPECTED_DEK_IV = @as(c_int, 130);
pub const PEM_R_UNSUPPORTED_CIPHER = @as(c_int, 113);
pub const PEM_R_UNSUPPORTED_ENCRYPTION = @as(c_int, 114);
pub const PEM_R_UNSUPPORTED_KEY_COMPONENTS = @as(c_int, 126);
pub const PEM_R_UNSUPPORTED_PUBLIC_KEY_TYPE = @as(c_int, 110);
pub const PEM_BUFSIZE = @as(c_int, 1024);
pub const PEM_STRING_X509_OLD = "X509 CERTIFICATE";
pub const PEM_STRING_X509 = "CERTIFICATE";
pub const PEM_STRING_X509_TRUSTED = "TRUSTED CERTIFICATE";
pub const PEM_STRING_X509_REQ_OLD = "NEW CERTIFICATE REQUEST";
pub const PEM_STRING_X509_REQ = "CERTIFICATE REQUEST";
pub const PEM_STRING_X509_CRL = "X509 CRL";
pub const PEM_STRING_EVP_PKEY = "ANY PRIVATE KEY";
pub const PEM_STRING_PUBLIC = "PUBLIC KEY";
pub const PEM_STRING_RSA = "RSA PRIVATE KEY";
pub const PEM_STRING_RSA_PUBLIC = "RSA PUBLIC KEY";
pub const PEM_STRING_DSA = "DSA PRIVATE KEY";
pub const PEM_STRING_DSA_PUBLIC = "DSA PUBLIC KEY";
pub const PEM_STRING_PKCS7 = "PKCS7";
pub const PEM_STRING_PKCS7_SIGNED = "PKCS #7 SIGNED DATA";
pub const PEM_STRING_PKCS8 = "ENCRYPTED PRIVATE KEY";
pub const PEM_STRING_PKCS8INF = "PRIVATE KEY";
pub const PEM_STRING_DHPARAMS = "DH PARAMETERS";
pub const PEM_STRING_DHXPARAMS = "X9.42 DH PARAMETERS";
pub const PEM_STRING_SSL_SESSION = "SSL SESSION PARAMETERS";
pub const PEM_STRING_DSAPARAMS = "DSA PARAMETERS";
pub const PEM_STRING_ECDSA_PUBLIC = "ECDSA PUBLIC KEY";
pub const PEM_STRING_ECPARAMETERS = "EC PARAMETERS";
pub const PEM_STRING_ECPRIVATEKEY = "EC PRIVATE KEY";
pub const PEM_STRING_PARAMETERS = "PARAMETERS";
pub const PEM_STRING_CMS = "CMS";
pub const PEM_STRING_SM2PARAMETERS = "SM2 PARAMETERS";
pub const PEM_STRING_ACERT = "ATTRIBUTE CERTIFICATE";
pub const PEM_TYPE_ENCRYPTED = @as(c_int, 10);
pub const PEM_TYPE_MIC_ONLY = @as(c_int, 20);
pub const PEM_TYPE_MIC_CLEAR = @as(c_int, 30);
pub const PEM_TYPE_CLEAR = @as(c_int, 40);
pub const PEM_read_cb_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /usr/include/openssl/pem.h:74:10
pub const PEM_read_cb_ex_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /usr/include/openssl/pem.h:77:10
pub const PEM_write_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /usr/include/openssl/pem.h:83:10
pub const PEM_write_cb_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /usr/include/openssl/pem.h:85:10
pub const PEM_write_ex_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /usr/include/openssl/pem.h:90:10
pub const PEM_write_cb_ex_fnsig = @compileError("unable to translate macro: undefined identifier `PEM_`");
// /usr/include/openssl/pem.h:94:10
pub const IMPLEMENT_PEM_read_fp = @compileError("unable to translate macro: undefined identifier `PEM_read_`");
// /usr/include/openssl/pem.h:115:11
pub const IMPLEMENT_PEM_write_fp = @compileError("unable to translate macro: undefined identifier `i2d_`");
// /usr/include/openssl/pem.h:122:11
pub inline fn IMPLEMENT_PEM_write_fp_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_fp(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_fp(name, @"type", str, asn1);
}
pub const IMPLEMENT_PEM_write_cb_fp = @compileError("unable to translate macro: undefined identifier `i2d_`");
// /usr/include/openssl/pem.h:134:11
pub inline fn IMPLEMENT_PEM_write_cb_fp_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_cb_fp(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_cb_fp(name, @"type", str, asn1);
}
pub const IMPLEMENT_PEM_read_bio = @compileError("unable to translate macro: undefined identifier `PEM_read_bio_`");
// /usr/include/openssl/pem.h:147:10
pub const IMPLEMENT_PEM_write_bio = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /usr/include/openssl/pem.h:155:10
pub inline fn IMPLEMENT_PEM_write_bio_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_bio(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_bio(name, @"type", str, asn1);
}
pub const IMPLEMENT_PEM_write_cb_bio = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /usr/include/openssl/pem.h:167:10
pub inline fn IMPLEMENT_PEM_write_cb_bio_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_cb_bio(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_cb_bio(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_write(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_fp(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_fp(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_write_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_bio_const(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_fp_const(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_bio_const(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_fp_const(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_write_cb(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_cb_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb_fp(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_cb_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb_fp(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_write_cb_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_write_cb_bio_const(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb_fp_const(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_write_cb_bio_const(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb_fp_const(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_read(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_read_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_read_fp(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_read_bio(name, @"type", str, asn1) ++ IMPLEMENT_PEM_read_fp(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_rw(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_rw_const(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_const(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_const(name, @"type", str, asn1);
}
pub inline fn IMPLEMENT_PEM_rw_cb(name: anytype, @"type": anytype, str: anytype, asn1: anytype) @TypeOf(IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb(name, @"type", str, asn1)) {
    _ = &name;
    _ = &@"type";
    _ = &str;
    _ = &asn1;
    return IMPLEMENT_PEM_read(name, @"type", str, asn1) ++ IMPLEMENT_PEM_write_cb(name, @"type", str, asn1);
}
pub const DECLARE_PEM_read_fp_attr = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/openssl/pem.h:238:11
pub const DECLARE_PEM_read_fp_ex_attr = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/openssl/pem.h:240:11
pub const DECLARE_PEM_write_fp_attr = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/openssl/pem.h:244:11
pub const DECLARE_PEM_write_fp_ex_attr = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/openssl/pem.h:246:11
pub const DECLARE_PEM_write_fp_const_attr = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/openssl/pem.h:250:12
pub const DECLARE_PEM_write_cb_fp_attr = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/openssl/pem.h:253:11
pub const DECLARE_PEM_write_cb_fp_ex_attr = @compileError("unable to translate C expr: unexpected token ';'");
// /usr/include/openssl/pem.h:255:11
pub const DECLARE_PEM_read_fp = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:261:10
pub const DECLARE_PEM_write_fp = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:263:10
pub const DECLARE_PEM_write_fp_const = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:266:12
pub const DECLARE_PEM_write_cb_fp = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:269:10
pub const DECLARE_PEM_read_bio_attr = @compileError("unable to translate macro: undefined identifier `read_bio`");
// /usr/include/openssl/pem.h:272:11
pub const DECLARE_PEM_read_bio_ex_attr = @compileError("unable to translate macro: undefined identifier `read_bio`");
// /usr/include/openssl/pem.h:274:11
pub const DECLARE_PEM_read_bio = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:277:10
pub const DECLARE_PEM_read_bio_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:279:10
pub const DECLARE_PEM_write_bio_attr = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /usr/include/openssl/pem.h:282:10
pub const DECLARE_PEM_write_bio_ex_attr = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /usr/include/openssl/pem.h:284:10
pub const DECLARE_PEM_write_bio = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:287:10
pub const DECLARE_PEM_write_bio_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:289:10
pub const DECLARE_PEM_write_bio_const_attr = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /usr/include/openssl/pem.h:293:11
pub const DECLARE_PEM_write_bio_const = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:295:11
pub const DECLARE_PEM_write_cb_bio_attr = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /usr/include/openssl/pem.h:299:10
pub const DECLARE_PEM_write_cb_bio_ex_attr = @compileError("unable to translate macro: undefined identifier `write_bio`");
// /usr/include/openssl/pem.h:301:10
pub const DECLARE_PEM_write_cb_bio = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:304:10
pub const DECLARE_PEM_write_cb_ex_bio = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:306:10
pub inline fn DECLARE_PEM_write_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_write_bio_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_write_bio_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_attr(attr, name, @"type");
}
pub inline fn DECLARE_PEM_write_ex_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_write_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_ex_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_write_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_ex_attr(attr, name, @"type");
}
pub const DECLARE_PEM_write = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:315:10
pub const DECLARE_PEM_write_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:317:10
pub inline fn DECLARE_PEM_write_const_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_write_bio_const_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_const_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_write_bio_const_attr(attr, name, @"type") ++ DECLARE_PEM_write_fp_const_attr(attr, name, @"type");
}
pub const DECLARE_PEM_write_const = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:323:11
pub inline fn DECLARE_PEM_write_cb_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_write_cb_bio_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_fp_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_write_cb_bio_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_fp_attr(attr, name, @"type");
}
pub inline fn DECLARE_PEM_write_cb_ex_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_write_cb_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_fp_ex_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_write_cb_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_fp_ex_attr(attr, name, @"type");
}
pub const DECLARE_PEM_write_cb = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:332:10
pub const DECLARE_PEM_write_cb_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:334:10
pub inline fn DECLARE_PEM_read_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_bio_attr(attr, name, @"type") ++ DECLARE_PEM_read_fp_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_bio_attr(attr, name, @"type") ++ DECLARE_PEM_read_fp_attr(attr, name, @"type");
}
pub inline fn DECLARE_PEM_read_ex_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_read_fp_ex_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_bio_ex_attr(attr, name, @"type") ++ DECLARE_PEM_read_fp_ex_attr(attr, name, @"type");
}
pub const DECLARE_PEM_read = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:342:10
pub const DECLARE_PEM_read_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:344:10
pub inline fn DECLARE_PEM_rw_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_attr(attr, name, @"type");
}
pub inline fn DECLARE_PEM_rw_ex_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_ex_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_ex_attr(attr, name, @"type");
}
pub const DECLARE_PEM_rw = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:352:10
pub const DECLARE_PEM_rw_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:354:10
pub inline fn DECLARE_PEM_rw_const_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_const_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_const_attr(attr, name, @"type");
}
pub const DECLARE_PEM_rw_const = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:360:11
pub inline fn DECLARE_PEM_rw_cb_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_attr(attr, name, @"type");
}
pub inline fn DECLARE_PEM_rw_cb_ex_attr(attr: anytype, name: anytype, @"type": anytype) @TypeOf(DECLARE_PEM_read_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_ex_attr(attr, name, @"type")) {
    _ = &attr;
    _ = &name;
    _ = &@"type";
    return DECLARE_PEM_read_ex_attr(attr, name, @"type") ++ DECLARE_PEM_write_cb_ex_attr(attr, name, @"type");
}
pub const DECLARE_PEM_rw_cb = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:369:10
pub const DECLARE_PEM_rw_cb_ex = @compileError("unable to translate C expr: unexpected token 'extern'");
// /usr/include/openssl/pem.h:371:10
pub const PEM_FLAG_SECURE = @as(c_int, 0x1);
pub const PEM_FLAG_EAY_COMPATIBLE = @as(c_int, 0x2);
pub const PEM_FLAG_ONLY_B64 = @as(c_int, 0x4);
pub const OPENSSL_HMAC_H = "";
pub const HEADER_HMAC_H = "";
pub const HMAC_MAX_MD_CBLOCK = @as(c_int, 200);
pub const OPENSSL_ASYNC_H = "";
pub const HEADER_ASYNC_H = "";
pub const OSSL_ASYNC_FD = c_int;
pub const OSSL_BAD_ASYNC_FD = -@as(c_int, 1);
pub const OPENSSL_ASYNCERR_H = "";
pub const ASYNC_R_FAILED_TO_SET_POOL = @as(c_int, 101);
pub const ASYNC_R_FAILED_TO_SWAP_CONTEXT = @as(c_int, 102);
pub const ASYNC_R_INIT_FAILED = @as(c_int, 105);
pub const ASYNC_R_INVALID_POOL_SIZE = @as(c_int, 103);
pub const ASYNC_ERR = @as(c_int, 0);
pub const ASYNC_NO_JOBS = @as(c_int, 1);
pub const ASYNC_PAUSE = @as(c_int, 2);
pub const ASYNC_FINISH = @as(c_int, 3);
pub const ASYNC_STATUS_UNSUPPORTED = @as(c_int, 0);
pub const ASYNC_STATUS_ERR = @as(c_int, 1);
pub const ASYNC_STATUS_OK = @as(c_int, 2);
pub const ASYNC_STATUS_EAGAIN = @as(c_int, 3);
pub const OPENSSL_CT_H = "";
pub const HEADER_CT_H = "";
pub const OPENSSL_CTERR_H = "";
pub const CT_R_BASE64_DECODE_ERROR = @as(c_int, 108);
pub const CT_R_INVALID_LOG_ID_LENGTH = @as(c_int, 100);
pub const CT_R_LOG_CONF_INVALID = @as(c_int, 109);
pub const CT_R_LOG_CONF_INVALID_KEY = @as(c_int, 110);
pub const CT_R_LOG_CONF_MISSING_DESCRIPTION = @as(c_int, 111);
pub const CT_R_LOG_CONF_MISSING_KEY = @as(c_int, 112);
pub const CT_R_LOG_KEY_INVALID = @as(c_int, 113);
pub const CT_R_SCT_FUTURE_TIMESTAMP = @as(c_int, 116);
pub const CT_R_SCT_INVALID = @as(c_int, 104);
pub const CT_R_SCT_INVALID_SIGNATURE = @as(c_int, 107);
pub const CT_R_SCT_LIST_INVALID = @as(c_int, 105);
pub const CT_R_SCT_LOG_ID_MISMATCH = @as(c_int, 114);
pub const CT_R_SCT_NOT_SET = @as(c_int, 106);
pub const CT_R_SCT_UNSUPPORTED_VERSION = @as(c_int, 115);
pub const CT_R_UNRECOGNIZED_SIGNATURE_NID = @as(c_int, 101);
pub const CT_R_UNSUPPORTED_ENTRY_TYPE = @as(c_int, 102);
pub const CT_R_UNSUPPORTED_VERSION = @as(c_int, 103);
pub const SCT_MIN_RSA_BITS = @as(c_int, 2048);
pub const CT_V1_HASHLEN = SHA256_DIGEST_LENGTH;
pub inline fn sk_SCT_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_SCT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_SCT_sk_type(sk));
}
pub inline fn sk_SCT_value(sk: anytype, idx: anytype) [*c]SCT {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_value(ossl_check_const_SCT_sk_type(sk), idx));
}
pub const sk_SCT_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ct.h:45:9
pub const sk_SCT_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ct.h:46:9
pub const sk_SCT_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ct.h:47:9
pub inline fn sk_SCT_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_SCT_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_SCT_sk_type(sk), n);
}
pub inline fn sk_SCT_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_SCT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_SCT_sk_type(sk));
}
pub inline fn sk_SCT_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_SCT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_SCT_sk_type(sk));
}
pub inline fn sk_SCT_delete(sk: anytype, i: anytype) [*c]SCT {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_delete(ossl_check_SCT_sk_type(sk), i));
}
pub inline fn sk_SCT_delete_ptr(sk: anytype, ptr: anytype) [*c]SCT {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_delete_ptr(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr)));
}
pub inline fn sk_SCT_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr));
}
pub inline fn sk_SCT_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr));
}
pub inline fn sk_SCT_pop(sk: anytype) [*c]SCT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_pop(ossl_check_SCT_sk_type(sk)));
}
pub inline fn sk_SCT_shift(sk: anytype) [*c]SCT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_shift(ossl_check_SCT_sk_type(sk)));
}
pub inline fn sk_SCT_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_SCT_sk_type(sk), ossl_check_SCT_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_SCT_sk_type(sk), ossl_check_SCT_freefunc_type(freefunc));
}
pub inline fn sk_SCT_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr), idx);
}
pub inline fn sk_SCT_set(sk: anytype, idx: anytype, ptr: anytype) [*c]SCT {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SCT, OPENSSL_sk_set(ossl_check_SCT_sk_type(sk), idx, ossl_check_SCT_type(ptr)));
}
pub inline fn sk_SCT_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr));
}
pub inline fn sk_SCT_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr));
}
pub inline fn sk_SCT_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_SCT_sk_type(sk), ossl_check_SCT_type(ptr), pnum);
}
pub inline fn sk_SCT_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_SCT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_SCT_sk_type(sk));
}
pub inline fn sk_SCT_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_SCT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_SCT_sk_type(sk));
}
pub const sk_SCT_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ct.h:65:9
pub const sk_SCT_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ct.h:66:9
pub inline fn sk_SCT_set_cmp_func(sk: anytype, cmp: anytype) sk_SCT_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_SCT_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_SCT_sk_type(sk), ossl_check_SCT_compfunc_type(cmp)));
}
pub inline fn sk_CTLOG_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_CTLOG_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_CTLOG_sk_type(sk));
}
pub inline fn sk_CTLOG_value(sk: anytype, idx: anytype) [*c]CTLOG {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_value(ossl_check_const_CTLOG_sk_type(sk), idx));
}
pub const sk_CTLOG_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ct.h:71:9
pub const sk_CTLOG_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ct.h:72:9
pub const sk_CTLOG_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ct.h:73:9
pub inline fn sk_CTLOG_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_CTLOG_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_CTLOG_sk_type(sk), n);
}
pub inline fn sk_CTLOG_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_CTLOG_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_CTLOG_sk_type(sk));
}
pub inline fn sk_CTLOG_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_CTLOG_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_CTLOG_sk_type(sk));
}
pub inline fn sk_CTLOG_delete(sk: anytype, i: anytype) [*c]CTLOG {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_delete(ossl_check_CTLOG_sk_type(sk), i));
}
pub inline fn sk_CTLOG_delete_ptr(sk: anytype, ptr: anytype) [*c]CTLOG {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_delete_ptr(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr)));
}
pub inline fn sk_CTLOG_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr));
}
pub inline fn sk_CTLOG_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr));
}
pub inline fn sk_CTLOG_pop(sk: anytype) [*c]CTLOG {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_pop(ossl_check_CTLOG_sk_type(sk)));
}
pub inline fn sk_CTLOG_shift(sk: anytype) [*c]CTLOG {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_shift(ossl_check_CTLOG_sk_type(sk)));
}
pub inline fn sk_CTLOG_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_freefunc_type(freefunc));
}
pub inline fn sk_CTLOG_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr), idx);
}
pub inline fn sk_CTLOG_set(sk: anytype, idx: anytype, ptr: anytype) [*c]CTLOG {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]CTLOG, OPENSSL_sk_set(ossl_check_CTLOG_sk_type(sk), idx, ossl_check_CTLOG_type(ptr)));
}
pub inline fn sk_CTLOG_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr));
}
pub inline fn sk_CTLOG_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr));
}
pub inline fn sk_CTLOG_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_type(ptr), pnum);
}
pub inline fn sk_CTLOG_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_CTLOG_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_CTLOG_sk_type(sk));
}
pub inline fn sk_CTLOG_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_CTLOG_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_CTLOG_sk_type(sk));
}
pub const sk_CTLOG_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ct.h:91:9
pub const sk_CTLOG_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ct.h:92:9
pub inline fn sk_CTLOG_set_cmp_func(sk: anytype, cmp: anytype) sk_CTLOG_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_CTLOG_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_CTLOG_sk_type(sk), ossl_check_CTLOG_compfunc_type(cmp)));
}
pub const OPENSSL_SSLERR_H = "";
pub const OPENSSL_SSLERR_LEGACY_H = "";
pub const SSL_F_ADD_CLIENT_KEY_SHARE_EXT = @as(c_int, 0);
pub const SSL_F_ADD_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_BYTES_TO_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_CHECK_SUITEB_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_CIPHERSUITE_CB = @as(c_int, 0);
pub const SSL_F_CONSTRUCT_CA_NAMES = @as(c_int, 0);
pub const SSL_F_CONSTRUCT_KEY_EXCHANGE_TBS = @as(c_int, 0);
pub const SSL_F_CONSTRUCT_STATEFUL_TICKET = @as(c_int, 0);
pub const SSL_F_CONSTRUCT_STATELESS_TICKET = @as(c_int, 0);
pub const SSL_F_CREATE_SYNTHETIC_MESSAGE_HASH = @as(c_int, 0);
pub const SSL_F_CREATE_TICKET_PREQUEL = @as(c_int, 0);
pub const SSL_F_CT_MOVE_SCTS = @as(c_int, 0);
pub const SSL_F_CT_STRICT = @as(c_int, 0);
pub const SSL_F_CUSTOM_EXT_ADD = @as(c_int, 0);
pub const SSL_F_CUSTOM_EXT_PARSE = @as(c_int, 0);
pub const SSL_F_D2I_SSL_SESSION = @as(c_int, 0);
pub const SSL_F_DANE_CTX_ENABLE = @as(c_int, 0);
pub const SSL_F_DANE_MTYPE_SET = @as(c_int, 0);
pub const SSL_F_DANE_TLSA_ADD = @as(c_int, 0);
pub const SSL_F_DERIVE_SECRET_KEY_AND_IV = @as(c_int, 0);
pub const SSL_F_DO_DTLS1_WRITE = @as(c_int, 0);
pub const SSL_F_DO_SSL3_WRITE = @as(c_int, 0);
pub const SSL_F_DTLS1_BUFFER_RECORD = @as(c_int, 0);
pub const SSL_F_DTLS1_CHECK_TIMEOUT_NUM = @as(c_int, 0);
pub const SSL_F_DTLS1_HEARTBEAT = @as(c_int, 0);
pub const SSL_F_DTLS1_HM_FRAGMENT_NEW = @as(c_int, 0);
pub const SSL_F_DTLS1_PREPROCESS_FRAGMENT = @as(c_int, 0);
pub const SSL_F_DTLS1_PROCESS_BUFFERED_RECORDS = @as(c_int, 0);
pub const SSL_F_DTLS1_PROCESS_RECORD = @as(c_int, 0);
pub const SSL_F_DTLS1_READ_BYTES = @as(c_int, 0);
pub const SSL_F_DTLS1_READ_FAILED = @as(c_int, 0);
pub const SSL_F_DTLS1_RETRANSMIT_MESSAGE = @as(c_int, 0);
pub const SSL_F_DTLS1_WRITE_APP_DATA_BYTES = @as(c_int, 0);
pub const SSL_F_DTLS1_WRITE_BYTES = @as(c_int, 0);
pub const SSL_F_DTLSV1_LISTEN = @as(c_int, 0);
pub const SSL_F_DTLS_CONSTRUCT_CHANGE_CIPHER_SPEC = @as(c_int, 0);
pub const SSL_F_DTLS_CONSTRUCT_HELLO_VERIFY_REQUEST = @as(c_int, 0);
pub const SSL_F_DTLS_GET_REASSEMBLED_MESSAGE = @as(c_int, 0);
pub const SSL_F_DTLS_PROCESS_HELLO_VERIFY = @as(c_int, 0);
pub const SSL_F_DTLS_RECORD_LAYER_NEW = @as(c_int, 0);
pub const SSL_F_DTLS_WAIT_FOR_DRY = @as(c_int, 0);
pub const SSL_F_EARLY_DATA_COUNT_OK = @as(c_int, 0);
pub const SSL_F_FINAL_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_FINAL_EC_PT_FORMATS = @as(c_int, 0);
pub const SSL_F_FINAL_EMS = @as(c_int, 0);
pub const SSL_F_FINAL_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_FINAL_MAXFRAGMENTLEN = @as(c_int, 0);
pub const SSL_F_FINAL_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_FINAL_SERVER_NAME = @as(c_int, 0);
pub const SSL_F_FINAL_SIG_ALGS = @as(c_int, 0);
pub const SSL_F_GET_CERT_VERIFY_TBS_DATA = @as(c_int, 0);
pub const SSL_F_NSS_KEYLOG_INT = @as(c_int, 0);
pub const SSL_F_OPENSSL_INIT_SSL = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT13_READ_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT13_WRITE_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT_CONSTRUCT_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT_POST_PROCESS_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT_PROCESS_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT_READ_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_CLIENT_WRITE_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER13_READ_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER13_WRITE_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_CONSTRUCT_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_POST_PROCESS_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_POST_WORK = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_PRE_WORK = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_PROCESS_MESSAGE = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_READ_TRANSITION = @as(c_int, 0);
pub const SSL_F_OSSL_STATEM_SERVER_WRITE_TRANSITION = @as(c_int, 0);
pub const SSL_F_PARSE_CA_NAMES = @as(c_int, 0);
pub const SSL_F_PITEM_NEW = @as(c_int, 0);
pub const SSL_F_PQUEUE_NEW = @as(c_int, 0);
pub const SSL_F_PROCESS_KEY_SHARE_EXT = @as(c_int, 0);
pub const SSL_F_READ_STATE_MACHINE = @as(c_int, 0);
pub const SSL_F_SET_CLIENT_CIPHERSUITE = @as(c_int, 0);
pub const SSL_F_SRP_GENERATE_CLIENT_MASTER_SECRET = @as(c_int, 0);
pub const SSL_F_SRP_GENERATE_SERVER_MASTER_SECRET = @as(c_int, 0);
pub const SSL_F_SRP_VERIFY_SERVER_PARAM = @as(c_int, 0);
pub const SSL_F_SSL3_CHANGE_CIPHER_STATE = @as(c_int, 0);
pub const SSL_F_SSL3_CHECK_CERT_AND_ALGORITHM = @as(c_int, 0);
pub const SSL_F_SSL3_CTRL = @as(c_int, 0);
pub const SSL_F_SSL3_CTX_CTRL = @as(c_int, 0);
pub const SSL_F_SSL3_DIGEST_CACHED_RECORDS = @as(c_int, 0);
pub const SSL_F_SSL3_DO_CHANGE_CIPHER_SPEC = @as(c_int, 0);
pub const SSL_F_SSL3_ENC = @as(c_int, 0);
pub const SSL_F_SSL3_FINAL_FINISH_MAC = @as(c_int, 0);
pub const SSL_F_SSL3_FINISH_MAC = @as(c_int, 0);
pub const SSL_F_SSL3_GENERATE_KEY_BLOCK = @as(c_int, 0);
pub const SSL_F_SSL3_GENERATE_MASTER_SECRET = @as(c_int, 0);
pub const SSL_F_SSL3_GET_RECORD = @as(c_int, 0);
pub const SSL_F_SSL3_INIT_FINISHED_MAC = @as(c_int, 0);
pub const SSL_F_SSL3_OUTPUT_CERT_CHAIN = @as(c_int, 0);
pub const SSL_F_SSL3_READ_BYTES = @as(c_int, 0);
pub const SSL_F_SSL3_READ_N = @as(c_int, 0);
pub const SSL_F_SSL3_SETUP_KEY_BLOCK = @as(c_int, 0);
pub const SSL_F_SSL3_SETUP_READ_BUFFER = @as(c_int, 0);
pub const SSL_F_SSL3_SETUP_WRITE_BUFFER = @as(c_int, 0);
pub const SSL_F_SSL3_WRITE_BYTES = @as(c_int, 0);
pub const SSL_F_SSL3_WRITE_PENDING = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CERT_CHAIN = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CERT_TO_BUF = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CERT_TO_WPACKET = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CLIENTHELLO_RENEGOTIATE_EXT = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_ADD_CLIENTHELLO_USE_SRTP_EXT = @as(c_int, 0);
pub const SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK = @as(c_int, 0);
pub const SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK = @as(c_int, 0);
pub const SSL_F_SSL_ADD_SERVERHELLO_RENEGOTIATE_EXT = @as(c_int, 0);
pub const SSL_F_SSL_ADD_SERVERHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_ADD_SERVERHELLO_USE_SRTP_EXT = @as(c_int, 0);
pub const SSL_F_SSL_BUILD_CERT_CHAIN = @as(c_int, 0);
pub const SSL_F_SSL_BYTES_TO_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_SSL_CACHE_CIPHERLIST = @as(c_int, 0);
pub const SSL_F_SSL_CERT_ADD0_CHAIN_CERT = @as(c_int, 0);
pub const SSL_F_SSL_CERT_DUP = @as(c_int, 0);
pub const SSL_F_SSL_CERT_NEW = @as(c_int, 0);
pub const SSL_F_SSL_CERT_SET0_CHAIN = @as(c_int, 0);
pub const SSL_F_SSL_CHECK_PRIVATE_KEY = @as(c_int, 0);
pub const SSL_F_SSL_CHECK_SERVERHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_CHECK_SRP_EXT_CLIENTHELLO = @as(c_int, 0);
pub const SSL_F_SSL_CHECK_SRVR_ECC_CERT_AND_ALG = @as(c_int, 0);
pub const SSL_F_SSL_CHOOSE_CLIENT_VERSION = @as(c_int, 0);
pub const SSL_F_SSL_CIPHER_DESCRIPTION = @as(c_int, 0);
pub const SSL_F_SSL_CIPHER_LIST_TO_BYTES = @as(c_int, 0);
pub const SSL_F_SSL_CIPHER_PROCESS_RULESTR = @as(c_int, 0);
pub const SSL_F_SSL_CIPHER_STRENGTH_SORT = @as(c_int, 0);
pub const SSL_F_SSL_CLEAR = @as(c_int, 0);
pub const SSL_F_SSL_CLIENT_HELLO_GET1_EXTENSIONS_PRESENT = @as(c_int, 0);
pub const SSL_F_SSL_COMP_ADD_COMPRESSION_METHOD = @as(c_int, 0);
pub const SSL_F_SSL_CONF_CMD = @as(c_int, 0);
pub const SSL_F_SSL_CREATE_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_SSL_CTRL = @as(c_int, 0);
pub const SSL_F_SSL_CTX_CHECK_PRIVATE_KEY = @as(c_int, 0);
pub const SSL_F_SSL_CTX_ENABLE_CT = @as(c_int, 0);
pub const SSL_F_SSL_CTX_MAKE_PROFILES = @as(c_int, 0);
pub const SSL_F_SSL_CTX_NEW = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_ALPN_PROTOS = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_CLIENT_CERT_ENGINE = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_CT_VALIDATION_CALLBACK = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_SESSION_ID_CONTEXT = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_SSL_VERSION = @as(c_int, 0);
pub const SSL_F_SSL_CTX_SET_TLSEXT_MAX_FRAGMENT_LENGTH = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_CERTIFICATE_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_CERTIFICATE_FILE = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_PRIVATEKEY_FILE = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_PSK_IDENTITY_HINT = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_RSAPRIVATEKEY_FILE = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_SERVERINFO = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_SERVERINFO_EX = @as(c_int, 0);
pub const SSL_F_SSL_CTX_USE_SERVERINFO_FILE = @as(c_int, 0);
pub const SSL_F_SSL_DANE_DUP = @as(c_int, 0);
pub const SSL_F_SSL_DANE_ENABLE = @as(c_int, 0);
pub const SSL_F_SSL_DERIVE = @as(c_int, 0);
pub const SSL_F_SSL_DO_CONFIG = @as(c_int, 0);
pub const SSL_F_SSL_DO_HANDSHAKE = @as(c_int, 0);
pub const SSL_F_SSL_DUP_CA_LIST = @as(c_int, 0);
pub const SSL_F_SSL_ENABLE_CT = @as(c_int, 0);
pub const SSL_F_SSL_GENERATE_PKEY_GROUP = @as(c_int, 0);
pub const SSL_F_SSL_GENERATE_SESSION_ID = @as(c_int, 0);
pub const SSL_F_SSL_GET_NEW_SESSION = @as(c_int, 0);
pub const SSL_F_SSL_GET_PREV_SESSION = @as(c_int, 0);
pub const SSL_F_SSL_GET_SERVER_CERT_INDEX = @as(c_int, 0);
pub const SSL_F_SSL_GET_SIGN_PKEY = @as(c_int, 0);
pub const SSL_F_SSL_HANDSHAKE_HASH = @as(c_int, 0);
pub const SSL_F_SSL_INIT_WBIO_BUFFER = @as(c_int, 0);
pub const SSL_F_SSL_KEY_UPDATE = @as(c_int, 0);
pub const SSL_F_SSL_LOAD_CLIENT_CA_FILE = @as(c_int, 0);
pub const SSL_F_SSL_LOG_MASTER_SECRET = @as(c_int, 0);
pub const SSL_F_SSL_LOG_RSA_CLIENT_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_SSL_MODULE_INIT = @as(c_int, 0);
pub const SSL_F_SSL_NEW = @as(c_int, 0);
pub const SSL_F_SSL_NEXT_PROTO_VALIDATE = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_CLIENTHELLO_RENEGOTIATE_EXT = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_CLIENTHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_CLIENTHELLO_USE_SRTP_EXT = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_SERVERHELLO_RENEGOTIATE_EXT = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_SERVERHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_PARSE_SERVERHELLO_USE_SRTP_EXT = @as(c_int, 0);
pub const SSL_F_SSL_PEEK = @as(c_int, 0);
pub const SSL_F_SSL_PEEK_EX = @as(c_int, 0);
pub const SSL_F_SSL_PEEK_INTERNAL = @as(c_int, 0);
pub const SSL_F_SSL_READ = @as(c_int, 0);
pub const SSL_F_SSL_READ_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_SSL_READ_EX = @as(c_int, 0);
pub const SSL_F_SSL_READ_INTERNAL = @as(c_int, 0);
pub const SSL_F_SSL_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_SSL_RENEGOTIATE_ABBREVIATED = @as(c_int, 0);
pub const SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_SCAN_SERVERHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_SSL_SESSION_DUP = @as(c_int, 0);
pub const SSL_F_SSL_SESSION_NEW = @as(c_int, 0);
pub const SSL_F_SSL_SESSION_PRINT_FP = @as(c_int, 0);
pub const SSL_F_SSL_SESSION_SET1_ID = @as(c_int, 0);
pub const SSL_F_SSL_SESSION_SET1_ID_CONTEXT = @as(c_int, 0);
pub const SSL_F_SSL_SET_ALPN_PROTOS = @as(c_int, 0);
pub const SSL_F_SSL_SET_CERT = @as(c_int, 0);
pub const SSL_F_SSL_SET_CERT_AND_KEY = @as(c_int, 0);
pub const SSL_F_SSL_SET_CIPHER_LIST = @as(c_int, 0);
pub const SSL_F_SSL_SET_CT_VALIDATION_CALLBACK = @as(c_int, 0);
pub const SSL_F_SSL_SET_FD = @as(c_int, 0);
pub const SSL_F_SSL_SET_PKEY = @as(c_int, 0);
pub const SSL_F_SSL_SET_RFD = @as(c_int, 0);
pub const SSL_F_SSL_SET_SESSION = @as(c_int, 0);
pub const SSL_F_SSL_SET_SESSION_ID_CONTEXT = @as(c_int, 0);
pub const SSL_F_SSL_SET_SESSION_TICKET_EXT = @as(c_int, 0);
pub const SSL_F_SSL_SET_TLSEXT_MAX_FRAGMENT_LENGTH = @as(c_int, 0);
pub const SSL_F_SSL_SET_WFD = @as(c_int, 0);
pub const SSL_F_SSL_SHUTDOWN = @as(c_int, 0);
pub const SSL_F_SSL_SRP_CTX_INIT = @as(c_int, 0);
pub const SSL_F_SSL_START_ASYNC_JOB = @as(c_int, 0);
pub const SSL_F_SSL_UNDEFINED_FUNCTION = @as(c_int, 0);
pub const SSL_F_SSL_UNDEFINED_VOID_FUNCTION = @as(c_int, 0);
pub const SSL_F_SSL_USE_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_SSL_USE_CERTIFICATE_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_USE_CERTIFICATE_FILE = @as(c_int, 0);
pub const SSL_F_SSL_USE_PRIVATEKEY = @as(c_int, 0);
pub const SSL_F_SSL_USE_PRIVATEKEY_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_USE_PRIVATEKEY_FILE = @as(c_int, 0);
pub const SSL_F_SSL_USE_PSK_IDENTITY_HINT = @as(c_int, 0);
pub const SSL_F_SSL_USE_RSAPRIVATEKEY = @as(c_int, 0);
pub const SSL_F_SSL_USE_RSAPRIVATEKEY_ASN1 = @as(c_int, 0);
pub const SSL_F_SSL_USE_RSAPRIVATEKEY_FILE = @as(c_int, 0);
pub const SSL_F_SSL_VALIDATE_CT = @as(c_int, 0);
pub const SSL_F_SSL_VERIFY_CERT_CHAIN = @as(c_int, 0);
pub const SSL_F_SSL_VERIFY_CLIENT_POST_HANDSHAKE = @as(c_int, 0);
pub const SSL_F_SSL_WRITE = @as(c_int, 0);
pub const SSL_F_SSL_WRITE_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_SSL_WRITE_EARLY_FINISH = @as(c_int, 0);
pub const SSL_F_SSL_WRITE_EX = @as(c_int, 0);
pub const SSL_F_SSL_WRITE_INTERNAL = @as(c_int, 0);
pub const SSL_F_STATE_MACHINE = @as(c_int, 0);
pub const SSL_F_TLS12_CHECK_PEER_SIGALG = @as(c_int, 0);
pub const SSL_F_TLS12_COPY_SIGALGS = @as(c_int, 0);
pub const SSL_F_TLS13_CHANGE_CIPHER_STATE = @as(c_int, 0);
pub const SSL_F_TLS13_ENC = @as(c_int, 0);
pub const SSL_F_TLS13_FINAL_FINISH_MAC = @as(c_int, 0);
pub const SSL_F_TLS13_GENERATE_SECRET = @as(c_int, 0);
pub const SSL_F_TLS13_HKDF_EXPAND = @as(c_int, 0);
pub const SSL_F_TLS13_RESTORE_HANDSHAKE_DIGEST_FOR_PHA = @as(c_int, 0);
pub const SSL_F_TLS13_SAVE_HANDSHAKE_DIGEST_FOR_PHA = @as(c_int, 0);
pub const SSL_F_TLS13_SETUP_KEY_BLOCK = @as(c_int, 0);
pub const SSL_F_TLS1_CHANGE_CIPHER_STATE = @as(c_int, 0);
pub const SSL_F_TLS1_CHECK_DUPLICATE_EXTENSIONS = @as(c_int, 0);
pub const SSL_F_TLS1_ENC = @as(c_int, 0);
pub const SSL_F_TLS1_EXPORT_KEYING_MATERIAL = @as(c_int, 0);
pub const SSL_F_TLS1_GET_CURVELIST = @as(c_int, 0);
pub const SSL_F_TLS1_PRF = @as(c_int, 0);
pub const SSL_F_TLS1_SAVE_U16 = @as(c_int, 0);
pub const SSL_F_TLS1_SETUP_KEY_BLOCK = @as(c_int, 0);
pub const SSL_F_TLS1_SET_GROUPS = @as(c_int, 0);
pub const SSL_F_TLS1_SET_RAW_SIGALGS = @as(c_int, 0);
pub const SSL_F_TLS1_SET_SERVER_SIGALGS = @as(c_int, 0);
pub const SSL_F_TLS1_SET_SHARED_SIGALGS = @as(c_int, 0);
pub const SSL_F_TLS1_SET_SIGALGS = @as(c_int, 0);
pub const SSL_F_TLS_CHOOSE_SIGALG = @as(c_int, 0);
pub const SSL_F_TLS_CLIENT_KEY_EXCHANGE_POST_WORK = @as(c_int, 0);
pub const SSL_F_TLS_COLLECT_EXTENSIONS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CERTIFICATE_AUTHORITIES = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CERTIFICATE_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CERT_STATUS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CERT_STATUS_BODY = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CERT_VERIFY = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CHANGE_CIPHER_SPEC = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_DHE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_ECDHE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_GOST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_PSK_PREAMBLE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_RSA = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CKE_SRP = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CLIENT_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CLIENT_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CLIENT_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CLIENT_VERIFY = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_ALPN = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_COOKIE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_EC_PT_FORMATS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_EMS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_ETM = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_MAXFRAGMENTLEN = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_NPN = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_PADDING = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_POST_HANDSHAKE_AUTH = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_PSK = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_PSK_KEX_MODES = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SCT = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SERVER_NAME = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SIG_ALGS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SRP = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_STATUS_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SUPPORTED_GROUPS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_SUPPORTED_VERSIONS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_USE_SRTP = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_CTOS_VERIFY = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_ENCRYPTED_EXTENSIONS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_END_OF_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_EXTENSIONS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_FINISHED = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_HELLO_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_HELLO_RETRY_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_KEY_UPDATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_NEW_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_NEXT_PROTO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_SERVER_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_SERVER_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_SERVER_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_ALPN = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_COOKIE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_CRYPTOPRO_BUG = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_DONE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_EARLY_DATA_INFO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_EC_PT_FORMATS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_EMS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_ETM = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_MAXFRAGMENTLEN = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_NEXT_PROTO_NEG = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_PSK = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_SERVER_NAME = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_STATUS_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_SUPPORTED_GROUPS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_SUPPORTED_VERSIONS = @as(c_int, 0);
pub const SSL_F_TLS_CONSTRUCT_STOC_USE_SRTP = @as(c_int, 0);
pub const SSL_F_TLS_EARLY_POST_PROCESS_CLIENT_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_FINISH_HANDSHAKE = @as(c_int, 0);
pub const SSL_F_TLS_GET_MESSAGE_BODY = @as(c_int, 0);
pub const SSL_F_TLS_GET_MESSAGE_HEADER = @as(c_int, 0);
pub const SSL_F_TLS_HANDLE_ALPN = @as(c_int, 0);
pub const SSL_F_TLS_HANDLE_STATUS_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CERTIFICATE_AUTHORITIES = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CLIENTHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_ALPN = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_COOKIE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_EC_PT_FORMATS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_EMS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_MAXFRAGMENTLEN = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_POST_HANDSHAKE_AUTH = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_PSK = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_PSK_KEX_MODES = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SERVER_NAME = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SIG_ALGS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SIG_ALGS_CERT = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SRP = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_STATUS_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_SUPPORTED_GROUPS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_CTOS_USE_SRTP = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_ALPN = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_COOKIE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_EARLY_DATA_INFO = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_EC_PT_FORMATS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_KEY_SHARE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_MAXFRAGMENTLEN = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_NPN = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_PSK = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_RENEGOTIATE = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_SCT = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_SERVER_NAME = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_STATUS_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_SUPPORTED_VERSIONS = @as(c_int, 0);
pub const SSL_F_TLS_PARSE_STOC_USE_SRTP = @as(c_int, 0);
pub const SSL_F_TLS_POST_PROCESS_CLIENT_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_POST_PROCESS_CLIENT_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_PREPARE_CLIENT_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_AS_HELLO_RETRY_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CERTIFICATE_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CERT_STATUS = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CERT_STATUS_BODY = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CERT_VERIFY = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CHANGE_CIPHER_SPEC = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_DHE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_ECDHE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_GOST = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_PSK_PREAMBLE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_RSA = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CKE_SRP = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CLIENT_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CLIENT_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_CLIENT_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_ENCRYPTED_EXTENSIONS = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_END_OF_EARLY_DATA = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_FINISHED = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_HELLO_REQ = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_HELLO_RETRY_REQUEST = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_INITIAL_SERVER_FLIGHT = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_KEY_EXCHANGE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_KEY_UPDATE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_NEW_SESSION_TICKET = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_NEXT_PROTO = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SERVER_CERTIFICATE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SERVER_DONE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SERVER_HELLO = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SKE_DHE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SKE_ECDHE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SKE_PSK_PREAMBLE = @as(c_int, 0);
pub const SSL_F_TLS_PROCESS_SKE_SRP = @as(c_int, 0);
pub const SSL_F_TLS_PSK_DO_BINDER = @as(c_int, 0);
pub const SSL_F_TLS_SCAN_CLIENTHELLO_TLSEXT = @as(c_int, 0);
pub const SSL_F_TLS_SETUP_HANDSHAKE = @as(c_int, 0);
pub const SSL_F_USE_CERTIFICATE_CHAIN_FILE = @as(c_int, 0);
pub const SSL_F_WPACKET_INTERN_INIT_LEN = @as(c_int, 0);
pub const SSL_F_WPACKET_START_SUB_PACKET_LEN__ = @as(c_int, 0);
pub const SSL_F_WRITE_STATE_MACHINE = @as(c_int, 0);
pub const SSL_R_APPLICATION_DATA_AFTER_CLOSE_NOTIFY = @as(c_int, 291);
pub const SSL_R_APP_DATA_IN_HANDSHAKE = @as(c_int, 100);
pub const SSL_R_ATTEMPT_TO_REUSE_SESSION_IN_DIFFERENT_CONTEXT = @as(c_int, 272);
pub const SSL_R_AT_LEAST_TLS_1_2_NEEDED_IN_SUITEB_MODE = @as(c_int, 158);
pub const SSL_R_BAD_CERTIFICATE = @as(c_int, 348);
pub const SSL_R_BAD_CHANGE_CIPHER_SPEC = @as(c_int, 103);
pub const SSL_R_BAD_CIPHER = @as(c_int, 186);
pub const SSL_R_BAD_COMPRESSION_ALGORITHM = @as(c_int, 326);
pub const SSL_R_BAD_DATA = @as(c_int, 390);
pub const SSL_R_BAD_DATA_RETURNED_BY_CALLBACK = @as(c_int, 106);
pub const SSL_R_BAD_DECOMPRESSION = @as(c_int, 107);
pub const SSL_R_BAD_DH_VALUE = @as(c_int, 102);
pub const SSL_R_BAD_DIGEST_LENGTH = @as(c_int, 111);
pub const SSL_R_BAD_EARLY_DATA = @as(c_int, 233);
pub const SSL_R_BAD_ECC_CERT = @as(c_int, 304);
pub const SSL_R_BAD_ECPOINT = @as(c_int, 306);
pub const SSL_R_BAD_EXTENSION = @as(c_int, 110);
pub const SSL_R_BAD_HANDSHAKE_LENGTH = @as(c_int, 332);
pub const SSL_R_BAD_HANDSHAKE_STATE = @as(c_int, 236);
pub const SSL_R_BAD_HELLO_REQUEST = @as(c_int, 105);
pub const SSL_R_BAD_HRR_VERSION = @as(c_int, 263);
pub const SSL_R_BAD_KEY_SHARE = @as(c_int, 108);
pub const SSL_R_BAD_KEY_UPDATE = @as(c_int, 122);
pub const SSL_R_BAD_LEGACY_VERSION = @as(c_int, 292);
pub const SSL_R_BAD_LENGTH = @as(c_int, 271);
pub const SSL_R_BAD_PACKET = @as(c_int, 240);
pub const SSL_R_BAD_PACKET_LENGTH = @as(c_int, 115);
pub const SSL_R_BAD_PROTOCOL_VERSION_NUMBER = @as(c_int, 116);
pub const SSL_R_BAD_PSK = @as(c_int, 219);
pub const SSL_R_BAD_PSK_IDENTITY = @as(c_int, 114);
pub const SSL_R_BAD_RECORD_TYPE = @as(c_int, 443);
pub const SSL_R_BAD_RSA_ENCRYPT = @as(c_int, 119);
pub const SSL_R_BAD_SIGNATURE = @as(c_int, 123);
pub const SSL_R_BAD_SRP_A_LENGTH = @as(c_int, 347);
pub const SSL_R_BAD_SRP_PARAMETERS = @as(c_int, 371);
pub const SSL_R_BAD_SRTP_MKI_VALUE = @as(c_int, 352);
pub const SSL_R_BAD_SRTP_PROTECTION_PROFILE_LIST = @as(c_int, 353);
pub const SSL_R_BAD_SSL_FILETYPE = @as(c_int, 124);
pub const SSL_R_BAD_VALUE = @as(c_int, 384);
pub const SSL_R_BAD_WRITE_RETRY = @as(c_int, 127);
pub const SSL_R_BINDER_DOES_NOT_VERIFY = @as(c_int, 253);
pub const SSL_R_BIO_NOT_SET = @as(c_int, 128);
pub const SSL_R_BLOCK_CIPHER_PAD_IS_WRONG = @as(c_int, 129);
pub const SSL_R_BN_LIB = @as(c_int, 130);
pub const SSL_R_CALLBACK_FAILED = @as(c_int, 234);
pub const SSL_R_CANNOT_CHANGE_CIPHER = @as(c_int, 109);
pub const SSL_R_CANNOT_GET_GROUP_NAME = @as(c_int, 299);
pub const SSL_R_CA_DN_LENGTH_MISMATCH = @as(c_int, 131);
pub const SSL_R_CA_KEY_TOO_SMALL = @as(c_int, 397);
pub const SSL_R_CA_MD_TOO_WEAK = @as(c_int, 398);
pub const SSL_R_CCS_RECEIVED_EARLY = @as(c_int, 133);
pub const SSL_R_CERTIFICATE_VERIFY_FAILED = @as(c_int, 134);
pub const SSL_R_CERT_CB_ERROR = @as(c_int, 377);
pub const SSL_R_CERT_LENGTH_MISMATCH = @as(c_int, 135);
pub const SSL_R_CIPHERSUITE_DIGEST_HAS_CHANGED = @as(c_int, 218);
pub const SSL_R_CIPHER_CODE_WRONG_LENGTH = @as(c_int, 137);
pub const SSL_R_CLIENTHELLO_TLSEXT = @as(c_int, 226);
pub const SSL_R_COMPRESSED_LENGTH_TOO_LONG = @as(c_int, 140);
pub const SSL_R_COMPRESSION_DISABLED = @as(c_int, 343);
pub const SSL_R_COMPRESSION_FAILURE = @as(c_int, 141);
pub const SSL_R_COMPRESSION_ID_NOT_WITHIN_PRIVATE_RANGE = @as(c_int, 307);
pub const SSL_R_COMPRESSION_LIBRARY_ERROR = @as(c_int, 142);
pub const SSL_R_CONNECTION_TYPE_NOT_SET = @as(c_int, 144);
pub const SSL_R_CONN_USE_ONLY = @as(c_int, 356);
pub const SSL_R_CONTEXT_NOT_DANE_ENABLED = @as(c_int, 167);
pub const SSL_R_COOKIE_GEN_CALLBACK_FAILURE = @as(c_int, 400);
pub const SSL_R_COOKIE_MISMATCH = @as(c_int, 308);
pub const SSL_R_COPY_PARAMETERS_FAILED = @as(c_int, 296);
pub const SSL_R_CUSTOM_EXT_HANDLER_ALREADY_INSTALLED = @as(c_int, 206);
pub const SSL_R_DANE_ALREADY_ENABLED = @as(c_int, 172);
pub const SSL_R_DANE_CANNOT_OVERRIDE_MTYPE_FULL = @as(c_int, 173);
pub const SSL_R_DANE_NOT_ENABLED = @as(c_int, 175);
pub const SSL_R_DANE_TLSA_BAD_CERTIFICATE = @as(c_int, 180);
pub const SSL_R_DANE_TLSA_BAD_CERTIFICATE_USAGE = @as(c_int, 184);
pub const SSL_R_DANE_TLSA_BAD_DATA_LENGTH = @as(c_int, 189);
pub const SSL_R_DANE_TLSA_BAD_DIGEST_LENGTH = @as(c_int, 192);
pub const SSL_R_DANE_TLSA_BAD_MATCHING_TYPE = @as(c_int, 200);
pub const SSL_R_DANE_TLSA_BAD_PUBLIC_KEY = @as(c_int, 201);
pub const SSL_R_DANE_TLSA_BAD_SELECTOR = @as(c_int, 202);
pub const SSL_R_DANE_TLSA_NULL_DATA = @as(c_int, 203);
pub const SSL_R_DATA_BETWEEN_CCS_AND_FINISHED = @as(c_int, 145);
pub const SSL_R_DATA_LENGTH_TOO_LONG = @as(c_int, 146);
pub const SSL_R_DECRYPTION_FAILED = @as(c_int, 147);
pub const SSL_R_DECRYPTION_FAILED_OR_BAD_RECORD_MAC = @as(c_int, 281);
pub const SSL_R_DH_KEY_TOO_SMALL = @as(c_int, 394);
pub const SSL_R_DH_PUBLIC_VALUE_LENGTH_IS_WRONG = @as(c_int, 148);
pub const SSL_R_DIGEST_CHECK_FAILED = @as(c_int, 149);
pub const SSL_R_DTLS_MESSAGE_TOO_BIG = @as(c_int, 334);
pub const SSL_R_DUPLICATE_COMPRESSION_ID = @as(c_int, 309);
pub const SSL_R_ECC_CERT_NOT_FOR_SIGNING = @as(c_int, 318);
pub const SSL_R_ECDH_REQUIRED_FOR_SUITEB_MODE = @as(c_int, 374);
pub const SSL_R_EE_KEY_TOO_SMALL = @as(c_int, 399);
pub const SSL_R_EMPTY_RAW_PUBLIC_KEY = @as(c_int, 349);
pub const SSL_R_EMPTY_SRTP_PROTECTION_PROFILE_LIST = @as(c_int, 354);
pub const SSL_R_ENCRYPTED_LENGTH_TOO_LONG = @as(c_int, 150);
pub const SSL_R_ERROR_IN_RECEIVED_CIPHER_LIST = @as(c_int, 151);
pub const SSL_R_ERROR_IN_SYSTEM_DEFAULT_CONFIG = @as(c_int, 419);
pub const SSL_R_ERROR_SETTING_TLSA_BASE_DOMAIN = @as(c_int, 204);
pub const SSL_R_EXCEEDS_MAX_FRAGMENT_SIZE = @as(c_int, 194);
pub const SSL_R_EXCESSIVE_MESSAGE_SIZE = @as(c_int, 152);
pub const SSL_R_EXTENSION_NOT_RECEIVED = @as(c_int, 279);
pub const SSL_R_EXTRA_DATA_IN_MESSAGE = @as(c_int, 153);
pub const SSL_R_EXT_LENGTH_MISMATCH = @as(c_int, 163);
pub const SSL_R_FAILED_TO_GET_PARAMETER = @as(c_int, 316);
pub const SSL_R_FAILED_TO_INIT_ASYNC = @as(c_int, 405);
pub const SSL_R_FEATURE_NEGOTIATION_NOT_COMPLETE = @as(c_int, 417);
pub const SSL_R_FEATURE_NOT_RENEGOTIABLE = @as(c_int, 413);
pub const SSL_R_FRAGMENTED_CLIENT_HELLO = @as(c_int, 401);
pub const SSL_R_GOT_A_FIN_BEFORE_A_CCS = @as(c_int, 154);
pub const SSL_R_HTTPS_PROXY_REQUEST = @as(c_int, 155);
pub const SSL_R_HTTP_REQUEST = @as(c_int, 156);
pub const SSL_R_ILLEGAL_POINT_COMPRESSION = @as(c_int, 162);
pub const SSL_R_ILLEGAL_SUITEB_DIGEST = @as(c_int, 380);
pub const SSL_R_INAPPROPRIATE_FALLBACK = @as(c_int, 373);
pub const SSL_R_INCONSISTENT_COMPRESSION = @as(c_int, 340);
pub const SSL_R_INCONSISTENT_EARLY_DATA_ALPN = @as(c_int, 222);
pub const SSL_R_INCONSISTENT_EARLY_DATA_SNI = @as(c_int, 231);
pub const SSL_R_INCONSISTENT_EXTMS = @as(c_int, 104);
pub const SSL_R_INSUFFICIENT_SECURITY = @as(c_int, 241);
pub const SSL_R_INVALID_ALERT = @as(c_int, 205);
pub const SSL_R_INVALID_CCS_MESSAGE = @as(c_int, 260);
pub const SSL_R_INVALID_CERTIFICATE_OR_ALG = @as(c_int, 238);
pub const SSL_R_INVALID_COMMAND = @as(c_int, 280);
pub const SSL_R_INVALID_COMPRESSION_ALGORITHM = @as(c_int, 341);
pub const SSL_R_INVALID_CONFIG = @as(c_int, 283);
pub const SSL_R_INVALID_CONFIGURATION_NAME = @as(c_int, 113);
pub const SSL_R_INVALID_CONTEXT = @as(c_int, 282);
pub const SSL_R_INVALID_CT_VALIDATION_TYPE = @as(c_int, 212);
pub const SSL_R_INVALID_KEY_UPDATE_TYPE = @as(c_int, 120);
pub const SSL_R_INVALID_MAX_EARLY_DATA = @as(c_int, 174);
pub const SSL_R_INVALID_NULL_CMD_NAME = @as(c_int, 385);
pub const SSL_R_INVALID_RAW_PUBLIC_KEY = @as(c_int, 350);
pub const SSL_R_INVALID_RECORD = @as(c_int, 317);
pub const SSL_R_INVALID_SEQUENCE_NUMBER = @as(c_int, 402);
pub const SSL_R_INVALID_SERVERINFO_DATA = @as(c_int, 388);
pub const SSL_R_INVALID_SESSION_ID = @as(c_int, 999);
pub const SSL_R_INVALID_SRP_USERNAME = @as(c_int, 357);
pub const SSL_R_INVALID_STATUS_RESPONSE = @as(c_int, 328);
pub const SSL_R_INVALID_TICKET_KEYS_LENGTH = @as(c_int, 325);
pub const SSL_R_LEGACY_SIGALG_DISALLOWED_OR_UNSUPPORTED = @as(c_int, 333);
pub const SSL_R_LENGTH_MISMATCH = @as(c_int, 159);
pub const SSL_R_LENGTH_TOO_LONG = @as(c_int, 404);
pub const SSL_R_LENGTH_TOO_SHORT = @as(c_int, 160);
pub const SSL_R_LIBRARY_BUG = @as(c_int, 274);
pub const SSL_R_LIBRARY_HAS_NO_CIPHERS = @as(c_int, 161);
pub const SSL_R_MAXIMUM_ENCRYPTED_PKTS_REACHED = @as(c_int, 395);
pub const SSL_R_MISSING_DSA_SIGNING_CERT = @as(c_int, 165);
pub const SSL_R_MISSING_ECDSA_SIGNING_CERT = @as(c_int, 381);
pub const SSL_R_MISSING_FATAL = @as(c_int, 256);
pub const SSL_R_MISSING_PARAMETERS = @as(c_int, 290);
pub const SSL_R_MISSING_PSK_KEX_MODES_EXTENSION = @as(c_int, 310);
pub const SSL_R_MISSING_RSA_CERTIFICATE = @as(c_int, 168);
pub const SSL_R_MISSING_RSA_ENCRYPTING_CERT = @as(c_int, 169);
pub const SSL_R_MISSING_RSA_SIGNING_CERT = @as(c_int, 170);
pub const SSL_R_MISSING_SIGALGS_EXTENSION = @as(c_int, 112);
pub const SSL_R_MISSING_SIGNING_CERT = @as(c_int, 221);
pub const SSL_R_MISSING_SRP_PARAM = @as(c_int, 358);
pub const SSL_R_MISSING_SUPPORTED_GROUPS_EXTENSION = @as(c_int, 209);
pub const SSL_R_MISSING_SUPPORTED_VERSIONS_EXTENSION = @as(c_int, 420);
pub const SSL_R_MISSING_TMP_DH_KEY = @as(c_int, 171);
pub const SSL_R_MISSING_TMP_ECDH_KEY = @as(c_int, 311);
pub const SSL_R_MIXED_HANDSHAKE_AND_NON_HANDSHAKE_DATA = @as(c_int, 293);
pub const SSL_R_NOT_ON_RECORD_BOUNDARY = @as(c_int, 182);
pub const SSL_R_NOT_REPLACING_CERTIFICATE = @as(c_int, 289);
pub const SSL_R_NOT_SERVER = @as(c_int, 284);
pub const SSL_R_NO_APPLICATION_PROTOCOL = @as(c_int, 235);
pub const SSL_R_NO_CERTIFICATES_RETURNED = @as(c_int, 176);
pub const SSL_R_NO_CERTIFICATE_ASSIGNED = @as(c_int, 177);
pub const SSL_R_NO_CERTIFICATE_SET = @as(c_int, 179);
pub const SSL_R_NO_CHANGE_FOLLOWING_HRR = @as(c_int, 214);
pub const SSL_R_NO_CIPHERS_AVAILABLE = @as(c_int, 181);
pub const SSL_R_NO_CIPHERS_SPECIFIED = @as(c_int, 183);
pub const SSL_R_NO_CIPHER_MATCH = @as(c_int, 185);
pub const SSL_R_NO_CLIENT_CERT_METHOD = @as(c_int, 331);
pub const SSL_R_NO_COMPRESSION_SPECIFIED = @as(c_int, 187);
pub const SSL_R_NO_COOKIE_CALLBACK_SET = @as(c_int, 287);
pub const SSL_R_NO_GOST_CERTIFICATE_SENT_BY_PEER = @as(c_int, 330);
pub const SSL_R_NO_METHOD_SPECIFIED = @as(c_int, 188);
pub const SSL_R_NO_PEM_EXTENSIONS = @as(c_int, 389);
pub const SSL_R_NO_PRIVATE_KEY_ASSIGNED = @as(c_int, 190);
pub const SSL_R_NO_PROTOCOLS_AVAILABLE = @as(c_int, 191);
pub const SSL_R_NO_RENEGOTIATION = @as(c_int, 339);
pub const SSL_R_NO_REQUIRED_DIGEST = @as(c_int, 324);
pub const SSL_R_NO_SHARED_CIPHER = @as(c_int, 193);
pub const SSL_R_NO_SHARED_GROUPS = @as(c_int, 410);
pub const SSL_R_NO_SHARED_SIGNATURE_ALGORITHMS = @as(c_int, 376);
pub const SSL_R_NO_SRTP_PROFILES = @as(c_int, 359);
pub const SSL_R_NO_STREAM = @as(c_int, 355);
pub const SSL_R_NO_SUITABLE_DIGEST_ALGORITHM = @as(c_int, 297);
pub const SSL_R_NO_SUITABLE_GROUPS = @as(c_int, 295);
pub const SSL_R_NO_SUITABLE_KEY_SHARE = @as(c_int, 101);
pub const SSL_R_NO_SUITABLE_RECORD_LAYER = @as(c_int, 322);
pub const SSL_R_NO_SUITABLE_SIGNATURE_ALGORITHM = @as(c_int, 118);
pub const SSL_R_NO_VALID_SCTS = @as(c_int, 216);
pub const SSL_R_NO_VERIFY_COOKIE_CALLBACK = @as(c_int, 403);
pub const SSL_R_NULL_SSL_CTX = @as(c_int, 195);
pub const SSL_R_NULL_SSL_METHOD_PASSED = @as(c_int, 196);
pub const SSL_R_OCSP_CALLBACK_FAILURE = @as(c_int, 305);
pub const SSL_R_OLD_SESSION_CIPHER_NOT_RETURNED = @as(c_int, 197);
pub const SSL_R_OLD_SESSION_COMPRESSION_ALGORITHM_NOT_RETURNED = @as(c_int, 344);
pub const SSL_R_OVERFLOW_ERROR = @as(c_int, 237);
pub const SSL_R_PACKET_LENGTH_TOO_LONG = @as(c_int, 198);
pub const SSL_R_PARSE_TLSEXT = @as(c_int, 227);
pub const SSL_R_PATH_TOO_LONG = @as(c_int, 270);
pub const SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE = @as(c_int, 199);
pub const SSL_R_PEM_NAME_BAD_PREFIX = @as(c_int, 391);
pub const SSL_R_PEM_NAME_TOO_SHORT = @as(c_int, 392);
pub const SSL_R_PIPELINE_FAILURE = @as(c_int, 406);
pub const SSL_R_POLL_REQUEST_NOT_SUPPORTED = @as(c_int, 418);
pub const SSL_R_POST_HANDSHAKE_AUTH_ENCODING_ERR = @as(c_int, 278);
pub const SSL_R_PRIVATE_KEY_MISMATCH = @as(c_int, 288);
pub const SSL_R_PROTOCOL_IS_SHUTDOWN = @as(c_int, 207);
pub const SSL_R_PSK_IDENTITY_NOT_FOUND = @as(c_int, 223);
pub const SSL_R_PSK_NO_CLIENT_CB = @as(c_int, 224);
pub const SSL_R_PSK_NO_SERVER_CB = @as(c_int, 225);
pub const SSL_R_QUIC_HANDSHAKE_LAYER_ERROR = @as(c_int, 393);
pub const SSL_R_QUIC_NETWORK_ERROR = @as(c_int, 387);
pub const SSL_R_QUIC_PROTOCOL_ERROR = @as(c_int, 382);
pub const SSL_R_READ_BIO_NOT_SET = @as(c_int, 211);
pub const SSL_R_READ_TIMEOUT_EXPIRED = @as(c_int, 312);
pub const SSL_R_RECORDS_NOT_RELEASED = @as(c_int, 321);
pub const SSL_R_RECORD_LAYER_FAILURE = @as(c_int, 313);
pub const SSL_R_RECORD_LENGTH_MISMATCH = @as(c_int, 213);
pub const SSL_R_RECORD_TOO_SMALL = @as(c_int, 298);
pub const SSL_R_REMOTE_PEER_ADDRESS_NOT_SET = @as(c_int, 346);
pub const SSL_R_RENEGOTIATE_EXT_TOO_LONG = @as(c_int, 335);
pub const SSL_R_RENEGOTIATION_ENCODING_ERR = @as(c_int, 336);
pub const SSL_R_RENEGOTIATION_MISMATCH = @as(c_int, 337);
pub const SSL_R_REQUEST_PENDING = @as(c_int, 285);
pub const SSL_R_REQUEST_SENT = @as(c_int, 286);
pub const SSL_R_REQUIRED_CIPHER_MISSING = @as(c_int, 215);
pub const SSL_R_REQUIRED_COMPRESSION_ALGORITHM_MISSING = @as(c_int, 342);
pub const SSL_R_SCSV_RECEIVED_WHEN_RENEGOTIATING = @as(c_int, 345);
pub const SSL_R_SCT_VERIFICATION_FAILED = @as(c_int, 208);
pub const SSL_R_SEQUENCE_CTR_WRAPPED = @as(c_int, 327);
pub const SSL_R_SERVERHELLO_TLSEXT = @as(c_int, 275);
pub const SSL_R_SESSION_ID_CONTEXT_UNINITIALIZED = @as(c_int, 277);
pub const SSL_R_SHUTDOWN_WHILE_IN_INIT = @as(c_int, 407);
pub const SSL_R_SIGNATURE_ALGORITHMS_ERROR = @as(c_int, 360);
pub const SSL_R_SIGNATURE_FOR_NON_SIGNING_CERTIFICATE = @as(c_int, 220);
pub const SSL_R_SRP_A_CALC = @as(c_int, 361);
pub const SSL_R_SRTP_COULD_NOT_ALLOCATE_PROFILES = @as(c_int, 362);
pub const SSL_R_SRTP_PROTECTION_PROFILE_LIST_TOO_LONG = @as(c_int, 363);
pub const SSL_R_SRTP_UNKNOWN_PROTECTION_PROFILE = @as(c_int, 364);
pub const SSL_R_SSL3_EXT_INVALID_MAX_FRAGMENT_LENGTH = @as(c_int, 232);
pub const SSL_R_SSL3_EXT_INVALID_SERVERNAME = @as(c_int, 319);
pub const SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE = @as(c_int, 320);
pub const SSL_R_SSL3_SESSION_ID_TOO_LONG = @as(c_int, 300);
pub const SSL_R_SSLV3_ALERT_BAD_CERTIFICATE = @as(c_int, 1042);
pub const SSL_R_SSLV3_ALERT_BAD_RECORD_MAC = @as(c_int, 1020);
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED = @as(c_int, 1045);
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_REVOKED = @as(c_int, 1044);
pub const SSL_R_SSLV3_ALERT_CERTIFICATE_UNKNOWN = @as(c_int, 1046);
pub const SSL_R_SSLV3_ALERT_DECOMPRESSION_FAILURE = @as(c_int, 1030);
pub const SSL_R_SSLV3_ALERT_HANDSHAKE_FAILURE = @as(c_int, 1040);
pub const SSL_R_SSLV3_ALERT_ILLEGAL_PARAMETER = @as(c_int, 1047);
pub const SSL_R_SSLV3_ALERT_NO_CERTIFICATE = @as(c_int, 1041);
pub const SSL_R_SSLV3_ALERT_UNEXPECTED_MESSAGE = @as(c_int, 1010);
pub const SSL_R_SSLV3_ALERT_UNSUPPORTED_CERTIFICATE = @as(c_int, 1043);
pub const SSL_R_SSL_COMMAND_SECTION_EMPTY = @as(c_int, 117);
pub const SSL_R_SSL_COMMAND_SECTION_NOT_FOUND = @as(c_int, 125);
pub const SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION = @as(c_int, 228);
pub const SSL_R_SSL_HANDSHAKE_FAILURE = @as(c_int, 229);
pub const SSL_R_SSL_LIBRARY_HAS_NO_CIPHERS = @as(c_int, 230);
pub const SSL_R_SSL_NEGATIVE_LENGTH = @as(c_int, 372);
pub const SSL_R_SSL_SECTION_EMPTY = @as(c_int, 126);
pub const SSL_R_SSL_SECTION_NOT_FOUND = @as(c_int, 136);
pub const SSL_R_SSL_SESSION_ID_CALLBACK_FAILED = @as(c_int, 301);
pub const SSL_R_SSL_SESSION_ID_CONFLICT = @as(c_int, 302);
pub const SSL_R_SSL_SESSION_ID_CONTEXT_TOO_LONG = @as(c_int, 273);
pub const SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH = @as(c_int, 303);
pub const SSL_R_SSL_SESSION_ID_TOO_LONG = @as(c_int, 408);
pub const SSL_R_SSL_SESSION_VERSION_MISMATCH = @as(c_int, 210);
pub const SSL_R_STILL_IN_INIT = @as(c_int, 121);
pub const SSL_R_STREAM_COUNT_LIMITED = @as(c_int, 411);
pub const SSL_R_STREAM_FINISHED = @as(c_int, 365);
pub const SSL_R_STREAM_RECV_ONLY = @as(c_int, 366);
pub const SSL_R_STREAM_RESET = @as(c_int, 375);
pub const SSL_R_STREAM_SEND_ONLY = @as(c_int, 379);
pub const SSL_R_TLSV13_ALERT_CERTIFICATE_REQUIRED = @as(c_int, 1116);
pub const SSL_R_TLSV13_ALERT_MISSING_EXTENSION = @as(c_int, 1109);
pub const SSL_R_TLSV1_ALERT_ACCESS_DENIED = @as(c_int, 1049);
pub const SSL_R_TLSV1_ALERT_DECODE_ERROR = @as(c_int, 1050);
pub const SSL_R_TLSV1_ALERT_DECRYPTION_FAILED = @as(c_int, 1021);
pub const SSL_R_TLSV1_ALERT_DECRYPT_ERROR = @as(c_int, 1051);
pub const SSL_R_TLSV1_ALERT_EXPORT_RESTRICTION = @as(c_int, 1060);
pub const SSL_R_TLSV1_ALERT_INAPPROPRIATE_FALLBACK = @as(c_int, 1086);
pub const SSL_R_TLSV1_ALERT_INSUFFICIENT_SECURITY = @as(c_int, 1071);
pub const SSL_R_TLSV1_ALERT_INTERNAL_ERROR = @as(c_int, 1080);
pub const SSL_R_TLSV1_ALERT_NO_APPLICATION_PROTOCOL = @as(c_int, 1120);
pub const SSL_R_TLSV1_ALERT_NO_RENEGOTIATION = @as(c_int, 1100);
pub const SSL_R_TLSV1_ALERT_PROTOCOL_VERSION = @as(c_int, 1070);
pub const SSL_R_TLSV1_ALERT_RECORD_OVERFLOW = @as(c_int, 1022);
pub const SSL_R_TLSV1_ALERT_UNKNOWN_CA = @as(c_int, 1048);
pub const SSL_R_TLSV1_ALERT_UNKNOWN_PSK_IDENTITY = @as(c_int, 1115);
pub const SSL_R_TLSV1_ALERT_USER_CANCELLED = @as(c_int, 1090);
pub const SSL_R_TLSV1_BAD_CERTIFICATE_HASH_VALUE = @as(c_int, 1114);
pub const SSL_R_TLSV1_BAD_CERTIFICATE_STATUS_RESPONSE = @as(c_int, 1113);
pub const SSL_R_TLSV1_CERTIFICATE_UNOBTAINABLE = @as(c_int, 1111);
pub const SSL_R_TLSV1_UNRECOGNIZED_NAME = @as(c_int, 1112);
pub const SSL_R_TLSV1_UNSUPPORTED_EXTENSION = @as(c_int, 1110);
pub const SSL_R_TLS_ILLEGAL_EXPORTER_LABEL = @as(c_int, 367);
pub const SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST = @as(c_int, 157);
pub const SSL_R_TOO_MANY_KEY_UPDATES = @as(c_int, 132);
pub const SSL_R_TOO_MANY_WARN_ALERTS = @as(c_int, 409);
pub const SSL_R_TOO_MUCH_EARLY_DATA = @as(c_int, 164);
pub const SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS = @as(c_int, 314);
pub const SSL_R_UNABLE_TO_FIND_PUBLIC_KEY_PARAMETERS = @as(c_int, 239);
pub const SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES = @as(c_int, 242);
pub const SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES = @as(c_int, 243);
pub const SSL_R_UNEXPECTED_CCS_MESSAGE = @as(c_int, 262);
pub const SSL_R_UNEXPECTED_END_OF_EARLY_DATA = @as(c_int, 178);
pub const SSL_R_UNEXPECTED_EOF_WHILE_READING = @as(c_int, 294);
pub const SSL_R_UNEXPECTED_MESSAGE = @as(c_int, 244);
pub const SSL_R_UNEXPECTED_RECORD = @as(c_int, 245);
pub const SSL_R_UNINITIALIZED = @as(c_int, 276);
pub const SSL_R_UNKNOWN_ALERT_TYPE = @as(c_int, 246);
pub const SSL_R_UNKNOWN_CERTIFICATE_TYPE = @as(c_int, 247);
pub const SSL_R_UNKNOWN_CIPHER_RETURNED = @as(c_int, 248);
pub const SSL_R_UNKNOWN_CIPHER_TYPE = @as(c_int, 249);
pub const SSL_R_UNKNOWN_CMD_NAME = @as(c_int, 386);
pub const SSL_R_UNKNOWN_COMMAND = @as(c_int, 139);
pub const SSL_R_UNKNOWN_DIGEST = @as(c_int, 368);
pub const SSL_R_UNKNOWN_KEY_EXCHANGE_TYPE = @as(c_int, 250);
pub const SSL_R_UNKNOWN_MANDATORY_PARAMETER = @as(c_int, 323);
pub const SSL_R_UNKNOWN_PKEY_TYPE = @as(c_int, 251);
pub const SSL_R_UNKNOWN_PROTOCOL = @as(c_int, 252);
pub const SSL_R_UNKNOWN_SSL_VERSION = @as(c_int, 254);
pub const SSL_R_UNKNOWN_STATE = @as(c_int, 255);
pub const SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED = @as(c_int, 338);
pub const SSL_R_UNSOLICITED_EXTENSION = @as(c_int, 217);
pub const SSL_R_UNSUPPORTED_COMPRESSION_ALGORITHM = @as(c_int, 257);
pub const SSL_R_UNSUPPORTED_CONFIG_VALUE = @as(c_int, 414);
pub const SSL_R_UNSUPPORTED_CONFIG_VALUE_CLASS = @as(c_int, 415);
pub const SSL_R_UNSUPPORTED_CONFIG_VALUE_OP = @as(c_int, 416);
pub const SSL_R_UNSUPPORTED_ELLIPTIC_CURVE = @as(c_int, 315);
pub const SSL_R_UNSUPPORTED_PROTOCOL = @as(c_int, 258);
pub const SSL_R_UNSUPPORTED_SSL_VERSION = @as(c_int, 259);
pub const SSL_R_UNSUPPORTED_STATUS_TYPE = @as(c_int, 329);
pub const SSL_R_UNSUPPORTED_WRITE_FLAG = @as(c_int, 412);
pub const SSL_R_USE_SRTP_NOT_NEGOTIATED = @as(c_int, 369);
pub const SSL_R_VERSION_TOO_HIGH = @as(c_int, 166);
pub const SSL_R_VERSION_TOO_LOW = @as(c_int, 396);
pub const SSL_R_WRONG_CERTIFICATE_TYPE = @as(c_int, 383);
pub const SSL_R_WRONG_CIPHER_RETURNED = @as(c_int, 261);
pub const SSL_R_WRONG_CURVE = @as(c_int, 378);
pub const SSL_R_WRONG_RPK_TYPE = @as(c_int, 351);
pub const SSL_R_WRONG_SIGNATURE_LENGTH = @as(c_int, 264);
pub const SSL_R_WRONG_SIGNATURE_SIZE = @as(c_int, 265);
pub const SSL_R_WRONG_SIGNATURE_TYPE = @as(c_int, 370);
pub const SSL_R_WRONG_SSL_VERSION = @as(c_int, 266);
pub const SSL_R_WRONG_VERSION_NUMBER = @as(c_int, 267);
pub const SSL_R_X509_LIB = @as(c_int, 268);
pub const SSL_R_X509_VERIFICATION_SETUP_PROBLEMS = @as(c_int, 269);
pub const OPENSSL_PROV_SSL_H = "";
pub const SSL_MAX_MASTER_KEY_LENGTH = @as(c_int, 48);
pub const SSL3_VERSION = @as(c_int, 0x0300);
pub const TLS1_VERSION = @as(c_int, 0x0301);
pub const TLS1_1_VERSION = @as(c_int, 0x0302);
pub const TLS1_2_VERSION = @as(c_int, 0x0303);
pub const TLS1_3_VERSION = @as(c_int, 0x0304);
pub const DTLS1_VERSION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFEFF, .hex);
pub const DTLS1_2_VERSION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFEFD, .hex);
pub const DTLS1_BAD_VER = @as(c_int, 0x0100);
pub const OSSL_QUIC1_VERSION = @as(c_int, 0x0000001);
pub const SSL_SESSION_ASN1_VERSION = @as(c_int, 0x0001);
pub const SSL_MAX_SSL_SESSION_ID_LENGTH = @as(c_int, 32);
pub const SSL_MAX_SID_CTX_LENGTH = @as(c_int, 32);
pub const SSL_MIN_RSA_MODULUS_LENGTH_IN_BYTES = @import("std").zig.c_translation.MacroArithmetic.div(@as(c_int, 512), @as(c_int, 8));
pub const SSL_MAX_KEY_ARG_LENGTH = @as(c_int, 8);
pub const SSL_MAX_PIPELINES = @as(c_int, 32);
pub const SSL_TXT_LOW = "LOW";
pub const SSL_TXT_MEDIUM = "MEDIUM";
pub const SSL_TXT_HIGH = "HIGH";
pub const SSL_TXT_FIPS = "FIPS";
pub const SSL_TXT_aNULL = "aNULL";
pub const SSL_TXT_eNULL = "eNULL";
pub const SSL_TXT_NULL = "NULL";
pub const SSL_TXT_kRSA = "kRSA";
pub const SSL_TXT_kDHr = "kDHr";
pub const SSL_TXT_kDHd = "kDHd";
pub const SSL_TXT_kDH = "kDH";
pub const SSL_TXT_kEDH = "kEDH";
pub const SSL_TXT_kDHE = "kDHE";
pub const SSL_TXT_kECDHr = "kECDHr";
pub const SSL_TXT_kECDHe = "kECDHe";
pub const SSL_TXT_kECDH = "kECDH";
pub const SSL_TXT_kEECDH = "kEECDH";
pub const SSL_TXT_kECDHE = "kECDHE";
pub const SSL_TXT_kPSK = "kPSK";
pub const SSL_TXT_kRSAPSK = "kRSAPSK";
pub const SSL_TXT_kECDHEPSK = "kECDHEPSK";
pub const SSL_TXT_kDHEPSK = "kDHEPSK";
pub const SSL_TXT_kGOST = "kGOST";
pub const SSL_TXT_kGOST18 = "kGOST18";
pub const SSL_TXT_kSRP = "kSRP";
pub const SSL_TXT_aRSA = "aRSA";
pub const SSL_TXT_aDSS = "aDSS";
pub const SSL_TXT_aDH = "aDH";
pub const SSL_TXT_aECDH = "aECDH";
pub const SSL_TXT_aECDSA = "aECDSA";
pub const SSL_TXT_aPSK = "aPSK";
pub const SSL_TXT_aGOST94 = "aGOST94";
pub const SSL_TXT_aGOST01 = "aGOST01";
pub const SSL_TXT_aGOST12 = "aGOST12";
pub const SSL_TXT_aGOST = "aGOST";
pub const SSL_TXT_aSRP = "aSRP";
pub const SSL_TXT_DSS = "DSS";
pub const SSL_TXT_DH = "DH";
pub const SSL_TXT_DHE = "DHE";
pub const SSL_TXT_EDH = "EDH";
pub const SSL_TXT_ADH = "ADH";
pub const SSL_TXT_RSA = "RSA";
pub const SSL_TXT_ECDH = "ECDH";
pub const SSL_TXT_EECDH = "EECDH";
pub const SSL_TXT_ECDHE = "ECDHE";
pub const SSL_TXT_AECDH = "AECDH";
pub const SSL_TXT_ECDSA = "ECDSA";
pub const SSL_TXT_PSK = "PSK";
pub const SSL_TXT_SRP = "SRP";
pub const SSL_TXT_DES = "DES";
pub const SSL_TXT_3DES = "3DES";
pub const SSL_TXT_RC4 = "RC4";
pub const SSL_TXT_RC2 = "RC2";
pub const SSL_TXT_IDEA = "IDEA";
pub const SSL_TXT_SEED = "SEED";
pub const SSL_TXT_AES128 = "AES128";
pub const SSL_TXT_AES256 = "AES256";
pub const SSL_TXT_AES = "AES";
pub const SSL_TXT_AES_GCM = "AESGCM";
pub const SSL_TXT_AES_CCM = "AESCCM";
pub const SSL_TXT_AES_CCM_8 = "AESCCM8";
pub const SSL_TXT_CAMELLIA128 = "CAMELLIA128";
pub const SSL_TXT_CAMELLIA256 = "CAMELLIA256";
pub const SSL_TXT_CAMELLIA = "CAMELLIA";
pub const SSL_TXT_CHACHA20 = "CHACHA20";
pub const SSL_TXT_GOST = "GOST89";
pub const SSL_TXT_ARIA = "ARIA";
pub const SSL_TXT_ARIA_GCM = "ARIAGCM";
pub const SSL_TXT_ARIA128 = "ARIA128";
pub const SSL_TXT_ARIA256 = "ARIA256";
pub const SSL_TXT_GOST2012_GOST8912_GOST8912 = "GOST2012-GOST8912-GOST8912";
pub const SSL_TXT_CBC = "CBC";
pub const SSL_TXT_MD5 = "MD5";
pub const SSL_TXT_SHA1 = "SHA1";
pub const SSL_TXT_SHA = "SHA";
pub const SSL_TXT_GOST94 = "GOST94";
pub const SSL_TXT_GOST89MAC = "GOST89MAC";
pub const SSL_TXT_GOST12 = "GOST12";
pub const SSL_TXT_GOST89MAC12 = "GOST89MAC12";
pub const SSL_TXT_SHA256 = "SHA256";
pub const SSL_TXT_SHA384 = "SHA384";
pub const SSL_TXT_SSLV3 = "SSLv3";
pub const SSL_TXT_TLSV1 = "TLSv1";
pub const SSL_TXT_TLSV1_1 = "TLSv1.1";
pub const SSL_TXT_TLSV1_2 = "TLSv1.2";
pub const SSL_TXT_ALL = "ALL";
pub const SSL_TXT_CMPALL = "COMPLEMENTOFALL";
pub const SSL_TXT_CMPDEF = "COMPLEMENTOFDEFAULT";
pub const SSL_DEFAULT_CIPHER_LIST = "ALL:!COMPLEMENTOFDEFAULT:!eNULL";
pub const TLS_DEFAULT_CIPHERSUITES = "TLS_AES_256_GCM_SHA384:" ++ "TLS_CHACHA20_POLY1305_SHA256:" ++ "TLS_AES_128_GCM_SHA256";
pub const SSL_SENT_SHUTDOWN = @as(c_int, 1);
pub const SSL_RECEIVED_SHUTDOWN = @as(c_int, 2);
pub const SSL_FILETYPE_ASN1 = X509_FILETYPE_ASN1;
pub const SSL_FILETYPE_PEM = X509_FILETYPE_PEM;
pub inline fn sk_SRTP_PROTECTION_PROFILE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(sk));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_value(sk: anytype, idx: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_value(ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(sk), idx));
}
pub const sk_SRTP_PROTECTION_PROFILE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ssl.h:249:9
pub const sk_SRTP_PROTECTION_PROFILE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ssl.h:250:9
pub const sk_SRTP_PROTECTION_PROFILE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ssl.h:251:9
pub inline fn sk_SRTP_PROTECTION_PROFILE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), n);
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_delete(sk: anytype, i: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_delete(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), i));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_delete_ptr(sk: anytype, ptr: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_delete_ptr(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr)));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_pop(sk: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_pop(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk)));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_shift(sk: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_shift(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk)));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_freefunc_type(freefunc));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr), idx);
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]SRTP_PROTECTION_PROFILE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SRTP_PROTECTION_PROFILE, OPENSSL_sk_set(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), idx, ossl_check_SRTP_PROTECTION_PROFILE_type(ptr)));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_type(ptr), pnum);
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk));
}
pub inline fn sk_SRTP_PROTECTION_PROFILE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_SRTP_PROTECTION_PROFILE_sk_type(sk));
}
pub const sk_SRTP_PROTECTION_PROFILE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ssl.h:269:9
pub const sk_SRTP_PROTECTION_PROFILE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ssl.h:270:9
pub inline fn sk_SRTP_PROTECTION_PROFILE_set_cmp_func(sk: anytype, cmp: anytype) sk_SRTP_PROTECTION_PROFILE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_SRTP_PROTECTION_PROFILE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_SRTP_PROTECTION_PROFILE_sk_type(sk), ossl_check_SRTP_PROTECTION_PROFILE_compfunc_type(cmp)));
}
pub const SSL_EXT_TLS_ONLY = @as(c_int, 0x00001);
pub const SSL_EXT_DTLS_ONLY = @as(c_int, 0x00002);
pub const SSL_EXT_TLS_IMPLEMENTATION_ONLY = @as(c_int, 0x00004);
pub const SSL_EXT_SSL3_ALLOWED = @as(c_int, 0x00008);
pub const SSL_EXT_TLS1_2_AND_BELOW_ONLY = @as(c_int, 0x00010);
pub const SSL_EXT_TLS1_3_ONLY = @as(c_int, 0x00020);
pub const SSL_EXT_IGNORE_ON_RESUMPTION = @as(c_int, 0x00040);
pub const SSL_EXT_CLIENT_HELLO = @as(c_int, 0x00080);
pub const SSL_EXT_TLS1_2_SERVER_HELLO = @as(c_int, 0x00100);
pub const SSL_EXT_TLS1_3_SERVER_HELLO = @as(c_int, 0x00200);
pub const SSL_EXT_TLS1_3_ENCRYPTED_EXTENSIONS = @as(c_int, 0x00400);
pub const SSL_EXT_TLS1_3_HELLO_RETRY_REQUEST = @as(c_int, 0x00800);
pub const SSL_EXT_TLS1_3_CERTIFICATE = @as(c_int, 0x01000);
pub const SSL_EXT_TLS1_3_NEW_SESSION_TICKET = @as(c_int, 0x02000);
pub const SSL_EXT_TLS1_3_CERTIFICATE_REQUEST = @as(c_int, 0x04000);
pub const SSL_EXT_TLS1_3_CERTIFICATE_COMPRESSION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000, .hex);
pub const SSL_EXT_TLS1_3_RAW_PUBLIC_KEY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub inline fn SSL_OP_BIT(n: anytype) @TypeOf(@import("std").zig.c_translation.cast(u64, @as(c_int, 1)) << @import("std").zig.c_translation.cast(u64, n)) {
    _ = &n;
    return @import("std").zig.c_translation.cast(u64, @as(c_int, 1)) << @import("std").zig.c_translation.cast(u64, n);
}
pub const SSL_OP_NO_EXTENDED_MASTER_SECRET = SSL_OP_BIT(@as(c_int, 0));
pub const SSL_OP_CLEANSE_PLAINTEXT = SSL_OP_BIT(@as(c_int, 1));
pub const SSL_OP_LEGACY_SERVER_CONNECT = SSL_OP_BIT(@as(c_int, 2));
pub const SSL_OP_ENABLE_KTLS = SSL_OP_BIT(@as(c_int, 3));
pub const SSL_OP_TLSEXT_PADDING = SSL_OP_BIT(@as(c_int, 4));
pub const SSL_OP_SAFARI_ECDHE_ECDSA_BUG = SSL_OP_BIT(@as(c_int, 6));
pub const SSL_OP_IGNORE_UNEXPECTED_EOF = SSL_OP_BIT(@as(c_int, 7));
pub const SSL_OP_ALLOW_CLIENT_RENEGOTIATION = SSL_OP_BIT(@as(c_int, 8));
pub const SSL_OP_DISABLE_TLSEXT_CA_NAMES = SSL_OP_BIT(@as(c_int, 9));
pub const SSL_OP_ALLOW_NO_DHE_KEX = SSL_OP_BIT(@as(c_int, 10));
pub const SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = SSL_OP_BIT(@as(c_int, 11));
pub const SSL_OP_NO_QUERY_MTU = SSL_OP_BIT(@as(c_int, 12));
pub const SSL_OP_COOKIE_EXCHANGE = SSL_OP_BIT(@as(c_int, 13));
pub const SSL_OP_NO_TICKET = SSL_OP_BIT(@as(c_int, 14));
pub const SSL_OP_CISCO_ANYCONNECT = SSL_OP_BIT(@as(c_int, 15));
pub const SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = SSL_OP_BIT(@as(c_int, 16));
pub const SSL_OP_NO_COMPRESSION = SSL_OP_BIT(@as(c_int, 17));
pub const SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = SSL_OP_BIT(@as(c_int, 18));
pub const SSL_OP_NO_ENCRYPT_THEN_MAC = SSL_OP_BIT(@as(c_int, 19));
pub const SSL_OP_ENABLE_MIDDLEBOX_COMPAT = SSL_OP_BIT(@as(c_int, 20));
pub const SSL_OP_PRIORITIZE_CHACHA = SSL_OP_BIT(@as(c_int, 21));
pub const SSL_OP_CIPHER_SERVER_PREFERENCE = SSL_OP_BIT(@as(c_int, 22));
pub const SSL_OP_TLS_ROLLBACK_BUG = SSL_OP_BIT(@as(c_int, 23));
pub const SSL_OP_NO_ANTI_REPLAY = SSL_OP_BIT(@as(c_int, 24));
pub const SSL_OP_NO_SSLv3 = SSL_OP_BIT(@as(c_int, 25));
pub const SSL_OP_NO_TLSv1 = SSL_OP_BIT(@as(c_int, 26));
pub const SSL_OP_NO_TLSv1_2 = SSL_OP_BIT(@as(c_int, 27));
pub const SSL_OP_NO_TLSv1_1 = SSL_OP_BIT(@as(c_int, 28));
pub const SSL_OP_NO_TLSv1_3 = SSL_OP_BIT(@as(c_int, 29));
pub const SSL_OP_NO_DTLSv1 = SSL_OP_BIT(@as(c_int, 26));
pub const SSL_OP_NO_DTLSv1_2 = SSL_OP_BIT(@as(c_int, 27));
pub const SSL_OP_NO_RENEGOTIATION = SSL_OP_BIT(@as(c_int, 30));
pub const SSL_OP_CRYPTOPRO_TLSEXT_BUG = SSL_OP_BIT(@as(c_int, 31));
pub const SSL_OP_NO_TX_CERTIFICATE_COMPRESSION = SSL_OP_BIT(@as(c_int, 32));
pub const SSL_OP_NO_RX_CERTIFICATE_COMPRESSION = SSL_OP_BIT(@as(c_int, 33));
pub const SSL_OP_ENABLE_KTLS_TX_ZEROCOPY_SENDFILE = SSL_OP_BIT(@as(c_int, 34));
pub const SSL_OP_PREFER_NO_DHE_KEX = SSL_OP_BIT(@as(c_int, 35));
pub const SSL_OP_NO_SSL_MASK = (((SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1) | SSL_OP_NO_TLSv1_1) | SSL_OP_NO_TLSv1_2) | SSL_OP_NO_TLSv1_3;
pub const SSL_OP_NO_DTLS_MASK = SSL_OP_NO_DTLSv1 | SSL_OP_NO_DTLSv1_2;
pub const SSL_OP_ALL = ((SSL_OP_CRYPTOPRO_TLSEXT_BUG | SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS) | SSL_OP_TLSEXT_PADDING) | SSL_OP_SAFARI_ECDHE_ECDSA_BUG;
pub const SSL_OP_MICROSOFT_SESS_ID_BUG = @as(c_int, 0x0);
pub const SSL_OP_NETSCAPE_CHALLENGE_BUG = @as(c_int, 0x0);
pub const SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = @as(c_int, 0x0);
pub const SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = @as(c_int, 0x0);
pub const SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = @as(c_int, 0x0);
pub const SSL_OP_MSIE_SSLV2_RSA_PADDING = @as(c_int, 0x0);
pub const SSL_OP_SSLEAY_080_CLIENT_DH_BUG = @as(c_int, 0x0);
pub const SSL_OP_TLS_D5_BUG = @as(c_int, 0x0);
pub const SSL_OP_TLS_BLOCK_PADDING_BUG = @as(c_int, 0x0);
pub const SSL_OP_SINGLE_ECDH_USE = @as(c_int, 0x0);
pub const SSL_OP_SINGLE_DH_USE = @as(c_int, 0x0);
pub const SSL_OP_EPHEMERAL_RSA = @as(c_int, 0x0);
pub const SSL_OP_NO_SSLv2 = @as(c_int, 0x0);
pub const SSL_OP_PKCS1_CHECK_1 = @as(c_int, 0x0);
pub const SSL_OP_PKCS1_CHECK_2 = @as(c_int, 0x0);
pub const SSL_OP_NETSCAPE_CA_DN_BUG = @as(c_int, 0x0);
pub const SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = @as(c_int, 0x0);
pub const SSL_MODE_ENABLE_PARTIAL_WRITE = @as(c_uint, 0x00000001);
pub const SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER = @as(c_uint, 0x00000002);
pub const SSL_MODE_AUTO_RETRY = @as(c_uint, 0x00000004);
pub const SSL_MODE_NO_AUTO_CHAIN = @as(c_uint, 0x00000008);
pub const SSL_MODE_RELEASE_BUFFERS = @as(c_uint, 0x00000010);
pub const SSL_MODE_SEND_CLIENTHELLO_TIME = @as(c_uint, 0x00000020);
pub const SSL_MODE_SEND_SERVERHELLO_TIME = @as(c_uint, 0x00000040);
pub const SSL_MODE_SEND_FALLBACK_SCSV = @as(c_uint, 0x00000080);
pub const SSL_MODE_ASYNC = @as(c_uint, 0x00000100);
pub const SSL_MODE_DTLS_SCTP_LABEL_LENGTH_BUG = @as(c_uint, 0x00000400);
pub const SSL_CERT_FLAG_TLS_STRICT = @as(c_uint, 0x00000001);
pub const SSL_CERT_FLAG_SUITEB_128_LOS_ONLY = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const SSL_CERT_FLAG_SUITEB_192_LOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000, .hex);
pub const SSL_CERT_FLAG_SUITEB_128_LOS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x30000, .hex);
pub const SSL_CERT_FLAG_BROKEN_PROTOCOL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000000, .hex);
pub const SSL_BUILD_CHAIN_FLAG_UNTRUSTED = @as(c_int, 0x1);
pub const SSL_BUILD_CHAIN_FLAG_NO_ROOT = @as(c_int, 0x2);
pub const SSL_BUILD_CHAIN_FLAG_CHECK = @as(c_int, 0x4);
pub const SSL_BUILD_CHAIN_FLAG_IGNORE_ERROR = @as(c_int, 0x8);
pub const SSL_BUILD_CHAIN_FLAG_CLEAR_ERROR = @as(c_int, 0x10);
pub const CERT_PKEY_VALID = @as(c_int, 0x1);
pub const CERT_PKEY_SIGN = @as(c_int, 0x2);
pub const CERT_PKEY_EE_SIGNATURE = @as(c_int, 0x10);
pub const CERT_PKEY_CA_SIGNATURE = @as(c_int, 0x20);
pub const CERT_PKEY_EE_PARAM = @as(c_int, 0x40);
pub const CERT_PKEY_CA_PARAM = @as(c_int, 0x80);
pub const CERT_PKEY_EXPLICIT_SIGN = @as(c_int, 0x100);
pub const CERT_PKEY_ISSUER_NAME = @as(c_int, 0x200);
pub const CERT_PKEY_CERT_TYPE = @as(c_int, 0x400);
pub const CERT_PKEY_SUITEB = @as(c_int, 0x800);
pub const CERT_PKEY_RPK = @as(c_int, 0x1000);
pub const SSL_CONF_FLAG_CMDLINE = @as(c_int, 0x1);
pub const SSL_CONF_FLAG_FILE = @as(c_int, 0x2);
pub const SSL_CONF_FLAG_CLIENT = @as(c_int, 0x4);
pub const SSL_CONF_FLAG_SERVER = @as(c_int, 0x8);
pub const SSL_CONF_FLAG_SHOW_ERRORS = @as(c_int, 0x10);
pub const SSL_CONF_FLAG_CERTIFICATE = @as(c_int, 0x20);
pub const SSL_CONF_FLAG_REQUIRE_PRIVATE = @as(c_int, 0x40);
pub const SSL_CONF_TYPE_UNKNOWN = @as(c_int, 0x0);
pub const SSL_CONF_TYPE_STRING = @as(c_int, 0x1);
pub const SSL_CONF_TYPE_FILE = @as(c_int, 0x2);
pub const SSL_CONF_TYPE_DIR = @as(c_int, 0x3);
pub const SSL_CONF_TYPE_NONE = @as(c_int, 0x4);
pub const SSL_CONF_TYPE_STORE = @as(c_int, 0x5);
pub const SSL_COOKIE_LENGTH = @as(c_int, 4096);
pub inline fn SSL_CTX_set_mode(ctx: anytype, op: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, op, NULL)) {
    _ = &ctx;
    _ = &op;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, op, NULL);
}
pub inline fn SSL_CTX_clear_mode(ctx: anytype, op: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_MODE, op, NULL)) {
    _ = &ctx;
    _ = &op;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_MODE, op, NULL);
}
pub inline fn SSL_CTX_get_mode(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, @as(c_int, 0), NULL);
}
pub inline fn SSL_clear_mode(ssl: anytype, op: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_CLEAR_MODE, op, NULL)) {
    _ = &ssl;
    _ = &op;
    return SSL_ctrl(ssl, SSL_CTRL_CLEAR_MODE, op, NULL);
}
pub inline fn SSL_set_mode(ssl: anytype, op: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_MODE, op, NULL)) {
    _ = &ssl;
    _ = &op;
    return SSL_ctrl(ssl, SSL_CTRL_MODE, op, NULL);
}
pub inline fn SSL_get_mode(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_MODE, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_MODE, @as(c_int, 0), NULL);
}
pub inline fn SSL_set_mtu(ssl: anytype, mtu: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_MTU, mtu, NULL)) {
    _ = &ssl;
    _ = &mtu;
    return SSL_ctrl(ssl, SSL_CTRL_SET_MTU, mtu, NULL);
}
pub inline fn DTLS_set_link_mtu(ssl: anytype, mtu: anytype) @TypeOf(SSL_ctrl(ssl, DTLS_CTRL_SET_LINK_MTU, mtu, NULL)) {
    _ = &ssl;
    _ = &mtu;
    return SSL_ctrl(ssl, DTLS_CTRL_SET_LINK_MTU, mtu, NULL);
}
pub inline fn DTLS_get_link_min_mtu(ssl: anytype) @TypeOf(SSL_ctrl(ssl, DTLS_CTRL_GET_LINK_MIN_MTU, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, DTLS_CTRL_GET_LINK_MIN_MTU, @as(c_int, 0), NULL);
}
pub inline fn SSL_get_secure_renegotiation_support(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_RI_SUPPORT, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_GET_RI_SUPPORT, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set_cert_flags(ctx: anytype, op: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CERT_FLAGS, op, NULL)) {
    _ = &ctx;
    _ = &op;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CERT_FLAGS, op, NULL);
}
pub inline fn SSL_set_cert_flags(s: anytype, op: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CERT_FLAGS, op, NULL)) {
    _ = &s;
    _ = &op;
    return SSL_ctrl(s, SSL_CTRL_CERT_FLAGS, op, NULL);
}
pub inline fn SSL_CTX_clear_cert_flags(ctx: anytype, op: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_CERT_FLAGS, op, NULL)) {
    _ = &ctx;
    _ = &op;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_CERT_FLAGS, op, NULL);
}
pub inline fn SSL_clear_cert_flags(s: anytype, op: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CLEAR_CERT_FLAGS, op, NULL)) {
    _ = &s;
    _ = &op;
    return SSL_ctrl(s, SSL_CTRL_CLEAR_CERT_FLAGS, op, NULL);
}
pub inline fn SSL_CTX_set_msg_callback_arg(ctx: anytype, arg: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK_ARG, @as(c_int, 0), arg)) {
    _ = &ctx;
    _ = &arg;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MSG_CALLBACK_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_set_msg_callback_arg(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_MSG_CALLBACK_ARG, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_SET_MSG_CALLBACK_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_get_extms_support(s: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_EXTMS_SUPPORT, @as(c_int, 0), NULL)) {
    _ = &s;
    return SSL_ctrl(s, SSL_CTRL_GET_EXTMS_SUPPORT, @as(c_int, 0), NULL);
}
pub const SSL_MAX_CERT_LIST_DEFAULT = @as(c_int, 1024) * @as(c_int, 100);
pub const SSL_SESSION_CACHE_MAX_SIZE_DEFAULT = @as(c_int, 1024) * @as(c_int, 20);
pub const SSL_SESS_CACHE_OFF = @as(c_int, 0x0000);
pub const SSL_SESS_CACHE_CLIENT = @as(c_int, 0x0001);
pub const SSL_SESS_CACHE_SERVER = @as(c_int, 0x0002);
pub const SSL_SESS_CACHE_BOTH = SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_SERVER;
pub const SSL_SESS_CACHE_NO_AUTO_CLEAR = @as(c_int, 0x0080);
pub const SSL_SESS_CACHE_NO_INTERNAL_LOOKUP = @as(c_int, 0x0100);
pub const SSL_SESS_CACHE_NO_INTERNAL_STORE = @as(c_int, 0x0200);
pub const SSL_SESS_CACHE_NO_INTERNAL = SSL_SESS_CACHE_NO_INTERNAL_LOOKUP | SSL_SESS_CACHE_NO_INTERNAL_STORE;
pub const SSL_SESS_CACHE_UPDATE_TIME = @as(c_int, 0x0400);
pub inline fn SSL_CTX_sess_number(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_NUMBER, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_NUMBER, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_connect(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_connect_good(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_GOOD, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_GOOD, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_connect_renegotiate(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_RENEGOTIATE, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CONNECT_RENEGOTIATE, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_accept(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_accept_renegotiate(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_RENEGOTIATE, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_RENEGOTIATE, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_accept_good(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_GOOD, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_ACCEPT_GOOD, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_hits(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_HIT, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_HIT, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_cb_hits(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CB_HIT, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CB_HIT, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_misses(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_MISSES, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_MISSES, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_timeouts(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_TIMEOUTS, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_TIMEOUTS, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_sess_cache_full(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CACHE_FULL, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SESS_CACHE_FULL, @as(c_int, 0), NULL);
}
pub const SSL_CTX_set_npn_advertised_cb = SSL_CTX_set_next_protos_advertised_cb;
pub const SSL_CTX_set_npn_select_cb = SSL_CTX_set_next_proto_select_cb;
pub const SSL_get0_npn_negotiated = SSL_get0_next_proto_negotiated;
pub const OPENSSL_NPN_UNSUPPORTED = @as(c_int, 0);
pub const OPENSSL_NPN_NEGOTIATED = @as(c_int, 1);
pub const OPENSSL_NPN_NO_OVERLAP = @as(c_int, 2);
pub const PSK_MAX_IDENTITY_LEN = @as(c_int, 256);
pub const PSK_MAX_PSK_LEN = @as(c_int, 512);
pub const SSL_NOTHING = @as(c_int, 1);
pub const SSL_WRITING = @as(c_int, 2);
pub const SSL_READING = @as(c_int, 3);
pub const SSL_X509_LOOKUP = @as(c_int, 4);
pub const SSL_ASYNC_PAUSED = @as(c_int, 5);
pub const SSL_ASYNC_NO_JOBS = @as(c_int, 6);
pub const SSL_CLIENT_HELLO_CB = @as(c_int, 7);
pub const SSL_RETRY_VERIFY = @as(c_int, 8);
pub inline fn SSL_want_nothing(s: anytype) @TypeOf(SSL_want(s) == SSL_NOTHING) {
    _ = &s;
    return SSL_want(s) == SSL_NOTHING;
}
pub inline fn SSL_want_read(s: anytype) @TypeOf(SSL_want(s) == SSL_READING) {
    _ = &s;
    return SSL_want(s) == SSL_READING;
}
pub inline fn SSL_want_write(s: anytype) @TypeOf(SSL_want(s) == SSL_WRITING) {
    _ = &s;
    return SSL_want(s) == SSL_WRITING;
}
pub inline fn SSL_want_x509_lookup(s: anytype) @TypeOf(SSL_want(s) == SSL_X509_LOOKUP) {
    _ = &s;
    return SSL_want(s) == SSL_X509_LOOKUP;
}
pub inline fn SSL_want_retry_verify(s: anytype) @TypeOf(SSL_want(s) == SSL_RETRY_VERIFY) {
    _ = &s;
    return SSL_want(s) == SSL_RETRY_VERIFY;
}
pub inline fn SSL_want_async(s: anytype) @TypeOf(SSL_want(s) == SSL_ASYNC_PAUSED) {
    _ = &s;
    return SSL_want(s) == SSL_ASYNC_PAUSED;
}
pub inline fn SSL_want_async_job(s: anytype) @TypeOf(SSL_want(s) == SSL_ASYNC_NO_JOBS) {
    _ = &s;
    return SSL_want(s) == SSL_ASYNC_NO_JOBS;
}
pub inline fn SSL_want_client_hello_cb(s: anytype) @TypeOf(SSL_want(s) == SSL_CLIENT_HELLO_CB) {
    _ = &s;
    return SSL_want(s) == SSL_CLIENT_HELLO_CB;
}
pub const SSL_MAC_FLAG_READ_MAC_STREAM = @as(c_int, 1);
pub const SSL_MAC_FLAG_WRITE_MAC_STREAM = @as(c_int, 2);
pub const SSL_MAC_FLAG_READ_MAC_TLSTREE = @as(c_int, 4);
pub const SSL_MAC_FLAG_WRITE_MAC_TLSTREE = @as(c_int, 8);
pub const OPENSSL_SSL2_H = "";
pub const HEADER_SSL2_H = "";
pub const SSL2_VERSION = @as(c_int, 0x0002);
pub const SSL2_MT_CLIENT_HELLO = @as(c_int, 1);
pub const OPENSSL_SSL3_H = "";
pub const HEADER_SSL3_H = "";
pub const SSL3_CK_SCSV = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000FF, .hex);
pub const SSL3_CK_FALLBACK_SCSV = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03005600, .hex);
pub const SSL3_CK_RSA_NULL_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000001, .hex);
pub const SSL3_CK_RSA_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000002, .hex);
pub const SSL3_CK_RSA_RC4_40_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000003, .hex);
pub const SSL3_CK_RSA_RC4_128_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000004, .hex);
pub const SSL3_CK_RSA_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000005, .hex);
pub const SSL3_CK_RSA_RC2_40_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000006, .hex);
pub const SSL3_CK_RSA_IDEA_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000007, .hex);
pub const SSL3_CK_RSA_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000008, .hex);
pub const SSL3_CK_RSA_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000009, .hex);
pub const SSL3_CK_RSA_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000A, .hex);
pub const SSL3_CK_DH_DSS_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000B, .hex);
pub const SSL3_CK_DH_DSS_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000C, .hex);
pub const SSL3_CK_DH_DSS_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000D, .hex);
pub const SSL3_CK_DH_RSA_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000E, .hex);
pub const SSL3_CK_DH_RSA_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300000F, .hex);
pub const SSL3_CK_DH_RSA_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000010, .hex);
pub const SSL3_CK_DHE_DSS_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000011, .hex);
pub const SSL3_CK_EDH_DSS_DES_40_CBC_SHA = SSL3_CK_DHE_DSS_DES_40_CBC_SHA;
pub const SSL3_CK_DHE_DSS_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000012, .hex);
pub const SSL3_CK_EDH_DSS_DES_64_CBC_SHA = SSL3_CK_DHE_DSS_DES_64_CBC_SHA;
pub const SSL3_CK_DHE_DSS_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000013, .hex);
pub const SSL3_CK_EDH_DSS_DES_192_CBC3_SHA = SSL3_CK_DHE_DSS_DES_192_CBC3_SHA;
pub const SSL3_CK_DHE_RSA_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000014, .hex);
pub const SSL3_CK_EDH_RSA_DES_40_CBC_SHA = SSL3_CK_DHE_RSA_DES_40_CBC_SHA;
pub const SSL3_CK_DHE_RSA_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000015, .hex);
pub const SSL3_CK_EDH_RSA_DES_64_CBC_SHA = SSL3_CK_DHE_RSA_DES_64_CBC_SHA;
pub const SSL3_CK_DHE_RSA_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000016, .hex);
pub const SSL3_CK_EDH_RSA_DES_192_CBC3_SHA = SSL3_CK_DHE_RSA_DES_192_CBC3_SHA;
pub const SSL3_CK_ADH_RC4_40_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000017, .hex);
pub const SSL3_CK_ADH_RC4_128_MD5 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000018, .hex);
pub const SSL3_CK_ADH_DES_40_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000019, .hex);
pub const SSL3_CK_ADH_DES_64_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300001A, .hex);
pub const SSL3_CK_ADH_DES_192_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300001B, .hex);
pub const SSL3_RFC_RSA_NULL_MD5 = "TLS_RSA_WITH_NULL_MD5";
pub const SSL3_RFC_RSA_NULL_SHA = "TLS_RSA_WITH_NULL_SHA";
pub const SSL3_RFC_RSA_DES_192_CBC3_SHA = "TLS_RSA_WITH_3DES_EDE_CBC_SHA";
pub const SSL3_RFC_DHE_DSS_DES_192_CBC3_SHA = "TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA";
pub const SSL3_RFC_DHE_RSA_DES_192_CBC3_SHA = "TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA";
pub const SSL3_RFC_ADH_DES_192_CBC_SHA = "TLS_DH_anon_WITH_3DES_EDE_CBC_SHA";
pub const SSL3_RFC_RSA_IDEA_128_SHA = "TLS_RSA_WITH_IDEA_CBC_SHA";
pub const SSL3_RFC_RSA_RC4_128_MD5 = "TLS_RSA_WITH_RC4_128_MD5";
pub const SSL3_RFC_RSA_RC4_128_SHA = "TLS_RSA_WITH_RC4_128_SHA";
pub const SSL3_RFC_ADH_RC4_128_MD5 = "TLS_DH_anon_WITH_RC4_128_MD5";
pub const SSL3_TXT_RSA_NULL_MD5 = "NULL-MD5";
pub const SSL3_TXT_RSA_NULL_SHA = "NULL-SHA";
pub const SSL3_TXT_RSA_RC4_40_MD5 = "EXP-RC4-MD5";
pub const SSL3_TXT_RSA_RC4_128_MD5 = "RC4-MD5";
pub const SSL3_TXT_RSA_RC4_128_SHA = "RC4-SHA";
pub const SSL3_TXT_RSA_RC2_40_MD5 = "EXP-RC2-CBC-MD5";
pub const SSL3_TXT_RSA_IDEA_128_SHA = "IDEA-CBC-SHA";
pub const SSL3_TXT_RSA_DES_40_CBC_SHA = "EXP-DES-CBC-SHA";
pub const SSL3_TXT_RSA_DES_64_CBC_SHA = "DES-CBC-SHA";
pub const SSL3_TXT_RSA_DES_192_CBC3_SHA = "DES-CBC3-SHA";
pub const SSL3_TXT_DH_DSS_DES_40_CBC_SHA = "EXP-DH-DSS-DES-CBC-SHA";
pub const SSL3_TXT_DH_DSS_DES_64_CBC_SHA = "DH-DSS-DES-CBC-SHA";
pub const SSL3_TXT_DH_DSS_DES_192_CBC3_SHA = "DH-DSS-DES-CBC3-SHA";
pub const SSL3_TXT_DH_RSA_DES_40_CBC_SHA = "EXP-DH-RSA-DES-CBC-SHA";
pub const SSL3_TXT_DH_RSA_DES_64_CBC_SHA = "DH-RSA-DES-CBC-SHA";
pub const SSL3_TXT_DH_RSA_DES_192_CBC3_SHA = "DH-RSA-DES-CBC3-SHA";
pub const SSL3_TXT_DHE_DSS_DES_40_CBC_SHA = "EXP-DHE-DSS-DES-CBC-SHA";
pub const SSL3_TXT_DHE_DSS_DES_64_CBC_SHA = "DHE-DSS-DES-CBC-SHA";
pub const SSL3_TXT_DHE_DSS_DES_192_CBC3_SHA = "DHE-DSS-DES-CBC3-SHA";
pub const SSL3_TXT_DHE_RSA_DES_40_CBC_SHA = "EXP-DHE-RSA-DES-CBC-SHA";
pub const SSL3_TXT_DHE_RSA_DES_64_CBC_SHA = "DHE-RSA-DES-CBC-SHA";
pub const SSL3_TXT_DHE_RSA_DES_192_CBC3_SHA = "DHE-RSA-DES-CBC3-SHA";
pub const SSL3_TXT_EDH_DSS_DES_40_CBC_SHA = "EXP-EDH-DSS-DES-CBC-SHA";
pub const SSL3_TXT_EDH_DSS_DES_64_CBC_SHA = "EDH-DSS-DES-CBC-SHA";
pub const SSL3_TXT_EDH_DSS_DES_192_CBC3_SHA = "EDH-DSS-DES-CBC3-SHA";
pub const SSL3_TXT_EDH_RSA_DES_40_CBC_SHA = "EXP-EDH-RSA-DES-CBC-SHA";
pub const SSL3_TXT_EDH_RSA_DES_64_CBC_SHA = "EDH-RSA-DES-CBC-SHA";
pub const SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA = "EDH-RSA-DES-CBC3-SHA";
pub const SSL3_TXT_ADH_RC4_40_MD5 = "EXP-ADH-RC4-MD5";
pub const SSL3_TXT_ADH_RC4_128_MD5 = "ADH-RC4-MD5";
pub const SSL3_TXT_ADH_DES_40_CBC_SHA = "EXP-ADH-DES-CBC-SHA";
pub const SSL3_TXT_ADH_DES_64_CBC_SHA = "ADH-DES-CBC-SHA";
pub const SSL3_TXT_ADH_DES_192_CBC_SHA = "ADH-DES-CBC3-SHA";
pub const SSL3_SSL_SESSION_ID_LENGTH = @as(c_int, 32);
pub const SSL3_MAX_SSL_SESSION_ID_LENGTH = @as(c_int, 32);
pub const SSL3_MASTER_SECRET_SIZE = @as(c_int, 48);
pub const SSL3_RANDOM_SIZE = @as(c_int, 32);
pub const SSL3_SESSION_ID_SIZE = @as(c_int, 32);
pub const SSL3_RT_HEADER_LENGTH = @as(c_int, 5);
pub const SSL3_HM_HEADER_LENGTH = @as(c_int, 4);
pub const SSL3_ALIGN_PAYLOAD = @as(c_int, 8);
pub const SSL3_RT_MAX_MD_SIZE = @as(c_int, 64);
pub const SSL_RT_MAX_CIPHER_BLOCK_SIZE = @as(c_int, 16);
pub const SSL3_RT_MAX_EXTRA = @as(c_int, 16384);
pub const SSL3_RT_MAX_PLAIN_LENGTH = @as(c_int, 16384);
pub const SSL3_RT_MAX_COMPRESSED_OVERHEAD = @as(c_int, 1024);
pub const SSL3_RT_MAX_ENCRYPTED_OVERHEAD = @as(c_int, 256) + SSL3_RT_MAX_MD_SIZE;
pub const SSL3_RT_MAX_TLS13_ENCRYPTED_OVERHEAD = @as(c_int, 256);
pub const SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD = SSL_RT_MAX_CIPHER_BLOCK_SIZE + SSL3_RT_MAX_MD_SIZE;
pub const SSL3_RT_MAX_COMPRESSED_LENGTH = SSL3_RT_MAX_PLAIN_LENGTH + SSL3_RT_MAX_COMPRESSED_OVERHEAD;
pub const SSL3_RT_MAX_ENCRYPTED_LENGTH = SSL3_RT_MAX_ENCRYPTED_OVERHEAD + SSL3_RT_MAX_COMPRESSED_LENGTH;
pub const SSL3_RT_MAX_TLS13_ENCRYPTED_LENGTH = SSL3_RT_MAX_PLAIN_LENGTH + SSL3_RT_MAX_TLS13_ENCRYPTED_OVERHEAD;
pub const SSL3_RT_MAX_PACKET_SIZE = SSL3_RT_MAX_ENCRYPTED_LENGTH + SSL3_RT_HEADER_LENGTH;
pub const SSL3_MD_CLIENT_FINISHED_CONST = "\x43\x4c\x4e\x54";
pub const SSL3_MD_SERVER_FINISHED_CONST = "\x53\x52\x56\x52";
pub const SSL3_VERSION_MAJOR = @as(c_int, 0x03);
pub const SSL3_VERSION_MINOR = @as(c_int, 0x00);
pub const SSL3_RT_CHANGE_CIPHER_SPEC = @as(c_int, 20);
pub const SSL3_RT_ALERT = @as(c_int, 21);
pub const SSL3_RT_HANDSHAKE = @as(c_int, 22);
pub const SSL3_RT_APPLICATION_DATA = @as(c_int, 23);
pub const TLS1_RT_CRYPTO = @as(c_int, 0x1000);
pub const TLS1_RT_CRYPTO_PREMASTER = TLS1_RT_CRYPTO | @as(c_int, 0x1);
pub const TLS1_RT_CRYPTO_CLIENT_RANDOM = TLS1_RT_CRYPTO | @as(c_int, 0x2);
pub const TLS1_RT_CRYPTO_SERVER_RANDOM = TLS1_RT_CRYPTO | @as(c_int, 0x3);
pub const TLS1_RT_CRYPTO_MASTER = TLS1_RT_CRYPTO | @as(c_int, 0x4);
pub const TLS1_RT_CRYPTO_READ = @as(c_int, 0x0000);
pub const TLS1_RT_CRYPTO_WRITE = @as(c_int, 0x0100);
pub const TLS1_RT_CRYPTO_MAC = TLS1_RT_CRYPTO | @as(c_int, 0x5);
pub const TLS1_RT_CRYPTO_KEY = TLS1_RT_CRYPTO | @as(c_int, 0x6);
pub const TLS1_RT_CRYPTO_IV = TLS1_RT_CRYPTO | @as(c_int, 0x7);
pub const TLS1_RT_CRYPTO_FIXED_IV = TLS1_RT_CRYPTO | @as(c_int, 0x8);
pub const SSL3_RT_HEADER = @as(c_int, 0x100);
pub const SSL3_RT_INNER_CONTENT_TYPE = @as(c_int, 0x101);
pub const SSL3_RT_QUIC_DATAGRAM = @as(c_int, 0x200);
pub const SSL3_RT_QUIC_PACKET = @as(c_int, 0x201);
pub const SSL3_RT_QUIC_FRAME_FULL = @as(c_int, 0x202);
pub const SSL3_RT_QUIC_FRAME_HEADER = @as(c_int, 0x203);
pub const SSL3_RT_QUIC_FRAME_PADDING = @as(c_int, 0x204);
pub const SSL3_AL_WARNING = @as(c_int, 1);
pub const SSL3_AL_FATAL = @as(c_int, 2);
pub const SSL3_AD_CLOSE_NOTIFY = @as(c_int, 0);
pub const SSL3_AD_UNEXPECTED_MESSAGE = @as(c_int, 10);
pub const SSL3_AD_BAD_RECORD_MAC = @as(c_int, 20);
pub const SSL3_AD_DECOMPRESSION_FAILURE = @as(c_int, 30);
pub const SSL3_AD_HANDSHAKE_FAILURE = @as(c_int, 40);
pub const SSL3_AD_NO_CERTIFICATE = @as(c_int, 41);
pub const SSL3_AD_BAD_CERTIFICATE = @as(c_int, 42);
pub const SSL3_AD_UNSUPPORTED_CERTIFICATE = @as(c_int, 43);
pub const SSL3_AD_CERTIFICATE_REVOKED = @as(c_int, 44);
pub const SSL3_AD_CERTIFICATE_EXPIRED = @as(c_int, 45);
pub const SSL3_AD_CERTIFICATE_UNKNOWN = @as(c_int, 46);
pub const SSL3_AD_ILLEGAL_PARAMETER = @as(c_int, 47);
pub const TLS1_HB_REQUEST = @as(c_int, 1);
pub const TLS1_HB_RESPONSE = @as(c_int, 2);
pub const SSL3_CT_RSA_SIGN = @as(c_int, 1);
pub const SSL3_CT_DSS_SIGN = @as(c_int, 2);
pub const SSL3_CT_RSA_FIXED_DH = @as(c_int, 3);
pub const SSL3_CT_DSS_FIXED_DH = @as(c_int, 4);
pub const SSL3_CT_RSA_EPHEMERAL_DH = @as(c_int, 5);
pub const SSL3_CT_DSS_EPHEMERAL_DH = @as(c_int, 6);
pub const SSL3_CT_FORTEZZA_DMS = @as(c_int, 20);
pub const SSL3_CT_NUMBER = @as(c_int, 12);
pub const SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS = @as(c_int, 0x0001);
pub const TLS1_FLAGS_TLS_PADDING_BUG = @as(c_int, 0x0);
pub const TLS1_FLAGS_SKIP_CERT_VERIFY = @as(c_int, 0x0010);
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC_READ = @as(c_int, 0x0100);
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC = TLS1_FLAGS_ENCRYPT_THEN_MAC_READ;
pub const TLS1_FLAGS_RECEIVED_EXTMS = @as(c_int, 0x0200);
pub const TLS1_FLAGS_ENCRYPT_THEN_MAC_WRITE = @as(c_int, 0x0400);
pub const TLS1_FLAGS_STATELESS = @as(c_int, 0x0800);
pub const TLS1_FLAGS_REQUIRED_EXTMS = @as(c_int, 0x1000);
pub const SSL3_MT_HELLO_REQUEST = @as(c_int, 0);
pub const SSL3_MT_CLIENT_HELLO = @as(c_int, 1);
pub const SSL3_MT_SERVER_HELLO = @as(c_int, 2);
pub const SSL3_MT_NEWSESSION_TICKET = @as(c_int, 4);
pub const SSL3_MT_END_OF_EARLY_DATA = @as(c_int, 5);
pub const SSL3_MT_ENCRYPTED_EXTENSIONS = @as(c_int, 8);
pub const SSL3_MT_CERTIFICATE = @as(c_int, 11);
pub const SSL3_MT_SERVER_KEY_EXCHANGE = @as(c_int, 12);
pub const SSL3_MT_CERTIFICATE_REQUEST = @as(c_int, 13);
pub const SSL3_MT_SERVER_DONE = @as(c_int, 14);
pub const SSL3_MT_CERTIFICATE_VERIFY = @as(c_int, 15);
pub const SSL3_MT_CLIENT_KEY_EXCHANGE = @as(c_int, 16);
pub const SSL3_MT_FINISHED = @as(c_int, 20);
pub const SSL3_MT_CERTIFICATE_URL = @as(c_int, 21);
pub const SSL3_MT_CERTIFICATE_STATUS = @as(c_int, 22);
pub const SSL3_MT_SUPPLEMENTAL_DATA = @as(c_int, 23);
pub const SSL3_MT_KEY_UPDATE = @as(c_int, 24);
pub const SSL3_MT_COMPRESSED_CERTIFICATE = @as(c_int, 25);
pub const SSL3_MT_NEXT_PROTO = @as(c_int, 67);
pub const SSL3_MT_MESSAGE_HASH = @as(c_int, 254);
pub const DTLS1_MT_HELLO_VERIFY_REQUEST = @as(c_int, 3);
pub const SSL3_MT_CHANGE_CIPHER_SPEC = @as(c_int, 0x0101);
pub const SSL3_MT_CCS = @as(c_int, 1);
pub const SSL3_CC_READ = @as(c_int, 0x001);
pub const SSL3_CC_WRITE = @as(c_int, 0x002);
pub const SSL3_CC_CLIENT = @as(c_int, 0x010);
pub const SSL3_CC_SERVER = @as(c_int, 0x020);
pub const SSL3_CC_EARLY = @as(c_int, 0x040);
pub const SSL3_CC_HANDSHAKE = @as(c_int, 0x080);
pub const SSL3_CC_APPLICATION = @as(c_int, 0x100);
pub const SSL3_CHANGE_CIPHER_CLIENT_WRITE = SSL3_CC_CLIENT | SSL3_CC_WRITE;
pub const SSL3_CHANGE_CIPHER_SERVER_READ = SSL3_CC_SERVER | SSL3_CC_READ;
pub const SSL3_CHANGE_CIPHER_CLIENT_READ = SSL3_CC_CLIENT | SSL3_CC_READ;
pub const SSL3_CHANGE_CIPHER_SERVER_WRITE = SSL3_CC_SERVER | SSL3_CC_WRITE;
pub const OPENSSL_TLS1_H = "";
pub const HEADER_TLS1_H = "";
pub const OPENSSL_TLS_SECURITY_LEVEL = @as(c_int, 2);
pub const TLS_MAX_VERSION = TLS1_3_VERSION;
pub const TLS_ANY_VERSION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const TLS1_VERSION_MAJOR = @as(c_int, 0x03);
pub const TLS1_VERSION_MINOR = @as(c_int, 0x01);
pub const TLS1_1_VERSION_MAJOR = @as(c_int, 0x03);
pub const TLS1_1_VERSION_MINOR = @as(c_int, 0x02);
pub const TLS1_2_VERSION_MAJOR = @as(c_int, 0x03);
pub const TLS1_2_VERSION_MINOR = @as(c_int, 0x03);
pub inline fn TLS1_get_version(s: anytype) @TypeOf(if ((SSL_version(s) >> @as(c_int, 8)) == TLS1_VERSION_MAJOR) SSL_version(s) else @as(c_int, 0)) {
    _ = &s;
    return if ((SSL_version(s) >> @as(c_int, 8)) == TLS1_VERSION_MAJOR) SSL_version(s) else @as(c_int, 0);
}
pub inline fn TLS1_get_client_version(s: anytype) @TypeOf(if ((SSL_client_version(s) >> @as(c_int, 8)) == TLS1_VERSION_MAJOR) SSL_client_version(s) else @as(c_int, 0)) {
    _ = &s;
    return if ((SSL_client_version(s) >> @as(c_int, 8)) == TLS1_VERSION_MAJOR) SSL_client_version(s) else @as(c_int, 0);
}
pub const TLS1_AD_DECRYPTION_FAILED = @as(c_int, 21);
pub const TLS1_AD_RECORD_OVERFLOW = @as(c_int, 22);
pub const TLS1_AD_UNKNOWN_CA = @as(c_int, 48);
pub const TLS1_AD_ACCESS_DENIED = @as(c_int, 49);
pub const TLS1_AD_DECODE_ERROR = @as(c_int, 50);
pub const TLS1_AD_DECRYPT_ERROR = @as(c_int, 51);
pub const TLS1_AD_EXPORT_RESTRICTION = @as(c_int, 60);
pub const TLS1_AD_PROTOCOL_VERSION = @as(c_int, 70);
pub const TLS1_AD_INSUFFICIENT_SECURITY = @as(c_int, 71);
pub const TLS1_AD_INTERNAL_ERROR = @as(c_int, 80);
pub const TLS1_AD_INAPPROPRIATE_FALLBACK = @as(c_int, 86);
pub const TLS1_AD_USER_CANCELLED = @as(c_int, 90);
pub const TLS1_AD_NO_RENEGOTIATION = @as(c_int, 100);
pub const TLS13_AD_MISSING_EXTENSION = @as(c_int, 109);
pub const TLS13_AD_CERTIFICATE_REQUIRED = @as(c_int, 116);
pub const TLS1_AD_UNSUPPORTED_EXTENSION = @as(c_int, 110);
pub const TLS1_AD_CERTIFICATE_UNOBTAINABLE = @as(c_int, 111);
pub const TLS1_AD_UNRECOGNIZED_NAME = @as(c_int, 112);
pub const TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE = @as(c_int, 113);
pub const TLS1_AD_BAD_CERTIFICATE_HASH_VALUE = @as(c_int, 114);
pub const TLS1_AD_UNKNOWN_PSK_IDENTITY = @as(c_int, 115);
pub const TLS1_AD_NO_APPLICATION_PROTOCOL = @as(c_int, 120);
pub const TLSEXT_TYPE_server_name = @as(c_int, 0);
pub const TLSEXT_TYPE_max_fragment_length = @as(c_int, 1);
pub const TLSEXT_TYPE_client_certificate_url = @as(c_int, 2);
pub const TLSEXT_TYPE_trusted_ca_keys = @as(c_int, 3);
pub const TLSEXT_TYPE_truncated_hmac = @as(c_int, 4);
pub const TLSEXT_TYPE_status_request = @as(c_int, 5);
pub const TLSEXT_TYPE_user_mapping = @as(c_int, 6);
pub const TLSEXT_TYPE_client_authz = @as(c_int, 7);
pub const TLSEXT_TYPE_server_authz = @as(c_int, 8);
pub const TLSEXT_TYPE_cert_type = @as(c_int, 9);
pub const TLSEXT_TYPE_supported_groups = @as(c_int, 10);
pub const TLSEXT_TYPE_elliptic_curves = TLSEXT_TYPE_supported_groups;
pub const TLSEXT_TYPE_ec_point_formats = @as(c_int, 11);
pub const TLSEXT_TYPE_srp = @as(c_int, 12);
pub const TLSEXT_TYPE_signature_algorithms = @as(c_int, 13);
pub const TLSEXT_TYPE_use_srtp = @as(c_int, 14);
pub const TLSEXT_TYPE_application_layer_protocol_negotiation = @as(c_int, 16);
pub const TLSEXT_TYPE_signed_certificate_timestamp = @as(c_int, 18);
pub const TLSEXT_TYPE_client_cert_type = @as(c_int, 19);
pub const TLSEXT_TYPE_server_cert_type = @as(c_int, 20);
pub const TLSEXT_TYPE_padding = @as(c_int, 21);
pub const TLSEXT_TYPE_encrypt_then_mac = @as(c_int, 22);
pub const TLSEXT_TYPE_extended_master_secret = @as(c_int, 23);
pub const TLSEXT_TYPE_compress_certificate = @as(c_int, 27);
pub const TLSEXT_TYPE_session_ticket = @as(c_int, 35);
pub const TLSEXT_TYPE_psk = @as(c_int, 41);
pub const TLSEXT_TYPE_early_data = @as(c_int, 42);
pub const TLSEXT_TYPE_supported_versions = @as(c_int, 43);
pub const TLSEXT_TYPE_cookie = @as(c_int, 44);
pub const TLSEXT_TYPE_psk_kex_modes = @as(c_int, 45);
pub const TLSEXT_TYPE_certificate_authorities = @as(c_int, 47);
pub const TLSEXT_TYPE_post_handshake_auth = @as(c_int, 49);
pub const TLSEXT_TYPE_signature_algorithms_cert = @as(c_int, 50);
pub const TLSEXT_TYPE_key_share = @as(c_int, 51);
pub const TLSEXT_TYPE_quic_transport_parameters = @as(c_int, 57);
pub const TLSEXT_TYPE_renegotiate = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xff01, .hex);
pub const TLSEXT_TYPE_next_proto_neg = @as(c_int, 13172);
pub const TLSEXT_NAMETYPE_host_name = @as(c_int, 0);
pub const TLSEXT_STATUSTYPE_ocsp = @as(c_int, 1);
pub const TLSEXT_ECPOINTFORMAT_first = @as(c_int, 0);
pub const TLSEXT_ECPOINTFORMAT_uncompressed = @as(c_int, 0);
pub const TLSEXT_ECPOINTFORMAT_ansiX962_compressed_prime = @as(c_int, 1);
pub const TLSEXT_ECPOINTFORMAT_ansiX962_compressed_char2 = @as(c_int, 2);
pub const TLSEXT_ECPOINTFORMAT_last = @as(c_int, 2);
pub const TLSEXT_signature_anonymous = @as(c_int, 0);
pub const TLSEXT_signature_rsa = @as(c_int, 1);
pub const TLSEXT_signature_dsa = @as(c_int, 2);
pub const TLSEXT_signature_ecdsa = @as(c_int, 3);
pub const TLSEXT_signature_gostr34102001 = @as(c_int, 237);
pub const TLSEXT_signature_gostr34102012_256 = @as(c_int, 238);
pub const TLSEXT_signature_gostr34102012_512 = @as(c_int, 239);
pub const TLSEXT_signature_num = @as(c_int, 7);
pub const TLSEXT_hash_none = @as(c_int, 0);
pub const TLSEXT_hash_md5 = @as(c_int, 1);
pub const TLSEXT_hash_sha1 = @as(c_int, 2);
pub const TLSEXT_hash_sha224 = @as(c_int, 3);
pub const TLSEXT_hash_sha256 = @as(c_int, 4);
pub const TLSEXT_hash_sha384 = @as(c_int, 5);
pub const TLSEXT_hash_sha512 = @as(c_int, 6);
pub const TLSEXT_hash_gostr3411 = @as(c_int, 237);
pub const TLSEXT_hash_gostr34112012_256 = @as(c_int, 238);
pub const TLSEXT_hash_gostr34112012_512 = @as(c_int, 239);
pub const TLSEXT_hash_num = @as(c_int, 10);
pub const TLSEXT_comp_cert_none = @as(c_int, 0);
pub const TLSEXT_comp_cert_zlib = @as(c_int, 1);
pub const TLSEXT_comp_cert_brotli = @as(c_int, 2);
pub const TLSEXT_comp_cert_zstd = @as(c_int, 3);
pub const TLSEXT_comp_cert_limit = @as(c_int, 4);
pub const TLSEXT_nid_unknown = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1000000, .hex);
pub const TLSEXT_curve_P_256 = @as(c_int, 23);
pub const TLSEXT_curve_P_384 = @as(c_int, 24);
pub const TLSEXT_max_fragment_length_DISABLED = @as(c_int, 0);
pub const TLSEXT_max_fragment_length_512 = @as(c_int, 1);
pub const TLSEXT_max_fragment_length_1024 = @as(c_int, 2);
pub const TLSEXT_max_fragment_length_2048 = @as(c_int, 3);
pub const TLSEXT_max_fragment_length_4096 = @as(c_int, 4);
pub const TLSEXT_max_fragment_length_UNSPECIFIED = @as(c_int, 255);
pub const TLSEXT_cert_type_x509 = @as(c_int, 0);
pub const TLSEXT_cert_type_pgp = @as(c_int, 1);
pub const TLSEXT_cert_type_rpk = @as(c_int, 2);
pub const TLSEXT_cert_type_1609dot2 = @as(c_int, 3);
pub const TLSEXT_MAXLEN_host_name = @as(c_int, 255);
pub inline fn SSL_set_tlsext_host_name(s: anytype, name: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_TLSEXT_HOSTNAME, TLSEXT_NAMETYPE_host_name, @import("std").zig.c_translation.cast(?*anyopaque, name))) {
    _ = &s;
    _ = &name;
    return SSL_ctrl(s, SSL_CTRL_SET_TLSEXT_HOSTNAME, TLSEXT_NAMETYPE_host_name, @import("std").zig.c_translation.cast(?*anyopaque, name));
}
pub const SSL_set_tlsext_debug_callback = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/tls1.h:297:10
pub inline fn SSL_set_tlsext_debug_arg(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_DEBUG_ARG, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_DEBUG_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_get_tlsext_status_type(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE, @as(c_int, 0), NULL);
}
pub inline fn SSL_set_tlsext_status_type(ssl: anytype, @"type": anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE, @"type", NULL)) {
    _ = &ssl;
    _ = &@"type";
    return SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE, @"type", NULL);
}
pub inline fn SSL_get_tlsext_status_exts(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS, @as(c_int, 0), arg);
}
pub inline fn SSL_set_tlsext_status_exts(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS, @as(c_int, 0), arg);
}
pub inline fn SSL_get_tlsext_status_ids(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS, @as(c_int, 0), arg);
}
pub inline fn SSL_set_tlsext_status_ids(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS, @as(c_int, 0), arg);
}
pub inline fn SSL_get_tlsext_status_ocsp_resp(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP, @as(c_int, 0), arg);
}
pub inline fn SSL_set_tlsext_status_ocsp_resp(ssl: anytype, arg: anytype, arglen: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP, arglen, arg)) {
    _ = &ssl;
    _ = &arg;
    _ = &arglen;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP, arglen, arg);
}
pub const SSL_CTX_set_tlsext_servername_callback = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/tls1.h:328:10
pub const SSL_TLSEXT_ERR_OK = @as(c_int, 0);
pub const SSL_TLSEXT_ERR_ALERT_WARNING = @as(c_int, 1);
pub const SSL_TLSEXT_ERR_ALERT_FATAL = @as(c_int, 2);
pub const SSL_TLSEXT_ERR_NOACK = @as(c_int, 3);
pub inline fn SSL_CTX_set_tlsext_servername_arg(ctx: anytype, arg: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, @as(c_int, 0), arg)) {
    _ = &ctx;
    _ = &arg;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_CTX_get_tlsext_ticket_keys(ctx: anytype, keys: anytype, keylen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_TLSEXT_TICKET_KEYS, keylen, keys)) {
    _ = &ctx;
    _ = &keys;
    _ = &keylen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_TLSEXT_TICKET_KEYS, keylen, keys);
}
pub inline fn SSL_CTX_set_tlsext_ticket_keys(ctx: anytype, keys: anytype, keylen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_TICKET_KEYS, keylen, keys)) {
    _ = &ctx;
    _ = &keys;
    _ = &keylen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TLSEXT_TICKET_KEYS, keylen, keys);
}
pub inline fn SSL_CTX_get_tlsext_status_cb(ssl: anytype, cb: anytype) @TypeOf(SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, cb))) {
    _ = &ssl;
    _ = &cb;
    return SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, cb));
}
pub const SSL_CTX_set_tlsext_status_cb = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/tls1.h:347:10
pub inline fn SSL_CTX_get_tlsext_status_arg(ssl: anytype, arg: anytype) @TypeOf(SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB_ARG, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_CTX_set_tlsext_status_arg(ssl: anytype, arg: anytype) @TypeOf(SSL_CTX_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG, @as(c_int, 0), arg)) {
    _ = &ssl;
    _ = &arg;
    return SSL_CTX_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG, @as(c_int, 0), arg);
}
pub inline fn SSL_CTX_set_tlsext_status_type(ssl: anytype, @"type": anytype) @TypeOf(SSL_CTX_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE, @"type", NULL)) {
    _ = &ssl;
    _ = &@"type";
    return SSL_CTX_ctrl(ssl, SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE, @"type", NULL);
}
pub inline fn SSL_CTX_get_tlsext_status_type(ssl: anytype) @TypeOf(SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_CTX_ctrl(ssl, SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE, @as(c_int, 0), NULL);
}
pub const SSL_CTX_set_tlsext_ticket_key_cb = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/tls1.h:363:11
pub const TLS1_CK_PSK_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008A, .hex);
pub const TLS1_CK_PSK_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008B, .hex);
pub const TLS1_CK_PSK_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008C, .hex);
pub const TLS1_CK_PSK_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008D, .hex);
pub const TLS1_CK_DHE_PSK_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008E, .hex);
pub const TLS1_CK_DHE_PSK_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300008F, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000090, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000091, .hex);
pub const TLS1_CK_RSA_PSK_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000092, .hex);
pub const TLS1_CK_RSA_PSK_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000093, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000094, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000095, .hex);
pub const TLS1_CK_PSK_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A8, .hex);
pub const TLS1_CK_PSK_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A9, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AA, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AB, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AC, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AD, .hex);
pub const TLS1_CK_PSK_WITH_AES_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AE, .hex);
pub const TLS1_CK_PSK_WITH_AES_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000AF, .hex);
pub const TLS1_CK_PSK_WITH_NULL_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B0, .hex);
pub const TLS1_CK_PSK_WITH_NULL_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B1, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B2, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B3, .hex);
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B4, .hex);
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B5, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B6, .hex);
pub const TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B7, .hex);
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B8, .hex);
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000B9, .hex);
pub const TLS1_CK_PSK_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300002C, .hex);
pub const TLS1_CK_DHE_PSK_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300002D, .hex);
pub const TLS1_CK_RSA_PSK_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300002E, .hex);
pub const TLS1_CK_RSA_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300002F, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000030, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000031, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000032, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000033, .hex);
pub const TLS1_CK_ADH_WITH_AES_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000034, .hex);
pub const TLS1_CK_RSA_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000035, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000036, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000037, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000038, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000039, .hex);
pub const TLS1_CK_ADH_WITH_AES_256_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003A, .hex);
pub const TLS1_CK_RSA_WITH_NULL_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003B, .hex);
pub const TLS1_CK_RSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003C, .hex);
pub const TLS1_CK_RSA_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003D, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003E, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300003F, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000040, .hex);
pub const TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000041, .hex);
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000042, .hex);
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000043, .hex);
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000044, .hex);
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000045, .hex);
pub const TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000046, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000067, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000068, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000069, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300006A, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300006B, .hex);
pub const TLS1_CK_ADH_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300006C, .hex);
pub const TLS1_CK_ADH_WITH_AES_256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300006D, .hex);
pub const TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000084, .hex);
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000085, .hex);
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000086, .hex);
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000087, .hex);
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000088, .hex);
pub const TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000089, .hex);
pub const TLS1_CK_RSA_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000096, .hex);
pub const TLS1_CK_DH_DSS_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000097, .hex);
pub const TLS1_CK_DH_RSA_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000098, .hex);
pub const TLS1_CK_DHE_DSS_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03000099, .hex);
pub const TLS1_CK_DHE_RSA_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009A, .hex);
pub const TLS1_CK_ADH_WITH_SEED_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009B, .hex);
pub const TLS1_CK_RSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009C, .hex);
pub const TLS1_CK_RSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009D, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009E, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300009F, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A0, .hex);
pub const TLS1_CK_DH_RSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A1, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A2, .hex);
pub const TLS1_CK_DHE_DSS_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A3, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A4, .hex);
pub const TLS1_CK_DH_DSS_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A5, .hex);
pub const TLS1_CK_ADH_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A6, .hex);
pub const TLS1_CK_ADH_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000A7, .hex);
pub const TLS1_CK_RSA_WITH_AES_128_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09C, .hex);
pub const TLS1_CK_RSA_WITH_AES_256_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09D, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_128_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09E, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_256_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09F, .hex);
pub const TLS1_CK_RSA_WITH_AES_128_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A0, .hex);
pub const TLS1_CK_RSA_WITH_AES_256_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A1, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_128_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A2, .hex);
pub const TLS1_CK_DHE_RSA_WITH_AES_256_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A3, .hex);
pub const TLS1_CK_PSK_WITH_AES_128_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A4, .hex);
pub const TLS1_CK_PSK_WITH_AES_256_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A5, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A6, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A7, .hex);
pub const TLS1_CK_PSK_WITH_AES_128_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A8, .hex);
pub const TLS1_CK_PSK_WITH_AES_256_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0A9, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_128_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AA, .hex);
pub const TLS1_CK_DHE_PSK_WITH_AES_256_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AB, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AC, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AD, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AE, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM_8 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0AF, .hex);
pub const TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BA, .hex);
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BB, .hex);
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BC, .hex);
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BD, .hex);
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BE, .hex);
pub const TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000BF, .hex);
pub const TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C0, .hex);
pub const TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C1, .hex);
pub const TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C2, .hex);
pub const TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C3, .hex);
pub const TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C4, .hex);
pub const TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x030000C5, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C001, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C002, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C003, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C004, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C005, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C006, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C007, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C008, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C009, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00A, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00B, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00C, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00D, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00E, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C00F, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C010, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C011, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C012, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C013, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C014, .hex);
pub const TLS1_CK_ECDH_anon_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C015, .hex);
pub const TLS1_CK_ECDH_anon_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C016, .hex);
pub const TLS1_CK_ECDH_anon_WITH_DES_192_CBC3_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C017, .hex);
pub const TLS1_CK_ECDH_anon_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C018, .hex);
pub const TLS1_CK_ECDH_anon_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C019, .hex);
pub const TLS1_CK_SRP_SHA_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01A, .hex);
pub const TLS1_CK_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01B, .hex);
pub const TLS1_CK_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01C, .hex);
pub const TLS1_CK_SRP_SHA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01D, .hex);
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01E, .hex);
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C01F, .hex);
pub const TLS1_CK_SRP_SHA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C020, .hex);
pub const TLS1_CK_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C021, .hex);
pub const TLS1_CK_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C022, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C023, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C024, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C025, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C026, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C027, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C028, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C029, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02A, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02B, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02C, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02D, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02E, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C02F, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C030, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C031, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C032, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_RC4_128_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C033, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C034, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C035, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C036, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C037, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C038, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C039, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C03A, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_NULL_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C03B, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C072, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C073, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C074, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C075, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C076, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C077, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C078, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C079, .hex);
pub const TLS1_CK_PSK_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C094, .hex);
pub const TLS1_CK_PSK_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C095, .hex);
pub const TLS1_CK_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C096, .hex);
pub const TLS1_CK_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C097, .hex);
pub const TLS1_CK_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C098, .hex);
pub const TLS1_CK_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C099, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09A, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C09B, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCA8, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCA9, .hex);
pub const TLS1_CK_DHE_RSA_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCAA, .hex);
pub const TLS1_CK_PSK_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCAB, .hex);
pub const TLS1_CK_ECDHE_PSK_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCAC, .hex);
pub const TLS1_CK_DHE_PSK_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCAD, .hex);
pub const TLS1_CK_RSA_PSK_WITH_CHACHA20_POLY1305 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300CCAE, .hex);
pub const TLS1_3_CK_AES_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03001301, .hex);
pub const TLS1_3_CK_AES_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03001302, .hex);
pub const TLS1_3_CK_CHACHA20_POLY1305_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03001303, .hex);
pub const TLS1_3_CK_AES_128_CCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03001304, .hex);
pub const TLS1_3_CK_AES_128_CCM_8_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x03001305, .hex);
pub const TLS1_3_CK_SHA256_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0B4, .hex);
pub const TLS1_3_CK_SHA384_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C0B5, .hex);
pub const TLS1_CK_RSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C050, .hex);
pub const TLS1_CK_RSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C051, .hex);
pub const TLS1_CK_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C052, .hex);
pub const TLS1_CK_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C053, .hex);
pub const TLS1_CK_DH_RSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C054, .hex);
pub const TLS1_CK_DH_RSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C055, .hex);
pub const TLS1_CK_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C056, .hex);
pub const TLS1_CK_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C057, .hex);
pub const TLS1_CK_DH_DSS_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C058, .hex);
pub const TLS1_CK_DH_DSS_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C059, .hex);
pub const TLS1_CK_DH_anon_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05A, .hex);
pub const TLS1_CK_DH_anon_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05B, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05C, .hex);
pub const TLS1_CK_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05D, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05E, .hex);
pub const TLS1_CK_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C05F, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C060, .hex);
pub const TLS1_CK_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C061, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C062, .hex);
pub const TLS1_CK_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C063, .hex);
pub const TLS1_CK_PSK_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06A, .hex);
pub const TLS1_CK_PSK_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06B, .hex);
pub const TLS1_CK_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06C, .hex);
pub const TLS1_CK_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06D, .hex);
pub const TLS1_CK_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06E, .hex);
pub const TLS1_CK_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x0300C06F, .hex);
pub const TLS1_RFC_RSA_WITH_AES_128_SHA = "TLS_RSA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_SHA = "TLS_DHE_DSS_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_SHA = "TLS_DHE_RSA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_ADH_WITH_AES_128_SHA = "TLS_DH_anon_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_RSA_WITH_AES_256_SHA = "TLS_RSA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_SHA = "TLS_DHE_DSS_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_SHA = "TLS_DHE_RSA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_ADH_WITH_AES_256_SHA = "TLS_DH_anon_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_RSA_WITH_NULL_SHA256 = "TLS_RSA_WITH_NULL_SHA256";
pub const TLS1_RFC_RSA_WITH_AES_128_SHA256 = "TLS_RSA_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_RSA_WITH_AES_256_SHA256 = "TLS_RSA_WITH_AES_256_CBC_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_SHA256 = "TLS_DHE_DSS_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_SHA256 = "TLS_DHE_RSA_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_SHA256 = "TLS_DHE_DSS_WITH_AES_256_CBC_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_SHA256 = "TLS_DHE_RSA_WITH_AES_256_CBC_SHA256";
pub const TLS1_RFC_ADH_WITH_AES_128_SHA256 = "TLS_DH_anon_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_ADH_WITH_AES_256_SHA256 = "TLS_DH_anon_WITH_AES_256_CBC_SHA256";
pub const TLS1_RFC_RSA_WITH_AES_128_GCM_SHA256 = "TLS_RSA_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_RSA_WITH_AES_256_GCM_SHA384 = "TLS_RSA_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_GCM_SHA256 = "TLS_DHE_RSA_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_GCM_SHA384 = "TLS_DHE_RSA_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_DHE_DSS_WITH_AES_128_GCM_SHA256 = "TLS_DHE_DSS_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_AES_256_GCM_SHA384 = "TLS_DHE_DSS_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_ADH_WITH_AES_128_GCM_SHA256 = "TLS_DH_anon_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_ADH_WITH_AES_256_GCM_SHA384 = "TLS_DH_anon_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_RSA_WITH_AES_128_CCM = "TLS_RSA_WITH_AES_128_CCM";
pub const TLS1_RFC_RSA_WITH_AES_256_CCM = "TLS_RSA_WITH_AES_256_CCM";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_CCM = "TLS_DHE_RSA_WITH_AES_128_CCM";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_CCM = "TLS_DHE_RSA_WITH_AES_256_CCM";
pub const TLS1_RFC_RSA_WITH_AES_128_CCM_8 = "TLS_RSA_WITH_AES_128_CCM_8";
pub const TLS1_RFC_RSA_WITH_AES_256_CCM_8 = "TLS_RSA_WITH_AES_256_CCM_8";
pub const TLS1_RFC_DHE_RSA_WITH_AES_128_CCM_8 = "TLS_DHE_RSA_WITH_AES_128_CCM_8";
pub const TLS1_RFC_DHE_RSA_WITH_AES_256_CCM_8 = "TLS_DHE_RSA_WITH_AES_256_CCM_8";
pub const TLS1_RFC_PSK_WITH_AES_128_CCM = "TLS_PSK_WITH_AES_128_CCM";
pub const TLS1_RFC_PSK_WITH_AES_256_CCM = "TLS_PSK_WITH_AES_256_CCM";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CCM = "TLS_DHE_PSK_WITH_AES_128_CCM";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CCM = "TLS_DHE_PSK_WITH_AES_256_CCM";
pub const TLS1_RFC_PSK_WITH_AES_128_CCM_8 = "TLS_PSK_WITH_AES_128_CCM_8";
pub const TLS1_RFC_PSK_WITH_AES_256_CCM_8 = "TLS_PSK_WITH_AES_256_CCM_8";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CCM_8 = "TLS_PSK_DHE_WITH_AES_128_CCM_8";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CCM_8 = "TLS_PSK_DHE_WITH_AES_256_CCM_8";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CCM = "TLS_ECDHE_ECDSA_WITH_AES_128_CCM";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CCM = "TLS_ECDHE_ECDSA_WITH_AES_256_CCM";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CCM_8 = "TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CCM_8 = "TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8";
pub const TLS1_3_RFC_AES_128_GCM_SHA256 = "TLS_AES_128_GCM_SHA256";
pub const TLS1_3_RFC_AES_256_GCM_SHA384 = "TLS_AES_256_GCM_SHA384";
pub const TLS1_3_RFC_CHACHA20_POLY1305_SHA256 = "TLS_CHACHA20_POLY1305_SHA256";
pub const TLS1_3_RFC_SHA256_SHA256 = "TLS_SHA256_SHA256";
pub const TLS1_3_RFC_SHA384_SHA384 = "TLS_SHA384_SHA384";
pub const TLS1_3_RFC_AES_128_CCM_SHA256 = "TLS_AES_128_CCM_SHA256";
pub const TLS1_3_RFC_AES_128_CCM_8_SHA256 = "TLS_AES_128_CCM_8_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_NULL_SHA = "TLS_ECDHE_ECDSA_WITH_NULL_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA = "TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_ECDHE_RSA_WITH_NULL_SHA = "TLS_ECDHE_RSA_WITH_NULL_SHA";
pub const TLS1_RFC_ECDHE_RSA_WITH_DES_192_CBC3_SHA = "TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_CBC_SHA = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_CBC_SHA = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_ECDH_anon_WITH_NULL_SHA = "TLS_ECDH_anon_WITH_NULL_SHA";
pub const TLS1_RFC_ECDH_anon_WITH_DES_192_CBC3_SHA = "TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_ECDH_anon_WITH_AES_128_CBC_SHA = "TLS_ECDH_anon_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_ECDH_anon_WITH_AES_256_CBC_SHA = "TLS_ECDH_anon_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_SHA256 = "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_SHA384 = "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_SHA256 = "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_SHA384 = "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_PSK_WITH_NULL_SHA = "TLS_PSK_WITH_NULL_SHA";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA = "TLS_DHE_PSK_WITH_NULL_SHA";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA = "TLS_RSA_PSK_WITH_NULL_SHA";
pub const TLS1_RFC_PSK_WITH_3DES_EDE_CBC_SHA = "TLS_PSK_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_PSK_WITH_AES_128_CBC_SHA = "TLS_PSK_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_PSK_WITH_AES_256_CBC_SHA = "TLS_PSK_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_DHE_PSK_WITH_3DES_EDE_CBC_SHA = "TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CBC_SHA = "TLS_DHE_PSK_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CBC_SHA = "TLS_DHE_PSK_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_RSA_PSK_WITH_3DES_EDE_CBC_SHA = "TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_CBC_SHA = "TLS_RSA_PSK_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_CBC_SHA = "TLS_RSA_PSK_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_PSK_WITH_AES_128_GCM_SHA256 = "TLS_PSK_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_PSK_WITH_AES_256_GCM_SHA384 = "TLS_PSK_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_GCM_SHA256 = "TLS_DHE_PSK_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_GCM_SHA384 = "TLS_DHE_PSK_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_GCM_SHA256 = "TLS_RSA_PSK_WITH_AES_128_GCM_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_GCM_SHA384 = "TLS_RSA_PSK_WITH_AES_256_GCM_SHA384";
pub const TLS1_RFC_PSK_WITH_AES_128_CBC_SHA256 = "TLS_PSK_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_PSK_WITH_AES_256_CBC_SHA384 = "TLS_PSK_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_PSK_WITH_NULL_SHA256 = "TLS_PSK_WITH_NULL_SHA256";
pub const TLS1_RFC_PSK_WITH_NULL_SHA384 = "TLS_PSK_WITH_NULL_SHA384";
pub const TLS1_RFC_DHE_PSK_WITH_AES_128_CBC_SHA256 = "TLS_DHE_PSK_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_AES_256_CBC_SHA384 = "TLS_DHE_PSK_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA256 = "TLS_DHE_PSK_WITH_NULL_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_NULL_SHA384 = "TLS_DHE_PSK_WITH_NULL_SHA384";
pub const TLS1_RFC_RSA_PSK_WITH_AES_128_CBC_SHA256 = "TLS_RSA_PSK_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_AES_256_CBC_SHA384 = "TLS_RSA_PSK_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA256 = "TLS_RSA_PSK_WITH_NULL_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_NULL_SHA384 = "TLS_RSA_PSK_WITH_NULL_SHA384";
pub const TLS1_RFC_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = "TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_128_CBC_SHA = "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_256_CBC_SHA = "TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = "TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = "TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA = "TLS_ECDHE_PSK_WITH_NULL_SHA";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA256 = "TLS_ECDHE_PSK_WITH_NULL_SHA256";
pub const TLS1_RFC_ECDHE_PSK_WITH_NULL_SHA384 = "TLS_ECDHE_PSK_WITH_NULL_SHA384";
pub const TLS1_RFC_SRP_SHA_WITH_3DES_EDE_CBC_SHA = "TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = "TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = "TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_WITH_AES_128_CBC_SHA = "TLS_SRP_SHA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = "TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = "TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_WITH_AES_256_CBC_SHA = "TLS_SRP_SHA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = "TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = "TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_CHACHA20_POLY1305 = "TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_ECDHE_RSA_WITH_CHACHA20_POLY1305 = "TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = "TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_PSK_WITH_CHACHA20_POLY1305 = "TLS_PSK_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_ECDHE_PSK_WITH_CHACHA20_POLY1305 = "TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_CHACHA20_POLY1305 = "TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_CHACHA20_POLY1305 = "TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_256_CBC_SHA256 = "TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = "TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = "TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_256_CBC_SHA256 = "TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_256_CBC_SHA = "TLS_RSA_WITH_CAMELLIA_256_CBC_SHA";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = "TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = "TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_256_CBC_SHA = "TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA";
pub const TLS1_RFC_RSA_WITH_CAMELLIA_128_CBC_SHA = "TLS_RSA_WITH_CAMELLIA_128_CBC_SHA";
pub const TLS1_RFC_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = "TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = "TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA";
pub const TLS1_RFC_ADH_WITH_CAMELLIA_128_CBC_SHA = "TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256";
pub const TLS1_RFC_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384";
pub const TLS1_RFC_RSA_WITH_SEED_SHA = "TLS_RSA_WITH_SEED_CBC_SHA";
pub const TLS1_RFC_DHE_DSS_WITH_SEED_SHA = "TLS_DHE_DSS_WITH_SEED_CBC_SHA";
pub const TLS1_RFC_DHE_RSA_WITH_SEED_SHA = "TLS_DHE_RSA_WITH_SEED_CBC_SHA";
pub const TLS1_RFC_ADH_WITH_SEED_SHA = "TLS_DH_anon_WITH_SEED_CBC_SHA";
pub const TLS1_RFC_ECDHE_PSK_WITH_RC4_128_SHA = "TLS_ECDHE_PSK_WITH_RC4_128_SHA";
pub const TLS1_RFC_ECDH_anon_WITH_RC4_128_SHA = "TLS_ECDH_anon_WITH_RC4_128_SHA";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_RC4_128_SHA = "TLS_ECDHE_ECDSA_WITH_RC4_128_SHA";
pub const TLS1_RFC_ECDHE_RSA_WITH_RC4_128_SHA = "TLS_ECDHE_RSA_WITH_RC4_128_SHA";
pub const TLS1_RFC_PSK_WITH_RC4_128_SHA = "TLS_PSK_WITH_RC4_128_SHA";
pub const TLS1_RFC_RSA_PSK_WITH_RC4_128_SHA = "TLS_RSA_PSK_WITH_RC4_128_SHA";
pub const TLS1_RFC_DHE_PSK_WITH_RC4_128_SHA = "TLS_DHE_PSK_WITH_RC4_128_SHA";
pub const TLS1_RFC_RSA_WITH_ARIA_128_GCM_SHA256 = "TLS_RSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_RSA_WITH_ARIA_256_GCM_SHA384 = "TLS_RSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = "TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = "TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DH_RSA_WITH_ARIA_128_GCM_SHA256 = "TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DH_RSA_WITH_ARIA_256_GCM_SHA384 = "TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = "TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = "TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DH_DSS_WITH_ARIA_128_GCM_SHA256 = "TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DH_DSS_WITH_ARIA_256_GCM_SHA384 = "TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DH_anon_WITH_ARIA_128_GCM_SHA256 = "TLS_DH_anon_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DH_anon_WITH_ARIA_256_GCM_SHA384 = "TLS_DH_anon_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = "TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = "TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = "TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = "TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = "TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = "TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = "TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = "TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_PSK_WITH_ARIA_128_GCM_SHA256 = "TLS_PSK_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_PSK_WITH_ARIA_256_GCM_SHA384 = "TLS_PSK_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = "TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = "TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_RFC_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = "TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256";
pub const TLS1_RFC_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = "TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384";
pub const TLS1_TXT_DHE_DSS_WITH_RC4_128_SHA = "DHE-DSS-RC4-SHA";
pub const TLS1_TXT_PSK_WITH_NULL_SHA = "PSK-NULL-SHA";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA = "DHE-PSK-NULL-SHA";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA = "RSA-PSK-NULL-SHA";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA = "AES128-SHA";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA = "DH-DSS-AES128-SHA";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA = "DH-RSA-AES128-SHA";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA = "DHE-DSS-AES128-SHA";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA = "DHE-RSA-AES128-SHA";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA = "ADH-AES128-SHA";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA = "AES256-SHA";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA = "DH-DSS-AES256-SHA";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA = "DH-RSA-AES256-SHA";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA = "DHE-DSS-AES256-SHA";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA = "DHE-RSA-AES256-SHA";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA = "ADH-AES256-SHA";
pub const TLS1_TXT_ECDH_ECDSA_WITH_NULL_SHA = "ECDH-ECDSA-NULL-SHA";
pub const TLS1_TXT_ECDH_ECDSA_WITH_RC4_128_SHA = "ECDH-ECDSA-RC4-SHA";
pub const TLS1_TXT_ECDH_ECDSA_WITH_DES_192_CBC3_SHA = "ECDH-ECDSA-DES-CBC3-SHA";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_CBC_SHA = "ECDH-ECDSA-AES128-SHA";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_CBC_SHA = "ECDH-ECDSA-AES256-SHA";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_NULL_SHA = "ECDHE-ECDSA-NULL-SHA";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_RC4_128_SHA = "ECDHE-ECDSA-RC4-SHA";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA = "ECDHE-ECDSA-DES-CBC3-SHA";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = "ECDHE-ECDSA-AES128-SHA";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = "ECDHE-ECDSA-AES256-SHA";
pub const TLS1_TXT_ECDH_RSA_WITH_NULL_SHA = "ECDH-RSA-NULL-SHA";
pub const TLS1_TXT_ECDH_RSA_WITH_RC4_128_SHA = "ECDH-RSA-RC4-SHA";
pub const TLS1_TXT_ECDH_RSA_WITH_DES_192_CBC3_SHA = "ECDH-RSA-DES-CBC3-SHA";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_CBC_SHA = "ECDH-RSA-AES128-SHA";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_CBC_SHA = "ECDH-RSA-AES256-SHA";
pub const TLS1_TXT_ECDHE_RSA_WITH_NULL_SHA = "ECDHE-RSA-NULL-SHA";
pub const TLS1_TXT_ECDHE_RSA_WITH_RC4_128_SHA = "ECDHE-RSA-RC4-SHA";
pub const TLS1_TXT_ECDHE_RSA_WITH_DES_192_CBC3_SHA = "ECDHE-RSA-DES-CBC3-SHA";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_CBC_SHA = "ECDHE-RSA-AES128-SHA";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_CBC_SHA = "ECDHE-RSA-AES256-SHA";
pub const TLS1_TXT_ECDH_anon_WITH_NULL_SHA = "AECDH-NULL-SHA";
pub const TLS1_TXT_ECDH_anon_WITH_RC4_128_SHA = "AECDH-RC4-SHA";
pub const TLS1_TXT_ECDH_anon_WITH_DES_192_CBC3_SHA = "AECDH-DES-CBC3-SHA";
pub const TLS1_TXT_ECDH_anon_WITH_AES_128_CBC_SHA = "AECDH-AES128-SHA";
pub const TLS1_TXT_ECDH_anon_WITH_AES_256_CBC_SHA = "AECDH-AES256-SHA";
pub const TLS1_TXT_PSK_WITH_RC4_128_SHA = "PSK-RC4-SHA";
pub const TLS1_TXT_PSK_WITH_3DES_EDE_CBC_SHA = "PSK-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_PSK_WITH_AES_128_CBC_SHA = "PSK-AES128-CBC-SHA";
pub const TLS1_TXT_PSK_WITH_AES_256_CBC_SHA = "PSK-AES256-CBC-SHA";
pub const TLS1_TXT_DHE_PSK_WITH_RC4_128_SHA = "DHE-PSK-RC4-SHA";
pub const TLS1_TXT_DHE_PSK_WITH_3DES_EDE_CBC_SHA = "DHE-PSK-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CBC_SHA = "DHE-PSK-AES128-CBC-SHA";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CBC_SHA = "DHE-PSK-AES256-CBC-SHA";
pub const TLS1_TXT_RSA_PSK_WITH_RC4_128_SHA = "RSA-PSK-RC4-SHA";
pub const TLS1_TXT_RSA_PSK_WITH_3DES_EDE_CBC_SHA = "RSA-PSK-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_CBC_SHA = "RSA-PSK-AES128-CBC-SHA";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_CBC_SHA = "RSA-PSK-AES256-CBC-SHA";
pub const TLS1_TXT_PSK_WITH_AES_128_GCM_SHA256 = "PSK-AES128-GCM-SHA256";
pub const TLS1_TXT_PSK_WITH_AES_256_GCM_SHA384 = "PSK-AES256-GCM-SHA384";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_GCM_SHA256 = "DHE-PSK-AES128-GCM-SHA256";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_GCM_SHA384 = "DHE-PSK-AES256-GCM-SHA384";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_GCM_SHA256 = "RSA-PSK-AES128-GCM-SHA256";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_GCM_SHA384 = "RSA-PSK-AES256-GCM-SHA384";
pub const TLS1_TXT_PSK_WITH_AES_128_CBC_SHA256 = "PSK-AES128-CBC-SHA256";
pub const TLS1_TXT_PSK_WITH_AES_256_CBC_SHA384 = "PSK-AES256-CBC-SHA384";
pub const TLS1_TXT_PSK_WITH_NULL_SHA256 = "PSK-NULL-SHA256";
pub const TLS1_TXT_PSK_WITH_NULL_SHA384 = "PSK-NULL-SHA384";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CBC_SHA256 = "DHE-PSK-AES128-CBC-SHA256";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CBC_SHA384 = "DHE-PSK-AES256-CBC-SHA384";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA256 = "DHE-PSK-NULL-SHA256";
pub const TLS1_TXT_DHE_PSK_WITH_NULL_SHA384 = "DHE-PSK-NULL-SHA384";
pub const TLS1_TXT_RSA_PSK_WITH_AES_128_CBC_SHA256 = "RSA-PSK-AES128-CBC-SHA256";
pub const TLS1_TXT_RSA_PSK_WITH_AES_256_CBC_SHA384 = "RSA-PSK-AES256-CBC-SHA384";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA256 = "RSA-PSK-NULL-SHA256";
pub const TLS1_TXT_RSA_PSK_WITH_NULL_SHA384 = "RSA-PSK-NULL-SHA384";
pub const TLS1_TXT_SRP_SHA_WITH_3DES_EDE_CBC_SHA = "SRP-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA = "SRP-RSA-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA = "SRP-DSS-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_WITH_AES_128_CBC_SHA = "SRP-AES-128-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_128_CBC_SHA = "SRP-RSA-AES-128-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_128_CBC_SHA = "SRP-DSS-AES-128-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_WITH_AES_256_CBC_SHA = "SRP-AES-256-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_RSA_WITH_AES_256_CBC_SHA = "SRP-RSA-AES-256-CBC-SHA";
pub const TLS1_TXT_SRP_SHA_DSS_WITH_AES_256_CBC_SHA = "SRP-DSS-AES-256-CBC-SHA";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_128_CBC_SHA = "CAMELLIA128-SHA";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_128_CBC_SHA = "DH-DSS-CAMELLIA128-SHA";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_128_CBC_SHA = "DH-RSA-CAMELLIA128-SHA";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA = "DHE-DSS-CAMELLIA128-SHA";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA = "DHE-RSA-CAMELLIA128-SHA";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_128_CBC_SHA = "ADH-CAMELLIA128-SHA";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_256_CBC_SHA = "CAMELLIA256-SHA";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_256_CBC_SHA = "DH-DSS-CAMELLIA256-SHA";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_256_CBC_SHA = "DH-RSA-CAMELLIA256-SHA";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA = "DHE-DSS-CAMELLIA256-SHA";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA = "DHE-RSA-CAMELLIA256-SHA";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_256_CBC_SHA = "ADH-CAMELLIA256-SHA";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "CAMELLIA128-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256 = "DH-DSS-CAMELLIA128-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "DH-RSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256 = "DHE-DSS-CAMELLIA128-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "DHE-RSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_128_CBC_SHA256 = "ADH-CAMELLIA128-SHA256";
pub const TLS1_TXT_RSA_WITH_CAMELLIA_256_CBC_SHA256 = "CAMELLIA256-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256 = "DH-DSS-CAMELLIA256-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256 = "DH-RSA-CAMELLIA256-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256 = "DHE-DSS-CAMELLIA256-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256 = "DHE-RSA-CAMELLIA256-SHA256";
pub const TLS1_TXT_ADH_WITH_CAMELLIA_256_CBC_SHA256 = "ADH-CAMELLIA256-SHA256";
pub const TLS1_TXT_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "PSK-CAMELLIA128-SHA256";
pub const TLS1_TXT_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "PSK-CAMELLIA256-SHA384";
pub const TLS1_TXT_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "DHE-PSK-CAMELLIA128-SHA256";
pub const TLS1_TXT_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "DHE-PSK-CAMELLIA256-SHA384";
pub const TLS1_TXT_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "RSA-PSK-CAMELLIA128-SHA256";
pub const TLS1_TXT_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "RSA-PSK-CAMELLIA256-SHA384";
pub const TLS1_TXT_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256 = "ECDHE-PSK-CAMELLIA128-SHA256";
pub const TLS1_TXT_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384 = "ECDHE-PSK-CAMELLIA256-SHA384";
pub const TLS1_TXT_RSA_WITH_SEED_SHA = "SEED-SHA";
pub const TLS1_TXT_DH_DSS_WITH_SEED_SHA = "DH-DSS-SEED-SHA";
pub const TLS1_TXT_DH_RSA_WITH_SEED_SHA = "DH-RSA-SEED-SHA";
pub const TLS1_TXT_DHE_DSS_WITH_SEED_SHA = "DHE-DSS-SEED-SHA";
pub const TLS1_TXT_DHE_RSA_WITH_SEED_SHA = "DHE-RSA-SEED-SHA";
pub const TLS1_TXT_ADH_WITH_SEED_SHA = "ADH-SEED-SHA";
pub const TLS1_TXT_RSA_WITH_NULL_SHA256 = "NULL-SHA256";
pub const TLS1_TXT_RSA_WITH_AES_128_SHA256 = "AES128-SHA256";
pub const TLS1_TXT_RSA_WITH_AES_256_SHA256 = "AES256-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_SHA256 = "DH-DSS-AES128-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_SHA256 = "DH-RSA-AES128-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_SHA256 = "DHE-DSS-AES128-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_SHA256 = "DHE-RSA-AES128-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_SHA256 = "DH-DSS-AES256-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_SHA256 = "DH-RSA-AES256-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_SHA256 = "DHE-DSS-AES256-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_SHA256 = "DHE-RSA-AES256-SHA256";
pub const TLS1_TXT_ADH_WITH_AES_128_SHA256 = "ADH-AES128-SHA256";
pub const TLS1_TXT_ADH_WITH_AES_256_SHA256 = "ADH-AES256-SHA256";
pub const TLS1_TXT_RSA_WITH_AES_128_GCM_SHA256 = "AES128-GCM-SHA256";
pub const TLS1_TXT_RSA_WITH_AES_256_GCM_SHA384 = "AES256-GCM-SHA384";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_GCM_SHA256 = "DHE-RSA-AES128-GCM-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_GCM_SHA384 = "DHE-RSA-AES256-GCM-SHA384";
pub const TLS1_TXT_DH_RSA_WITH_AES_128_GCM_SHA256 = "DH-RSA-AES128-GCM-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_AES_256_GCM_SHA384 = "DH-RSA-AES256-GCM-SHA384";
pub const TLS1_TXT_DHE_DSS_WITH_AES_128_GCM_SHA256 = "DHE-DSS-AES128-GCM-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_AES_256_GCM_SHA384 = "DHE-DSS-AES256-GCM-SHA384";
pub const TLS1_TXT_DH_DSS_WITH_AES_128_GCM_SHA256 = "DH-DSS-AES128-GCM-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_AES_256_GCM_SHA384 = "DH-DSS-AES256-GCM-SHA384";
pub const TLS1_TXT_ADH_WITH_AES_128_GCM_SHA256 = "ADH-AES128-GCM-SHA256";
pub const TLS1_TXT_ADH_WITH_AES_256_GCM_SHA384 = "ADH-AES256-GCM-SHA384";
pub const TLS1_TXT_RSA_WITH_AES_128_CCM = "AES128-CCM";
pub const TLS1_TXT_RSA_WITH_AES_256_CCM = "AES256-CCM";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_CCM = "DHE-RSA-AES128-CCM";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_CCM = "DHE-RSA-AES256-CCM";
pub const TLS1_TXT_RSA_WITH_AES_128_CCM_8 = "AES128-CCM8";
pub const TLS1_TXT_RSA_WITH_AES_256_CCM_8 = "AES256-CCM8";
pub const TLS1_TXT_DHE_RSA_WITH_AES_128_CCM_8 = "DHE-RSA-AES128-CCM8";
pub const TLS1_TXT_DHE_RSA_WITH_AES_256_CCM_8 = "DHE-RSA-AES256-CCM8";
pub const TLS1_TXT_PSK_WITH_AES_128_CCM = "PSK-AES128-CCM";
pub const TLS1_TXT_PSK_WITH_AES_256_CCM = "PSK-AES256-CCM";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CCM = "DHE-PSK-AES128-CCM";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CCM = "DHE-PSK-AES256-CCM";
pub const TLS1_TXT_PSK_WITH_AES_128_CCM_8 = "PSK-AES128-CCM8";
pub const TLS1_TXT_PSK_WITH_AES_256_CCM_8 = "PSK-AES256-CCM8";
pub const TLS1_TXT_DHE_PSK_WITH_AES_128_CCM_8 = "DHE-PSK-AES128-CCM8";
pub const TLS1_TXT_DHE_PSK_WITH_AES_256_CCM_8 = "DHE-PSK-AES256-CCM8";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CCM = "ECDHE-ECDSA-AES128-CCM";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CCM = "ECDHE-ECDSA-AES256-CCM";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_CCM_8 = "ECDHE-ECDSA-AES128-CCM8";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CCM_8 = "ECDHE-ECDSA-AES256-CCM8";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_SHA256 = "ECDHE-ECDSA-AES128-SHA256";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_SHA384 = "ECDHE-ECDSA-AES256-SHA384";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_SHA256 = "ECDH-ECDSA-AES128-SHA256";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_SHA384 = "ECDH-ECDSA-AES256-SHA384";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_SHA256 = "ECDHE-RSA-AES128-SHA256";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_SHA384 = "ECDHE-RSA-AES256-SHA384";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_SHA256 = "ECDH-RSA-AES128-SHA256";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_SHA384 = "ECDH-RSA-AES256-SHA384";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = "ECDHE-ECDSA-AES128-GCM-SHA256";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = "ECDHE-ECDSA-AES256-GCM-SHA384";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 = "ECDH-ECDSA-AES128-GCM-SHA256";
pub const TLS1_TXT_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 = "ECDH-ECDSA-AES256-GCM-SHA384";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = "ECDHE-RSA-AES128-GCM-SHA256";
pub const TLS1_TXT_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = "ECDHE-RSA-AES256-GCM-SHA384";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_128_GCM_SHA256 = "ECDH-RSA-AES128-GCM-SHA256";
pub const TLS1_TXT_ECDH_RSA_WITH_AES_256_GCM_SHA384 = "ECDH-RSA-AES256-GCM-SHA384";
pub const TLS1_TXT_ECDHE_PSK_WITH_RC4_128_SHA = "ECDHE-PSK-RC4-SHA";
pub const TLS1_TXT_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA = "ECDHE-PSK-3DES-EDE-CBC-SHA";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_128_CBC_SHA = "ECDHE-PSK-AES128-CBC-SHA";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_256_CBC_SHA = "ECDHE-PSK-AES256-CBC-SHA";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_128_CBC_SHA256 = "ECDHE-PSK-AES128-CBC-SHA256";
pub const TLS1_TXT_ECDHE_PSK_WITH_AES_256_CBC_SHA384 = "ECDHE-PSK-AES256-CBC-SHA384";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA = "ECDHE-PSK-NULL-SHA";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA256 = "ECDHE-PSK-NULL-SHA256";
pub const TLS1_TXT_ECDHE_PSK_WITH_NULL_SHA384 = "ECDHE-PSK-NULL-SHA384";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = "ECDHE-ECDSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = "ECDHE-ECDSA-CAMELLIA256-SHA384";
pub const TLS1_TXT_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 = "ECDH-ECDSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384 = "ECDH-ECDSA-CAMELLIA256-SHA384";
pub const TLS1_TXT_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "ECDHE-RSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384 = "ECDHE-RSA-CAMELLIA256-SHA384";
pub const TLS1_TXT_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256 = "ECDH-RSA-CAMELLIA128-SHA256";
pub const TLS1_TXT_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384 = "ECDH-RSA-CAMELLIA256-SHA384";
pub const TLS1_TXT_ECDHE_RSA_WITH_CHACHA20_POLY1305 = "ECDHE-RSA-CHACHA20-POLY1305";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = "ECDHE-ECDSA-CHACHA20-POLY1305";
pub const TLS1_TXT_DHE_RSA_WITH_CHACHA20_POLY1305 = "DHE-RSA-CHACHA20-POLY1305";
pub const TLS1_TXT_PSK_WITH_CHACHA20_POLY1305 = "PSK-CHACHA20-POLY1305";
pub const TLS1_TXT_ECDHE_PSK_WITH_CHACHA20_POLY1305 = "ECDHE-PSK-CHACHA20-POLY1305";
pub const TLS1_TXT_DHE_PSK_WITH_CHACHA20_POLY1305 = "DHE-PSK-CHACHA20-POLY1305";
pub const TLS1_TXT_RSA_PSK_WITH_CHACHA20_POLY1305 = "RSA-PSK-CHACHA20-POLY1305";
pub const TLS1_TXT_RSA_WITH_ARIA_128_GCM_SHA256 = "ARIA128-GCM-SHA256";
pub const TLS1_TXT_RSA_WITH_ARIA_256_GCM_SHA384 = "ARIA256-GCM-SHA384";
pub const TLS1_TXT_DHE_RSA_WITH_ARIA_128_GCM_SHA256 = "DHE-RSA-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DHE_RSA_WITH_ARIA_256_GCM_SHA384 = "DHE-RSA-ARIA256-GCM-SHA384";
pub const TLS1_TXT_DH_RSA_WITH_ARIA_128_GCM_SHA256 = "DH-RSA-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DH_RSA_WITH_ARIA_256_GCM_SHA384 = "DH-RSA-ARIA256-GCM-SHA384";
pub const TLS1_TXT_DHE_DSS_WITH_ARIA_128_GCM_SHA256 = "DHE-DSS-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DHE_DSS_WITH_ARIA_256_GCM_SHA384 = "DHE-DSS-ARIA256-GCM-SHA384";
pub const TLS1_TXT_DH_DSS_WITH_ARIA_128_GCM_SHA256 = "DH-DSS-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DH_DSS_WITH_ARIA_256_GCM_SHA384 = "DH-DSS-ARIA256-GCM-SHA384";
pub const TLS1_TXT_DH_anon_WITH_ARIA_128_GCM_SHA256 = "ADH-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DH_anon_WITH_ARIA_256_GCM_SHA384 = "ADH-ARIA256-GCM-SHA384";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256 = "ECDHE-ECDSA-ARIA128-GCM-SHA256";
pub const TLS1_TXT_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384 = "ECDHE-ECDSA-ARIA256-GCM-SHA384";
pub const TLS1_TXT_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256 = "ECDH-ECDSA-ARIA128-GCM-SHA256";
pub const TLS1_TXT_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384 = "ECDH-ECDSA-ARIA256-GCM-SHA384";
pub const TLS1_TXT_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256 = "ECDHE-ARIA128-GCM-SHA256";
pub const TLS1_TXT_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384 = "ECDHE-ARIA256-GCM-SHA384";
pub const TLS1_TXT_ECDH_RSA_WITH_ARIA_128_GCM_SHA256 = "ECDH-ARIA128-GCM-SHA256";
pub const TLS1_TXT_ECDH_RSA_WITH_ARIA_256_GCM_SHA384 = "ECDH-ARIA256-GCM-SHA384";
pub const TLS1_TXT_PSK_WITH_ARIA_128_GCM_SHA256 = "PSK-ARIA128-GCM-SHA256";
pub const TLS1_TXT_PSK_WITH_ARIA_256_GCM_SHA384 = "PSK-ARIA256-GCM-SHA384";
pub const TLS1_TXT_DHE_PSK_WITH_ARIA_128_GCM_SHA256 = "DHE-PSK-ARIA128-GCM-SHA256";
pub const TLS1_TXT_DHE_PSK_WITH_ARIA_256_GCM_SHA384 = "DHE-PSK-ARIA256-GCM-SHA384";
pub const TLS1_TXT_RSA_PSK_WITH_ARIA_128_GCM_SHA256 = "RSA-PSK-ARIA128-GCM-SHA256";
pub const TLS1_TXT_RSA_PSK_WITH_ARIA_256_GCM_SHA384 = "RSA-PSK-ARIA256-GCM-SHA384";
pub const TLS_CT_RSA_SIGN = @as(c_int, 1);
pub const TLS_CT_DSS_SIGN = @as(c_int, 2);
pub const TLS_CT_RSA_FIXED_DH = @as(c_int, 3);
pub const TLS_CT_DSS_FIXED_DH = @as(c_int, 4);
pub const TLS_CT_ECDSA_SIGN = @as(c_int, 64);
pub const TLS_CT_RSA_FIXED_ECDH = @as(c_int, 65);
pub const TLS_CT_ECDSA_FIXED_ECDH = @as(c_int, 66);
pub const TLS_CT_GOST01_SIGN = @as(c_int, 22);
pub const TLS_CT_GOST12_IANA_SIGN = @as(c_int, 67);
pub const TLS_CT_GOST12_IANA_512_SIGN = @as(c_int, 68);
pub const TLS_CT_GOST12_LEGACY_SIGN = @as(c_int, 238);
pub const TLS_CT_GOST12_LEGACY_512_SIGN = @as(c_int, 239);
pub const TLS_CT_GOST12_SIGN = TLS_CT_GOST12_LEGACY_SIGN;
pub const TLS_CT_GOST12_512_SIGN = TLS_CT_GOST12_LEGACY_512_SIGN;
pub const TLS_CT_NUMBER = @as(c_int, 12);
pub const TLS1_FINISH_MAC_LENGTH = @as(c_int, 12);
pub const TLS_MD_MAX_CONST_SIZE = @as(c_int, 22);
pub const TLS_MD_CLIENT_FINISH_CONST = "\x63\x6c\x69\x65\x6e\x74\x20\x66\x69\x6e\x69\x73\x68\x65\x64";
pub const TLS_MD_CLIENT_FINISH_CONST_SIZE = @as(c_int, 15);
pub const TLS_MD_SERVER_FINISH_CONST = "\x73\x65\x72\x76\x65\x72\x20\x66\x69\x6e\x69\x73\x68\x65\x64";
pub const TLS_MD_SERVER_FINISH_CONST_SIZE = @as(c_int, 15);
pub const TLS_MD_SERVER_WRITE_KEY_CONST = "\x73\x65\x72\x76\x65\x72\x20\x77\x72\x69\x74\x65\x20\x6b\x65\x79";
pub const TLS_MD_SERVER_WRITE_KEY_CONST_SIZE = @as(c_int, 16);
pub const TLS_MD_KEY_EXPANSION_CONST = "\x6b\x65\x79\x20\x65\x78\x70\x61\x6e\x73\x69\x6f\x6e";
pub const TLS_MD_KEY_EXPANSION_CONST_SIZE = @as(c_int, 13);
pub const TLS_MD_CLIENT_WRITE_KEY_CONST = "\x63\x6c\x69\x65\x6e\x74\x20\x77\x72\x69\x74\x65\x20\x6b\x65\x79";
pub const TLS_MD_CLIENT_WRITE_KEY_CONST_SIZE = @as(c_int, 16);
pub const TLS_MD_IV_BLOCK_CONST = "\x49\x56\x20\x62\x6c\x6f\x63\x6b";
pub const TLS_MD_IV_BLOCK_CONST_SIZE = @as(c_int, 8);
pub const TLS_MD_MASTER_SECRET_CONST = "\x6d\x61\x73\x74\x65\x72\x20\x73\x65\x63\x72\x65\x74";
pub const TLS_MD_MASTER_SECRET_CONST_SIZE = @as(c_int, 13);
pub const TLS_MD_EXTENDED_MASTER_SECRET_CONST = "\x65\x78\x74\x65\x6e\x64\x65\x64\x20\x6d\x61\x73\x74\x65\x72\x20\x73\x65\x63\x72\x65\x74";
pub const TLS_MD_EXTENDED_MASTER_SECRET_CONST_SIZE = @as(c_int, 22);
pub const OPENSSL_DTLS1_H = "";
pub const HEADER_DTLS1_H = "";
pub const DTLS_MIN_VERSION = DTLS1_VERSION;
pub const DTLS_MAX_VERSION = DTLS1_2_VERSION;
pub const DTLS1_VERSION_MAJOR = @as(c_int, 0xFE);
pub const DTLS_ANY_VERSION = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x1FFFF, .hex);
pub const DTLS1_COOKIE_LENGTH = @as(c_int, 255);
pub const DTLS1_RT_HEADER_LENGTH = @as(c_int, 13);
pub const DTLS1_HM_HEADER_LENGTH = @as(c_int, 12);
pub const DTLS1_HM_BAD_FRAGMENT = -@as(c_int, 2);
pub const DTLS1_HM_FRAGMENT_RETRY = -@as(c_int, 3);
pub const DTLS1_CCS_HEADER_LENGTH = @as(c_int, 1);
pub const DTLS1_AL_HEADER_LENGTH = @as(c_int, 2);
pub const DTLS1_TMO_ALERT_COUNT = @as(c_int, 12);
pub const OPENSSL_SRTP_H = "";
pub const HEADER_D1_SRTP_H = "";
pub const SRTP_AES128_CM_SHA1_80 = @as(c_int, 0x0001);
pub const SRTP_AES128_CM_SHA1_32 = @as(c_int, 0x0002);
pub const SRTP_AES128_F8_SHA1_80 = @as(c_int, 0x0003);
pub const SRTP_AES128_F8_SHA1_32 = @as(c_int, 0x0004);
pub const SRTP_NULL_SHA1_80 = @as(c_int, 0x0005);
pub const SRTP_NULL_SHA1_32 = @as(c_int, 0x0006);
pub const SRTP_AEAD_AES_128_GCM = @as(c_int, 0x0007);
pub const SRTP_AEAD_AES_256_GCM = @as(c_int, 0x0008);
pub const SRTP_DOUBLE_AEAD_AES_128_GCM_AEAD_AES_128_GCM = @as(c_int, 0x0009);
pub const SRTP_DOUBLE_AEAD_AES_256_GCM_AEAD_AES_256_GCM = @as(c_int, 0x000A);
pub const SRTP_ARIA_128_CTR_HMAC_SHA1_80 = @as(c_int, 0x000B);
pub const SRTP_ARIA_128_CTR_HMAC_SHA1_32 = @as(c_int, 0x000C);
pub const SRTP_ARIA_256_CTR_HMAC_SHA1_80 = @as(c_int, 0x000D);
pub const SRTP_ARIA_256_CTR_HMAC_SHA1_32 = @as(c_int, 0x000E);
pub const SRTP_AEAD_ARIA_128_GCM = @as(c_int, 0x000F);
pub const SRTP_AEAD_ARIA_256_GCM = @as(c_int, 0x0010);
pub const OPENSSL_QUIC_H = "";
pub const OSSL_QUIC_ERR_NO_ERROR = @as(c_int, 0x00);
pub const OSSL_QUIC_ERR_INTERNAL_ERROR = @as(c_int, 0x01);
pub const OSSL_QUIC_ERR_CONNECTION_REFUSED = @as(c_int, 0x02);
pub const OSSL_QUIC_ERR_FLOW_CONTROL_ERROR = @as(c_int, 0x03);
pub const OSSL_QUIC_ERR_STREAM_LIMIT_ERROR = @as(c_int, 0x04);
pub const OSSL_QUIC_ERR_STREAM_STATE_ERROR = @as(c_int, 0x05);
pub const OSSL_QUIC_ERR_FINAL_SIZE_ERROR = @as(c_int, 0x06);
pub const OSSL_QUIC_ERR_FRAME_ENCODING_ERROR = @as(c_int, 0x07);
pub const OSSL_QUIC_ERR_TRANSPORT_PARAMETER_ERROR = @as(c_int, 0x08);
pub const OSSL_QUIC_ERR_CONNECTION_ID_LIMIT_ERROR = @as(c_int, 0x09);
pub const OSSL_QUIC_ERR_PROTOCOL_VIOLATION = @as(c_int, 0x0A);
pub const OSSL_QUIC_ERR_INVALID_TOKEN = @as(c_int, 0x0B);
pub const OSSL_QUIC_ERR_APPLICATION_ERROR = @as(c_int, 0x0C);
pub const OSSL_QUIC_ERR_CRYPTO_BUFFER_EXCEEDED = @as(c_int, 0x0D);
pub const OSSL_QUIC_ERR_KEY_UPDATE_ERROR = @as(c_int, 0x0E);
pub const OSSL_QUIC_ERR_AEAD_LIMIT_REACHED = @as(c_int, 0x0F);
pub const OSSL_QUIC_ERR_NO_VIABLE_PATH = @as(c_int, 0x10);
pub const OSSL_QUIC_ERR_CRYPTO_ERR_BEGIN = @as(c_int, 0x0100);
pub const OSSL_QUIC_ERR_CRYPTO_ERR_END = @as(c_int, 0x01FF);
pub inline fn OSSL_QUIC_ERR_CRYPTO_ERR(X: anytype) @TypeOf(OSSL_QUIC_ERR_CRYPTO_ERR_BEGIN + X) {
    _ = &X;
    return OSSL_QUIC_ERR_CRYPTO_ERR_BEGIN + X;
}
pub const OSSL_QUIC_LOCAL_ERR_IDLE_TIMEOUT = @import("std").zig.c_translation.cast(u64, @as(c_ulonglong, 0xFFFFFFFFFFFFFFFF));
pub inline fn sk_SSL_CIPHER_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_SSL_CIPHER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_SSL_CIPHER_sk_type(sk));
}
pub const sk_SSL_CIPHER_value = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/ssl.h:1000:9
pub const sk_SSL_CIPHER_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ssl.h:1001:9
pub const sk_SSL_CIPHER_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ssl.h:1002:9
pub const sk_SSL_CIPHER_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ssl.h:1003:9
pub inline fn sk_SSL_CIPHER_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_SSL_CIPHER_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_SSL_CIPHER_sk_type(sk), n);
}
pub inline fn sk_SSL_CIPHER_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_SSL_CIPHER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_SSL_CIPHER_sk_type(sk));
}
pub inline fn sk_SSL_CIPHER_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_SSL_CIPHER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_SSL_CIPHER_sk_type(sk));
}
pub const sk_SSL_CIPHER_delete = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/ssl.h:1007:9
pub const sk_SSL_CIPHER_delete_ptr = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/ssl.h:1008:9
pub inline fn sk_SSL_CIPHER_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr));
}
pub inline fn sk_SSL_CIPHER_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr));
}
pub const sk_SSL_CIPHER_pop = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/ssl.h:1011:9
pub const sk_SSL_CIPHER_shift = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/ssl.h:1012:9
pub inline fn sk_SSL_CIPHER_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_freefunc_type(freefunc));
}
pub inline fn sk_SSL_CIPHER_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr), idx);
}
pub const sk_SSL_CIPHER_set = @compileError("unable to translate C expr: unexpected token 'const'");
// /usr/include/openssl/ssl.h:1015:9
pub inline fn sk_SSL_CIPHER_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr));
}
pub inline fn sk_SSL_CIPHER_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr));
}
pub inline fn sk_SSL_CIPHER_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_type(ptr), pnum);
}
pub inline fn sk_SSL_CIPHER_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_SSL_CIPHER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_SSL_CIPHER_sk_type(sk));
}
pub inline fn sk_SSL_CIPHER_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_SSL_CIPHER_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_SSL_CIPHER_sk_type(sk));
}
pub const sk_SSL_CIPHER_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ssl.h:1021:9
pub const sk_SSL_CIPHER_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ssl.h:1022:9
pub inline fn sk_SSL_CIPHER_set_cmp_func(sk: anytype, cmp: anytype) sk_SSL_CIPHER_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_SSL_CIPHER_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_SSL_CIPHER_sk_type(sk), ossl_check_SSL_CIPHER_compfunc_type(cmp)));
}
pub inline fn SSL_set_app_data(s: anytype, arg: anytype) @TypeOf(SSL_set_ex_data(s, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, arg))) {
    _ = &s;
    _ = &arg;
    return SSL_set_ex_data(s, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, arg));
}
pub inline fn SSL_get_app_data(s: anytype) @TypeOf(SSL_get_ex_data(s, @as(c_int, 0))) {
    _ = &s;
    return SSL_get_ex_data(s, @as(c_int, 0));
}
pub inline fn SSL_SESSION_set_app_data(s: anytype, a: anytype) @TypeOf(SSL_SESSION_set_ex_data(s, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, a))) {
    _ = &s;
    _ = &a;
    return SSL_SESSION_set_ex_data(s, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, a));
}
pub inline fn SSL_SESSION_get_app_data(s: anytype) @TypeOf(SSL_SESSION_get_ex_data(s, @as(c_int, 0))) {
    _ = &s;
    return SSL_SESSION_get_ex_data(s, @as(c_int, 0));
}
pub inline fn SSL_CTX_get_app_data(ctx: anytype) @TypeOf(SSL_CTX_get_ex_data(ctx, @as(c_int, 0))) {
    _ = &ctx;
    return SSL_CTX_get_ex_data(ctx, @as(c_int, 0));
}
pub inline fn SSL_CTX_set_app_data(ctx: anytype, arg: anytype) @TypeOf(SSL_CTX_set_ex_data(ctx, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, arg))) {
    _ = &ctx;
    _ = &arg;
    return SSL_CTX_set_ex_data(ctx, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, arg));
}
pub const SSL_KEY_UPDATE_NONE = -@as(c_int, 1);
pub const SSL_KEY_UPDATE_NOT_REQUESTED = @as(c_int, 0);
pub const SSL_KEY_UPDATE_REQUESTED = @as(c_int, 1);
pub const SSL_ST_CONNECT = @as(c_int, 0x1000);
pub const SSL_ST_ACCEPT = @as(c_int, 0x2000);
pub const SSL_ST_MASK = @as(c_int, 0x0FFF);
pub const SSL_CB_LOOP = @as(c_int, 0x01);
pub const SSL_CB_EXIT = @as(c_int, 0x02);
pub const SSL_CB_READ = @as(c_int, 0x04);
pub const SSL_CB_WRITE = @as(c_int, 0x08);
pub const SSL_CB_ALERT = @as(c_int, 0x4000);
pub const SSL_CB_READ_ALERT = SSL_CB_ALERT | SSL_CB_READ;
pub const SSL_CB_WRITE_ALERT = SSL_CB_ALERT | SSL_CB_WRITE;
pub const SSL_CB_ACCEPT_LOOP = SSL_ST_ACCEPT | SSL_CB_LOOP;
pub const SSL_CB_ACCEPT_EXIT = SSL_ST_ACCEPT | SSL_CB_EXIT;
pub const SSL_CB_CONNECT_LOOP = SSL_ST_CONNECT | SSL_CB_LOOP;
pub const SSL_CB_CONNECT_EXIT = SSL_ST_CONNECT | SSL_CB_EXIT;
pub const SSL_CB_HANDSHAKE_START = @as(c_int, 0x10);
pub const SSL_CB_HANDSHAKE_DONE = @as(c_int, 0x20);
pub inline fn SSL_in_connect_init(a: anytype) @TypeOf((SSL_in_init(a) != 0) and !(SSL_is_server(a) != 0)) {
    _ = &a;
    return (SSL_in_init(a) != 0) and !(SSL_is_server(a) != 0);
}
pub inline fn SSL_in_accept_init(a: anytype) @TypeOf((SSL_in_init(a) != 0) and (SSL_is_server(a) != 0)) {
    _ = &a;
    return (SSL_in_init(a) != 0) and (SSL_is_server(a) != 0);
}
pub const SSL_ST_READ_HEADER = @as(c_int, 0xF0);
pub const SSL_ST_READ_BODY = @as(c_int, 0xF1);
pub const SSL_ST_READ_DONE = @as(c_int, 0xF2);
pub const SSL_VERIFY_NONE = @as(c_int, 0x00);
pub const SSL_VERIFY_PEER = @as(c_int, 0x01);
pub const SSL_VERIFY_FAIL_IF_NO_PEER_CERT = @as(c_int, 0x02);
pub const SSL_VERIFY_CLIENT_ONCE = @as(c_int, 0x04);
pub const SSL_VERIFY_POST_HANDSHAKE = @as(c_int, 0x08);
pub inline fn OpenSSL_add_ssl_algorithms() @TypeOf(SSL_library_init()) {
    return SSL_library_init();
}
pub inline fn SSLeay_add_ssl_algorithms() @TypeOf(SSL_library_init()) {
    return SSL_library_init();
}
pub inline fn SSL_get_cipher(s: anytype) @TypeOf(SSL_CIPHER_get_name(SSL_get_current_cipher(s))) {
    _ = &s;
    return SSL_CIPHER_get_name(SSL_get_current_cipher(s));
}
pub inline fn SSL_get_cipher_bits(s: anytype, np: anytype) @TypeOf(SSL_CIPHER_get_bits(SSL_get_current_cipher(s), np)) {
    _ = &s;
    _ = &np;
    return SSL_CIPHER_get_bits(SSL_get_current_cipher(s), np);
}
pub inline fn SSL_get_cipher_version(s: anytype) @TypeOf(SSL_CIPHER_get_version(SSL_get_current_cipher(s))) {
    _ = &s;
    return SSL_CIPHER_get_version(SSL_get_current_cipher(s));
}
pub inline fn SSL_get_cipher_name(s: anytype) @TypeOf(SSL_CIPHER_get_name(SSL_get_current_cipher(s))) {
    _ = &s;
    return SSL_CIPHER_get_name(SSL_get_current_cipher(s));
}
pub inline fn SSL_get_time(a: anytype) @TypeOf(SSL_SESSION_get_time(a)) {
    _ = &a;
    return SSL_SESSION_get_time(a);
}
pub inline fn SSL_set_time(a: anytype, b: anytype) @TypeOf(SSL_SESSION_set_time(a, b)) {
    _ = &a;
    _ = &b;
    return SSL_SESSION_set_time(a, b);
}
pub inline fn SSL_get_timeout(a: anytype) @TypeOf(SSL_SESSION_get_timeout(a)) {
    _ = &a;
    return SSL_SESSION_get_timeout(a);
}
pub inline fn SSL_set_timeout(a: anytype, b: anytype) @TypeOf(SSL_SESSION_set_timeout(a, b)) {
    _ = &a;
    _ = &b;
    return SSL_SESSION_set_timeout(a, b);
}
pub inline fn d2i_SSL_SESSION_bio(bp: anytype, s_id: anytype) @TypeOf(ASN1_d2i_bio_of(SSL_SESSION, SSL_SESSION_new, d2i_SSL_SESSION, bp, s_id)) {
    _ = &bp;
    _ = &s_id;
    return ASN1_d2i_bio_of(SSL_SESSION, SSL_SESSION_new, d2i_SSL_SESSION, bp, s_id);
}
pub inline fn i2d_SSL_SESSION_bio(bp: anytype, s_id: anytype) @TypeOf(ASN1_i2d_bio_of(SSL_SESSION, i2d_SSL_SESSION, bp, s_id)) {
    _ = &bp;
    _ = &s_id;
    return ASN1_i2d_bio_of(SSL_SESSION, i2d_SSL_SESSION, bp, s_id);
}
pub const SSL_AD_REASON_OFFSET = @as(c_int, 1000);
pub const SSL_AD_CLOSE_NOTIFY = SSL3_AD_CLOSE_NOTIFY;
pub const SSL_AD_UNEXPECTED_MESSAGE = SSL3_AD_UNEXPECTED_MESSAGE;
pub const SSL_AD_BAD_RECORD_MAC = SSL3_AD_BAD_RECORD_MAC;
pub const SSL_AD_DECRYPTION_FAILED = TLS1_AD_DECRYPTION_FAILED;
pub const SSL_AD_RECORD_OVERFLOW = TLS1_AD_RECORD_OVERFLOW;
pub const SSL_AD_DECOMPRESSION_FAILURE = SSL3_AD_DECOMPRESSION_FAILURE;
pub const SSL_AD_HANDSHAKE_FAILURE = SSL3_AD_HANDSHAKE_FAILURE;
pub const SSL_AD_NO_CERTIFICATE = SSL3_AD_NO_CERTIFICATE;
pub const SSL_AD_BAD_CERTIFICATE = SSL3_AD_BAD_CERTIFICATE;
pub const SSL_AD_UNSUPPORTED_CERTIFICATE = SSL3_AD_UNSUPPORTED_CERTIFICATE;
pub const SSL_AD_CERTIFICATE_REVOKED = SSL3_AD_CERTIFICATE_REVOKED;
pub const SSL_AD_CERTIFICATE_EXPIRED = SSL3_AD_CERTIFICATE_EXPIRED;
pub const SSL_AD_CERTIFICATE_UNKNOWN = SSL3_AD_CERTIFICATE_UNKNOWN;
pub const SSL_AD_ILLEGAL_PARAMETER = SSL3_AD_ILLEGAL_PARAMETER;
pub const SSL_AD_UNKNOWN_CA = TLS1_AD_UNKNOWN_CA;
pub const SSL_AD_ACCESS_DENIED = TLS1_AD_ACCESS_DENIED;
pub const SSL_AD_DECODE_ERROR = TLS1_AD_DECODE_ERROR;
pub const SSL_AD_DECRYPT_ERROR = TLS1_AD_DECRYPT_ERROR;
pub const SSL_AD_EXPORT_RESTRICTION = TLS1_AD_EXPORT_RESTRICTION;
pub const SSL_AD_PROTOCOL_VERSION = TLS1_AD_PROTOCOL_VERSION;
pub const SSL_AD_INSUFFICIENT_SECURITY = TLS1_AD_INSUFFICIENT_SECURITY;
pub const SSL_AD_INTERNAL_ERROR = TLS1_AD_INTERNAL_ERROR;
pub const SSL_AD_USER_CANCELLED = TLS1_AD_USER_CANCELLED;
pub const SSL_AD_NO_RENEGOTIATION = TLS1_AD_NO_RENEGOTIATION;
pub const SSL_AD_MISSING_EXTENSION = TLS13_AD_MISSING_EXTENSION;
pub const SSL_AD_CERTIFICATE_REQUIRED = TLS13_AD_CERTIFICATE_REQUIRED;
pub const SSL_AD_UNSUPPORTED_EXTENSION = TLS1_AD_UNSUPPORTED_EXTENSION;
pub const SSL_AD_CERTIFICATE_UNOBTAINABLE = TLS1_AD_CERTIFICATE_UNOBTAINABLE;
pub const SSL_AD_UNRECOGNIZED_NAME = TLS1_AD_UNRECOGNIZED_NAME;
pub const SSL_AD_BAD_CERTIFICATE_STATUS_RESPONSE = TLS1_AD_BAD_CERTIFICATE_STATUS_RESPONSE;
pub const SSL_AD_BAD_CERTIFICATE_HASH_VALUE = TLS1_AD_BAD_CERTIFICATE_HASH_VALUE;
pub const SSL_AD_UNKNOWN_PSK_IDENTITY = TLS1_AD_UNKNOWN_PSK_IDENTITY;
pub const SSL_AD_INAPPROPRIATE_FALLBACK = TLS1_AD_INAPPROPRIATE_FALLBACK;
pub const SSL_AD_NO_APPLICATION_PROTOCOL = TLS1_AD_NO_APPLICATION_PROTOCOL;
pub const SSL_ERROR_NONE = @as(c_int, 0);
pub const SSL_ERROR_SSL = @as(c_int, 1);
pub const SSL_ERROR_WANT_READ = @as(c_int, 2);
pub const SSL_ERROR_WANT_WRITE = @as(c_int, 3);
pub const SSL_ERROR_WANT_X509_LOOKUP = @as(c_int, 4);
pub const SSL_ERROR_SYSCALL = @as(c_int, 5);
pub const SSL_ERROR_ZERO_RETURN = @as(c_int, 6);
pub const SSL_ERROR_WANT_CONNECT = @as(c_int, 7);
pub const SSL_ERROR_WANT_ACCEPT = @as(c_int, 8);
pub const SSL_ERROR_WANT_ASYNC = @as(c_int, 9);
pub const SSL_ERROR_WANT_ASYNC_JOB = @as(c_int, 10);
pub const SSL_ERROR_WANT_CLIENT_HELLO_CB = @as(c_int, 11);
pub const SSL_ERROR_WANT_RETRY_VERIFY = @as(c_int, 12);
pub const SSL_CTRL_SET_TMP_DH = @as(c_int, 3);
pub const SSL_CTRL_SET_TMP_ECDH = @as(c_int, 4);
pub const SSL_CTRL_SET_TMP_DH_CB = @as(c_int, 6);
pub const SSL_CTRL_GET_CLIENT_CERT_REQUEST = @as(c_int, 9);
pub const SSL_CTRL_GET_NUM_RENEGOTIATIONS = @as(c_int, 10);
pub const SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS = @as(c_int, 11);
pub const SSL_CTRL_GET_TOTAL_RENEGOTIATIONS = @as(c_int, 12);
pub const SSL_CTRL_GET_FLAGS = @as(c_int, 13);
pub const SSL_CTRL_EXTRA_CHAIN_CERT = @as(c_int, 14);
pub const SSL_CTRL_SET_MSG_CALLBACK = @as(c_int, 15);
pub const SSL_CTRL_SET_MSG_CALLBACK_ARG = @as(c_int, 16);
pub const SSL_CTRL_SET_MTU = @as(c_int, 17);
pub const SSL_CTRL_SESS_NUMBER = @as(c_int, 20);
pub const SSL_CTRL_SESS_CONNECT = @as(c_int, 21);
pub const SSL_CTRL_SESS_CONNECT_GOOD = @as(c_int, 22);
pub const SSL_CTRL_SESS_CONNECT_RENEGOTIATE = @as(c_int, 23);
pub const SSL_CTRL_SESS_ACCEPT = @as(c_int, 24);
pub const SSL_CTRL_SESS_ACCEPT_GOOD = @as(c_int, 25);
pub const SSL_CTRL_SESS_ACCEPT_RENEGOTIATE = @as(c_int, 26);
pub const SSL_CTRL_SESS_HIT = @as(c_int, 27);
pub const SSL_CTRL_SESS_CB_HIT = @as(c_int, 28);
pub const SSL_CTRL_SESS_MISSES = @as(c_int, 29);
pub const SSL_CTRL_SESS_TIMEOUTS = @as(c_int, 30);
pub const SSL_CTRL_SESS_CACHE_FULL = @as(c_int, 31);
pub const SSL_CTRL_MODE = @as(c_int, 33);
pub const SSL_CTRL_GET_READ_AHEAD = @as(c_int, 40);
pub const SSL_CTRL_SET_READ_AHEAD = @as(c_int, 41);
pub const SSL_CTRL_SET_SESS_CACHE_SIZE = @as(c_int, 42);
pub const SSL_CTRL_GET_SESS_CACHE_SIZE = @as(c_int, 43);
pub const SSL_CTRL_SET_SESS_CACHE_MODE = @as(c_int, 44);
pub const SSL_CTRL_GET_SESS_CACHE_MODE = @as(c_int, 45);
pub const SSL_CTRL_GET_MAX_CERT_LIST = @as(c_int, 50);
pub const SSL_CTRL_SET_MAX_CERT_LIST = @as(c_int, 51);
pub const SSL_CTRL_SET_MAX_SEND_FRAGMENT = @as(c_int, 52);
pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_CB = @as(c_int, 53);
pub const SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG = @as(c_int, 54);
pub const SSL_CTRL_SET_TLSEXT_HOSTNAME = @as(c_int, 55);
pub const SSL_CTRL_SET_TLSEXT_DEBUG_CB = @as(c_int, 56);
pub const SSL_CTRL_SET_TLSEXT_DEBUG_ARG = @as(c_int, 57);
pub const SSL_CTRL_GET_TLSEXT_TICKET_KEYS = @as(c_int, 58);
pub const SSL_CTRL_SET_TLSEXT_TICKET_KEYS = @as(c_int, 59);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB = @as(c_int, 63);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG = @as(c_int, 64);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE = @as(c_int, 65);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS = @as(c_int, 66);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS = @as(c_int, 67);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS = @as(c_int, 68);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS = @as(c_int, 69);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP = @as(c_int, 70);
pub const SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP = @as(c_int, 71);
pub const SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB = @as(c_int, 72);
pub const SSL_CTRL_SET_TLS_EXT_SRP_USERNAME_CB = @as(c_int, 75);
pub const SSL_CTRL_SET_SRP_VERIFY_PARAM_CB = @as(c_int, 76);
pub const SSL_CTRL_SET_SRP_GIVE_CLIENT_PWD_CB = @as(c_int, 77);
pub const SSL_CTRL_SET_SRP_ARG = @as(c_int, 78);
pub const SSL_CTRL_SET_TLS_EXT_SRP_USERNAME = @as(c_int, 79);
pub const SSL_CTRL_SET_TLS_EXT_SRP_STRENGTH = @as(c_int, 80);
pub const SSL_CTRL_SET_TLS_EXT_SRP_PASSWORD = @as(c_int, 81);
pub const DTLS_CTRL_GET_TIMEOUT = @as(c_int, 73);
pub const DTLS_CTRL_HANDLE_TIMEOUT = @as(c_int, 74);
pub const SSL_CTRL_GET_RI_SUPPORT = @as(c_int, 76);
pub const SSL_CTRL_CLEAR_MODE = @as(c_int, 78);
pub const SSL_CTRL_SET_NOT_RESUMABLE_SESS_CB = @as(c_int, 79);
pub const SSL_CTRL_GET_EXTRA_CHAIN_CERTS = @as(c_int, 82);
pub const SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS = @as(c_int, 83);
pub const SSL_CTRL_CHAIN = @as(c_int, 88);
pub const SSL_CTRL_CHAIN_CERT = @as(c_int, 89);
pub const SSL_CTRL_GET_GROUPS = @as(c_int, 90);
pub const SSL_CTRL_SET_GROUPS = @as(c_int, 91);
pub const SSL_CTRL_SET_GROUPS_LIST = @as(c_int, 92);
pub const SSL_CTRL_GET_SHARED_GROUP = @as(c_int, 93);
pub const SSL_CTRL_SET_SIGALGS = @as(c_int, 97);
pub const SSL_CTRL_SET_SIGALGS_LIST = @as(c_int, 98);
pub const SSL_CTRL_CERT_FLAGS = @as(c_int, 99);
pub const SSL_CTRL_CLEAR_CERT_FLAGS = @as(c_int, 100);
pub const SSL_CTRL_SET_CLIENT_SIGALGS = @as(c_int, 101);
pub const SSL_CTRL_SET_CLIENT_SIGALGS_LIST = @as(c_int, 102);
pub const SSL_CTRL_GET_CLIENT_CERT_TYPES = @as(c_int, 103);
pub const SSL_CTRL_SET_CLIENT_CERT_TYPES = @as(c_int, 104);
pub const SSL_CTRL_BUILD_CERT_CHAIN = @as(c_int, 105);
pub const SSL_CTRL_SET_VERIFY_CERT_STORE = @as(c_int, 106);
pub const SSL_CTRL_SET_CHAIN_CERT_STORE = @as(c_int, 107);
pub const SSL_CTRL_GET_PEER_SIGNATURE_NID = @as(c_int, 108);
pub const SSL_CTRL_GET_PEER_TMP_KEY = @as(c_int, 109);
pub const SSL_CTRL_GET_RAW_CIPHERLIST = @as(c_int, 110);
pub const SSL_CTRL_GET_EC_POINT_FORMATS = @as(c_int, 111);
pub const SSL_CTRL_GET_CHAIN_CERTS = @as(c_int, 115);
pub const SSL_CTRL_SELECT_CURRENT_CERT = @as(c_int, 116);
pub const SSL_CTRL_SET_CURRENT_CERT = @as(c_int, 117);
pub const SSL_CTRL_SET_DH_AUTO = @as(c_int, 118);
pub const DTLS_CTRL_SET_LINK_MTU = @as(c_int, 120);
pub const DTLS_CTRL_GET_LINK_MIN_MTU = @as(c_int, 121);
pub const SSL_CTRL_GET_EXTMS_SUPPORT = @as(c_int, 122);
pub const SSL_CTRL_SET_MIN_PROTO_VERSION = @as(c_int, 123);
pub const SSL_CTRL_SET_MAX_PROTO_VERSION = @as(c_int, 124);
pub const SSL_CTRL_SET_SPLIT_SEND_FRAGMENT = @as(c_int, 125);
pub const SSL_CTRL_SET_MAX_PIPELINES = @as(c_int, 126);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_TYPE = @as(c_int, 127);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB = @as(c_int, 128);
pub const SSL_CTRL_GET_TLSEXT_STATUS_REQ_CB_ARG = @as(c_int, 129);
pub const SSL_CTRL_GET_MIN_PROTO_VERSION = @as(c_int, 130);
pub const SSL_CTRL_GET_MAX_PROTO_VERSION = @as(c_int, 131);
pub const SSL_CTRL_GET_SIGNATURE_NID = @as(c_int, 132);
pub const SSL_CTRL_GET_TMP_KEY = @as(c_int, 133);
pub const SSL_CTRL_GET_NEGOTIATED_GROUP = @as(c_int, 134);
pub const SSL_CTRL_GET_IANA_GROUPS = @as(c_int, 135);
pub const SSL_CTRL_SET_RETRY_VERIFY = @as(c_int, 136);
pub const SSL_CTRL_GET_VERIFY_CERT_STORE = @as(c_int, 137);
pub const SSL_CTRL_GET_CHAIN_CERT_STORE = @as(c_int, 138);
pub const SSL_CERT_SET_FIRST = @as(c_int, 1);
pub const SSL_CERT_SET_NEXT = @as(c_int, 2);
pub const SSL_CERT_SET_SERVER = @as(c_int, 3);
pub inline fn DTLSv1_get_timeout(ssl: anytype, arg: anytype) @TypeOf(SSL_ctrl(ssl, DTLS_CTRL_GET_TIMEOUT, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, arg))) {
    _ = &ssl;
    _ = &arg;
    return SSL_ctrl(ssl, DTLS_CTRL_GET_TIMEOUT, @as(c_int, 0), @import("std").zig.c_translation.cast(?*anyopaque, arg));
}
pub inline fn DTLSv1_handle_timeout(ssl: anytype) @TypeOf(SSL_ctrl(ssl, DTLS_CTRL_HANDLE_TIMEOUT, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, DTLS_CTRL_HANDLE_TIMEOUT, @as(c_int, 0), NULL);
}
pub inline fn SSL_num_renegotiations(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_NUM_RENEGOTIATIONS, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_GET_NUM_RENEGOTIATIONS, @as(c_int, 0), NULL);
}
pub inline fn SSL_clear_num_renegotiations(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS, @as(c_int, 0), NULL);
}
pub inline fn SSL_total_renegotiations(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_TOTAL_RENEGOTIATIONS, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_GET_TOTAL_RENEGOTIATIONS, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set_tmp_dh(ctx: anytype, dh: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TMP_DH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, dh))) {
    _ = &ctx;
    _ = &dh;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TMP_DH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, dh));
}
pub inline fn SSL_CTX_set_dh_auto(ctx: anytype, onoff: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_DH_AUTO, onoff, NULL)) {
    _ = &ctx;
    _ = &onoff;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_DH_AUTO, onoff, NULL);
}
pub inline fn SSL_set_dh_auto(s: anytype, onoff: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_DH_AUTO, onoff, NULL)) {
    _ = &s;
    _ = &onoff;
    return SSL_ctrl(s, SSL_CTRL_SET_DH_AUTO, onoff, NULL);
}
pub inline fn SSL_set_tmp_dh(ssl: anytype, dh: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TMP_DH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, dh))) {
    _ = &ssl;
    _ = &dh;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TMP_DH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, dh));
}
pub inline fn SSL_CTX_set_tmp_ecdh(ctx: anytype, ecdh: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TMP_ECDH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ecdh))) {
    _ = &ctx;
    _ = &ecdh;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_TMP_ECDH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ecdh));
}
pub inline fn SSL_set_tmp_ecdh(ssl: anytype, ecdh: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_TMP_ECDH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ecdh))) {
    _ = &ssl;
    _ = &ecdh;
    return SSL_ctrl(ssl, SSL_CTRL_SET_TMP_ECDH, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, ecdh));
}
pub inline fn SSL_CTX_add_extra_chain_cert(ctx: anytype, x509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_EXTRA_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &ctx;
    _ = &x509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_EXTRA_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_CTX_get_extra_chain_certs(ctx: anytype, px509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_EXTRA_CHAIN_CERTS, @as(c_int, 0), px509)) {
    _ = &ctx;
    _ = &px509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_EXTRA_CHAIN_CERTS, @as(c_int, 0), px509);
}
pub inline fn SSL_CTX_get_extra_chain_certs_only(ctx: anytype, px509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_EXTRA_CHAIN_CERTS, @as(c_int, 1), px509)) {
    _ = &ctx;
    _ = &px509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_EXTRA_CHAIN_CERTS, @as(c_int, 1), px509);
}
pub inline fn SSL_CTX_clear_extra_chain_certs(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set0_chain(ctx: anytype, sk: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sk))) {
    _ = &ctx;
    _ = &sk;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sk));
}
pub inline fn SSL_CTX_set1_chain(ctx: anytype, sk: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, sk))) {
    _ = &ctx;
    _ = &sk;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, sk));
}
pub inline fn SSL_CTX_add0_chain_cert(ctx: anytype, x509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &ctx;
    _ = &x509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_CTX_add1_chain_cert(ctx: anytype, x509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN_CERT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &ctx;
    _ = &x509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_CHAIN_CERT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_CTX_get0_chain_certs(ctx: anytype, px509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_CHAIN_CERTS, @as(c_int, 0), px509)) {
    _ = &ctx;
    _ = &px509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_CHAIN_CERTS, @as(c_int, 0), px509);
}
pub inline fn SSL_CTX_clear_chain_certs(ctx: anytype) @TypeOf(SSL_CTX_set0_chain(ctx, NULL)) {
    _ = &ctx;
    return SSL_CTX_set0_chain(ctx, NULL);
}
pub inline fn SSL_CTX_build_cert_chain(ctx: anytype, flags: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_BUILD_CERT_CHAIN, flags, NULL)) {
    _ = &ctx;
    _ = &flags;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_BUILD_CERT_CHAIN, flags, NULL);
}
pub inline fn SSL_CTX_select_current_cert(ctx: anytype, x509: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SELECT_CURRENT_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &ctx;
    _ = &x509;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SELECT_CURRENT_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_CTX_set_current_cert(ctx: anytype, op: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CURRENT_CERT, op, NULL)) {
    _ = &ctx;
    _ = &op;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CURRENT_CERT, op, NULL);
}
pub inline fn SSL_CTX_set0_verify_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_CTX_set1_verify_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_CTX_get0_verify_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_CTX_set0_chain_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_CTX_set1_chain_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_CTX_get0_chain_cert_store(ctx: anytype, st: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &ctx;
    _ = &st;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_set0_chain(s: anytype, sk: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CHAIN, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sk))) {
    _ = &s;
    _ = &sk;
    return SSL_ctrl(s, SSL_CTRL_CHAIN, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, sk));
}
pub inline fn SSL_set1_chain(s: anytype, sk: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CHAIN, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, sk))) {
    _ = &s;
    _ = &sk;
    return SSL_ctrl(s, SSL_CTRL_CHAIN, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, sk));
}
pub inline fn SSL_add0_chain_cert(s: anytype, x509: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &s;
    _ = &x509;
    return SSL_ctrl(s, SSL_CTRL_CHAIN_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_add1_chain_cert(s: anytype, x509: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_CHAIN_CERT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &s;
    _ = &x509;
    return SSL_ctrl(s, SSL_CTRL_CHAIN_CERT, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_get0_chain_certs(s: anytype, px509: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_CHAIN_CERTS, @as(c_int, 0), px509)) {
    _ = &s;
    _ = &px509;
    return SSL_ctrl(s, SSL_CTRL_GET_CHAIN_CERTS, @as(c_int, 0), px509);
}
pub inline fn SSL_clear_chain_certs(s: anytype) @TypeOf(SSL_set0_chain(s, NULL)) {
    _ = &s;
    return SSL_set0_chain(s, NULL);
}
pub inline fn SSL_build_cert_chain(s: anytype, flags: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_BUILD_CERT_CHAIN, flags, NULL)) {
    _ = &s;
    _ = &flags;
    return SSL_ctrl(s, SSL_CTRL_BUILD_CERT_CHAIN, flags, NULL);
}
pub inline fn SSL_select_current_cert(s: anytype, x509: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SELECT_CURRENT_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509))) {
    _ = &s;
    _ = &x509;
    return SSL_ctrl(s, SSL_CTRL_SELECT_CURRENT_CERT, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, x509));
}
pub inline fn SSL_set_current_cert(s: anytype, op: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CURRENT_CERT, op, NULL)) {
    _ = &s;
    _ = &op;
    return SSL_ctrl(s, SSL_CTRL_SET_CURRENT_CERT, op, NULL);
}
pub inline fn SSL_set0_verify_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_set1_verify_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_SET_VERIFY_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_get0_verify_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_GET_VERIFY_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_set0_chain_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_set1_chain_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_SET_CHAIN_CERT_STORE, @as(c_int, 1), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_get0_chain_cert_store(s: anytype, st: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st))) {
    _ = &s;
    _ = &st;
    return SSL_ctrl(s, SSL_CTRL_GET_CHAIN_CERT_STORE, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, st));
}
pub inline fn SSL_get1_groups(s: anytype, glist: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_GROUPS, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]c_int, glist))) {
    _ = &s;
    _ = &glist;
    return SSL_ctrl(s, SSL_CTRL_GET_GROUPS, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]c_int, glist));
}
pub const SSL_get0_iana_groups = @compileError("unable to translate C expr: expected ')' instead got '*'");
// /usr/include/openssl/ssl.h:1488:10
pub inline fn SSL_CTX_set1_groups(ctx: anytype, glist: anytype, glistlen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_GROUPS, glistlen, @import("std").zig.c_translation.cast([*c]c_int, glist))) {
    _ = &ctx;
    _ = &glist;
    _ = &glistlen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_GROUPS, glistlen, @import("std").zig.c_translation.cast([*c]c_int, glist));
}
pub inline fn SSL_CTX_set1_groups_list(ctx: anytype, s: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_GROUPS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s))) {
    _ = &ctx;
    _ = &s;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_GROUPS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s));
}
pub inline fn SSL_set1_groups(s: anytype, glist: anytype, glistlen: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_GROUPS, glistlen, @import("std").zig.c_translation.cast([*c]u8, glist))) {
    _ = &s;
    _ = &glist;
    _ = &glistlen;
    return SSL_ctrl(s, SSL_CTRL_SET_GROUPS, glistlen, @import("std").zig.c_translation.cast([*c]u8, glist));
}
pub inline fn SSL_set1_groups_list(s: anytype, str: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_GROUPS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str))) {
    _ = &s;
    _ = &str;
    return SSL_ctrl(s, SSL_CTRL_SET_GROUPS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str));
}
pub inline fn SSL_get_shared_group(s: anytype, n: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_SHARED_GROUP, n, NULL)) {
    _ = &s;
    _ = &n;
    return SSL_ctrl(s, SSL_CTRL_GET_SHARED_GROUP, n, NULL);
}
pub inline fn SSL_get_negotiated_group(s: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_NEGOTIATED_GROUP, @as(c_int, 0), NULL)) {
    _ = &s;
    return SSL_ctrl(s, SSL_CTRL_GET_NEGOTIATED_GROUP, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set1_sigalgs(ctx: anytype, slist: anytype, slistlen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist))) {
    _ = &ctx;
    _ = &slist;
    _ = &slistlen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist));
}
pub inline fn SSL_CTX_set1_sigalgs_list(ctx: anytype, s: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s))) {
    _ = &ctx;
    _ = &s;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s));
}
pub inline fn SSL_set1_sigalgs(s: anytype, slist: anytype, slistlen: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist))) {
    _ = &s;
    _ = &slist;
    _ = &slistlen;
    return SSL_ctrl(s, SSL_CTRL_SET_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist));
}
pub inline fn SSL_set1_sigalgs_list(s: anytype, str: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str))) {
    _ = &s;
    _ = &str;
    return SSL_ctrl(s, SSL_CTRL_SET_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str));
}
pub inline fn SSL_CTX_set1_client_sigalgs(ctx: anytype, slist: anytype, slistlen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist))) {
    _ = &ctx;
    _ = &slist;
    _ = &slistlen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist));
}
pub inline fn SSL_CTX_set1_client_sigalgs_list(ctx: anytype, s: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s))) {
    _ = &ctx;
    _ = &s;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, s));
}
pub inline fn SSL_set1_client_sigalgs(s: anytype, slist: anytype, slistlen: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CLIENT_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist))) {
    _ = &s;
    _ = &slist;
    _ = &slistlen;
    return SSL_ctrl(s, SSL_CTRL_SET_CLIENT_SIGALGS, slistlen, @import("std").zig.c_translation.cast([*c]c_int, slist));
}
pub inline fn SSL_set1_client_sigalgs_list(s: anytype, str: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CLIENT_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str))) {
    _ = &s;
    _ = &str;
    return SSL_ctrl(s, SSL_CTRL_SET_CLIENT_SIGALGS_LIST, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, str));
}
pub inline fn SSL_get0_certificate_types(s: anytype, clist: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_CLIENT_CERT_TYPES, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, clist))) {
    _ = &s;
    _ = &clist;
    return SSL_ctrl(s, SSL_CTRL_GET_CLIENT_CERT_TYPES, @as(c_int, 0), @import("std").zig.c_translation.cast([*c]u8, clist));
}
pub inline fn SSL_CTX_set1_client_certificate_types(ctx: anytype, clist: anytype, clistlen: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_CERT_TYPES, clistlen, @import("std").zig.c_translation.cast([*c]u8, clist))) {
    _ = &ctx;
    _ = &clist;
    _ = &clistlen;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_CLIENT_CERT_TYPES, clistlen, @import("std").zig.c_translation.cast([*c]u8, clist));
}
pub inline fn SSL_set1_client_certificate_types(s: anytype, clist: anytype, clistlen: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_CLIENT_CERT_TYPES, clistlen, @import("std").zig.c_translation.cast([*c]u8, clist))) {
    _ = &s;
    _ = &clist;
    _ = &clistlen;
    return SSL_ctrl(s, SSL_CTRL_SET_CLIENT_CERT_TYPES, clistlen, @import("std").zig.c_translation.cast([*c]u8, clist));
}
pub inline fn SSL_get_signature_nid(s: anytype, pn: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_SIGNATURE_NID, @as(c_int, 0), pn)) {
    _ = &s;
    _ = &pn;
    return SSL_ctrl(s, SSL_CTRL_GET_SIGNATURE_NID, @as(c_int, 0), pn);
}
pub inline fn SSL_get_peer_signature_nid(s: anytype, pn: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_PEER_SIGNATURE_NID, @as(c_int, 0), pn)) {
    _ = &s;
    _ = &pn;
    return SSL_ctrl(s, SSL_CTRL_GET_PEER_SIGNATURE_NID, @as(c_int, 0), pn);
}
pub inline fn SSL_get_peer_tmp_key(s: anytype, pk: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_PEER_TMP_KEY, @as(c_int, 0), pk)) {
    _ = &s;
    _ = &pk;
    return SSL_ctrl(s, SSL_CTRL_GET_PEER_TMP_KEY, @as(c_int, 0), pk);
}
pub inline fn SSL_get_tmp_key(s: anytype, pk: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_TMP_KEY, @as(c_int, 0), pk)) {
    _ = &s;
    _ = &pk;
    return SSL_ctrl(s, SSL_CTRL_GET_TMP_KEY, @as(c_int, 0), pk);
}
pub inline fn SSL_get0_raw_cipherlist(s: anytype, plst: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_RAW_CIPHERLIST, @as(c_int, 0), plst)) {
    _ = &s;
    _ = &plst;
    return SSL_ctrl(s, SSL_CTRL_GET_RAW_CIPHERLIST, @as(c_int, 0), plst);
}
pub inline fn SSL_get0_ec_point_formats(s: anytype, plst: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_EC_POINT_FORMATS, @as(c_int, 0), plst)) {
    _ = &s;
    _ = &plst;
    return SSL_ctrl(s, SSL_CTRL_GET_EC_POINT_FORMATS, @as(c_int, 0), plst);
}
pub inline fn SSL_CTX_set_min_proto_version(ctx: anytype, version: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL)) {
    _ = &ctx;
    _ = &version;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL);
}
pub inline fn SSL_CTX_set_max_proto_version(ctx: anytype, version: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL)) {
    _ = &ctx;
    _ = &version;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL);
}
pub inline fn SSL_CTX_get_min_proto_version(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MIN_PROTO_VERSION, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MIN_PROTO_VERSION, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_get_max_proto_version(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MAX_PROTO_VERSION, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MAX_PROTO_VERSION, @as(c_int, 0), NULL);
}
pub inline fn SSL_set_min_proto_version(s: anytype, version: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL)) {
    _ = &s;
    _ = &version;
    return SSL_ctrl(s, SSL_CTRL_SET_MIN_PROTO_VERSION, version, NULL);
}
pub inline fn SSL_set_max_proto_version(s: anytype, version: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL)) {
    _ = &s;
    _ = &version;
    return SSL_ctrl(s, SSL_CTRL_SET_MAX_PROTO_VERSION, version, NULL);
}
pub inline fn SSL_get_min_proto_version(s: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_MIN_PROTO_VERSION, @as(c_int, 0), NULL)) {
    _ = &s;
    return SSL_ctrl(s, SSL_CTRL_GET_MIN_PROTO_VERSION, @as(c_int, 0), NULL);
}
pub inline fn SSL_get_max_proto_version(s: anytype) @TypeOf(SSL_ctrl(s, SSL_CTRL_GET_MAX_PROTO_VERSION, @as(c_int, 0), NULL)) {
    _ = &s;
    return SSL_ctrl(s, SSL_CTRL_GET_MAX_PROTO_VERSION, @as(c_int, 0), NULL);
}
pub const SSL_CTRL_GET_SERVER_TMP_KEY = SSL_CTRL_GET_PEER_TMP_KEY;
pub inline fn SSL_get_server_tmp_key(s: anytype, pk: anytype) @TypeOf(SSL_get_peer_tmp_key(s, pk)) {
    _ = &s;
    _ = &pk;
    return SSL_get_peer_tmp_key(s, pk);
}
pub const SSL_CTRL_GET_CURVES = SSL_CTRL_GET_GROUPS;
pub const SSL_CTRL_SET_CURVES = SSL_CTRL_SET_GROUPS;
pub const SSL_CTRL_SET_CURVES_LIST = SSL_CTRL_SET_GROUPS_LIST;
pub const SSL_CTRL_GET_SHARED_CURVE = SSL_CTRL_GET_SHARED_GROUP;
pub const SSL_get1_curves = SSL_get1_groups;
pub const SSL_CTX_set1_curves = SSL_CTX_set1_groups;
pub const SSL_CTX_set1_curves_list = SSL_CTX_set1_groups_list;
pub const SSL_set1_curves = SSL_set1_groups;
pub const SSL_set1_curves_list = SSL_set1_groups_list;
pub const SSL_get_shared_curve = SSL_get_shared_group;
pub inline fn SSL_CTX_need_tmp_RSA(ctx: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &ctx;
    return @as(c_int, 0);
}
pub inline fn SSL_CTX_set_tmp_rsa(ctx: anytype, rsa: anytype) @TypeOf(@as(c_int, 1)) {
    _ = &ctx;
    _ = &rsa;
    return @as(c_int, 1);
}
pub inline fn SSL_need_tmp_RSA(ssl: anytype) @TypeOf(@as(c_int, 0)) {
    _ = &ssl;
    return @as(c_int, 0);
}
pub inline fn SSL_set_tmp_rsa(ssl: anytype, rsa: anytype) @TypeOf(@as(c_int, 1)) {
    _ = &ssl;
    _ = &rsa;
    return @as(c_int, 1);
}
pub inline fn SSL_CTX_set_ecdh_auto(dummy: anytype, onoff: anytype) @TypeOf(onoff != @as(c_int, 0)) {
    _ = &dummy;
    _ = &onoff;
    return onoff != @as(c_int, 0);
}
pub inline fn SSL_set_ecdh_auto(dummy: anytype, onoff: anytype) @TypeOf(onoff != @as(c_int, 0)) {
    _ = &dummy;
    _ = &onoff;
    return onoff != @as(c_int, 0);
}
pub const SSL_CTX_set_tmp_rsa_callback = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/ssl.h:1595:11
pub const SSL_set_tmp_rsa_callback = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/ssl.h:1596:11
pub const SSL_SERVERINFOV1 = @as(c_int, 1);
pub const SSL_SERVERINFOV2 = @as(c_int, 2);
pub inline fn SSL_load_error_strings() @TypeOf(OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL)) {
    return OPENSSL_init_ssl(OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
}
pub const SSL_get_peer_certificate = SSL_get1_peer_certificate;
pub const SSL_CLIENT_HELLO_SUCCESS = @as(c_int, 1);
pub const SSL_CLIENT_HELLO_ERROR = @as(c_int, 0);
pub const SSL_CLIENT_HELLO_RETRY = -@as(c_int, 1);
pub const SSL_READ_EARLY_DATA_ERROR = @as(c_int, 0);
pub const SSL_READ_EARLY_DATA_SUCCESS = @as(c_int, 1);
pub const SSL_READ_EARLY_DATA_FINISH = @as(c_int, 2);
pub const SSL_WRITE_FLAG_CONCLUDE = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_EARLY_DATA_NOT_SENT = @as(c_int, 0);
pub const SSL_EARLY_DATA_REJECTED = @as(c_int, 1);
pub const SSL_EARLY_DATA_ACCEPTED = @as(c_int, 2);
pub const SSLv23_method = TLS_method;
pub const SSLv23_server_method = TLS_server_method;
pub const SSLv23_client_method = TLS_client_method;
pub inline fn SSL_library_init() @TypeOf(OPENSSL_init_ssl(@as(c_int, 0), NULL)) {
    return OPENSSL_init_ssl(@as(c_int, 0), NULL);
}
pub const SSL_get0_session = SSL_get_session;
pub inline fn SSL_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, l, p, newf, dupf, freef);
}
pub inline fn SSL_SESSION_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_SESSION, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_SESSION, l, p, newf, dupf, freef);
}
pub inline fn SSL_CTX_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL_CTX, l, p, newf, dupf, freef);
}
pub inline fn SSL_CTX_sess_set_cache_size(ctx: anytype, t: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_SIZE, t, NULL)) {
    _ = &ctx;
    _ = &t;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_SIZE, t, NULL);
}
pub inline fn SSL_CTX_sess_get_cache_size(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_SESS_CACHE_SIZE, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_SESS_CACHE_SIZE, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set_session_cache_mode(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_MODE, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SESS_CACHE_MODE, m, NULL);
}
pub inline fn SSL_CTX_get_session_cache_mode(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_SESS_CACHE_MODE, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_SESS_CACHE_MODE, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_get_default_read_ahead(ctx: anytype) @TypeOf(SSL_CTX_get_read_ahead(ctx)) {
    _ = &ctx;
    return SSL_CTX_get_read_ahead(ctx);
}
pub inline fn SSL_CTX_set_default_read_ahead(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_set_read_ahead(ctx, m)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_set_read_ahead(ctx, m);
}
pub inline fn SSL_CTX_get_read_ahead(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_READ_AHEAD, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_READ_AHEAD, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set_read_ahead(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_READ_AHEAD, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_READ_AHEAD, m, NULL);
}
pub inline fn SSL_CTX_get_max_cert_list(ctx: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MAX_CERT_LIST, @as(c_int, 0), NULL)) {
    _ = &ctx;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_GET_MAX_CERT_LIST, @as(c_int, 0), NULL);
}
pub inline fn SSL_CTX_set_max_cert_list(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_CERT_LIST, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_CERT_LIST, m, NULL);
}
pub inline fn SSL_get_max_cert_list(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_GET_MAX_CERT_LIST, @as(c_int, 0), NULL)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_GET_MAX_CERT_LIST, @as(c_int, 0), NULL);
}
pub inline fn SSL_set_max_cert_list(ssl: anytype, m: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_MAX_CERT_LIST, m, NULL)) {
    _ = &ssl;
    _ = &m;
    return SSL_ctrl(ssl, SSL_CTRL_SET_MAX_CERT_LIST, m, NULL);
}
pub inline fn SSL_CTX_set_max_send_fragment(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_SEND_FRAGMENT, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_SEND_FRAGMENT, m, NULL);
}
pub inline fn SSL_set_max_send_fragment(ssl: anytype, m: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_MAX_SEND_FRAGMENT, m, NULL)) {
    _ = &ssl;
    _ = &m;
    return SSL_ctrl(ssl, SSL_CTRL_SET_MAX_SEND_FRAGMENT, m, NULL);
}
pub inline fn SSL_CTX_set_split_send_fragment(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SPLIT_SEND_FRAGMENT, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_SPLIT_SEND_FRAGMENT, m, NULL);
}
pub inline fn SSL_set_split_send_fragment(ssl: anytype, m: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_SPLIT_SEND_FRAGMENT, m, NULL)) {
    _ = &ssl;
    _ = &m;
    return SSL_ctrl(ssl, SSL_CTRL_SET_SPLIT_SEND_FRAGMENT, m, NULL);
}
pub inline fn SSL_CTX_set_max_pipelines(ctx: anytype, m: anytype) @TypeOf(SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PIPELINES, m, NULL)) {
    _ = &ctx;
    _ = &m;
    return SSL_CTX_ctrl(ctx, SSL_CTRL_SET_MAX_PIPELINES, m, NULL);
}
pub inline fn SSL_set_max_pipelines(ssl: anytype, m: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_MAX_PIPELINES, m, NULL)) {
    _ = &ssl;
    _ = &m;
    return SSL_ctrl(ssl, SSL_CTRL_SET_MAX_PIPELINES, m, NULL);
}
pub inline fn SSL_set_retry_verify(ssl: anytype) @TypeOf(SSL_ctrl(ssl, SSL_CTRL_SET_RETRY_VERIFY, @as(c_int, 0), NULL) > @as(c_int, 0)) {
    _ = &ssl;
    return SSL_ctrl(ssl, SSL_CTRL_SET_RETRY_VERIFY, @as(c_int, 0), NULL) > @as(c_int, 0);
}
pub const SSL_COMP_free_compression_methods = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/ssl.h:2275:11
pub const SSL_STREAM_TYPE_NONE = @as(c_int, 0);
pub const SSL_STREAM_TYPE_READ = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_STREAM_TYPE_WRITE = @as(c_uint, 1) << @as(c_int, 1);
pub const SSL_STREAM_TYPE_BIDI = SSL_STREAM_TYPE_READ | SSL_STREAM_TYPE_WRITE;
pub const SSL_DEFAULT_STREAM_MODE_NONE = @as(c_int, 0);
pub const SSL_DEFAULT_STREAM_MODE_AUTO_BIDI = @as(c_int, 1);
pub const SSL_DEFAULT_STREAM_MODE_AUTO_UNI = @as(c_int, 2);
pub const SSL_STREAM_FLAG_UNI = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_STREAM_FLAG_NO_BLOCK = @as(c_uint, 1) << @as(c_int, 1);
pub const SSL_STREAM_FLAG_ADVANCE = @as(c_uint, 1) << @as(c_int, 2);
pub const SSL_INCOMING_STREAM_POLICY_AUTO = @as(c_int, 0);
pub const SSL_INCOMING_STREAM_POLICY_ACCEPT = @as(c_int, 1);
pub const SSL_INCOMING_STREAM_POLICY_REJECT = @as(c_int, 2);
pub const SSL_ACCEPT_STREAM_NO_BLOCK = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_SHUTDOWN_FLAG_RAPID = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_SHUTDOWN_FLAG_NO_STREAM_FLUSH = @as(c_uint, 1) << @as(c_int, 1);
pub const SSL_SHUTDOWN_FLAG_NO_BLOCK = @as(c_uint, 1) << @as(c_int, 2);
pub const SSL_SHUTDOWN_FLAG_WAIT_PEER = @as(c_uint, 1) << @as(c_int, 3);
pub const SSL_STREAM_STATE_NONE = @as(c_int, 0);
pub const SSL_STREAM_STATE_OK = @as(c_int, 1);
pub const SSL_STREAM_STATE_WRONG_DIR = @as(c_int, 2);
pub const SSL_STREAM_STATE_FINISHED = @as(c_int, 3);
pub const SSL_STREAM_STATE_RESET_LOCAL = @as(c_int, 4);
pub const SSL_STREAM_STATE_RESET_REMOTE = @as(c_int, 5);
pub const SSL_STREAM_STATE_CONN_CLOSED = @as(c_int, 6);
pub const SSL_CONN_CLOSE_FLAG_LOCAL = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_CONN_CLOSE_FLAG_TRANSPORT = @as(c_uint, 1) << @as(c_int, 1);
pub const SSL_VALUE_CLASS_GENERIC = @as(c_int, 0);
pub const SSL_VALUE_CLASS_FEATURE_REQUEST = @as(c_int, 1);
pub const SSL_VALUE_CLASS_FEATURE_PEER_REQUEST = @as(c_int, 2);
pub const SSL_VALUE_CLASS_FEATURE_NEGOTIATED = @as(c_int, 3);
pub const SSL_VALUE_NONE = @as(c_int, 0);
pub const SSL_VALUE_QUIC_STREAM_BIDI_LOCAL_AVAIL = @as(c_int, 1);
pub const SSL_VALUE_QUIC_STREAM_BIDI_REMOTE_AVAIL = @as(c_int, 2);
pub const SSL_VALUE_QUIC_STREAM_UNI_LOCAL_AVAIL = @as(c_int, 3);
pub const SSL_VALUE_QUIC_STREAM_UNI_REMOTE_AVAIL = @as(c_int, 4);
pub const SSL_VALUE_QUIC_IDLE_TIMEOUT = @as(c_int, 5);
pub const SSL_VALUE_EVENT_HANDLING_MODE = @as(c_int, 6);
pub const SSL_VALUE_STREAM_WRITE_BUF_SIZE = @as(c_int, 7);
pub const SSL_VALUE_STREAM_WRITE_BUF_USED = @as(c_int, 8);
pub const SSL_VALUE_STREAM_WRITE_BUF_AVAIL = @as(c_int, 9);
pub const SSL_VALUE_EVENT_HANDLING_MODE_INHERIT = @as(c_int, 0);
pub const SSL_VALUE_EVENT_HANDLING_MODE_IMPLICIT = @as(c_int, 1);
pub const SSL_VALUE_EVENT_HANDLING_MODE_EXPLICIT = @as(c_int, 2);
pub inline fn SSL_get_generic_value_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_get_value_uint(ssl, SSL_VALUE_CLASS_GENERIC, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_get_value_uint(ssl, SSL_VALUE_CLASS_GENERIC, id, v);
}
pub inline fn SSL_set_generic_value_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_set_value_uint(ssl, SSL_VALUE_CLASS_GENERIC, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_set_value_uint(ssl, SSL_VALUE_CLASS_GENERIC, id, v);
}
pub inline fn SSL_get_feature_request_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_REQUEST, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_REQUEST, id, v);
}
pub inline fn SSL_set_feature_request_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_set_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_REQUEST, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_set_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_REQUEST, id, v);
}
pub inline fn SSL_get_feature_peer_request_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_PEER_REQUEST, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_PEER_REQUEST, id, v);
}
pub inline fn SSL_get_feature_negotiated_uint(ssl: anytype, id: anytype, v: anytype) @TypeOf(SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_NEGOTIATED, id, v)) {
    _ = &ssl;
    _ = &id;
    _ = &v;
    return SSL_get_value_uint(ssl, SSL_VALUE_CLASS_FEATURE_NEGOTIATED, id, v);
}
pub inline fn SSL_get_quic_stream_bidi_local_avail(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_BIDI_LOCAL_AVAIL, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_BIDI_LOCAL_AVAIL, value);
}
pub inline fn SSL_get_quic_stream_bidi_remote_avail(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_BIDI_REMOTE_AVAIL, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_BIDI_REMOTE_AVAIL, value);
}
pub inline fn SSL_get_quic_stream_uni_local_avail(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_UNI_LOCAL_AVAIL, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_UNI_LOCAL_AVAIL, value);
}
pub inline fn SSL_get_quic_stream_uni_remote_avail(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_UNI_REMOTE_AVAIL, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_QUIC_STREAM_UNI_REMOTE_AVAIL, value);
}
pub inline fn SSL_get_event_handling_mode(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_EVENT_HANDLING_MODE, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_EVENT_HANDLING_MODE, value);
}
pub inline fn SSL_set_event_handling_mode(ssl: anytype, value: anytype) @TypeOf(SSL_set_generic_value_uint(ssl, SSL_VALUE_EVENT_HANDLING_MODE, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_set_generic_value_uint(ssl, SSL_VALUE_EVENT_HANDLING_MODE, value);
}
pub inline fn SSL_get_stream_write_buf_size(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_SIZE, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_SIZE, value);
}
pub inline fn SSL_get_stream_write_buf_used(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_USED, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_USED, value);
}
pub inline fn SSL_get_stream_write_buf_avail(ssl: anytype, value: anytype) @TypeOf(SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_AVAIL, value)) {
    _ = &ssl;
    _ = &value;
    return SSL_get_generic_value_uint(ssl, SSL_VALUE_STREAM_WRITE_BUF_AVAIL, value);
}
pub const SSL_POLL_EVENT_NONE = @as(c_int, 0);
pub const SSL_POLL_EVENT_F = @as(c_uint, 1) << @as(c_int, 0);
pub const SSL_POLL_EVENT_EL = @as(c_uint, 1) << @as(c_int, 1);
pub const SSL_POLL_EVENT_EC = @as(c_uint, 1) << @as(c_int, 2);
pub const SSL_POLL_EVENT_ECD = @as(c_uint, 1) << @as(c_int, 3);
pub const SSL_POLL_EVENT_ER = @as(c_uint, 1) << @as(c_int, 4);
pub const SSL_POLL_EVENT_EW = @as(c_uint, 1) << @as(c_int, 5);
pub const SSL_POLL_EVENT_R = @as(c_uint, 1) << @as(c_int, 6);
pub const SSL_POLL_EVENT_W = @as(c_uint, 1) << @as(c_int, 7);
pub const SSL_POLL_EVENT_IC = @as(c_uint, 1) << @as(c_int, 8);
pub const SSL_POLL_EVENT_ISB = @as(c_uint, 1) << @as(c_int, 9);
pub const SSL_POLL_EVENT_ISU = @as(c_uint, 1) << @as(c_int, 10);
pub const SSL_POLL_EVENT_OSB = @as(c_uint, 1) << @as(c_int, 11);
pub const SSL_POLL_EVENT_OSU = @as(c_uint, 1) << @as(c_int, 12);
pub const SSL_POLL_EVENT_RW = SSL_POLL_EVENT_R | SSL_POLL_EVENT_W;
pub const SSL_POLL_EVENT_RE = SSL_POLL_EVENT_R | SSL_POLL_EVENT_ER;
pub const SSL_POLL_EVENT_WE = SSL_POLL_EVENT_W | SSL_POLL_EVENT_EW;
pub const SSL_POLL_EVENT_RWE = SSL_POLL_EVENT_RE | SSL_POLL_EVENT_WE;
pub const SSL_POLL_EVENT_E = ((SSL_POLL_EVENT_EL | SSL_POLL_EVENT_EC) | SSL_POLL_EVENT_ER) | SSL_POLL_EVENT_EW;
pub const SSL_POLL_EVENT_IS = SSL_POLL_EVENT_ISB | SSL_POLL_EVENT_ISU;
pub const SSL_POLL_EVENT_ISE = SSL_POLL_EVENT_IS | SSL_POLL_EVENT_EC;
pub const SSL_POLL_EVENT_I = SSL_POLL_EVENT_IS | SSL_POLL_EVENT_IC;
pub const SSL_POLL_EVENT_OS = SSL_POLL_EVENT_OSB | SSL_POLL_EVENT_OSU;
pub const SSL_POLL_EVENT_OSE = SSL_POLL_EVENT_OS | SSL_POLL_EVENT_EC;
pub const SSL_POLL_FLAG_NO_HANDLE_EVENTS = @as(c_uint, 1) << @as(c_int, 0);
pub inline fn SSL_cache_hit(s: anytype) @TypeOf(SSL_session_reused(s)) {
    _ = &s;
    return SSL_session_reused(s);
}
pub const SSL_disable_ct = @compileError("unable to translate macro: undefined identifier `SSL_set_validation_callback`");
// /usr/include/openssl/ssl.h:2609:9
pub const SSL_CTX_disable_ct = @compileError("unable to translate macro: undefined identifier `SSL_CTX_set_validation_callback`");
// /usr/include/openssl/ssl.h:2611:9
pub const SSL_SECOP_OTHER_TYPE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xffff0000, .hex);
pub const SSL_SECOP_OTHER_NONE = @as(c_int, 0);
pub const SSL_SECOP_OTHER_CIPHER = @as(c_int, 1) << @as(c_int, 16);
pub const SSL_SECOP_OTHER_CURVE = @as(c_int, 2) << @as(c_int, 16);
pub const SSL_SECOP_OTHER_DH = @as(c_int, 3) << @as(c_int, 16);
pub const SSL_SECOP_OTHER_PKEY = @as(c_int, 4) << @as(c_int, 16);
pub const SSL_SECOP_OTHER_SIGALG = @as(c_int, 5) << @as(c_int, 16);
pub const SSL_SECOP_OTHER_CERT = @as(c_int, 6) << @as(c_int, 16);
pub const SSL_SECOP_PEER = @as(c_int, 0x1000);
pub const SSL_SECOP_CIPHER_SUPPORTED = @as(c_int, 1) | SSL_SECOP_OTHER_CIPHER;
pub const SSL_SECOP_CIPHER_SHARED = @as(c_int, 2) | SSL_SECOP_OTHER_CIPHER;
pub const SSL_SECOP_CIPHER_CHECK = @as(c_int, 3) | SSL_SECOP_OTHER_CIPHER;
pub const SSL_SECOP_CURVE_SUPPORTED = @as(c_int, 4) | SSL_SECOP_OTHER_CURVE;
pub const SSL_SECOP_CURVE_SHARED = @as(c_int, 5) | SSL_SECOP_OTHER_CURVE;
pub const SSL_SECOP_CURVE_CHECK = @as(c_int, 6) | SSL_SECOP_OTHER_CURVE;
pub const SSL_SECOP_TMP_DH = @as(c_int, 7) | SSL_SECOP_OTHER_PKEY;
pub const SSL_SECOP_VERSION = @as(c_int, 9) | SSL_SECOP_OTHER_NONE;
pub const SSL_SECOP_TICKET = @as(c_int, 10) | SSL_SECOP_OTHER_NONE;
pub const SSL_SECOP_SIGALG_SUPPORTED = @as(c_int, 11) | SSL_SECOP_OTHER_SIGALG;
pub const SSL_SECOP_SIGALG_SHARED = @as(c_int, 12) | SSL_SECOP_OTHER_SIGALG;
pub const SSL_SECOP_SIGALG_CHECK = @as(c_int, 13) | SSL_SECOP_OTHER_SIGALG;
pub const SSL_SECOP_SIGALG_MASK = @as(c_int, 14) | SSL_SECOP_OTHER_SIGALG;
pub const SSL_SECOP_COMPRESSION = @as(c_int, 15) | SSL_SECOP_OTHER_NONE;
pub const SSL_SECOP_EE_KEY = @as(c_int, 16) | SSL_SECOP_OTHER_CERT;
pub const SSL_SECOP_CA_KEY = @as(c_int, 17) | SSL_SECOP_OTHER_CERT;
pub const SSL_SECOP_CA_MD = @as(c_int, 18) | SSL_SECOP_OTHER_CERT;
pub const SSL_SECOP_PEER_EE_KEY = SSL_SECOP_EE_KEY | SSL_SECOP_PEER;
pub const SSL_SECOP_PEER_CA_KEY = SSL_SECOP_CA_KEY | SSL_SECOP_PEER;
pub const SSL_SECOP_PEER_CA_MD = SSL_SECOP_CA_MD | SSL_SECOP_PEER;
pub const OPENSSL_INIT_NO_LOAD_SSL_STRINGS = @as(c_long, 0x00100000);
pub const OPENSSL_INIT_LOAD_SSL_STRINGS = @as(c_long, 0x00200000);
pub const OPENSSL_INIT_SSL_DEFAULT = OPENSSL_INIT_LOAD_SSL_STRINGS | OPENSSL_INIT_LOAD_CRYPTO_STRINGS;
pub const SSL_TICKET_FATAL_ERR_MALLOC = @as(c_int, 0);
pub const SSL_TICKET_FATAL_ERR_OTHER = @as(c_int, 1);
pub const SSL_TICKET_NONE = @as(c_int, 2);
pub const SSL_TICKET_EMPTY = @as(c_int, 3);
pub const SSL_TICKET_NO_DECRYPT = @as(c_int, 4);
pub const SSL_TICKET_SUCCESS = @as(c_int, 5);
pub const SSL_TICKET_SUCCESS_RENEW = @as(c_int, 6);
pub const SSL_TICKET_RETURN_ABORT = @as(c_int, 0);
pub const SSL_TICKET_RETURN_IGNORE = @as(c_int, 1);
pub const SSL_TICKET_RETURN_IGNORE_RENEW = @as(c_int, 2);
pub const SSL_TICKET_RETURN_USE = @as(c_int, 3);
pub const SSL_TICKET_RETURN_USE_RENEW = @as(c_int, 4);
pub const OPENSSL_ERR_H = "";
pub const HEADER_ERR_H = "";
pub inline fn ERR_PUT_error(l: anytype, f: anytype, r: anytype, @"fn": anytype, ln: anytype) @TypeOf(ERR_put_error(l, f, r, @"fn", ln)) {
    _ = &l;
    _ = &f;
    _ = &r;
    _ = &@"fn";
    _ = &ln;
    return ERR_put_error(l, f, r, @"fn", ln);
}
pub const ERR_TXT_MALLOCED = @as(c_int, 0x01);
pub const ERR_TXT_STRING = @as(c_int, 0x02);
pub const ERR_FLAG_MARK = @as(c_int, 0x01);
pub const ERR_FLAG_CLEAR = @as(c_int, 0x02);
pub const ERR_NUM_ERRORS = @as(c_int, 16);
pub const ERR_LIB_NONE = @as(c_int, 1);
pub const ERR_LIB_SYS = @as(c_int, 2);
pub const ERR_LIB_BN = @as(c_int, 3);
pub const ERR_LIB_RSA = @as(c_int, 4);
pub const ERR_LIB_DH = @as(c_int, 5);
pub const ERR_LIB_EVP = @as(c_int, 6);
pub const ERR_LIB_BUF = @as(c_int, 7);
pub const ERR_LIB_OBJ = @as(c_int, 8);
pub const ERR_LIB_PEM = @as(c_int, 9);
pub const ERR_LIB_DSA = @as(c_int, 10);
pub const ERR_LIB_X509 = @as(c_int, 11);
pub const ERR_LIB_ASN1 = @as(c_int, 13);
pub const ERR_LIB_CONF = @as(c_int, 14);
pub const ERR_LIB_CRYPTO = @as(c_int, 15);
pub const ERR_LIB_EC = @as(c_int, 16);
pub const ERR_LIB_SSL = @as(c_int, 20);
pub const ERR_LIB_BIO = @as(c_int, 32);
pub const ERR_LIB_PKCS7 = @as(c_int, 33);
pub const ERR_LIB_X509V3 = @as(c_int, 34);
pub const ERR_LIB_PKCS12 = @as(c_int, 35);
pub const ERR_LIB_RAND = @as(c_int, 36);
pub const ERR_LIB_DSO = @as(c_int, 37);
pub const ERR_LIB_ENGINE = @as(c_int, 38);
pub const ERR_LIB_OCSP = @as(c_int, 39);
pub const ERR_LIB_UI = @as(c_int, 40);
pub const ERR_LIB_COMP = @as(c_int, 41);
pub const ERR_LIB_ECDSA = @as(c_int, 42);
pub const ERR_LIB_ECDH = @as(c_int, 43);
pub const ERR_LIB_OSSL_STORE = @as(c_int, 44);
pub const ERR_LIB_FIPS = @as(c_int, 45);
pub const ERR_LIB_CMS = @as(c_int, 46);
pub const ERR_LIB_TS = @as(c_int, 47);
pub const ERR_LIB_HMAC = @as(c_int, 48);
pub const ERR_LIB_CT = @as(c_int, 50);
pub const ERR_LIB_ASYNC = @as(c_int, 51);
pub const ERR_LIB_KDF = @as(c_int, 52);
pub const ERR_LIB_SM2 = @as(c_int, 53);
pub const ERR_LIB_ESS = @as(c_int, 54);
pub const ERR_LIB_PROP = @as(c_int, 55);
pub const ERR_LIB_CRMF = @as(c_int, 56);
pub const ERR_LIB_PROV = @as(c_int, 57);
pub const ERR_LIB_CMP = @as(c_int, 58);
pub const ERR_LIB_OSSL_ENCODER = @as(c_int, 59);
pub const ERR_LIB_OSSL_DECODER = @as(c_int, 60);
pub const ERR_LIB_HTTP = @as(c_int, 61);
pub const ERR_LIB_USER = @as(c_int, 128);
pub inline fn ASN1err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ASN1, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ASN1, r, NULL);
}
pub inline fn ASYNCerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ASYNC, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ASYNC, r, NULL);
}
pub inline fn BIOerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_BIO, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_BIO, r, NULL);
}
pub inline fn BNerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_BN, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_BN, r, NULL);
}
pub inline fn BUFerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_BUF, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_BUF, r, NULL);
}
pub inline fn CMPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CMP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CMP, r, NULL);
}
pub inline fn CMSerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CMS, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CMS, r, NULL);
}
pub inline fn COMPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_COMP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_COMP, r, NULL);
}
pub inline fn CONFerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CONF, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CONF, r, NULL);
}
pub inline fn CRMFerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CRMF, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CRMF, r, NULL);
}
pub inline fn CRYPTOerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CRYPTO, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CRYPTO, r, NULL);
}
pub inline fn CTerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_CT, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_CT, r, NULL);
}
pub inline fn DHerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_DH, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_DH, r, NULL);
}
pub inline fn DSAerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_DSA, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_DSA, r, NULL);
}
pub inline fn DSOerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_DSO, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_DSO, r, NULL);
}
pub inline fn ECDHerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ECDH, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ECDH, r, NULL);
}
pub inline fn ECDSAerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ECDSA, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ECDSA, r, NULL);
}
pub inline fn ECerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_EC, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_EC, r, NULL);
}
pub inline fn ENGINEerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ENGINE, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ENGINE, r, NULL);
}
pub inline fn ESSerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_ESS, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_ESS, r, NULL);
}
pub inline fn EVPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_EVP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_EVP, r, NULL);
}
pub inline fn FIPSerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_FIPS, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_FIPS, r, NULL);
}
pub inline fn HMACerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_HMAC, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_HMAC, r, NULL);
}
pub inline fn HTTPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_HTTP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_HTTP, r, NULL);
}
pub inline fn KDFerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_KDF, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_KDF, r, NULL);
}
pub inline fn OBJerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_OBJ, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_OBJ, r, NULL);
}
pub inline fn OCSPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_OCSP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_OCSP, r, NULL);
}
pub inline fn OSSL_STOREerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_OSSL_STORE, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_OSSL_STORE, r, NULL);
}
pub inline fn PEMerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_PEM, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_PEM, r, NULL);
}
pub inline fn PKCS12err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_PKCS12, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_PKCS12, r, NULL);
}
pub inline fn PKCS7err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_PKCS7, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_PKCS7, r, NULL);
}
pub inline fn PROPerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_PROP, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_PROP, r, NULL);
}
pub inline fn PROVerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_PROV, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_PROV, r, NULL);
}
pub inline fn RANDerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_RAND, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_RAND, r, NULL);
}
pub inline fn RSAerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_RSA, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_RSA, r, NULL);
}
pub inline fn SM2err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_SM2, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_SM2, r, NULL);
}
pub inline fn SSLerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_SSL, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_SSL, r, NULL);
}
pub inline fn SYSerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_SYS, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_SYS, r, NULL);
}
pub inline fn TSerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_TS, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_TS, r, NULL);
}
pub inline fn UIerr(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_UI, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_UI, r, NULL);
}
pub inline fn X509V3err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_X509V3, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_X509V3, r, NULL);
}
pub inline fn X509err(f: anytype, r: anytype) @TypeOf(ERR_raise_data(ERR_LIB_X509, r, NULL)) {
    _ = &f;
    _ = &r;
    return ERR_raise_data(ERR_LIB_X509, r, NULL);
}
pub const ERR_SYSTEM_FLAG = @import("std").zig.c_translation.cast(c_uint, INT_MAX) + @as(c_int, 1);
pub const ERR_SYSTEM_MASK = @import("std").zig.c_translation.cast(c_uint, INT_MAX);
pub const ERR_LIB_OFFSET = @as(c_long, 23);
pub const ERR_LIB_MASK = @as(c_int, 0xFF);
pub const ERR_RFLAGS_OFFSET = @as(c_long, 18);
pub const ERR_RFLAGS_MASK = @as(c_int, 0x1F);
pub const ERR_REASON_MASK = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x7FFFFF, .hex);
pub const ERR_RFLAG_FATAL = @as(c_int, 0x1) << ERR_RFLAGS_OFFSET;
pub const ERR_RFLAG_COMMON = @as(c_int, 0x2) << ERR_RFLAGS_OFFSET;
pub inline fn ERR_SYSTEM_ERROR(errcode: anytype) @TypeOf((errcode & ERR_SYSTEM_FLAG) != @as(c_int, 0)) {
    _ = &errcode;
    return (errcode & ERR_SYSTEM_FLAG) != @as(c_int, 0);
}
pub inline fn ERR_PACK(lib: anytype, func: anytype, reason: anytype) @TypeOf(((@import("std").zig.c_translation.cast(c_ulong, lib) & ERR_LIB_MASK) << ERR_LIB_OFFSET) | (@import("std").zig.c_translation.cast(c_ulong, reason) & ERR_REASON_MASK)) {
    _ = &lib;
    _ = &func;
    _ = &reason;
    return ((@import("std").zig.c_translation.cast(c_ulong, lib) & ERR_LIB_MASK) << ERR_LIB_OFFSET) | (@import("std").zig.c_translation.cast(c_ulong, reason) & ERR_REASON_MASK);
}
pub const SYS_F_FOPEN = @as(c_int, 0);
pub const SYS_F_CONNECT = @as(c_int, 0);
pub const SYS_F_GETSERVBYNAME = @as(c_int, 0);
pub const SYS_F_SOCKET = @as(c_int, 0);
pub const SYS_F_IOCTLSOCKET = @as(c_int, 0);
pub const SYS_F_BIND = @as(c_int, 0);
pub const SYS_F_LISTEN = @as(c_int, 0);
pub const SYS_F_ACCEPT = @as(c_int, 0);
pub const SYS_F_WSASTARTUP = @as(c_int, 0);
pub const SYS_F_OPENDIR = @as(c_int, 0);
pub const SYS_F_FREAD = @as(c_int, 0);
pub const SYS_F_GETADDRINFO = @as(c_int, 0);
pub const SYS_F_GETNAMEINFO = @as(c_int, 0);
pub const SYS_F_SETSOCKOPT = @as(c_int, 0);
pub const SYS_F_GETSOCKOPT = @as(c_int, 0);
pub const SYS_F_GETSOCKNAME = @as(c_int, 0);
pub const SYS_F_GETHOSTBYNAME = @as(c_int, 0);
pub const SYS_F_FFLUSH = @as(c_int, 0);
pub const SYS_F_OPEN = @as(c_int, 0);
pub const SYS_F_CLOSE = @as(c_int, 0);
pub const SYS_F_IOCTL = @as(c_int, 0);
pub const SYS_F_STAT = @as(c_int, 0);
pub const SYS_F_FCNTL = @as(c_int, 0);
pub const SYS_F_FSTAT = @as(c_int, 0);
pub const SYS_F_SENDFILE = @as(c_int, 0);
pub const ERR_R_SYS_LIB = ERR_LIB_SYS | ERR_RFLAG_COMMON;
pub const ERR_R_BN_LIB = ERR_LIB_BN | ERR_RFLAG_COMMON;
pub const ERR_R_RSA_LIB = ERR_LIB_RSA | ERR_RFLAG_COMMON;
pub const ERR_R_DH_LIB = ERR_LIB_DH | ERR_RFLAG_COMMON;
pub const ERR_R_EVP_LIB = ERR_LIB_EVP | ERR_RFLAG_COMMON;
pub const ERR_R_BUF_LIB = ERR_LIB_BUF | ERR_RFLAG_COMMON;
pub const ERR_R_OBJ_LIB = ERR_LIB_OBJ | ERR_RFLAG_COMMON;
pub const ERR_R_PEM_LIB = ERR_LIB_PEM | ERR_RFLAG_COMMON;
pub const ERR_R_DSA_LIB = ERR_LIB_DSA | ERR_RFLAG_COMMON;
pub const ERR_R_X509_LIB = ERR_LIB_X509 | ERR_RFLAG_COMMON;
pub const ERR_R_ASN1_LIB = ERR_LIB_ASN1 | ERR_RFLAG_COMMON;
pub const ERR_R_CONF_LIB = ERR_LIB_CONF | ERR_RFLAG_COMMON;
pub const ERR_R_CRYPTO_LIB = ERR_LIB_CRYPTO | ERR_RFLAG_COMMON;
pub const ERR_R_EC_LIB = ERR_LIB_EC | ERR_RFLAG_COMMON;
pub const ERR_R_SSL_LIB = ERR_LIB_SSL | ERR_RFLAG_COMMON;
pub const ERR_R_BIO_LIB = ERR_LIB_BIO | ERR_RFLAG_COMMON;
pub const ERR_R_PKCS7_LIB = ERR_LIB_PKCS7 | ERR_RFLAG_COMMON;
pub const ERR_R_X509V3_LIB = ERR_LIB_X509V3 | ERR_RFLAG_COMMON;
pub const ERR_R_PKCS12_LIB = ERR_LIB_PKCS12 | ERR_RFLAG_COMMON;
pub const ERR_R_RAND_LIB = ERR_LIB_RAND | ERR_RFLAG_COMMON;
pub const ERR_R_DSO_LIB = ERR_LIB_DSO | ERR_RFLAG_COMMON;
pub const ERR_R_ENGINE_LIB = ERR_LIB_ENGINE | ERR_RFLAG_COMMON;
pub const ERR_R_UI_LIB = ERR_LIB_UI | ERR_RFLAG_COMMON;
pub const ERR_R_ECDSA_LIB = ERR_LIB_ECDSA | ERR_RFLAG_COMMON;
pub const ERR_R_OSSL_STORE_LIB = ERR_LIB_OSSL_STORE | ERR_RFLAG_COMMON;
pub const ERR_R_CMS_LIB = ERR_LIB_CMS | ERR_RFLAG_COMMON;
pub const ERR_R_TS_LIB = ERR_LIB_TS | ERR_RFLAG_COMMON;
pub const ERR_R_CT_LIB = ERR_LIB_CT | ERR_RFLAG_COMMON;
pub const ERR_R_PROV_LIB = ERR_LIB_PROV | ERR_RFLAG_COMMON;
pub const ERR_R_ESS_LIB = ERR_LIB_ESS | ERR_RFLAG_COMMON;
pub const ERR_R_CMP_LIB = ERR_LIB_CMP | ERR_RFLAG_COMMON;
pub const ERR_R_OSSL_ENCODER_LIB = ERR_LIB_OSSL_ENCODER | ERR_RFLAG_COMMON;
pub const ERR_R_OSSL_DECODER_LIB = ERR_LIB_OSSL_DECODER | ERR_RFLAG_COMMON;
pub const ERR_R_FATAL = ERR_RFLAG_FATAL | ERR_RFLAG_COMMON;
pub const ERR_R_MALLOC_FAILURE = @as(c_int, 256) | ERR_R_FATAL;
pub const ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED = @as(c_int, 257) | ERR_R_FATAL;
pub const ERR_R_PASSED_NULL_PARAMETER = @as(c_int, 258) | ERR_R_FATAL;
pub const ERR_R_INTERNAL_ERROR = @as(c_int, 259) | ERR_R_FATAL;
pub const ERR_R_DISABLED = @as(c_int, 260) | ERR_R_FATAL;
pub const ERR_R_INIT_FAIL = @as(c_int, 261) | ERR_R_FATAL;
pub const ERR_R_PASSED_INVALID_ARGUMENT = @as(c_int, 262) | ERR_RFLAG_COMMON;
pub const ERR_R_OPERATION_FAIL = @as(c_int, 263) | ERR_R_FATAL;
pub const ERR_R_INVALID_PROVIDER_FUNCTIONS = @as(c_int, 264) | ERR_R_FATAL;
pub const ERR_R_INTERRUPTED_OR_CANCELLED = @as(c_int, 265) | ERR_RFLAG_COMMON;
pub const ERR_R_NESTED_ASN1_ERROR = @as(c_int, 266) | ERR_RFLAG_COMMON;
pub const ERR_R_MISSING_ASN1_EOS = @as(c_int, 267) | ERR_RFLAG_COMMON;
pub const ERR_R_UNSUPPORTED = @as(c_int, 268) | ERR_RFLAG_COMMON;
pub const ERR_R_FETCH_FAILED = @as(c_int, 269) | ERR_RFLAG_COMMON;
pub const ERR_R_INVALID_PROPERTY_DEFINITION = @as(c_int, 270) | ERR_RFLAG_COMMON;
pub const ERR_R_UNABLE_TO_GET_READ_LOCK = @as(c_int, 271) | ERR_R_FATAL;
pub const ERR_R_UNABLE_TO_GET_WRITE_LOCK = @as(c_int, 272) | ERR_R_FATAL;
pub const lh_ERR_STRING_DATA_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/err.h:375:9
pub inline fn lh_ERR_STRING_DATA_free(lh: anytype) @TypeOf(OPENSSL_LH_free(ossl_check_ERR_STRING_DATA_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_free(ossl_check_ERR_STRING_DATA_lh_type(lh));
}
pub inline fn lh_ERR_STRING_DATA_flush(lh: anytype) @TypeOf(OPENSSL_LH_flush(ossl_check_ERR_STRING_DATA_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_flush(ossl_check_ERR_STRING_DATA_lh_type(lh));
}
pub inline fn lh_ERR_STRING_DATA_insert(lh: anytype, ptr: anytype) [*c]ERR_STRING_DATA {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ERR_STRING_DATA, OPENSSL_LH_insert(ossl_check_ERR_STRING_DATA_lh_type(lh), ossl_check_ERR_STRING_DATA_lh_plain_type(ptr)));
}
pub inline fn lh_ERR_STRING_DATA_delete(lh: anytype, ptr: anytype) [*c]ERR_STRING_DATA {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ERR_STRING_DATA, OPENSSL_LH_delete(ossl_check_ERR_STRING_DATA_lh_type(lh), ossl_check_const_ERR_STRING_DATA_lh_plain_type(ptr)));
}
pub inline fn lh_ERR_STRING_DATA_retrieve(lh: anytype, ptr: anytype) [*c]ERR_STRING_DATA {
    _ = &lh;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ERR_STRING_DATA, OPENSSL_LH_retrieve(ossl_check_ERR_STRING_DATA_lh_type(lh), ossl_check_const_ERR_STRING_DATA_lh_plain_type(ptr)));
}
pub inline fn lh_ERR_STRING_DATA_error(lh: anytype) @TypeOf(OPENSSL_LH_error(ossl_check_ERR_STRING_DATA_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_error(ossl_check_ERR_STRING_DATA_lh_type(lh));
}
pub inline fn lh_ERR_STRING_DATA_num_items(lh: anytype) @TypeOf(OPENSSL_LH_num_items(ossl_check_ERR_STRING_DATA_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_num_items(ossl_check_ERR_STRING_DATA_lh_type(lh));
}
pub inline fn lh_ERR_STRING_DATA_node_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out);
}
pub inline fn lh_ERR_STRING_DATA_node_usage_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_node_usage_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_node_usage_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out);
}
pub inline fn lh_ERR_STRING_DATA_stats_bio(lh: anytype, out: anytype) @TypeOf(OPENSSL_LH_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out)) {
    _ = &lh;
    _ = &out;
    return OPENSSL_LH_stats_bio(ossl_check_const_ERR_STRING_DATA_lh_type(lh), out);
}
pub inline fn lh_ERR_STRING_DATA_get_down_load(lh: anytype) @TypeOf(OPENSSL_LH_get_down_load(ossl_check_ERR_STRING_DATA_lh_type(lh))) {
    _ = &lh;
    return OPENSSL_LH_get_down_load(ossl_check_ERR_STRING_DATA_lh_type(lh));
}
pub inline fn lh_ERR_STRING_DATA_set_down_load(lh: anytype, dl: anytype) @TypeOf(OPENSSL_LH_set_down_load(ossl_check_ERR_STRING_DATA_lh_type(lh), dl)) {
    _ = &lh;
    _ = &dl;
    return OPENSSL_LH_set_down_load(ossl_check_ERR_STRING_DATA_lh_type(lh), dl);
}
pub inline fn lh_ERR_STRING_DATA_doall(lh: anytype, dfn: anytype) @TypeOf(OPENSSL_LH_doall(ossl_check_ERR_STRING_DATA_lh_type(lh), ossl_check_ERR_STRING_DATA_lh_doallfunc_type(dfn))) {
    _ = &lh;
    _ = &dfn;
    return OPENSSL_LH_doall(ossl_check_ERR_STRING_DATA_lh_type(lh), ossl_check_ERR_STRING_DATA_lh_doallfunc_type(dfn));
}
pub const ERR_MAX_DATA_SIZE = @as(c_int, 1024);
pub inline fn ERR_raise(lib: anytype, reason: anytype) @TypeOf(ERR_raise_data(lib, reason, NULL)) {
    _ = &lib;
    _ = &reason;
    return ERR_raise_data(lib, reason, NULL);
}
pub const ERR_raise_data = blk_1: {
    _ = ERR_new();
    _ = ERR_set_debug(OPENSSL_FILE, OPENSSL_LINE, OPENSSL_FUNC);
    break :blk_1 ERR_set_error;
};
pub const ERR_put_error = @compileError("unable to translate C expr: expected ')' instead got 'line'");
// /usr/include/openssl/err.h:409:11
pub inline fn ERR_load_crypto_strings() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CRYPTO_STRINGS, NULL);
}
pub const ERR_free_strings = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/err.h:482:10
pub const OPENSSL_ENGINE_H = "";
pub const HEADER_ENGINE_H = "";
pub const OPENSSL_RAND_H = "";
pub const HEADER_RAND_H = "";
pub const OPENSSL_RANDERR_H = "";
pub const RAND_R_ADDITIONAL_INPUT_TOO_LONG = @as(c_int, 102);
pub const RAND_R_ALREADY_INSTANTIATED = @as(c_int, 103);
pub const RAND_R_ARGUMENT_OUT_OF_RANGE = @as(c_int, 105);
pub const RAND_R_CANNOT_OPEN_FILE = @as(c_int, 121);
pub const RAND_R_DRBG_ALREADY_INITIALIZED = @as(c_int, 129);
pub const RAND_R_DRBG_NOT_INITIALISED = @as(c_int, 104);
pub const RAND_R_ENTROPY_INPUT_TOO_LONG = @as(c_int, 106);
pub const RAND_R_ENTROPY_OUT_OF_RANGE = @as(c_int, 124);
pub const RAND_R_ERROR_ENTROPY_POOL_WAS_IGNORED = @as(c_int, 127);
pub const RAND_R_ERROR_INITIALISING_DRBG = @as(c_int, 107);
pub const RAND_R_ERROR_INSTANTIATING_DRBG = @as(c_int, 108);
pub const RAND_R_ERROR_RETRIEVING_ADDITIONAL_INPUT = @as(c_int, 109);
pub const RAND_R_ERROR_RETRIEVING_ENTROPY = @as(c_int, 110);
pub const RAND_R_ERROR_RETRIEVING_NONCE = @as(c_int, 111);
pub const RAND_R_FAILED_TO_CREATE_LOCK = @as(c_int, 126);
pub const RAND_R_FUNC_NOT_IMPLEMENTED = @as(c_int, 101);
pub const RAND_R_FWRITE_ERROR = @as(c_int, 123);
pub const RAND_R_GENERATE_ERROR = @as(c_int, 112);
pub const RAND_R_INSUFFICIENT_DRBG_STRENGTH = @as(c_int, 139);
pub const RAND_R_INTERNAL_ERROR = @as(c_int, 113);
pub const RAND_R_INVALID_PROPERTY_QUERY = @as(c_int, 137);
pub const RAND_R_IN_ERROR_STATE = @as(c_int, 114);
pub const RAND_R_NOT_A_REGULAR_FILE = @as(c_int, 122);
pub const RAND_R_NOT_INSTANTIATED = @as(c_int, 115);
pub const RAND_R_NO_DRBG_IMPLEMENTATION_SELECTED = @as(c_int, 128);
pub const RAND_R_PARENT_LOCKING_NOT_ENABLED = @as(c_int, 130);
pub const RAND_R_PARENT_STRENGTH_TOO_WEAK = @as(c_int, 131);
pub const RAND_R_PERSONALISATION_STRING_TOO_LONG = @as(c_int, 116);
pub const RAND_R_PREDICTION_RESISTANCE_NOT_SUPPORTED = @as(c_int, 133);
pub const RAND_R_PRNG_NOT_SEEDED = @as(c_int, 100);
pub const RAND_R_RANDOM_POOL_OVERFLOW = @as(c_int, 125);
pub const RAND_R_RANDOM_POOL_UNDERFLOW = @as(c_int, 134);
pub const RAND_R_REQUEST_TOO_LARGE_FOR_DRBG = @as(c_int, 117);
pub const RAND_R_RESEED_ERROR = @as(c_int, 118);
pub const RAND_R_SELFTEST_FAILURE = @as(c_int, 119);
pub const RAND_R_TOO_LITTLE_NONCE_REQUESTED = @as(c_int, 135);
pub const RAND_R_TOO_MUCH_NONCE_REQUESTED = @as(c_int, 136);
pub const RAND_R_UNABLE_TO_CREATE_DRBG = @as(c_int, 143);
pub const RAND_R_UNABLE_TO_FETCH_DRBG = @as(c_int, 144);
pub const RAND_R_UNABLE_TO_GET_PARENT_RESEED_PROP_COUNTER = @as(c_int, 141);
pub const RAND_R_UNABLE_TO_GET_PARENT_STRENGTH = @as(c_int, 138);
pub const RAND_R_UNABLE_TO_LOCK_PARENT = @as(c_int, 140);
pub const RAND_R_UNSUPPORTED_DRBG_FLAGS = @as(c_int, 132);
pub const RAND_R_UNSUPPORTED_DRBG_TYPE = @as(c_int, 120);
pub const RAND_DRBG_STRENGTH = @as(c_int, 256);
pub const RAND_cleanup = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/rand.h:59:12
pub const OPENSSL_UI_H = "";
pub const HEADER_UI_H = "";
pub const OPENSSL_UIERR_H = "";
pub const UI_R_COMMON_OK_AND_CANCEL_CHARACTERS = @as(c_int, 104);
pub const UI_R_INDEX_TOO_LARGE = @as(c_int, 102);
pub const UI_R_INDEX_TOO_SMALL = @as(c_int, 103);
pub const UI_R_NO_RESULT_BUFFER = @as(c_int, 105);
pub const UI_R_PROCESSING_ERROR = @as(c_int, 107);
pub const UI_R_RESULT_TOO_LARGE = @as(c_int, 100);
pub const UI_R_RESULT_TOO_SMALL = @as(c_int, 101);
pub const UI_R_SYSASSIGN_ERROR = @as(c_int, 109);
pub const UI_R_SYSDASSGN_ERROR = @as(c_int, 110);
pub const UI_R_SYSQIOW_ERROR = @as(c_int, 111);
pub const UI_R_UNKNOWN_CONTROL_COMMAND = @as(c_int, 106);
pub const UI_R_UNKNOWN_TTYGET_ERRNO_VALUE = @as(c_int, 108);
pub const UI_R_USER_DATA_DUPLICATION_UNSUPPORTED = @as(c_int, 112);
pub const UI_INPUT_FLAG_ECHO = @as(c_int, 0x01);
pub const UI_INPUT_FLAG_DEFAULT_PWD = @as(c_int, 0x02);
pub const UI_INPUT_FLAG_USER_BASE = @as(c_int, 16);
pub const UI_CTRL_PRINT_ERRORS = @as(c_int, 1);
pub const UI_CTRL_IS_REDOABLE = @as(c_int, 2);
pub inline fn UI_set_app_data(s: anytype, arg: anytype) @TypeOf(UI_set_ex_data(s, @as(c_int, 0), arg)) {
    _ = &s;
    _ = &arg;
    return UI_set_ex_data(s, @as(c_int, 0), arg);
}
pub inline fn UI_get_app_data(s: anytype) @TypeOf(UI_get_ex_data(s, @as(c_int, 0))) {
    _ = &s;
    return UI_get_ex_data(s, @as(c_int, 0));
}
pub inline fn UI_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_UI, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_UI, l, p, newf, dupf, freef);
}
pub inline fn sk_UI_STRING_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_UI_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_UI_STRING_sk_type(sk));
}
pub inline fn sk_UI_STRING_value(sk: anytype, idx: anytype) [*c]UI_STRING {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]UI_STRING, OPENSSL_sk_value(ossl_check_const_UI_STRING_sk_type(sk), idx));
}
pub const sk_UI_STRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ui.h:296:9
pub const sk_UI_STRING_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ui.h:297:9
pub const sk_UI_STRING_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ui.h:298:9
pub inline fn sk_UI_STRING_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_UI_STRING_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_UI_STRING_sk_type(sk), n);
}
pub inline fn sk_UI_STRING_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_UI_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_UI_STRING_sk_type(sk));
}
pub inline fn sk_UI_STRING_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_UI_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_UI_STRING_sk_type(sk));
}
pub inline fn sk_UI_STRING_delete(sk: anytype, i: anytype) [*c]UI_STRING {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]UI_STRING, OPENSSL_sk_delete(ossl_check_UI_STRING_sk_type(sk), i));
}
pub inline fn sk_UI_STRING_delete_ptr(sk: anytype, ptr: anytype) [*c]UI_STRING {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]UI_STRING, OPENSSL_sk_delete_ptr(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr)));
}
pub inline fn sk_UI_STRING_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr));
}
pub inline fn sk_UI_STRING_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr));
}
pub inline fn sk_UI_STRING_pop(sk: anytype) [*c]UI_STRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]UI_STRING, OPENSSL_sk_pop(ossl_check_UI_STRING_sk_type(sk)));
}
pub inline fn sk_UI_STRING_shift(sk: anytype) [*c]UI_STRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]UI_STRING, OPENSSL_sk_shift(ossl_check_UI_STRING_sk_type(sk)));
}
pub inline fn sk_UI_STRING_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_freefunc_type(freefunc));
}
pub inline fn sk_UI_STRING_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr), idx);
}
pub inline fn sk_UI_STRING_set(sk: anytype, idx: anytype, ptr: anytype) [*c]UI_STRING {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]UI_STRING, OPENSSL_sk_set(ossl_check_UI_STRING_sk_type(sk), idx, ossl_check_UI_STRING_type(ptr)));
}
pub inline fn sk_UI_STRING_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr));
}
pub inline fn sk_UI_STRING_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr));
}
pub inline fn sk_UI_STRING_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_type(ptr), pnum);
}
pub inline fn sk_UI_STRING_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_UI_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_UI_STRING_sk_type(sk));
}
pub inline fn sk_UI_STRING_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_UI_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_UI_STRING_sk_type(sk));
}
pub const sk_UI_STRING_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ui.h:316:9
pub const sk_UI_STRING_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ui.h:317:9
pub inline fn sk_UI_STRING_set_cmp_func(sk: anytype, cmp: anytype) sk_UI_STRING_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_UI_STRING_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_UI_STRING_sk_type(sk), ossl_check_UI_STRING_compfunc_type(cmp)));
}
pub const OPENSSL_ENGINEERR_H = "";
pub const ENGINE_R_ALREADY_LOADED = @as(c_int, 100);
pub const ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER = @as(c_int, 133);
pub const ENGINE_R_CMD_NOT_EXECUTABLE = @as(c_int, 134);
pub const ENGINE_R_COMMAND_TAKES_INPUT = @as(c_int, 135);
pub const ENGINE_R_COMMAND_TAKES_NO_INPUT = @as(c_int, 136);
pub const ENGINE_R_CONFLICTING_ENGINE_ID = @as(c_int, 103);
pub const ENGINE_R_CTRL_COMMAND_NOT_IMPLEMENTED = @as(c_int, 119);
pub const ENGINE_R_DSO_FAILURE = @as(c_int, 104);
pub const ENGINE_R_DSO_NOT_FOUND = @as(c_int, 132);
pub const ENGINE_R_ENGINES_SECTION_ERROR = @as(c_int, 148);
pub const ENGINE_R_ENGINE_CONFIGURATION_ERROR = @as(c_int, 102);
pub const ENGINE_R_ENGINE_IS_NOT_IN_LIST = @as(c_int, 105);
pub const ENGINE_R_ENGINE_SECTION_ERROR = @as(c_int, 149);
pub const ENGINE_R_FAILED_LOADING_PRIVATE_KEY = @as(c_int, 128);
pub const ENGINE_R_FAILED_LOADING_PUBLIC_KEY = @as(c_int, 129);
pub const ENGINE_R_FINISH_FAILED = @as(c_int, 106);
pub const ENGINE_R_ID_OR_NAME_MISSING = @as(c_int, 108);
pub const ENGINE_R_INIT_FAILED = @as(c_int, 109);
pub const ENGINE_R_INTERNAL_LIST_ERROR = @as(c_int, 110);
pub const ENGINE_R_INVALID_ARGUMENT = @as(c_int, 143);
pub const ENGINE_R_INVALID_CMD_NAME = @as(c_int, 137);
pub const ENGINE_R_INVALID_CMD_NUMBER = @as(c_int, 138);
pub const ENGINE_R_INVALID_INIT_VALUE = @as(c_int, 151);
pub const ENGINE_R_INVALID_STRING = @as(c_int, 150);
pub const ENGINE_R_NOT_INITIALISED = @as(c_int, 117);
pub const ENGINE_R_NOT_LOADED = @as(c_int, 112);
pub const ENGINE_R_NO_CONTROL_FUNCTION = @as(c_int, 120);
pub const ENGINE_R_NO_INDEX = @as(c_int, 144);
pub const ENGINE_R_NO_LOAD_FUNCTION = @as(c_int, 125);
pub const ENGINE_R_NO_REFERENCE = @as(c_int, 130);
pub const ENGINE_R_NO_SUCH_ENGINE = @as(c_int, 116);
pub const ENGINE_R_UNIMPLEMENTED_CIPHER = @as(c_int, 146);
pub const ENGINE_R_UNIMPLEMENTED_DIGEST = @as(c_int, 147);
pub const ENGINE_R_UNIMPLEMENTED_PUBLIC_KEY_METHOD = @as(c_int, 101);
pub const ENGINE_R_VERSION_INCOMPATIBILITY = @as(c_int, 145);
pub const ENGINE_METHOD_RSA = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0001));
pub const ENGINE_METHOD_DSA = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0002));
pub const ENGINE_METHOD_DH = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0004));
pub const ENGINE_METHOD_RAND = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0008));
pub const ENGINE_METHOD_CIPHERS = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0040));
pub const ENGINE_METHOD_DIGESTS = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0080));
pub const ENGINE_METHOD_PKEY_METHS = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0200));
pub const ENGINE_METHOD_PKEY_ASN1_METHS = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0400));
pub const ENGINE_METHOD_EC = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0800));
pub const ENGINE_METHOD_ALL = @import("std").zig.c_translation.cast(c_uint, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFFFF, .hex));
pub const ENGINE_METHOD_NONE = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0000));
pub const ENGINE_TABLE_FLAG_NOINIT = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0001));
pub const ENGINE_FLAGS_MANUAL_CMD_CTRL = @import("std").zig.c_translation.cast(c_int, @as(c_int, 0x0002));
pub const ENGINE_FLAGS_BY_ID_COPY = @import("std").zig.c_translation.cast(c_int, @as(c_int, 0x0004));
pub const ENGINE_FLAGS_NO_REGISTER_ALL = @import("std").zig.c_translation.cast(c_int, @as(c_int, 0x0008));
pub const ENGINE_CMD_FLAG_NUMERIC = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0001));
pub const ENGINE_CMD_FLAG_STRING = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0002));
pub const ENGINE_CMD_FLAG_NO_INPUT = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0004));
pub const ENGINE_CMD_FLAG_INTERNAL = @import("std").zig.c_translation.cast(c_uint, @as(c_int, 0x0008));
pub const ENGINE_CTRL_SET_LOGSTREAM = @as(c_int, 1);
pub const ENGINE_CTRL_SET_PASSWORD_CALLBACK = @as(c_int, 2);
pub const ENGINE_CTRL_HUP = @as(c_int, 3);
pub const ENGINE_CTRL_SET_USER_INTERFACE = @as(c_int, 4);
pub const ENGINE_CTRL_SET_CALLBACK_DATA = @as(c_int, 5);
pub const ENGINE_CTRL_LOAD_CONFIGURATION = @as(c_int, 6);
pub const ENGINE_CTRL_LOAD_SECTION = @as(c_int, 7);
pub const ENGINE_CTRL_HAS_CTRL_FUNCTION = @as(c_int, 10);
pub const ENGINE_CTRL_GET_FIRST_CMD_TYPE = @as(c_int, 11);
pub const ENGINE_CTRL_GET_NEXT_CMD_TYPE = @as(c_int, 12);
pub const ENGINE_CTRL_GET_CMD_FROM_NAME = @as(c_int, 13);
pub const ENGINE_CTRL_GET_NAME_LEN_FROM_CMD = @as(c_int, 14);
pub const ENGINE_CTRL_GET_NAME_FROM_CMD = @as(c_int, 15);
pub const ENGINE_CTRL_GET_DESC_LEN_FROM_CMD = @as(c_int, 16);
pub const ENGINE_CTRL_GET_DESC_FROM_CMD = @as(c_int, 17);
pub const ENGINE_CTRL_GET_CMD_FLAGS = @as(c_int, 18);
pub const ENGINE_CMD_BASE = @as(c_int, 200);
pub const ENGINE_CTRL_CHIL_SET_FORKCHECK = @as(c_int, 100);
pub const ENGINE_CTRL_CHIL_NO_LOCKING = @as(c_int, 101);
pub inline fn ENGINE_load_openssl() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_OPENSSL, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_OPENSSL, NULL);
}
pub inline fn ENGINE_load_dynamic() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_DYNAMIC, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_DYNAMIC, NULL);
}
pub inline fn ENGINE_load_cryptodev() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_CRYPTODEV, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_CRYPTODEV, NULL);
}
pub inline fn ENGINE_load_rdrand() @TypeOf(OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_RDRAND, NULL)) {
    return OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_RDRAND, NULL);
}
pub inline fn ENGINE_get_ex_new_index(l: anytype, p: anytype, newf: anytype, dupf: anytype, freef: anytype) @TypeOf(CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_ENGINE, l, p, newf, dupf, freef)) {
    _ = &l;
    _ = &p;
    _ = &newf;
    _ = &dupf;
    _ = &freef;
    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_ENGINE, l, p, newf, dupf, freef);
}
pub const ENGINE_cleanup = @compileError("unable to translate C expr: unexpected token 'while'");
// /usr/include/openssl/engine.h:542:12
pub const OSSL_DYNAMIC_VERSION = @import("std").zig.c_translation.cast(c_ulong, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00030000, .hex));
pub const OSSL_DYNAMIC_OLDEST = @import("std").zig.c_translation.cast(c_ulong, @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00030000, .hex));
pub const IMPLEMENT_DYNAMIC_CHECK_FN = @compileError("unable to translate macro: undefined identifier `v_check`");
// /usr/include/openssl/engine.h:769:11
pub const IMPLEMENT_DYNAMIC_BIND_FN = @compileError("unable to translate macro: undefined identifier `bind_engine`");
// /usr/include/openssl/engine.h:795:11
pub const OPENSSL_OCSP_H = "";
pub const HEADER_OCSP_H = "";
pub const OCSP_REVOKED_STATUS_NOSTATUS = -@as(c_int, 1);
pub const OCSP_REVOKED_STATUS_UNSPECIFIED = @as(c_int, 0);
pub const OCSP_REVOKED_STATUS_KEYCOMPROMISE = @as(c_int, 1);
pub const OCSP_REVOKED_STATUS_CACOMPROMISE = @as(c_int, 2);
pub const OCSP_REVOKED_STATUS_AFFILIATIONCHANGED = @as(c_int, 3);
pub const OCSP_REVOKED_STATUS_SUPERSEDED = @as(c_int, 4);
pub const OCSP_REVOKED_STATUS_CESSATIONOFOPERATION = @as(c_int, 5);
pub const OCSP_REVOKED_STATUS_CERTIFICATEHOLD = @as(c_int, 6);
pub const OCSP_REVOKED_STATUS_REMOVEFROMCRL = @as(c_int, 8);
pub const OCSP_REVOKED_STATUS_PRIVILEGEWITHDRAWN = @as(c_int, 9);
pub const OCSP_REVOKED_STATUS_AACOMPROMISE = @as(c_int, 10);
pub const OPENSSL_X509V3_H = "";
pub const HEADER_X509V3_H = "";
pub const OPENSSL_X509V3ERR_H = "";
pub const X509V3_R_BAD_IP_ADDRESS = @as(c_int, 118);
pub const X509V3_R_BAD_OBJECT = @as(c_int, 119);
pub const X509V3_R_BAD_OPTION = @as(c_int, 170);
pub const X509V3_R_BAD_VALUE = @as(c_int, 171);
pub const X509V3_R_BN_DEC2BN_ERROR = @as(c_int, 100);
pub const X509V3_R_BN_TO_ASN1_INTEGER_ERROR = @as(c_int, 101);
pub const X509V3_R_DIRNAME_ERROR = @as(c_int, 149);
pub const X509V3_R_DISTPOINT_ALREADY_SET = @as(c_int, 160);
pub const X509V3_R_DUPLICATE_ZONE_ID = @as(c_int, 133);
pub const X509V3_R_EMPTY_KEY_USAGE = @as(c_int, 169);
pub const X509V3_R_ERROR_CONVERTING_ZONE = @as(c_int, 131);
pub const X509V3_R_ERROR_CREATING_EXTENSION = @as(c_int, 144);
pub const X509V3_R_ERROR_IN_EXTENSION = @as(c_int, 128);
pub const X509V3_R_EXPECTED_A_SECTION_NAME = @as(c_int, 137);
pub const X509V3_R_EXTENSION_EXISTS = @as(c_int, 145);
pub const X509V3_R_EXTENSION_NAME_ERROR = @as(c_int, 115);
pub const X509V3_R_EXTENSION_NOT_FOUND = @as(c_int, 102);
pub const X509V3_R_EXTENSION_SETTING_NOT_SUPPORTED = @as(c_int, 103);
pub const X509V3_R_EXTENSION_VALUE_ERROR = @as(c_int, 116);
pub const X509V3_R_ILLEGAL_EMPTY_EXTENSION = @as(c_int, 151);
pub const X509V3_R_INCORRECT_POLICY_SYNTAX_TAG = @as(c_int, 152);
pub const X509V3_R_INVALID_ASNUMBER = @as(c_int, 162);
pub const X509V3_R_INVALID_ASRANGE = @as(c_int, 163);
pub const X509V3_R_INVALID_BOOLEAN_STRING = @as(c_int, 104);
pub const X509V3_R_INVALID_CERTIFICATE = @as(c_int, 158);
pub const X509V3_R_INVALID_EMPTY_NAME = @as(c_int, 108);
pub const X509V3_R_INVALID_EXTENSION_STRING = @as(c_int, 105);
pub const X509V3_R_INVALID_INHERITANCE = @as(c_int, 165);
pub const X509V3_R_INVALID_IPADDRESS = @as(c_int, 166);
pub const X509V3_R_INVALID_MULTIPLE_RDNS = @as(c_int, 161);
pub const X509V3_R_INVALID_NAME = @as(c_int, 106);
pub const X509V3_R_INVALID_NULL_ARGUMENT = @as(c_int, 107);
pub const X509V3_R_INVALID_NULL_VALUE = @as(c_int, 109);
pub const X509V3_R_INVALID_NUMBER = @as(c_int, 140);
pub const X509V3_R_INVALID_NUMBERS = @as(c_int, 141);
pub const X509V3_R_INVALID_OBJECT_IDENTIFIER = @as(c_int, 110);
pub const X509V3_R_INVALID_OPTION = @as(c_int, 138);
pub const X509V3_R_INVALID_POLICY_IDENTIFIER = @as(c_int, 134);
pub const X509V3_R_INVALID_PROXY_POLICY_SETTING = @as(c_int, 153);
pub const X509V3_R_INVALID_PURPOSE = @as(c_int, 146);
pub const X509V3_R_INVALID_SAFI = @as(c_int, 164);
pub const X509V3_R_INVALID_SECTION = @as(c_int, 135);
pub const X509V3_R_INVALID_SYNTAX = @as(c_int, 143);
pub const X509V3_R_ISSUER_DECODE_ERROR = @as(c_int, 126);
pub const X509V3_R_MISSING_VALUE = @as(c_int, 124);
pub const X509V3_R_NEED_ORGANIZATION_AND_NUMBERS = @as(c_int, 142);
pub const X509V3_R_NEGATIVE_PATHLEN = @as(c_int, 168);
pub const X509V3_R_NO_CONFIG_DATABASE = @as(c_int, 136);
pub const X509V3_R_NO_ISSUER_CERTIFICATE = @as(c_int, 121);
pub const X509V3_R_NO_ISSUER_DETAILS = @as(c_int, 127);
pub const X509V3_R_NO_POLICY_IDENTIFIER = @as(c_int, 139);
pub const X509V3_R_NO_PROXY_CERT_POLICY_LANGUAGE_DEFINED = @as(c_int, 154);
pub const X509V3_R_NO_PUBLIC_KEY = @as(c_int, 114);
pub const X509V3_R_NO_SUBJECT_DETAILS = @as(c_int, 125);
pub const X509V3_R_OPERATION_NOT_DEFINED = @as(c_int, 148);
pub const X509V3_R_OTHERNAME_ERROR = @as(c_int, 147);
pub const X509V3_R_POLICY_LANGUAGE_ALREADY_DEFINED = @as(c_int, 155);
pub const X509V3_R_POLICY_PATH_LENGTH = @as(c_int, 156);
pub const X509V3_R_POLICY_PATH_LENGTH_ALREADY_DEFINED = @as(c_int, 157);
pub const X509V3_R_POLICY_WHEN_PROXY_LANGUAGE_REQUIRES_NO_POLICY = @as(c_int, 159);
pub const X509V3_R_SECTION_NOT_FOUND = @as(c_int, 150);
pub const X509V3_R_UNABLE_TO_GET_ISSUER_DETAILS = @as(c_int, 122);
pub const X509V3_R_UNABLE_TO_GET_ISSUER_KEYID = @as(c_int, 123);
pub const X509V3_R_UNKNOWN_BIT_STRING_ARGUMENT = @as(c_int, 111);
pub const X509V3_R_UNKNOWN_EXTENSION = @as(c_int, 129);
pub const X509V3_R_UNKNOWN_EXTENSION_NAME = @as(c_int, 130);
pub const X509V3_R_UNKNOWN_OPTION = @as(c_int, 120);
pub const X509V3_R_UNKNOWN_VALUE = @as(c_int, 172);
pub const X509V3_R_UNSUPPORTED_OPTION = @as(c_int, 117);
pub const X509V3_R_UNSUPPORTED_TYPE = @as(c_int, 167);
pub const X509V3_R_USER_TOO_LONG = @as(c_int, 132);
pub const X509V3_CTX_TEST = @as(c_int, 0x1);
pub const CTX_TEST = X509V3_CTX_TEST;
pub const X509V3_CTX_REPLACE = @as(c_int, 0x2);
pub inline fn sk_X509V3_EXT_METHOD_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509V3_EXT_METHOD_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509V3_EXT_METHOD_sk_type(sk));
}
pub inline fn sk_X509V3_EXT_METHOD_value(sk: anytype, idx: anytype) [*c]X509V3_EXT_METHOD {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509V3_EXT_METHOD, OPENSSL_sk_value(ossl_check_const_X509V3_EXT_METHOD_sk_type(sk), idx));
}
pub const sk_X509V3_EXT_METHOD_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:115:9
pub const sk_X509V3_EXT_METHOD_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:116:9
pub const sk_X509V3_EXT_METHOD_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:117:9
pub inline fn sk_X509V3_EXT_METHOD_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509V3_EXT_METHOD_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509V3_EXT_METHOD_sk_type(sk), n);
}
pub inline fn sk_X509V3_EXT_METHOD_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509V3_EXT_METHOD_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509V3_EXT_METHOD_sk_type(sk));
}
pub inline fn sk_X509V3_EXT_METHOD_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509V3_EXT_METHOD_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509V3_EXT_METHOD_sk_type(sk));
}
pub inline fn sk_X509V3_EXT_METHOD_delete(sk: anytype, i: anytype) [*c]X509V3_EXT_METHOD {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509V3_EXT_METHOD, OPENSSL_sk_delete(ossl_check_X509V3_EXT_METHOD_sk_type(sk), i));
}
pub inline fn sk_X509V3_EXT_METHOD_delete_ptr(sk: anytype, ptr: anytype) [*c]X509V3_EXT_METHOD {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509V3_EXT_METHOD, OPENSSL_sk_delete_ptr(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr)));
}
pub inline fn sk_X509V3_EXT_METHOD_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr));
}
pub inline fn sk_X509V3_EXT_METHOD_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr));
}
pub inline fn sk_X509V3_EXT_METHOD_pop(sk: anytype) [*c]X509V3_EXT_METHOD {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509V3_EXT_METHOD, OPENSSL_sk_pop(ossl_check_X509V3_EXT_METHOD_sk_type(sk)));
}
pub inline fn sk_X509V3_EXT_METHOD_shift(sk: anytype) [*c]X509V3_EXT_METHOD {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509V3_EXT_METHOD, OPENSSL_sk_shift(ossl_check_X509V3_EXT_METHOD_sk_type(sk)));
}
pub inline fn sk_X509V3_EXT_METHOD_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_freefunc_type(freefunc));
}
pub inline fn sk_X509V3_EXT_METHOD_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr), idx);
}
pub inline fn sk_X509V3_EXT_METHOD_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509V3_EXT_METHOD {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509V3_EXT_METHOD, OPENSSL_sk_set(ossl_check_X509V3_EXT_METHOD_sk_type(sk), idx, ossl_check_X509V3_EXT_METHOD_type(ptr)));
}
pub inline fn sk_X509V3_EXT_METHOD_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr));
}
pub inline fn sk_X509V3_EXT_METHOD_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr));
}
pub inline fn sk_X509V3_EXT_METHOD_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_type(ptr), pnum);
}
pub inline fn sk_X509V3_EXT_METHOD_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509V3_EXT_METHOD_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509V3_EXT_METHOD_sk_type(sk));
}
pub inline fn sk_X509V3_EXT_METHOD_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509V3_EXT_METHOD_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509V3_EXT_METHOD_sk_type(sk));
}
pub const sk_X509V3_EXT_METHOD_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:135:9
pub const sk_X509V3_EXT_METHOD_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:136:9
pub inline fn sk_X509V3_EXT_METHOD_set_cmp_func(sk: anytype, cmp: anytype) sk_X509V3_EXT_METHOD_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509V3_EXT_METHOD_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509V3_EXT_METHOD_sk_type(sk), ossl_check_X509V3_EXT_METHOD_compfunc_type(cmp)));
}
pub const X509V3_EXT_DYNAMIC = @as(c_int, 0x1);
pub const X509V3_EXT_CTX_DEP = @as(c_int, 0x2);
pub const X509V3_EXT_MULTILINE = @as(c_int, 0x4);
pub const GEN_OTHERNAME = @as(c_int, 0);
pub const GEN_EMAIL = @as(c_int, 1);
pub const GEN_DNS = @as(c_int, 2);
pub const GEN_X400 = @as(c_int, 3);
pub const GEN_DIRNAME = @as(c_int, 4);
pub const GEN_EDIPARTY = @as(c_int, 5);
pub const GEN_URI = @as(c_int, 6);
pub const GEN_IPADD = @as(c_int, 7);
pub const GEN_RID = @as(c_int, 8);
pub inline fn sk_ACCESS_DESCRIPTION_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ACCESS_DESCRIPTION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ACCESS_DESCRIPTION_sk_type(sk));
}
pub inline fn sk_ACCESS_DESCRIPTION_value(sk: anytype, idx: anytype) [*c]ACCESS_DESCRIPTION {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ACCESS_DESCRIPTION, OPENSSL_sk_value(ossl_check_const_ACCESS_DESCRIPTION_sk_type(sk), idx));
}
pub const sk_ACCESS_DESCRIPTION_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:214:9
pub const sk_ACCESS_DESCRIPTION_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:215:9
pub const sk_ACCESS_DESCRIPTION_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:216:9
pub inline fn sk_ACCESS_DESCRIPTION_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), n);
}
pub inline fn sk_ACCESS_DESCRIPTION_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ACCESS_DESCRIPTION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ACCESS_DESCRIPTION_sk_type(sk));
}
pub inline fn sk_ACCESS_DESCRIPTION_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ACCESS_DESCRIPTION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ACCESS_DESCRIPTION_sk_type(sk));
}
pub inline fn sk_ACCESS_DESCRIPTION_delete(sk: anytype, i: anytype) [*c]ACCESS_DESCRIPTION {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ACCESS_DESCRIPTION, OPENSSL_sk_delete(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), i));
}
pub inline fn sk_ACCESS_DESCRIPTION_delete_ptr(sk: anytype, ptr: anytype) [*c]ACCESS_DESCRIPTION {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ACCESS_DESCRIPTION, OPENSSL_sk_delete_ptr(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr)));
}
pub inline fn sk_ACCESS_DESCRIPTION_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr));
}
pub inline fn sk_ACCESS_DESCRIPTION_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr));
}
pub inline fn sk_ACCESS_DESCRIPTION_pop(sk: anytype) [*c]ACCESS_DESCRIPTION {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ACCESS_DESCRIPTION, OPENSSL_sk_pop(ossl_check_ACCESS_DESCRIPTION_sk_type(sk)));
}
pub inline fn sk_ACCESS_DESCRIPTION_shift(sk: anytype) [*c]ACCESS_DESCRIPTION {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ACCESS_DESCRIPTION, OPENSSL_sk_shift(ossl_check_ACCESS_DESCRIPTION_sk_type(sk)));
}
pub inline fn sk_ACCESS_DESCRIPTION_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_freefunc_type(freefunc));
}
pub inline fn sk_ACCESS_DESCRIPTION_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr), idx);
}
pub inline fn sk_ACCESS_DESCRIPTION_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ACCESS_DESCRIPTION {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ACCESS_DESCRIPTION, OPENSSL_sk_set(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), idx, ossl_check_ACCESS_DESCRIPTION_type(ptr)));
}
pub inline fn sk_ACCESS_DESCRIPTION_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr));
}
pub inline fn sk_ACCESS_DESCRIPTION_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr));
}
pub inline fn sk_ACCESS_DESCRIPTION_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_type(ptr), pnum);
}
pub inline fn sk_ACCESS_DESCRIPTION_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ACCESS_DESCRIPTION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ACCESS_DESCRIPTION_sk_type(sk));
}
pub inline fn sk_ACCESS_DESCRIPTION_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ACCESS_DESCRIPTION_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ACCESS_DESCRIPTION_sk_type(sk));
}
pub const sk_ACCESS_DESCRIPTION_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:234:9
pub const sk_ACCESS_DESCRIPTION_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:235:9
pub inline fn sk_ACCESS_DESCRIPTION_set_cmp_func(sk: anytype, cmp: anytype) sk_ACCESS_DESCRIPTION_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ACCESS_DESCRIPTION_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ACCESS_DESCRIPTION_sk_type(sk), ossl_check_ACCESS_DESCRIPTION_compfunc_type(cmp)));
}
pub inline fn sk_GENERAL_NAME_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_GENERAL_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_GENERAL_NAME_sk_type(sk));
}
pub inline fn sk_GENERAL_NAME_value(sk: anytype, idx: anytype) [*c]GENERAL_NAME {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAME, OPENSSL_sk_value(ossl_check_const_GENERAL_NAME_sk_type(sk), idx));
}
pub const sk_GENERAL_NAME_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:240:9
pub const sk_GENERAL_NAME_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:241:9
pub const sk_GENERAL_NAME_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:242:9
pub inline fn sk_GENERAL_NAME_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_GENERAL_NAME_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_GENERAL_NAME_sk_type(sk), n);
}
pub inline fn sk_GENERAL_NAME_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_GENERAL_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_GENERAL_NAME_sk_type(sk));
}
pub inline fn sk_GENERAL_NAME_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_GENERAL_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_GENERAL_NAME_sk_type(sk));
}
pub inline fn sk_GENERAL_NAME_delete(sk: anytype, i: anytype) [*c]GENERAL_NAME {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAME, OPENSSL_sk_delete(ossl_check_GENERAL_NAME_sk_type(sk), i));
}
pub inline fn sk_GENERAL_NAME_delete_ptr(sk: anytype, ptr: anytype) [*c]GENERAL_NAME {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAME, OPENSSL_sk_delete_ptr(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr)));
}
pub inline fn sk_GENERAL_NAME_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr));
}
pub inline fn sk_GENERAL_NAME_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr));
}
pub inline fn sk_GENERAL_NAME_pop(sk: anytype) [*c]GENERAL_NAME {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAME, OPENSSL_sk_pop(ossl_check_GENERAL_NAME_sk_type(sk)));
}
pub inline fn sk_GENERAL_NAME_shift(sk: anytype) [*c]GENERAL_NAME {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAME, OPENSSL_sk_shift(ossl_check_GENERAL_NAME_sk_type(sk)));
}
pub inline fn sk_GENERAL_NAME_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_freefunc_type(freefunc));
}
pub inline fn sk_GENERAL_NAME_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr), idx);
}
pub inline fn sk_GENERAL_NAME_set(sk: anytype, idx: anytype, ptr: anytype) [*c]GENERAL_NAME {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAME, OPENSSL_sk_set(ossl_check_GENERAL_NAME_sk_type(sk), idx, ossl_check_GENERAL_NAME_type(ptr)));
}
pub inline fn sk_GENERAL_NAME_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr));
}
pub inline fn sk_GENERAL_NAME_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr));
}
pub inline fn sk_GENERAL_NAME_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_type(ptr), pnum);
}
pub inline fn sk_GENERAL_NAME_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_GENERAL_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_GENERAL_NAME_sk_type(sk));
}
pub inline fn sk_GENERAL_NAME_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_GENERAL_NAME_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_GENERAL_NAME_sk_type(sk));
}
pub const sk_GENERAL_NAME_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:260:9
pub const sk_GENERAL_NAME_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:261:9
pub inline fn sk_GENERAL_NAME_set_cmp_func(sk: anytype, cmp: anytype) sk_GENERAL_NAME_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_GENERAL_NAME_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_GENERAL_NAME_sk_type(sk), ossl_check_GENERAL_NAME_compfunc_type(cmp)));
}
pub inline fn sk_GENERAL_NAMES_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_GENERAL_NAMES_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_GENERAL_NAMES_sk_type(sk));
}
pub inline fn sk_GENERAL_NAMES_value(sk: anytype, idx: anytype) [*c]GENERAL_NAMES {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAMES, OPENSSL_sk_value(ossl_check_const_GENERAL_NAMES_sk_type(sk), idx));
}
pub const sk_GENERAL_NAMES_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:273:9
pub const sk_GENERAL_NAMES_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:274:9
pub const sk_GENERAL_NAMES_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:275:9
pub inline fn sk_GENERAL_NAMES_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_GENERAL_NAMES_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_GENERAL_NAMES_sk_type(sk), n);
}
pub inline fn sk_GENERAL_NAMES_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_GENERAL_NAMES_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_GENERAL_NAMES_sk_type(sk));
}
pub inline fn sk_GENERAL_NAMES_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_GENERAL_NAMES_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_GENERAL_NAMES_sk_type(sk));
}
pub inline fn sk_GENERAL_NAMES_delete(sk: anytype, i: anytype) [*c]GENERAL_NAMES {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAMES, OPENSSL_sk_delete(ossl_check_GENERAL_NAMES_sk_type(sk), i));
}
pub inline fn sk_GENERAL_NAMES_delete_ptr(sk: anytype, ptr: anytype) [*c]GENERAL_NAMES {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAMES, OPENSSL_sk_delete_ptr(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr)));
}
pub inline fn sk_GENERAL_NAMES_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr));
}
pub inline fn sk_GENERAL_NAMES_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr));
}
pub inline fn sk_GENERAL_NAMES_pop(sk: anytype) [*c]GENERAL_NAMES {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAMES, OPENSSL_sk_pop(ossl_check_GENERAL_NAMES_sk_type(sk)));
}
pub inline fn sk_GENERAL_NAMES_shift(sk: anytype) [*c]GENERAL_NAMES {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAMES, OPENSSL_sk_shift(ossl_check_GENERAL_NAMES_sk_type(sk)));
}
pub inline fn sk_GENERAL_NAMES_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_freefunc_type(freefunc));
}
pub inline fn sk_GENERAL_NAMES_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr), idx);
}
pub inline fn sk_GENERAL_NAMES_set(sk: anytype, idx: anytype, ptr: anytype) [*c]GENERAL_NAMES {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]GENERAL_NAMES, OPENSSL_sk_set(ossl_check_GENERAL_NAMES_sk_type(sk), idx, ossl_check_GENERAL_NAMES_type(ptr)));
}
pub inline fn sk_GENERAL_NAMES_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr));
}
pub inline fn sk_GENERAL_NAMES_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr));
}
pub inline fn sk_GENERAL_NAMES_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_type(ptr), pnum);
}
pub inline fn sk_GENERAL_NAMES_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_GENERAL_NAMES_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_GENERAL_NAMES_sk_type(sk));
}
pub inline fn sk_GENERAL_NAMES_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_GENERAL_NAMES_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_GENERAL_NAMES_sk_type(sk));
}
pub const sk_GENERAL_NAMES_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:293:9
pub const sk_GENERAL_NAMES_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:294:9
pub inline fn sk_GENERAL_NAMES_set_cmp_func(sk: anytype, cmp: anytype) sk_GENERAL_NAMES_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_GENERAL_NAMES_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_GENERAL_NAMES_sk_type(sk), ossl_check_GENERAL_NAMES_compfunc_type(cmp)));
}
pub const CRLDP_ALL_REASONS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x807f, .hex);
pub const CRL_REASON_NONE = -@as(c_int, 1);
pub const CRL_REASON_UNSPECIFIED = @as(c_int, 0);
pub const CRL_REASON_KEY_COMPROMISE = @as(c_int, 1);
pub const CRL_REASON_CA_COMPROMISE = @as(c_int, 2);
pub const CRL_REASON_AFFILIATION_CHANGED = @as(c_int, 3);
pub const CRL_REASON_SUPERSEDED = @as(c_int, 4);
pub const CRL_REASON_CESSATION_OF_OPERATION = @as(c_int, 5);
pub const CRL_REASON_CERTIFICATE_HOLD = @as(c_int, 6);
pub const CRL_REASON_REMOVE_FROM_CRL = @as(c_int, 8);
pub const CRL_REASON_PRIVILEGE_WITHDRAWN = @as(c_int, 9);
pub const CRL_REASON_AA_COMPROMISE = @as(c_int, 10);
pub inline fn sk_DIST_POINT_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_DIST_POINT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_DIST_POINT_sk_type(sk));
}
pub inline fn sk_DIST_POINT_value(sk: anytype, idx: anytype) [*c]DIST_POINT {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]DIST_POINT, OPENSSL_sk_value(ossl_check_const_DIST_POINT_sk_type(sk), idx));
}
pub const sk_DIST_POINT_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:333:9
pub const sk_DIST_POINT_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:334:9
pub const sk_DIST_POINT_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:335:9
pub inline fn sk_DIST_POINT_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_DIST_POINT_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_DIST_POINT_sk_type(sk), n);
}
pub inline fn sk_DIST_POINT_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_DIST_POINT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_DIST_POINT_sk_type(sk));
}
pub inline fn sk_DIST_POINT_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_DIST_POINT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_DIST_POINT_sk_type(sk));
}
pub inline fn sk_DIST_POINT_delete(sk: anytype, i: anytype) [*c]DIST_POINT {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]DIST_POINT, OPENSSL_sk_delete(ossl_check_DIST_POINT_sk_type(sk), i));
}
pub inline fn sk_DIST_POINT_delete_ptr(sk: anytype, ptr: anytype) [*c]DIST_POINT {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]DIST_POINT, OPENSSL_sk_delete_ptr(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr)));
}
pub inline fn sk_DIST_POINT_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr));
}
pub inline fn sk_DIST_POINT_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr));
}
pub inline fn sk_DIST_POINT_pop(sk: anytype) [*c]DIST_POINT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]DIST_POINT, OPENSSL_sk_pop(ossl_check_DIST_POINT_sk_type(sk)));
}
pub inline fn sk_DIST_POINT_shift(sk: anytype) [*c]DIST_POINT {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]DIST_POINT, OPENSSL_sk_shift(ossl_check_DIST_POINT_sk_type(sk)));
}
pub inline fn sk_DIST_POINT_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_freefunc_type(freefunc));
}
pub inline fn sk_DIST_POINT_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr), idx);
}
pub inline fn sk_DIST_POINT_set(sk: anytype, idx: anytype, ptr: anytype) [*c]DIST_POINT {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]DIST_POINT, OPENSSL_sk_set(ossl_check_DIST_POINT_sk_type(sk), idx, ossl_check_DIST_POINT_type(ptr)));
}
pub inline fn sk_DIST_POINT_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr));
}
pub inline fn sk_DIST_POINT_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr));
}
pub inline fn sk_DIST_POINT_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_type(ptr), pnum);
}
pub inline fn sk_DIST_POINT_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_DIST_POINT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_DIST_POINT_sk_type(sk));
}
pub inline fn sk_DIST_POINT_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_DIST_POINT_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_DIST_POINT_sk_type(sk));
}
pub const sk_DIST_POINT_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:353:9
pub const sk_DIST_POINT_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:354:9
pub inline fn sk_DIST_POINT_set_cmp_func(sk: anytype, cmp: anytype) sk_DIST_POINT_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_DIST_POINT_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_DIST_POINT_sk_type(sk), ossl_check_DIST_POINT_compfunc_type(cmp)));
}
pub inline fn sk_SXNETID_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_SXNETID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_SXNETID_sk_type(sk));
}
pub inline fn sk_SXNETID_value(sk: anytype, idx: anytype) [*c]SXNETID {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]SXNETID, OPENSSL_sk_value(ossl_check_const_SXNETID_sk_type(sk), idx));
}
pub const sk_SXNETID_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:376:9
pub const sk_SXNETID_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:377:9
pub const sk_SXNETID_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:378:9
pub inline fn sk_SXNETID_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_SXNETID_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_SXNETID_sk_type(sk), n);
}
pub inline fn sk_SXNETID_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_SXNETID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_SXNETID_sk_type(sk));
}
pub inline fn sk_SXNETID_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_SXNETID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_SXNETID_sk_type(sk));
}
pub inline fn sk_SXNETID_delete(sk: anytype, i: anytype) [*c]SXNETID {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]SXNETID, OPENSSL_sk_delete(ossl_check_SXNETID_sk_type(sk), i));
}
pub inline fn sk_SXNETID_delete_ptr(sk: anytype, ptr: anytype) [*c]SXNETID {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SXNETID, OPENSSL_sk_delete_ptr(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr)));
}
pub inline fn sk_SXNETID_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr));
}
pub inline fn sk_SXNETID_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr));
}
pub inline fn sk_SXNETID_pop(sk: anytype) [*c]SXNETID {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SXNETID, OPENSSL_sk_pop(ossl_check_SXNETID_sk_type(sk)));
}
pub inline fn sk_SXNETID_shift(sk: anytype) [*c]SXNETID {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]SXNETID, OPENSSL_sk_shift(ossl_check_SXNETID_sk_type(sk)));
}
pub inline fn sk_SXNETID_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_freefunc_type(freefunc));
}
pub inline fn sk_SXNETID_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr), idx);
}
pub inline fn sk_SXNETID_set(sk: anytype, idx: anytype, ptr: anytype) [*c]SXNETID {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]SXNETID, OPENSSL_sk_set(ossl_check_SXNETID_sk_type(sk), idx, ossl_check_SXNETID_type(ptr)));
}
pub inline fn sk_SXNETID_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr));
}
pub inline fn sk_SXNETID_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr));
}
pub inline fn sk_SXNETID_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_type(ptr), pnum);
}
pub inline fn sk_SXNETID_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_SXNETID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_SXNETID_sk_type(sk));
}
pub inline fn sk_SXNETID_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_SXNETID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_SXNETID_sk_type(sk));
}
pub const sk_SXNETID_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:396:9
pub const sk_SXNETID_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:397:9
pub inline fn sk_SXNETID_set_cmp_func(sk: anytype, cmp: anytype) sk_SXNETID_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_SXNETID_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_SXNETID_sk_type(sk), ossl_check_SXNETID_compfunc_type(cmp)));
}
pub inline fn sk_POLICYQUALINFO_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_POLICYQUALINFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_POLICYQUALINFO_sk_type(sk));
}
pub inline fn sk_POLICYQUALINFO_value(sk: anytype, idx: anytype) [*c]POLICYQUALINFO {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]POLICYQUALINFO, OPENSSL_sk_value(ossl_check_const_POLICYQUALINFO_sk_type(sk), idx));
}
pub const sk_POLICYQUALINFO_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:436:9
pub const sk_POLICYQUALINFO_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:437:9
pub const sk_POLICYQUALINFO_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:438:9
pub inline fn sk_POLICYQUALINFO_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_POLICYQUALINFO_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_POLICYQUALINFO_sk_type(sk), n);
}
pub inline fn sk_POLICYQUALINFO_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_POLICYQUALINFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_POLICYQUALINFO_sk_type(sk));
}
pub inline fn sk_POLICYQUALINFO_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_POLICYQUALINFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_POLICYQUALINFO_sk_type(sk));
}
pub inline fn sk_POLICYQUALINFO_delete(sk: anytype, i: anytype) [*c]POLICYQUALINFO {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]POLICYQUALINFO, OPENSSL_sk_delete(ossl_check_POLICYQUALINFO_sk_type(sk), i));
}
pub inline fn sk_POLICYQUALINFO_delete_ptr(sk: anytype, ptr: anytype) [*c]POLICYQUALINFO {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]POLICYQUALINFO, OPENSSL_sk_delete_ptr(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr)));
}
pub inline fn sk_POLICYQUALINFO_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr));
}
pub inline fn sk_POLICYQUALINFO_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr));
}
pub inline fn sk_POLICYQUALINFO_pop(sk: anytype) [*c]POLICYQUALINFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]POLICYQUALINFO, OPENSSL_sk_pop(ossl_check_POLICYQUALINFO_sk_type(sk)));
}
pub inline fn sk_POLICYQUALINFO_shift(sk: anytype) [*c]POLICYQUALINFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]POLICYQUALINFO, OPENSSL_sk_shift(ossl_check_POLICYQUALINFO_sk_type(sk)));
}
pub inline fn sk_POLICYQUALINFO_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_freefunc_type(freefunc));
}
pub inline fn sk_POLICYQUALINFO_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr), idx);
}
pub inline fn sk_POLICYQUALINFO_set(sk: anytype, idx: anytype, ptr: anytype) [*c]POLICYQUALINFO {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]POLICYQUALINFO, OPENSSL_sk_set(ossl_check_POLICYQUALINFO_sk_type(sk), idx, ossl_check_POLICYQUALINFO_type(ptr)));
}
pub inline fn sk_POLICYQUALINFO_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr));
}
pub inline fn sk_POLICYQUALINFO_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr));
}
pub inline fn sk_POLICYQUALINFO_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_type(ptr), pnum);
}
pub inline fn sk_POLICYQUALINFO_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_POLICYQUALINFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_POLICYQUALINFO_sk_type(sk));
}
pub inline fn sk_POLICYQUALINFO_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_POLICYQUALINFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_POLICYQUALINFO_sk_type(sk));
}
pub const sk_POLICYQUALINFO_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:456:9
pub const sk_POLICYQUALINFO_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:457:9
pub inline fn sk_POLICYQUALINFO_set_cmp_func(sk: anytype, cmp: anytype) sk_POLICYQUALINFO_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_POLICYQUALINFO_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_POLICYQUALINFO_sk_type(sk), ossl_check_POLICYQUALINFO_compfunc_type(cmp)));
}
pub inline fn sk_POLICYINFO_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_POLICYINFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_POLICYINFO_sk_type(sk));
}
pub inline fn sk_POLICYINFO_value(sk: anytype, idx: anytype) [*c]POLICYINFO {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]POLICYINFO, OPENSSL_sk_value(ossl_check_const_POLICYINFO_sk_type(sk), idx));
}
pub const sk_POLICYINFO_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:470:9
pub const sk_POLICYINFO_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:471:9
pub const sk_POLICYINFO_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:472:9
pub inline fn sk_POLICYINFO_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_POLICYINFO_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_POLICYINFO_sk_type(sk), n);
}
pub inline fn sk_POLICYINFO_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_POLICYINFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_POLICYINFO_sk_type(sk));
}
pub inline fn sk_POLICYINFO_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_POLICYINFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_POLICYINFO_sk_type(sk));
}
pub inline fn sk_POLICYINFO_delete(sk: anytype, i: anytype) [*c]POLICYINFO {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]POLICYINFO, OPENSSL_sk_delete(ossl_check_POLICYINFO_sk_type(sk), i));
}
pub inline fn sk_POLICYINFO_delete_ptr(sk: anytype, ptr: anytype) [*c]POLICYINFO {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]POLICYINFO, OPENSSL_sk_delete_ptr(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr)));
}
pub inline fn sk_POLICYINFO_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr));
}
pub inline fn sk_POLICYINFO_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr));
}
pub inline fn sk_POLICYINFO_pop(sk: anytype) [*c]POLICYINFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]POLICYINFO, OPENSSL_sk_pop(ossl_check_POLICYINFO_sk_type(sk)));
}
pub inline fn sk_POLICYINFO_shift(sk: anytype) [*c]POLICYINFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]POLICYINFO, OPENSSL_sk_shift(ossl_check_POLICYINFO_sk_type(sk)));
}
pub inline fn sk_POLICYINFO_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_freefunc_type(freefunc));
}
pub inline fn sk_POLICYINFO_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr), idx);
}
pub inline fn sk_POLICYINFO_set(sk: anytype, idx: anytype, ptr: anytype) [*c]POLICYINFO {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]POLICYINFO, OPENSSL_sk_set(ossl_check_POLICYINFO_sk_type(sk), idx, ossl_check_POLICYINFO_type(ptr)));
}
pub inline fn sk_POLICYINFO_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr));
}
pub inline fn sk_POLICYINFO_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr));
}
pub inline fn sk_POLICYINFO_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_type(ptr), pnum);
}
pub inline fn sk_POLICYINFO_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_POLICYINFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_POLICYINFO_sk_type(sk));
}
pub inline fn sk_POLICYINFO_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_POLICYINFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_POLICYINFO_sk_type(sk));
}
pub const sk_POLICYINFO_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:490:9
pub const sk_POLICYINFO_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:491:9
pub inline fn sk_POLICYINFO_set_cmp_func(sk: anytype, cmp: anytype) sk_POLICYINFO_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_POLICYINFO_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_POLICYINFO_sk_type(sk), ossl_check_POLICYINFO_compfunc_type(cmp)));
}
pub inline fn sk_POLICY_MAPPING_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_POLICY_MAPPING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_POLICY_MAPPING_sk_type(sk));
}
pub inline fn sk_POLICY_MAPPING_value(sk: anytype, idx: anytype) [*c]POLICY_MAPPING {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]POLICY_MAPPING, OPENSSL_sk_value(ossl_check_const_POLICY_MAPPING_sk_type(sk), idx));
}
pub const sk_POLICY_MAPPING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:505:9
pub const sk_POLICY_MAPPING_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:506:9
pub const sk_POLICY_MAPPING_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:507:9
pub inline fn sk_POLICY_MAPPING_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_POLICY_MAPPING_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_POLICY_MAPPING_sk_type(sk), n);
}
pub inline fn sk_POLICY_MAPPING_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_POLICY_MAPPING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_POLICY_MAPPING_sk_type(sk));
}
pub inline fn sk_POLICY_MAPPING_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_POLICY_MAPPING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_POLICY_MAPPING_sk_type(sk));
}
pub inline fn sk_POLICY_MAPPING_delete(sk: anytype, i: anytype) [*c]POLICY_MAPPING {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]POLICY_MAPPING, OPENSSL_sk_delete(ossl_check_POLICY_MAPPING_sk_type(sk), i));
}
pub inline fn sk_POLICY_MAPPING_delete_ptr(sk: anytype, ptr: anytype) [*c]POLICY_MAPPING {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]POLICY_MAPPING, OPENSSL_sk_delete_ptr(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr)));
}
pub inline fn sk_POLICY_MAPPING_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr));
}
pub inline fn sk_POLICY_MAPPING_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr));
}
pub inline fn sk_POLICY_MAPPING_pop(sk: anytype) [*c]POLICY_MAPPING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]POLICY_MAPPING, OPENSSL_sk_pop(ossl_check_POLICY_MAPPING_sk_type(sk)));
}
pub inline fn sk_POLICY_MAPPING_shift(sk: anytype) [*c]POLICY_MAPPING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]POLICY_MAPPING, OPENSSL_sk_shift(ossl_check_POLICY_MAPPING_sk_type(sk)));
}
pub inline fn sk_POLICY_MAPPING_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_freefunc_type(freefunc));
}
pub inline fn sk_POLICY_MAPPING_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr), idx);
}
pub inline fn sk_POLICY_MAPPING_set(sk: anytype, idx: anytype, ptr: anytype) [*c]POLICY_MAPPING {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]POLICY_MAPPING, OPENSSL_sk_set(ossl_check_POLICY_MAPPING_sk_type(sk), idx, ossl_check_POLICY_MAPPING_type(ptr)));
}
pub inline fn sk_POLICY_MAPPING_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr));
}
pub inline fn sk_POLICY_MAPPING_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr));
}
pub inline fn sk_POLICY_MAPPING_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_type(ptr), pnum);
}
pub inline fn sk_POLICY_MAPPING_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_POLICY_MAPPING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_POLICY_MAPPING_sk_type(sk));
}
pub inline fn sk_POLICY_MAPPING_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_POLICY_MAPPING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_POLICY_MAPPING_sk_type(sk));
}
pub const sk_POLICY_MAPPING_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:525:9
pub const sk_POLICY_MAPPING_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:526:9
pub inline fn sk_POLICY_MAPPING_set_cmp_func(sk: anytype, cmp: anytype) sk_POLICY_MAPPING_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_POLICY_MAPPING_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_POLICY_MAPPING_sk_type(sk), ossl_check_POLICY_MAPPING_compfunc_type(cmp)));
}
pub inline fn sk_GENERAL_SUBTREE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_GENERAL_SUBTREE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_GENERAL_SUBTREE_sk_type(sk));
}
pub inline fn sk_GENERAL_SUBTREE_value(sk: anytype, idx: anytype) [*c]GENERAL_SUBTREE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]GENERAL_SUBTREE, OPENSSL_sk_value(ossl_check_const_GENERAL_SUBTREE_sk_type(sk), idx));
}
pub const sk_GENERAL_SUBTREE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:541:9
pub const sk_GENERAL_SUBTREE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:542:9
pub const sk_GENERAL_SUBTREE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:543:9
pub inline fn sk_GENERAL_SUBTREE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_GENERAL_SUBTREE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_GENERAL_SUBTREE_sk_type(sk), n);
}
pub inline fn sk_GENERAL_SUBTREE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_GENERAL_SUBTREE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_GENERAL_SUBTREE_sk_type(sk));
}
pub inline fn sk_GENERAL_SUBTREE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_GENERAL_SUBTREE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_GENERAL_SUBTREE_sk_type(sk));
}
pub inline fn sk_GENERAL_SUBTREE_delete(sk: anytype, i: anytype) [*c]GENERAL_SUBTREE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]GENERAL_SUBTREE, OPENSSL_sk_delete(ossl_check_GENERAL_SUBTREE_sk_type(sk), i));
}
pub inline fn sk_GENERAL_SUBTREE_delete_ptr(sk: anytype, ptr: anytype) [*c]GENERAL_SUBTREE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]GENERAL_SUBTREE, OPENSSL_sk_delete_ptr(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr)));
}
pub inline fn sk_GENERAL_SUBTREE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr));
}
pub inline fn sk_GENERAL_SUBTREE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr));
}
pub inline fn sk_GENERAL_SUBTREE_pop(sk: anytype) [*c]GENERAL_SUBTREE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]GENERAL_SUBTREE, OPENSSL_sk_pop(ossl_check_GENERAL_SUBTREE_sk_type(sk)));
}
pub inline fn sk_GENERAL_SUBTREE_shift(sk: anytype) [*c]GENERAL_SUBTREE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]GENERAL_SUBTREE, OPENSSL_sk_shift(ossl_check_GENERAL_SUBTREE_sk_type(sk)));
}
pub inline fn sk_GENERAL_SUBTREE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_freefunc_type(freefunc));
}
pub inline fn sk_GENERAL_SUBTREE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr), idx);
}
pub inline fn sk_GENERAL_SUBTREE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]GENERAL_SUBTREE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]GENERAL_SUBTREE, OPENSSL_sk_set(ossl_check_GENERAL_SUBTREE_sk_type(sk), idx, ossl_check_GENERAL_SUBTREE_type(ptr)));
}
pub inline fn sk_GENERAL_SUBTREE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr));
}
pub inline fn sk_GENERAL_SUBTREE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr));
}
pub inline fn sk_GENERAL_SUBTREE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_type(ptr), pnum);
}
pub inline fn sk_GENERAL_SUBTREE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_GENERAL_SUBTREE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_GENERAL_SUBTREE_sk_type(sk));
}
pub inline fn sk_GENERAL_SUBTREE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_GENERAL_SUBTREE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_GENERAL_SUBTREE_sk_type(sk));
}
pub const sk_GENERAL_SUBTREE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:561:9
pub const sk_GENERAL_SUBTREE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:562:9
pub inline fn sk_GENERAL_SUBTREE_set_cmp_func(sk: anytype, cmp: anytype) sk_GENERAL_SUBTREE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_GENERAL_SUBTREE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_GENERAL_SUBTREE_sk_type(sk), ossl_check_GENERAL_SUBTREE_compfunc_type(cmp)));
}
pub const IDP_PRESENT = @as(c_int, 0x1);
pub const IDP_INVALID = @as(c_int, 0x2);
pub const IDP_ONLYUSER = @as(c_int, 0x4);
pub const IDP_ONLYCA = @as(c_int, 0x8);
pub const IDP_ONLYATTR = @as(c_int, 0x10);
pub const IDP_INDIRECT = @as(c_int, 0x20);
pub const IDP_REASONS = @as(c_int, 0x40);
pub inline fn X509V3_conf_err(val: anytype) @TypeOf(ERR_add_error_data(@as(c_int, 6), "section:", val.*.section, ",name:", val.*.name, ",value:", val.*.value)) {
    _ = &val;
    return ERR_add_error_data(@as(c_int, 6), "section:", val.*.section, ",name:", val.*.name, ",value:", val.*.value);
}
pub inline fn X509V3_set_ctx_test(ctx: anytype) @TypeOf(X509V3_set_ctx(ctx, NULL, NULL, NULL, NULL, X509V3_CTX_TEST)) {
    _ = &ctx;
    return X509V3_set_ctx(ctx, NULL, NULL, NULL, NULL, X509V3_CTX_TEST);
}
pub const X509V3_set_ctx_nodb = @compileError("unable to translate C expr: unexpected token '='");
// /usr/include/openssl/x509v3.h:621:10
pub const EXT_BITSTRING = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/openssl/x509v3.h:623:10
pub const EXT_IA5STRING = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/openssl/x509v3.h:631:10
pub const EXT_UTF8STRING = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/openssl/x509v3.h:638:9
pub const EXT_END = @compileError("unable to translate C expr: unexpected token '{'");
// /usr/include/openssl/x509v3.h:645:10
pub const EXFLAG_BCONS = @as(c_int, 0x1);
pub const EXFLAG_KUSAGE = @as(c_int, 0x2);
pub const EXFLAG_XKUSAGE = @as(c_int, 0x4);
pub const EXFLAG_NSCERT = @as(c_int, 0x8);
pub const EXFLAG_CA = @as(c_int, 0x10);
pub const EXFLAG_SI = @as(c_int, 0x20);
pub const EXFLAG_V1 = @as(c_int, 0x40);
pub const EXFLAG_INVALID = @as(c_int, 0x80);
pub const EXFLAG_SET = @as(c_int, 0x100);
pub const EXFLAG_CRITICAL = @as(c_int, 0x200);
pub const EXFLAG_PROXY = @as(c_int, 0x400);
pub const EXFLAG_INVALID_POLICY = @as(c_int, 0x800);
pub const EXFLAG_FRESHEST = @as(c_int, 0x1000);
pub const EXFLAG_SS = @as(c_int, 0x2000);
pub const EXFLAG_BCONS_CRITICAL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000, .hex);
pub const EXFLAG_AKID_CRITICAL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000, .hex);
pub const EXFLAG_SKID_CRITICAL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000, .hex);
pub const EXFLAG_SAN_CRITICAL = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000, .hex);
pub const EXFLAG_NO_FINGERPRINT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x100000, .hex);
pub const KU_DIGITAL_SIGNATURE = X509v3_KU_DIGITAL_SIGNATURE;
pub const KU_NON_REPUDIATION = X509v3_KU_NON_REPUDIATION;
pub const KU_KEY_ENCIPHERMENT = X509v3_KU_KEY_ENCIPHERMENT;
pub const KU_DATA_ENCIPHERMENT = X509v3_KU_DATA_ENCIPHERMENT;
pub const KU_KEY_AGREEMENT = X509v3_KU_KEY_AGREEMENT;
pub const KU_KEY_CERT_SIGN = X509v3_KU_KEY_CERT_SIGN;
pub const KU_CRL_SIGN = X509v3_KU_CRL_SIGN;
pub const KU_ENCIPHER_ONLY = X509v3_KU_ENCIPHER_ONLY;
pub const KU_DECIPHER_ONLY = X509v3_KU_DECIPHER_ONLY;
pub const NS_SSL_CLIENT = @as(c_int, 0x80);
pub const NS_SSL_SERVER = @as(c_int, 0x40);
pub const NS_SMIME = @as(c_int, 0x20);
pub const NS_OBJSIGN = @as(c_int, 0x10);
pub const NS_SSL_CA = @as(c_int, 0x04);
pub const NS_SMIME_CA = @as(c_int, 0x02);
pub const NS_OBJSIGN_CA = @as(c_int, 0x01);
pub const NS_ANY_CA = (NS_SSL_CA | NS_SMIME_CA) | NS_OBJSIGN_CA;
pub const XKU_SSL_SERVER = @as(c_int, 0x1);
pub const XKU_SSL_CLIENT = @as(c_int, 0x2);
pub const XKU_SMIME = @as(c_int, 0x4);
pub const XKU_CODE_SIGN = @as(c_int, 0x8);
pub const XKU_SGC = @as(c_int, 0x10);
pub const XKU_OCSP_SIGN = @as(c_int, 0x20);
pub const XKU_TIMESTAMP = @as(c_int, 0x40);
pub const XKU_DVCS = @as(c_int, 0x80);
pub const XKU_ANYEKU = @as(c_int, 0x100);
pub const X509_PURPOSE_DYNAMIC = @as(c_int, 0x1);
pub const X509_PURPOSE_DYNAMIC_NAME = @as(c_int, 0x2);
pub inline fn sk_X509_PURPOSE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_PURPOSE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_PURPOSE_sk_type(sk));
}
pub inline fn sk_X509_PURPOSE_value(sk: anytype, idx: anytype) [*c]X509_PURPOSE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_PURPOSE, OPENSSL_sk_value(ossl_check_const_X509_PURPOSE_sk_type(sk), idx));
}
pub const sk_X509_PURPOSE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:719:9
pub const sk_X509_PURPOSE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:720:9
pub const sk_X509_PURPOSE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:721:9
pub inline fn sk_X509_PURPOSE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_PURPOSE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_PURPOSE_sk_type(sk), n);
}
pub inline fn sk_X509_PURPOSE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_PURPOSE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_PURPOSE_sk_type(sk));
}
pub inline fn sk_X509_PURPOSE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_PURPOSE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_PURPOSE_sk_type(sk));
}
pub inline fn sk_X509_PURPOSE_delete(sk: anytype, i: anytype) [*c]X509_PURPOSE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_PURPOSE, OPENSSL_sk_delete(ossl_check_X509_PURPOSE_sk_type(sk), i));
}
pub inline fn sk_X509_PURPOSE_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_PURPOSE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_PURPOSE, OPENSSL_sk_delete_ptr(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr)));
}
pub inline fn sk_X509_PURPOSE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr));
}
pub inline fn sk_X509_PURPOSE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr));
}
pub inline fn sk_X509_PURPOSE_pop(sk: anytype) [*c]X509_PURPOSE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_PURPOSE, OPENSSL_sk_pop(ossl_check_X509_PURPOSE_sk_type(sk)));
}
pub inline fn sk_X509_PURPOSE_shift(sk: anytype) [*c]X509_PURPOSE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_PURPOSE, OPENSSL_sk_shift(ossl_check_X509_PURPOSE_sk_type(sk)));
}
pub inline fn sk_X509_PURPOSE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_freefunc_type(freefunc));
}
pub inline fn sk_X509_PURPOSE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr), idx);
}
pub inline fn sk_X509_PURPOSE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_PURPOSE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_PURPOSE, OPENSSL_sk_set(ossl_check_X509_PURPOSE_sk_type(sk), idx, ossl_check_X509_PURPOSE_type(ptr)));
}
pub inline fn sk_X509_PURPOSE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr));
}
pub inline fn sk_X509_PURPOSE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr));
}
pub inline fn sk_X509_PURPOSE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_type(ptr), pnum);
}
pub inline fn sk_X509_PURPOSE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_PURPOSE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_PURPOSE_sk_type(sk));
}
pub inline fn sk_X509_PURPOSE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_PURPOSE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_PURPOSE_sk_type(sk));
}
pub const sk_X509_PURPOSE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:739:9
pub const sk_X509_PURPOSE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:740:9
pub inline fn sk_X509_PURPOSE_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_PURPOSE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_PURPOSE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_PURPOSE_sk_type(sk), ossl_check_X509_PURPOSE_compfunc_type(cmp)));
}
pub const X509_PURPOSE_SSL_CLIENT = @as(c_int, 1);
pub const X509_PURPOSE_SSL_SERVER = @as(c_int, 2);
pub const X509_PURPOSE_NS_SSL_SERVER = @as(c_int, 3);
pub const X509_PURPOSE_SMIME_SIGN = @as(c_int, 4);
pub const X509_PURPOSE_SMIME_ENCRYPT = @as(c_int, 5);
pub const X509_PURPOSE_CRL_SIGN = @as(c_int, 6);
pub const X509_PURPOSE_ANY = @as(c_int, 7);
pub const X509_PURPOSE_OCSP_HELPER = @as(c_int, 8);
pub const X509_PURPOSE_TIMESTAMP_SIGN = @as(c_int, 9);
pub const X509_PURPOSE_CODE_SIGN = @as(c_int, 10);
pub const X509_PURPOSE_MIN = @as(c_int, 1);
pub const X509_PURPOSE_MAX = @as(c_int, 10);
pub const X509V3_EXT_UNKNOWN_MASK = @as(c_long, 0xf) << @as(c_int, 16);
pub const X509V3_EXT_DEFAULT = @as(c_int, 0);
pub const X509V3_EXT_ERROR_UNKNOWN = @as(c_long, 1) << @as(c_int, 16);
pub const X509V3_EXT_PARSE_UNKNOWN = @as(c_long, 2) << @as(c_int, 16);
pub const X509V3_EXT_DUMP_UNKNOWN = @as(c_long, 3) << @as(c_int, 16);
pub const X509V3_ADD_OP_MASK = @as(c_long, 0xf);
pub const X509V3_ADD_DEFAULT = @as(c_long, 0);
pub const X509V3_ADD_APPEND = @as(c_long, 1);
pub const X509V3_ADD_REPLACE = @as(c_long, 2);
pub const X509V3_ADD_REPLACE_EXISTING = @as(c_long, 3);
pub const X509V3_ADD_KEEP_EXISTING = @as(c_long, 4);
pub const X509V3_ADD_DELETE = @as(c_long, 5);
pub const X509V3_ADD_SILENT = @as(c_int, 0x10);
pub const hex_to_string = OPENSSL_buf2hexstr;
pub const string_to_hex = OPENSSL_hexstr2buf;
pub const X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT = @as(c_int, 0x1);
pub const X509_CHECK_FLAG_NO_WILDCARDS = @as(c_int, 0x2);
pub const X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS = @as(c_int, 0x4);
pub const X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS = @as(c_int, 0x8);
pub const X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS = @as(c_int, 0x10);
pub const X509_CHECK_FLAG_NEVER_CHECK_SUBJECT = @as(c_int, 0x20);
pub const _X509_CHECK_FLAG_DOT_SUBDOMAINS = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x8000, .hex);
pub inline fn sk_X509_POLICY_NODE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_X509_POLICY_NODE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_X509_POLICY_NODE_sk_type(sk));
}
pub inline fn sk_X509_POLICY_NODE_value(sk: anytype, idx: anytype) [*c]X509_POLICY_NODE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]X509_POLICY_NODE, OPENSSL_sk_value(ossl_check_const_X509_POLICY_NODE_sk_type(sk), idx));
}
pub const sk_X509_POLICY_NODE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1065:9
pub const sk_X509_POLICY_NODE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1066:9
pub const sk_X509_POLICY_NODE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1067:9
pub inline fn sk_X509_POLICY_NODE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_X509_POLICY_NODE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_X509_POLICY_NODE_sk_type(sk), n);
}
pub inline fn sk_X509_POLICY_NODE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_X509_POLICY_NODE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_X509_POLICY_NODE_sk_type(sk));
}
pub inline fn sk_X509_POLICY_NODE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_X509_POLICY_NODE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_X509_POLICY_NODE_sk_type(sk));
}
pub inline fn sk_X509_POLICY_NODE_delete(sk: anytype, i: anytype) [*c]X509_POLICY_NODE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]X509_POLICY_NODE, OPENSSL_sk_delete(ossl_check_X509_POLICY_NODE_sk_type(sk), i));
}
pub inline fn sk_X509_POLICY_NODE_delete_ptr(sk: anytype, ptr: anytype) [*c]X509_POLICY_NODE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_POLICY_NODE, OPENSSL_sk_delete_ptr(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr)));
}
pub inline fn sk_X509_POLICY_NODE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr));
}
pub inline fn sk_X509_POLICY_NODE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr));
}
pub inline fn sk_X509_POLICY_NODE_pop(sk: anytype) [*c]X509_POLICY_NODE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_POLICY_NODE, OPENSSL_sk_pop(ossl_check_X509_POLICY_NODE_sk_type(sk)));
}
pub inline fn sk_X509_POLICY_NODE_shift(sk: anytype) [*c]X509_POLICY_NODE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]X509_POLICY_NODE, OPENSSL_sk_shift(ossl_check_X509_POLICY_NODE_sk_type(sk)));
}
pub inline fn sk_X509_POLICY_NODE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_freefunc_type(freefunc));
}
pub inline fn sk_X509_POLICY_NODE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr), idx);
}
pub inline fn sk_X509_POLICY_NODE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]X509_POLICY_NODE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]X509_POLICY_NODE, OPENSSL_sk_set(ossl_check_X509_POLICY_NODE_sk_type(sk), idx, ossl_check_X509_POLICY_NODE_type(ptr)));
}
pub inline fn sk_X509_POLICY_NODE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr));
}
pub inline fn sk_X509_POLICY_NODE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr));
}
pub inline fn sk_X509_POLICY_NODE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_type(ptr), pnum);
}
pub inline fn sk_X509_POLICY_NODE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_X509_POLICY_NODE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_X509_POLICY_NODE_sk_type(sk));
}
pub inline fn sk_X509_POLICY_NODE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_X509_POLICY_NODE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_X509_POLICY_NODE_sk_type(sk));
}
pub const sk_X509_POLICY_NODE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1085:9
pub const sk_X509_POLICY_NODE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1086:9
pub inline fn sk_X509_POLICY_NODE_set_cmp_func(sk: anytype, cmp: anytype) sk_X509_POLICY_NODE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_X509_POLICY_NODE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_X509_POLICY_NODE_sk_type(sk), ossl_check_X509_POLICY_NODE_compfunc_type(cmp)));
}
pub const ASIdOrRange_id = @as(c_int, 0);
pub const ASIdOrRange_range = @as(c_int, 1);
pub inline fn sk_ASIdOrRange_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASIdOrRange_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASIdOrRange_sk_type(sk));
}
pub inline fn sk_ASIdOrRange_value(sk: anytype, idx: anytype) [*c]ASIdOrRange {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASIdOrRange, OPENSSL_sk_value(ossl_check_const_ASIdOrRange_sk_type(sk), idx));
}
pub const sk_ASIdOrRange_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1110:9
pub const sk_ASIdOrRange_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1111:9
pub const sk_ASIdOrRange_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1112:9
pub inline fn sk_ASIdOrRange_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASIdOrRange_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASIdOrRange_sk_type(sk), n);
}
pub inline fn sk_ASIdOrRange_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASIdOrRange_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASIdOrRange_sk_type(sk));
}
pub inline fn sk_ASIdOrRange_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASIdOrRange_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASIdOrRange_sk_type(sk));
}
pub inline fn sk_ASIdOrRange_delete(sk: anytype, i: anytype) [*c]ASIdOrRange {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASIdOrRange, OPENSSL_sk_delete(ossl_check_ASIdOrRange_sk_type(sk), i));
}
pub inline fn sk_ASIdOrRange_delete_ptr(sk: anytype, ptr: anytype) [*c]ASIdOrRange {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASIdOrRange, OPENSSL_sk_delete_ptr(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr)));
}
pub inline fn sk_ASIdOrRange_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr));
}
pub inline fn sk_ASIdOrRange_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr));
}
pub inline fn sk_ASIdOrRange_pop(sk: anytype) [*c]ASIdOrRange {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASIdOrRange, OPENSSL_sk_pop(ossl_check_ASIdOrRange_sk_type(sk)));
}
pub inline fn sk_ASIdOrRange_shift(sk: anytype) [*c]ASIdOrRange {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASIdOrRange, OPENSSL_sk_shift(ossl_check_ASIdOrRange_sk_type(sk)));
}
pub inline fn sk_ASIdOrRange_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_freefunc_type(freefunc));
}
pub inline fn sk_ASIdOrRange_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr), idx);
}
pub inline fn sk_ASIdOrRange_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASIdOrRange {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASIdOrRange, OPENSSL_sk_set(ossl_check_ASIdOrRange_sk_type(sk), idx, ossl_check_ASIdOrRange_type(ptr)));
}
pub inline fn sk_ASIdOrRange_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr));
}
pub inline fn sk_ASIdOrRange_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr));
}
pub inline fn sk_ASIdOrRange_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_type(ptr), pnum);
}
pub inline fn sk_ASIdOrRange_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASIdOrRange_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASIdOrRange_sk_type(sk));
}
pub inline fn sk_ASIdOrRange_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASIdOrRange_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASIdOrRange_sk_type(sk));
}
pub const sk_ASIdOrRange_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1130:9
pub const sk_ASIdOrRange_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1131:9
pub inline fn sk_ASIdOrRange_set_cmp_func(sk: anytype, cmp: anytype) sk_ASIdOrRange_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASIdOrRange_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASIdOrRange_sk_type(sk), ossl_check_ASIdOrRange_compfunc_type(cmp)));
}
pub const ASIdentifierChoice_inherit = @as(c_int, 0);
pub const ASIdentifierChoice_asIdsOrRanges = @as(c_int, 1);
pub const IPAddressOrRange_addressPrefix = @as(c_int, 0);
pub const IPAddressOrRange_addressRange = @as(c_int, 1);
pub inline fn sk_IPAddressOrRange_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_IPAddressOrRange_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_IPAddressOrRange_sk_type(sk));
}
pub inline fn sk_IPAddressOrRange_value(sk: anytype, idx: anytype) [*c]IPAddressOrRange {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]IPAddressOrRange, OPENSSL_sk_value(ossl_check_const_IPAddressOrRange_sk_type(sk), idx));
}
pub const sk_IPAddressOrRange_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1175:9
pub const sk_IPAddressOrRange_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1176:9
pub const sk_IPAddressOrRange_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1177:9
pub inline fn sk_IPAddressOrRange_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_IPAddressOrRange_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_IPAddressOrRange_sk_type(sk), n);
}
pub inline fn sk_IPAddressOrRange_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_IPAddressOrRange_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_IPAddressOrRange_sk_type(sk));
}
pub inline fn sk_IPAddressOrRange_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_IPAddressOrRange_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_IPAddressOrRange_sk_type(sk));
}
pub inline fn sk_IPAddressOrRange_delete(sk: anytype, i: anytype) [*c]IPAddressOrRange {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]IPAddressOrRange, OPENSSL_sk_delete(ossl_check_IPAddressOrRange_sk_type(sk), i));
}
pub inline fn sk_IPAddressOrRange_delete_ptr(sk: anytype, ptr: anytype) [*c]IPAddressOrRange {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]IPAddressOrRange, OPENSSL_sk_delete_ptr(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr)));
}
pub inline fn sk_IPAddressOrRange_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr));
}
pub inline fn sk_IPAddressOrRange_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr));
}
pub inline fn sk_IPAddressOrRange_pop(sk: anytype) [*c]IPAddressOrRange {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]IPAddressOrRange, OPENSSL_sk_pop(ossl_check_IPAddressOrRange_sk_type(sk)));
}
pub inline fn sk_IPAddressOrRange_shift(sk: anytype) [*c]IPAddressOrRange {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]IPAddressOrRange, OPENSSL_sk_shift(ossl_check_IPAddressOrRange_sk_type(sk)));
}
pub inline fn sk_IPAddressOrRange_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_freefunc_type(freefunc));
}
pub inline fn sk_IPAddressOrRange_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr), idx);
}
pub inline fn sk_IPAddressOrRange_set(sk: anytype, idx: anytype, ptr: anytype) [*c]IPAddressOrRange {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]IPAddressOrRange, OPENSSL_sk_set(ossl_check_IPAddressOrRange_sk_type(sk), idx, ossl_check_IPAddressOrRange_type(ptr)));
}
pub inline fn sk_IPAddressOrRange_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr));
}
pub inline fn sk_IPAddressOrRange_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr));
}
pub inline fn sk_IPAddressOrRange_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_type(ptr), pnum);
}
pub inline fn sk_IPAddressOrRange_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_IPAddressOrRange_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_IPAddressOrRange_sk_type(sk));
}
pub inline fn sk_IPAddressOrRange_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_IPAddressOrRange_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_IPAddressOrRange_sk_type(sk));
}
pub const sk_IPAddressOrRange_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1195:9
pub const sk_IPAddressOrRange_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1196:9
pub inline fn sk_IPAddressOrRange_set_cmp_func(sk: anytype, cmp: anytype) sk_IPAddressOrRange_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_IPAddressOrRange_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_IPAddressOrRange_sk_type(sk), ossl_check_IPAddressOrRange_compfunc_type(cmp)));
}
pub const IPAddressChoice_inherit = @as(c_int, 0);
pub const IPAddressChoice_addressesOrRanges = @as(c_int, 1);
pub inline fn sk_IPAddressFamily_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_IPAddressFamily_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_IPAddressFamily_sk_type(sk));
}
pub inline fn sk_IPAddressFamily_value(sk: anytype, idx: anytype) [*c]IPAddressFamily {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]IPAddressFamily, OPENSSL_sk_value(ossl_check_const_IPAddressFamily_sk_type(sk), idx));
}
pub const sk_IPAddressFamily_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1221:9
pub const sk_IPAddressFamily_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1222:9
pub const sk_IPAddressFamily_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1223:9
pub inline fn sk_IPAddressFamily_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_IPAddressFamily_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_IPAddressFamily_sk_type(sk), n);
}
pub inline fn sk_IPAddressFamily_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_IPAddressFamily_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_IPAddressFamily_sk_type(sk));
}
pub inline fn sk_IPAddressFamily_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_IPAddressFamily_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_IPAddressFamily_sk_type(sk));
}
pub inline fn sk_IPAddressFamily_delete(sk: anytype, i: anytype) [*c]IPAddressFamily {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]IPAddressFamily, OPENSSL_sk_delete(ossl_check_IPAddressFamily_sk_type(sk), i));
}
pub inline fn sk_IPAddressFamily_delete_ptr(sk: anytype, ptr: anytype) [*c]IPAddressFamily {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]IPAddressFamily, OPENSSL_sk_delete_ptr(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr)));
}
pub inline fn sk_IPAddressFamily_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr));
}
pub inline fn sk_IPAddressFamily_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr));
}
pub inline fn sk_IPAddressFamily_pop(sk: anytype) [*c]IPAddressFamily {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]IPAddressFamily, OPENSSL_sk_pop(ossl_check_IPAddressFamily_sk_type(sk)));
}
pub inline fn sk_IPAddressFamily_shift(sk: anytype) [*c]IPAddressFamily {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]IPAddressFamily, OPENSSL_sk_shift(ossl_check_IPAddressFamily_sk_type(sk)));
}
pub inline fn sk_IPAddressFamily_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_freefunc_type(freefunc));
}
pub inline fn sk_IPAddressFamily_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr), idx);
}
pub inline fn sk_IPAddressFamily_set(sk: anytype, idx: anytype, ptr: anytype) [*c]IPAddressFamily {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]IPAddressFamily, OPENSSL_sk_set(ossl_check_IPAddressFamily_sk_type(sk), idx, ossl_check_IPAddressFamily_type(ptr)));
}
pub inline fn sk_IPAddressFamily_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr));
}
pub inline fn sk_IPAddressFamily_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr));
}
pub inline fn sk_IPAddressFamily_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_type(ptr), pnum);
}
pub inline fn sk_IPAddressFamily_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_IPAddressFamily_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_IPAddressFamily_sk_type(sk));
}
pub inline fn sk_IPAddressFamily_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_IPAddressFamily_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_IPAddressFamily_sk_type(sk));
}
pub const sk_IPAddressFamily_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1241:9
pub const sk_IPAddressFamily_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1242:9
pub inline fn sk_IPAddressFamily_set_cmp_func(sk: anytype, cmp: anytype) sk_IPAddressFamily_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_IPAddressFamily_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_IPAddressFamily_sk_type(sk), ossl_check_IPAddressFamily_compfunc_type(cmp)));
}
pub const V3_ASID_ASNUM = @as(c_int, 0);
pub const V3_ASID_RDI = @as(c_int, 1);
pub const IANA_AFI_IPV4 = @as(c_int, 1);
pub const IANA_AFI_IPV6 = @as(c_int, 2);
pub inline fn sk_ASN1_STRING_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ASN1_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ASN1_STRING_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_value(sk: anytype, idx: anytype) [*c]ASN1_STRING {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING, OPENSSL_sk_value(ossl_check_const_ASN1_STRING_sk_type(sk), idx));
}
pub const sk_ASN1_STRING_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1322:9
pub const sk_ASN1_STRING_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1323:9
pub const sk_ASN1_STRING_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1324:9
pub inline fn sk_ASN1_STRING_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ASN1_STRING_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ASN1_STRING_sk_type(sk), n);
}
pub inline fn sk_ASN1_STRING_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ASN1_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ASN1_STRING_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ASN1_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ASN1_STRING_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_delete(sk: anytype, i: anytype) [*c]ASN1_STRING {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING, OPENSSL_sk_delete(ossl_check_ASN1_STRING_sk_type(sk), i));
}
pub inline fn sk_ASN1_STRING_delete_ptr(sk: anytype, ptr: anytype) [*c]ASN1_STRING {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING, OPENSSL_sk_delete_ptr(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr)));
}
pub inline fn sk_ASN1_STRING_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr));
}
pub inline fn sk_ASN1_STRING_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr));
}
pub inline fn sk_ASN1_STRING_pop(sk: anytype) [*c]ASN1_STRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING, OPENSSL_sk_pop(ossl_check_ASN1_STRING_sk_type(sk)));
}
pub inline fn sk_ASN1_STRING_shift(sk: anytype) [*c]ASN1_STRING {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING, OPENSSL_sk_shift(ossl_check_ASN1_STRING_sk_type(sk)));
}
pub inline fn sk_ASN1_STRING_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_freefunc_type(freefunc));
}
pub inline fn sk_ASN1_STRING_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr), idx);
}
pub inline fn sk_ASN1_STRING_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ASN1_STRING {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ASN1_STRING, OPENSSL_sk_set(ossl_check_ASN1_STRING_sk_type(sk), idx, ossl_check_ASN1_STRING_type(ptr)));
}
pub inline fn sk_ASN1_STRING_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr));
}
pub inline fn sk_ASN1_STRING_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr));
}
pub inline fn sk_ASN1_STRING_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_type(ptr), pnum);
}
pub inline fn sk_ASN1_STRING_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ASN1_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ASN1_STRING_sk_type(sk));
}
pub inline fn sk_ASN1_STRING_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ASN1_STRING_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ASN1_STRING_sk_type(sk));
}
pub const sk_ASN1_STRING_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1342:9
pub const sk_ASN1_STRING_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1343:9
pub inline fn sk_ASN1_STRING_set_cmp_func(sk: anytype, cmp: anytype) sk_ASN1_STRING_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ASN1_STRING_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ASN1_STRING_sk_type(sk), ossl_check_ASN1_STRING_compfunc_type(cmp)));
}
pub inline fn sk_PROFESSION_INFO_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_PROFESSION_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_PROFESSION_INFO_sk_type(sk));
}
pub inline fn sk_PROFESSION_INFO_value(sk: anytype, idx: anytype) [*c]PROFESSION_INFO {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]PROFESSION_INFO, OPENSSL_sk_value(ossl_check_const_PROFESSION_INFO_sk_type(sk), idx));
}
pub const sk_PROFESSION_INFO_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1361:9
pub const sk_PROFESSION_INFO_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1362:9
pub const sk_PROFESSION_INFO_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1363:9
pub inline fn sk_PROFESSION_INFO_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_PROFESSION_INFO_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_PROFESSION_INFO_sk_type(sk), n);
}
pub inline fn sk_PROFESSION_INFO_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_PROFESSION_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_PROFESSION_INFO_sk_type(sk));
}
pub inline fn sk_PROFESSION_INFO_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_PROFESSION_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_PROFESSION_INFO_sk_type(sk));
}
pub inline fn sk_PROFESSION_INFO_delete(sk: anytype, i: anytype) [*c]PROFESSION_INFO {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]PROFESSION_INFO, OPENSSL_sk_delete(ossl_check_PROFESSION_INFO_sk_type(sk), i));
}
pub inline fn sk_PROFESSION_INFO_delete_ptr(sk: anytype, ptr: anytype) [*c]PROFESSION_INFO {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PROFESSION_INFO, OPENSSL_sk_delete_ptr(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr)));
}
pub inline fn sk_PROFESSION_INFO_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr));
}
pub inline fn sk_PROFESSION_INFO_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr));
}
pub inline fn sk_PROFESSION_INFO_pop(sk: anytype) [*c]PROFESSION_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PROFESSION_INFO, OPENSSL_sk_pop(ossl_check_PROFESSION_INFO_sk_type(sk)));
}
pub inline fn sk_PROFESSION_INFO_shift(sk: anytype) [*c]PROFESSION_INFO {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]PROFESSION_INFO, OPENSSL_sk_shift(ossl_check_PROFESSION_INFO_sk_type(sk)));
}
pub inline fn sk_PROFESSION_INFO_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_freefunc_type(freefunc));
}
pub inline fn sk_PROFESSION_INFO_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr), idx);
}
pub inline fn sk_PROFESSION_INFO_set(sk: anytype, idx: anytype, ptr: anytype) [*c]PROFESSION_INFO {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]PROFESSION_INFO, OPENSSL_sk_set(ossl_check_PROFESSION_INFO_sk_type(sk), idx, ossl_check_PROFESSION_INFO_type(ptr)));
}
pub inline fn sk_PROFESSION_INFO_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr));
}
pub inline fn sk_PROFESSION_INFO_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr));
}
pub inline fn sk_PROFESSION_INFO_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_type(ptr), pnum);
}
pub inline fn sk_PROFESSION_INFO_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_PROFESSION_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_PROFESSION_INFO_sk_type(sk));
}
pub inline fn sk_PROFESSION_INFO_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_PROFESSION_INFO_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_PROFESSION_INFO_sk_type(sk));
}
pub const sk_PROFESSION_INFO_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1381:9
pub const sk_PROFESSION_INFO_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1382:9
pub inline fn sk_PROFESSION_INFO_set_cmp_func(sk: anytype, cmp: anytype) sk_PROFESSION_INFO_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_PROFESSION_INFO_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_PROFESSION_INFO_sk_type(sk), ossl_check_PROFESSION_INFO_compfunc_type(cmp)));
}
pub inline fn sk_ADMISSIONS_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_ADMISSIONS_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_ADMISSIONS_sk_type(sk));
}
pub inline fn sk_ADMISSIONS_value(sk: anytype, idx: anytype) [*c]ADMISSIONS {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]ADMISSIONS, OPENSSL_sk_value(ossl_check_const_ADMISSIONS_sk_type(sk), idx));
}
pub const sk_ADMISSIONS_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1387:9
pub const sk_ADMISSIONS_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1388:9
pub const sk_ADMISSIONS_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1389:9
pub inline fn sk_ADMISSIONS_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_ADMISSIONS_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_ADMISSIONS_sk_type(sk), n);
}
pub inline fn sk_ADMISSIONS_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_ADMISSIONS_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_ADMISSIONS_sk_type(sk));
}
pub inline fn sk_ADMISSIONS_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_ADMISSIONS_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_ADMISSIONS_sk_type(sk));
}
pub inline fn sk_ADMISSIONS_delete(sk: anytype, i: anytype) [*c]ADMISSIONS {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]ADMISSIONS, OPENSSL_sk_delete(ossl_check_ADMISSIONS_sk_type(sk), i));
}
pub inline fn sk_ADMISSIONS_delete_ptr(sk: anytype, ptr: anytype) [*c]ADMISSIONS {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ADMISSIONS, OPENSSL_sk_delete_ptr(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr)));
}
pub inline fn sk_ADMISSIONS_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr));
}
pub inline fn sk_ADMISSIONS_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr));
}
pub inline fn sk_ADMISSIONS_pop(sk: anytype) [*c]ADMISSIONS {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ADMISSIONS, OPENSSL_sk_pop(ossl_check_ADMISSIONS_sk_type(sk)));
}
pub inline fn sk_ADMISSIONS_shift(sk: anytype) [*c]ADMISSIONS {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]ADMISSIONS, OPENSSL_sk_shift(ossl_check_ADMISSIONS_sk_type(sk)));
}
pub inline fn sk_ADMISSIONS_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_freefunc_type(freefunc));
}
pub inline fn sk_ADMISSIONS_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr), idx);
}
pub inline fn sk_ADMISSIONS_set(sk: anytype, idx: anytype, ptr: anytype) [*c]ADMISSIONS {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]ADMISSIONS, OPENSSL_sk_set(ossl_check_ADMISSIONS_sk_type(sk), idx, ossl_check_ADMISSIONS_type(ptr)));
}
pub inline fn sk_ADMISSIONS_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr));
}
pub inline fn sk_ADMISSIONS_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr));
}
pub inline fn sk_ADMISSIONS_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_type(ptr), pnum);
}
pub inline fn sk_ADMISSIONS_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_ADMISSIONS_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_ADMISSIONS_sk_type(sk));
}
pub inline fn sk_ADMISSIONS_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_ADMISSIONS_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_ADMISSIONS_sk_type(sk));
}
pub const sk_ADMISSIONS_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1407:9
pub const sk_ADMISSIONS_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1408:9
pub inline fn sk_ADMISSIONS_set_cmp_func(sk: anytype, cmp: anytype) sk_ADMISSIONS_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_ADMISSIONS_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_ADMISSIONS_sk_type(sk), ossl_check_ADMISSIONS_compfunc_type(cmp)));
}
pub inline fn sk_USERNOTICE_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_USERNOTICE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_USERNOTICE_sk_type(sk));
}
pub inline fn sk_USERNOTICE_value(sk: anytype, idx: anytype) [*c]USERNOTICE {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]USERNOTICE, OPENSSL_sk_value(ossl_check_const_USERNOTICE_sk_type(sk), idx));
}
pub const sk_USERNOTICE_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1472:9
pub const sk_USERNOTICE_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1473:9
pub const sk_USERNOTICE_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1474:9
pub inline fn sk_USERNOTICE_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_USERNOTICE_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_USERNOTICE_sk_type(sk), n);
}
pub inline fn sk_USERNOTICE_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_USERNOTICE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_USERNOTICE_sk_type(sk));
}
pub inline fn sk_USERNOTICE_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_USERNOTICE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_USERNOTICE_sk_type(sk));
}
pub inline fn sk_USERNOTICE_delete(sk: anytype, i: anytype) [*c]USERNOTICE {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]USERNOTICE, OPENSSL_sk_delete(ossl_check_USERNOTICE_sk_type(sk), i));
}
pub inline fn sk_USERNOTICE_delete_ptr(sk: anytype, ptr: anytype) [*c]USERNOTICE {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]USERNOTICE, OPENSSL_sk_delete_ptr(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr)));
}
pub inline fn sk_USERNOTICE_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr));
}
pub inline fn sk_USERNOTICE_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr));
}
pub inline fn sk_USERNOTICE_pop(sk: anytype) [*c]USERNOTICE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]USERNOTICE, OPENSSL_sk_pop(ossl_check_USERNOTICE_sk_type(sk)));
}
pub inline fn sk_USERNOTICE_shift(sk: anytype) [*c]USERNOTICE {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]USERNOTICE, OPENSSL_sk_shift(ossl_check_USERNOTICE_sk_type(sk)));
}
pub inline fn sk_USERNOTICE_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_freefunc_type(freefunc));
}
pub inline fn sk_USERNOTICE_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr), idx);
}
pub inline fn sk_USERNOTICE_set(sk: anytype, idx: anytype, ptr: anytype) [*c]USERNOTICE {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]USERNOTICE, OPENSSL_sk_set(ossl_check_USERNOTICE_sk_type(sk), idx, ossl_check_USERNOTICE_type(ptr)));
}
pub inline fn sk_USERNOTICE_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr));
}
pub inline fn sk_USERNOTICE_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr));
}
pub inline fn sk_USERNOTICE_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_type(ptr), pnum);
}
pub inline fn sk_USERNOTICE_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_USERNOTICE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_USERNOTICE_sk_type(sk));
}
pub inline fn sk_USERNOTICE_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_USERNOTICE_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_USERNOTICE_sk_type(sk));
}
pub const sk_USERNOTICE_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1492:9
pub const sk_USERNOTICE_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/x509v3.h:1493:9
pub inline fn sk_USERNOTICE_set_cmp_func(sk: anytype, cmp: anytype) sk_USERNOTICE_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_USERNOTICE_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_USERNOTICE_sk_type(sk), ossl_check_USERNOTICE_compfunc_type(cmp)));
}
pub const OPENSSL_OCSPERR_H = "";
pub const OCSP_R_CERTIFICATE_VERIFY_ERROR = @as(c_int, 101);
pub const OCSP_R_DIGEST_ERR = @as(c_int, 102);
pub const OCSP_R_DIGEST_NAME_ERR = @as(c_int, 106);
pub const OCSP_R_DIGEST_SIZE_ERR = @as(c_int, 107);
pub const OCSP_R_ERROR_IN_NEXTUPDATE_FIELD = @as(c_int, 122);
pub const OCSP_R_ERROR_IN_THISUPDATE_FIELD = @as(c_int, 123);
pub const OCSP_R_MISSING_OCSPSIGNING_USAGE = @as(c_int, 103);
pub const OCSP_R_NEXTUPDATE_BEFORE_THISUPDATE = @as(c_int, 124);
pub const OCSP_R_NOT_BASIC_RESPONSE = @as(c_int, 104);
pub const OCSP_R_NO_CERTIFICATES_IN_CHAIN = @as(c_int, 105);
pub const OCSP_R_NO_RESPONSE_DATA = @as(c_int, 108);
pub const OCSP_R_NO_REVOKED_TIME = @as(c_int, 109);
pub const OCSP_R_NO_SIGNER_KEY = @as(c_int, 130);
pub const OCSP_R_PRIVATE_KEY_DOES_NOT_MATCH_CERTIFICATE = @as(c_int, 110);
pub const OCSP_R_REQUEST_NOT_SIGNED = @as(c_int, 128);
pub const OCSP_R_RESPONSE_CONTAINS_NO_REVOCATION_DATA = @as(c_int, 111);
pub const OCSP_R_ROOT_CA_NOT_TRUSTED = @as(c_int, 112);
pub const OCSP_R_SIGNATURE_FAILURE = @as(c_int, 117);
pub const OCSP_R_SIGNER_CERTIFICATE_NOT_FOUND = @as(c_int, 118);
pub const OCSP_R_STATUS_EXPIRED = @as(c_int, 125);
pub const OCSP_R_STATUS_NOT_YET_VALID = @as(c_int, 126);
pub const OCSP_R_STATUS_TOO_OLD = @as(c_int, 127);
pub const OCSP_R_UNKNOWN_MESSAGE_DIGEST = @as(c_int, 119);
pub const OCSP_R_UNKNOWN_NID = @as(c_int, 120);
pub const OCSP_R_UNSUPPORTED_REQUESTORNAME_TYPE = @as(c_int, 129);
pub const OCSP_DEFAULT_NONCE_LENGTH = @as(c_int, 16);
pub const OCSP_NOCERTS = @as(c_int, 0x1);
pub const OCSP_NOINTERN = @as(c_int, 0x2);
pub const OCSP_NOSIGS = @as(c_int, 0x4);
pub const OCSP_NOCHAIN = @as(c_int, 0x8);
pub const OCSP_NOVERIFY = @as(c_int, 0x10);
pub const OCSP_NOEXPLICIT = @as(c_int, 0x20);
pub const OCSP_NOCASIGN = @as(c_int, 0x40);
pub const OCSP_NODELEGATED = @as(c_int, 0x80);
pub const OCSP_NOCHECKS = @as(c_int, 0x100);
pub const OCSP_TRUSTOTHER = @as(c_int, 0x200);
pub const OCSP_RESPID_KEY = @as(c_int, 0x400);
pub const OCSP_NOTIME = @as(c_int, 0x800);
pub const OCSP_PARTIAL_CHAIN = @as(c_int, 0x1000);
pub inline fn sk_OCSP_CERTID_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_OCSP_CERTID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_OCSP_CERTID_sk_type(sk));
}
pub inline fn sk_OCSP_CERTID_value(sk: anytype, idx: anytype) [*c]OCSP_CERTID {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]OCSP_CERTID, OPENSSL_sk_value(ossl_check_const_OCSP_CERTID_sk_type(sk), idx));
}
pub const sk_OCSP_CERTID_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:98:9
pub const sk_OCSP_CERTID_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:99:9
pub const sk_OCSP_CERTID_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:100:9
pub inline fn sk_OCSP_CERTID_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_OCSP_CERTID_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_OCSP_CERTID_sk_type(sk), n);
}
pub inline fn sk_OCSP_CERTID_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_OCSP_CERTID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_OCSP_CERTID_sk_type(sk));
}
pub inline fn sk_OCSP_CERTID_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_OCSP_CERTID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_OCSP_CERTID_sk_type(sk));
}
pub inline fn sk_OCSP_CERTID_delete(sk: anytype, i: anytype) [*c]OCSP_CERTID {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]OCSP_CERTID, OPENSSL_sk_delete(ossl_check_OCSP_CERTID_sk_type(sk), i));
}
pub inline fn sk_OCSP_CERTID_delete_ptr(sk: anytype, ptr: anytype) [*c]OCSP_CERTID {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OCSP_CERTID, OPENSSL_sk_delete_ptr(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr)));
}
pub inline fn sk_OCSP_CERTID_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr));
}
pub inline fn sk_OCSP_CERTID_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr));
}
pub inline fn sk_OCSP_CERTID_pop(sk: anytype) [*c]OCSP_CERTID {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]OCSP_CERTID, OPENSSL_sk_pop(ossl_check_OCSP_CERTID_sk_type(sk)));
}
pub inline fn sk_OCSP_CERTID_shift(sk: anytype) [*c]OCSP_CERTID {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]OCSP_CERTID, OPENSSL_sk_shift(ossl_check_OCSP_CERTID_sk_type(sk)));
}
pub inline fn sk_OCSP_CERTID_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_freefunc_type(freefunc));
}
pub inline fn sk_OCSP_CERTID_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr), idx);
}
pub inline fn sk_OCSP_CERTID_set(sk: anytype, idx: anytype, ptr: anytype) [*c]OCSP_CERTID {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OCSP_CERTID, OPENSSL_sk_set(ossl_check_OCSP_CERTID_sk_type(sk), idx, ossl_check_OCSP_CERTID_type(ptr)));
}
pub inline fn sk_OCSP_CERTID_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr));
}
pub inline fn sk_OCSP_CERTID_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr));
}
pub inline fn sk_OCSP_CERTID_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_type(ptr), pnum);
}
pub inline fn sk_OCSP_CERTID_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_OCSP_CERTID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_OCSP_CERTID_sk_type(sk));
}
pub inline fn sk_OCSP_CERTID_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_OCSP_CERTID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_OCSP_CERTID_sk_type(sk));
}
pub const sk_OCSP_CERTID_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:118:9
pub const sk_OCSP_CERTID_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:119:9
pub inline fn sk_OCSP_CERTID_set_cmp_func(sk: anytype, cmp: anytype) sk_OCSP_CERTID_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_OCSP_CERTID_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_OCSP_CERTID_sk_type(sk), ossl_check_OCSP_CERTID_compfunc_type(cmp)));
}
pub inline fn sk_OCSP_ONEREQ_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_OCSP_ONEREQ_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_OCSP_ONEREQ_sk_type(sk));
}
pub inline fn sk_OCSP_ONEREQ_value(sk: anytype, idx: anytype) [*c]OCSP_ONEREQ {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]OCSP_ONEREQ, OPENSSL_sk_value(ossl_check_const_OCSP_ONEREQ_sk_type(sk), idx));
}
pub const sk_OCSP_ONEREQ_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:124:9
pub const sk_OCSP_ONEREQ_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:125:9
pub const sk_OCSP_ONEREQ_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:126:9
pub inline fn sk_OCSP_ONEREQ_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_OCSP_ONEREQ_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_OCSP_ONEREQ_sk_type(sk), n);
}
pub inline fn sk_OCSP_ONEREQ_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_OCSP_ONEREQ_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_OCSP_ONEREQ_sk_type(sk));
}
pub inline fn sk_OCSP_ONEREQ_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_OCSP_ONEREQ_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_OCSP_ONEREQ_sk_type(sk));
}
pub inline fn sk_OCSP_ONEREQ_delete(sk: anytype, i: anytype) [*c]OCSP_ONEREQ {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]OCSP_ONEREQ, OPENSSL_sk_delete(ossl_check_OCSP_ONEREQ_sk_type(sk), i));
}
pub inline fn sk_OCSP_ONEREQ_delete_ptr(sk: anytype, ptr: anytype) [*c]OCSP_ONEREQ {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OCSP_ONEREQ, OPENSSL_sk_delete_ptr(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr)));
}
pub inline fn sk_OCSP_ONEREQ_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr));
}
pub inline fn sk_OCSP_ONEREQ_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr));
}
pub inline fn sk_OCSP_ONEREQ_pop(sk: anytype) [*c]OCSP_ONEREQ {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]OCSP_ONEREQ, OPENSSL_sk_pop(ossl_check_OCSP_ONEREQ_sk_type(sk)));
}
pub inline fn sk_OCSP_ONEREQ_shift(sk: anytype) [*c]OCSP_ONEREQ {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]OCSP_ONEREQ, OPENSSL_sk_shift(ossl_check_OCSP_ONEREQ_sk_type(sk)));
}
pub inline fn sk_OCSP_ONEREQ_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_freefunc_type(freefunc));
}
pub inline fn sk_OCSP_ONEREQ_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr), idx);
}
pub inline fn sk_OCSP_ONEREQ_set(sk: anytype, idx: anytype, ptr: anytype) [*c]OCSP_ONEREQ {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OCSP_ONEREQ, OPENSSL_sk_set(ossl_check_OCSP_ONEREQ_sk_type(sk), idx, ossl_check_OCSP_ONEREQ_type(ptr)));
}
pub inline fn sk_OCSP_ONEREQ_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr));
}
pub inline fn sk_OCSP_ONEREQ_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr));
}
pub inline fn sk_OCSP_ONEREQ_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_type(ptr), pnum);
}
pub inline fn sk_OCSP_ONEREQ_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_OCSP_ONEREQ_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_OCSP_ONEREQ_sk_type(sk));
}
pub inline fn sk_OCSP_ONEREQ_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_OCSP_ONEREQ_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_OCSP_ONEREQ_sk_type(sk));
}
pub const sk_OCSP_ONEREQ_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:144:9
pub const sk_OCSP_ONEREQ_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:145:9
pub inline fn sk_OCSP_ONEREQ_set_cmp_func(sk: anytype, cmp: anytype) sk_OCSP_ONEREQ_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_OCSP_ONEREQ_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_OCSP_ONEREQ_sk_type(sk), ossl_check_OCSP_ONEREQ_compfunc_type(cmp)));
}
pub const OCSP_RESPONSE_STATUS_SUCCESSFUL = @as(c_int, 0);
pub const OCSP_RESPONSE_STATUS_MALFORMEDREQUEST = @as(c_int, 1);
pub const OCSP_RESPONSE_STATUS_INTERNALERROR = @as(c_int, 2);
pub const OCSP_RESPONSE_STATUS_TRYLATER = @as(c_int, 3);
pub const OCSP_RESPONSE_STATUS_SIGREQUIRED = @as(c_int, 5);
pub const OCSP_RESPONSE_STATUS_UNAUTHORIZED = @as(c_int, 6);
pub const V_OCSP_RESPID_NAME = @as(c_int, 0);
pub const V_OCSP_RESPID_KEY = @as(c_int, 1);
pub inline fn sk_OCSP_RESPID_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_OCSP_RESPID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_OCSP_RESPID_sk_type(sk));
}
pub inline fn sk_OCSP_RESPID_value(sk: anytype, idx: anytype) [*c]OCSP_RESPID {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]OCSP_RESPID, OPENSSL_sk_value(ossl_check_const_OCSP_RESPID_sk_type(sk), idx));
}
pub const sk_OCSP_RESPID_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:164:9
pub const sk_OCSP_RESPID_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:165:9
pub const sk_OCSP_RESPID_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:166:9
pub inline fn sk_OCSP_RESPID_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_OCSP_RESPID_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_OCSP_RESPID_sk_type(sk), n);
}
pub inline fn sk_OCSP_RESPID_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_OCSP_RESPID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_OCSP_RESPID_sk_type(sk));
}
pub inline fn sk_OCSP_RESPID_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_OCSP_RESPID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_OCSP_RESPID_sk_type(sk));
}
pub inline fn sk_OCSP_RESPID_delete(sk: anytype, i: anytype) [*c]OCSP_RESPID {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]OCSP_RESPID, OPENSSL_sk_delete(ossl_check_OCSP_RESPID_sk_type(sk), i));
}
pub inline fn sk_OCSP_RESPID_delete_ptr(sk: anytype, ptr: anytype) [*c]OCSP_RESPID {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OCSP_RESPID, OPENSSL_sk_delete_ptr(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr)));
}
pub inline fn sk_OCSP_RESPID_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr));
}
pub inline fn sk_OCSP_RESPID_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr));
}
pub inline fn sk_OCSP_RESPID_pop(sk: anytype) [*c]OCSP_RESPID {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]OCSP_RESPID, OPENSSL_sk_pop(ossl_check_OCSP_RESPID_sk_type(sk)));
}
pub inline fn sk_OCSP_RESPID_shift(sk: anytype) [*c]OCSP_RESPID {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]OCSP_RESPID, OPENSSL_sk_shift(ossl_check_OCSP_RESPID_sk_type(sk)));
}
pub inline fn sk_OCSP_RESPID_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_freefunc_type(freefunc));
}
pub inline fn sk_OCSP_RESPID_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr), idx);
}
pub inline fn sk_OCSP_RESPID_set(sk: anytype, idx: anytype, ptr: anytype) [*c]OCSP_RESPID {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OCSP_RESPID, OPENSSL_sk_set(ossl_check_OCSP_RESPID_sk_type(sk), idx, ossl_check_OCSP_RESPID_type(ptr)));
}
pub inline fn sk_OCSP_RESPID_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr));
}
pub inline fn sk_OCSP_RESPID_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr));
}
pub inline fn sk_OCSP_RESPID_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_type(ptr), pnum);
}
pub inline fn sk_OCSP_RESPID_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_OCSP_RESPID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_OCSP_RESPID_sk_type(sk));
}
pub inline fn sk_OCSP_RESPID_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_OCSP_RESPID_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_OCSP_RESPID_sk_type(sk));
}
pub const sk_OCSP_RESPID_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:184:9
pub const sk_OCSP_RESPID_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:185:9
pub inline fn sk_OCSP_RESPID_set_cmp_func(sk: anytype, cmp: anytype) sk_OCSP_RESPID_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_OCSP_RESPID_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_OCSP_RESPID_sk_type(sk), ossl_check_OCSP_RESPID_compfunc_type(cmp)));
}
pub const V_OCSP_CERTSTATUS_GOOD = @as(c_int, 0);
pub const V_OCSP_CERTSTATUS_REVOKED = @as(c_int, 1);
pub const V_OCSP_CERTSTATUS_UNKNOWN = @as(c_int, 2);
pub inline fn sk_OCSP_SINGLERESP_num(sk: anytype) @TypeOf(OPENSSL_sk_num(ossl_check_const_OCSP_SINGLERESP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_num(ossl_check_const_OCSP_SINGLERESP_sk_type(sk));
}
pub inline fn sk_OCSP_SINGLERESP_value(sk: anytype, idx: anytype) [*c]OCSP_SINGLERESP {
    _ = &sk;
    _ = &idx;
    return @import("std").zig.c_translation.cast([*c]OCSP_SINGLERESP, OPENSSL_sk_value(ossl_check_const_OCSP_SINGLERESP_sk_type(sk), idx));
}
pub const sk_OCSP_SINGLERESP_new = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:201:9
pub const sk_OCSP_SINGLERESP_new_null = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:202:9
pub const sk_OCSP_SINGLERESP_new_reserve = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:203:9
pub inline fn sk_OCSP_SINGLERESP_reserve(sk: anytype, n: anytype) @TypeOf(OPENSSL_sk_reserve(ossl_check_OCSP_SINGLERESP_sk_type(sk), n)) {
    _ = &sk;
    _ = &n;
    return OPENSSL_sk_reserve(ossl_check_OCSP_SINGLERESP_sk_type(sk), n);
}
pub inline fn sk_OCSP_SINGLERESP_free(sk: anytype) @TypeOf(OPENSSL_sk_free(ossl_check_OCSP_SINGLERESP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_free(ossl_check_OCSP_SINGLERESP_sk_type(sk));
}
pub inline fn sk_OCSP_SINGLERESP_zero(sk: anytype) @TypeOf(OPENSSL_sk_zero(ossl_check_OCSP_SINGLERESP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_zero(ossl_check_OCSP_SINGLERESP_sk_type(sk));
}
pub inline fn sk_OCSP_SINGLERESP_delete(sk: anytype, i: anytype) [*c]OCSP_SINGLERESP {
    _ = &sk;
    _ = &i;
    return @import("std").zig.c_translation.cast([*c]OCSP_SINGLERESP, OPENSSL_sk_delete(ossl_check_OCSP_SINGLERESP_sk_type(sk), i));
}
pub inline fn sk_OCSP_SINGLERESP_delete_ptr(sk: anytype, ptr: anytype) [*c]OCSP_SINGLERESP {
    _ = &sk;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OCSP_SINGLERESP, OPENSSL_sk_delete_ptr(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr)));
}
pub inline fn sk_OCSP_SINGLERESP_push(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_push(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_push(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr));
}
pub inline fn sk_OCSP_SINGLERESP_unshift(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_unshift(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_unshift(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr));
}
pub inline fn sk_OCSP_SINGLERESP_pop(sk: anytype) [*c]OCSP_SINGLERESP {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]OCSP_SINGLERESP, OPENSSL_sk_pop(ossl_check_OCSP_SINGLERESP_sk_type(sk)));
}
pub inline fn sk_OCSP_SINGLERESP_shift(sk: anytype) [*c]OCSP_SINGLERESP {
    _ = &sk;
    return @import("std").zig.c_translation.cast([*c]OCSP_SINGLERESP, OPENSSL_sk_shift(ossl_check_OCSP_SINGLERESP_sk_type(sk)));
}
pub inline fn sk_OCSP_SINGLERESP_pop_free(sk: anytype, freefunc: anytype) @TypeOf(OPENSSL_sk_pop_free(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_freefunc_type(freefunc))) {
    _ = &sk;
    _ = &freefunc;
    return OPENSSL_sk_pop_free(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_freefunc_type(freefunc));
}
pub inline fn sk_OCSP_SINGLERESP_insert(sk: anytype, ptr: anytype, idx: anytype) @TypeOf(OPENSSL_sk_insert(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr), idx)) {
    _ = &sk;
    _ = &ptr;
    _ = &idx;
    return OPENSSL_sk_insert(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr), idx);
}
pub inline fn sk_OCSP_SINGLERESP_set(sk: anytype, idx: anytype, ptr: anytype) [*c]OCSP_SINGLERESP {
    _ = &sk;
    _ = &idx;
    _ = &ptr;
    return @import("std").zig.c_translation.cast([*c]OCSP_SINGLERESP, OPENSSL_sk_set(ossl_check_OCSP_SINGLERESP_sk_type(sk), idx, ossl_check_OCSP_SINGLERESP_type(ptr)));
}
pub inline fn sk_OCSP_SINGLERESP_find(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr));
}
pub inline fn sk_OCSP_SINGLERESP_find_ex(sk: anytype, ptr: anytype) @TypeOf(OPENSSL_sk_find_ex(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr))) {
    _ = &sk;
    _ = &ptr;
    return OPENSSL_sk_find_ex(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr));
}
pub inline fn sk_OCSP_SINGLERESP_find_all(sk: anytype, ptr: anytype, pnum: anytype) @TypeOf(OPENSSL_sk_find_all(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr), pnum)) {
    _ = &sk;
    _ = &ptr;
    _ = &pnum;
    return OPENSSL_sk_find_all(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_type(ptr), pnum);
}
pub inline fn sk_OCSP_SINGLERESP_sort(sk: anytype) @TypeOf(OPENSSL_sk_sort(ossl_check_OCSP_SINGLERESP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_sort(ossl_check_OCSP_SINGLERESP_sk_type(sk));
}
pub inline fn sk_OCSP_SINGLERESP_is_sorted(sk: anytype) @TypeOf(OPENSSL_sk_is_sorted(ossl_check_const_OCSP_SINGLERESP_sk_type(sk))) {
    _ = &sk;
    return OPENSSL_sk_is_sorted(ossl_check_const_OCSP_SINGLERESP_sk_type(sk));
}
pub const sk_OCSP_SINGLERESP_dup = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:221:9
pub const sk_OCSP_SINGLERESP_deep_copy = @compileError("unable to translate C expr: unexpected token ')'");
// /usr/include/openssl/ocsp.h:222:9
pub inline fn sk_OCSP_SINGLERESP_set_cmp_func(sk: anytype, cmp: anytype) sk_OCSP_SINGLERESP_compfunc {
    _ = &sk;
    _ = &cmp;
    return @import("std").zig.c_translation.cast(sk_OCSP_SINGLERESP_compfunc, OPENSSL_sk_set_cmp_func(ossl_check_OCSP_SINGLERESP_sk_type(sk), ossl_check_OCSP_SINGLERESP_compfunc_type(cmp)));
}
pub const PEM_STRING_OCSP_REQUEST = "OCSP REQUEST";
pub const PEM_STRING_OCSP_RESPONSE = "OCSP RESPONSE";
pub inline fn d2i_OCSP_REQUEST_bio(bp: anytype, p: anytype) @TypeOf(ASN1_d2i_bio_of(OCSP_REQUEST, OCSP_REQUEST_new, d2i_OCSP_REQUEST, bp, p)) {
    _ = &bp;
    _ = &p;
    return ASN1_d2i_bio_of(OCSP_REQUEST, OCSP_REQUEST_new, d2i_OCSP_REQUEST, bp, p);
}
pub inline fn d2i_OCSP_RESPONSE_bio(bp: anytype, p: anytype) @TypeOf(ASN1_d2i_bio_of(OCSP_RESPONSE, OCSP_RESPONSE_new, d2i_OCSP_RESPONSE, bp, p)) {
    _ = &bp;
    _ = &p;
    return ASN1_d2i_bio_of(OCSP_RESPONSE, OCSP_RESPONSE_new, d2i_OCSP_RESPONSE, bp, p);
}
pub const PEM_read_bio_OCSP_REQUEST = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/ocsp.h:240:11
pub const PEM_read_bio_OCSP_RESPONSE = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/ocsp.h:244:11
pub const PEM_write_bio_OCSP_REQUEST = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/ocsp.h:248:11
pub const PEM_write_bio_OCSP_RESPONSE = @compileError("unable to translate C expr: expected ')' instead got '('");
// /usr/include/openssl/ocsp.h:252:11
pub inline fn i2d_OCSP_RESPONSE_bio(bp: anytype, o: anytype) @TypeOf(ASN1_i2d_bio_of(OCSP_RESPONSE, i2d_OCSP_RESPONSE, bp, o)) {
    _ = &bp;
    _ = &o;
    return ASN1_i2d_bio_of(OCSP_RESPONSE, i2d_OCSP_RESPONSE, bp, o);
}
pub inline fn i2d_OCSP_REQUEST_bio(bp: anytype, o: anytype) @TypeOf(ASN1_i2d_bio_of(OCSP_REQUEST, i2d_OCSP_REQUEST, bp, o)) {
    _ = &bp;
    _ = &o;
    return ASN1_i2d_bio_of(OCSP_REQUEST, i2d_OCSP_REQUEST, bp, o);
}
pub inline fn ASN1_BIT_STRING_digest(data: anytype, @"type": anytype, md: anytype, len: anytype) @TypeOf(ASN1_item_digest(ASN1_ITEM_rptr(ASN1_BIT_STRING), @"type", data, md, len)) {
    _ = &data;
    _ = &@"type";
    _ = &md;
    _ = &len;
    return ASN1_item_digest(ASN1_ITEM_rptr(ASN1_BIT_STRING), @"type", data, md, len);
}
pub inline fn OCSP_CERTSTATUS_dup(cs: anytype) [*c]OCSP_CERTSTATUS {
    _ = &cs;
    return @import("std").zig.c_translation.cast([*c]OCSP_CERTSTATUS, ASN1_dup(@import("std").zig.c_translation.cast([*c]i2d_of_void, i2d_OCSP_CERTSTATUS), @import("std").zig.c_translation.cast([*c]d2i_of_void, d2i_OCSP_CERTSTATUS), @import("std").zig.c_translation.cast([*c]u8, cs)));
}
pub inline fn OCSP_REQ_CTX_new(io: anytype, buf_size: anytype) @TypeOf(OSSL_HTTP_REQ_CTX_new(io, io, buf_size)) {
    _ = &io;
    _ = &buf_size;
    return OSSL_HTTP_REQ_CTX_new(io, io, buf_size);
}
pub const OCSP_REQ_CTX_free = OSSL_HTTP_REQ_CTX_free;
pub inline fn OCSP_REQ_CTX_http(rctx: anytype, op: anytype, path: anytype) @TypeOf((OSSL_HTTP_REQ_CTX_set_expected(rctx, NULL, @as(c_int, 1), @as(c_int, 0), @as(c_int, 0)) != 0) and (OSSL_HTTP_REQ_CTX_set_request_line(rctx, strcmp(op, "POST") == @as(c_int, 0), NULL, NULL, path) != 0)) {
    _ = &rctx;
    _ = &op;
    _ = &path;
    return (OSSL_HTTP_REQ_CTX_set_expected(rctx, NULL, @as(c_int, 1), @as(c_int, 0), @as(c_int, 0)) != 0) and (OSSL_HTTP_REQ_CTX_set_request_line(rctx, strcmp(op, "POST") == @as(c_int, 0), NULL, NULL, path) != 0);
}
pub const OCSP_REQ_CTX_add1_header = OSSL_HTTP_REQ_CTX_add1_header;
pub inline fn OCSP_REQ_CTX_i2d(r: anytype, it: anytype, req: anytype) @TypeOf(OSSL_HTTP_REQ_CTX_set1_req(r, "application/ocsp-request", it, req)) {
    _ = &r;
    _ = &it;
    _ = &req;
    return OSSL_HTTP_REQ_CTX_set1_req(r, "application/ocsp-request", it, req);
}
pub inline fn OCSP_REQ_CTX_set1_req(r: anytype, req: anytype) @TypeOf(OCSP_REQ_CTX_i2d(r, ASN1_ITEM_rptr(OCSP_REQUEST), @import("std").zig.c_translation.cast([*c]ASN1_VALUE, req))) {
    _ = &r;
    _ = &req;
    return OCSP_REQ_CTX_i2d(r, ASN1_ITEM_rptr(OCSP_REQUEST), @import("std").zig.c_translation.cast([*c]ASN1_VALUE, req));
}
pub const OCSP_REQ_CTX_nbio = OSSL_HTTP_REQ_CTX_nbio;
pub const OCSP_REQ_CTX_nbio_d2i = OSSL_HTTP_REQ_CTX_nbio_d2i;
pub const OCSP_sendreq_nbio = @compileError("unable to translate C expr: expected ')' instead got '*'");
// /usr/include/openssl/ocsp.h:289:12
pub const OCSP_REQ_CTX_get0_mem_bio = OSSL_HTTP_REQ_CTX_get0_mem_bio;
pub const OCSP_set_max_response_length = OSSL_HTTP_REQ_CTX_set_max_response_length;
pub inline fn OCSP_parse_url(url: anytype, host: anytype, port: anytype, path: anytype, ssl: anytype) @TypeOf(OSSL_HTTP_parse_url(url, ssl, NULL, host, port, NULL, path, NULL, NULL)) {
    _ = &url;
    _ = &host;
    _ = &port;
    _ = &path;
    _ = &ssl;
    return OSSL_HTTP_parse_url(url, ssl, NULL, host, port, NULL, path, NULL, NULL);
}
pub const NGX_SSL_NAME = "OpenSSL";
pub inline fn ngx_ssl_version() @TypeOf(OpenSSL_version(OPENSSL_VERSION)) {
    return OpenSSL_version(OPENSSL_VERSION);
}
pub const ngx_ssl_session_t = SSL_SESSION;
pub const ngx_ssl_conn_t = SSL;
pub const NGX_SSL_NO_SCACHE = -@as(c_int, 2);
pub const NGX_SSL_NONE_SCACHE = -@as(c_int, 3);
pub const NGX_SSL_NO_BUILTIN_SCACHE = -@as(c_int, 4);
pub const NGX_SSL_DFLT_BUILTIN_SCACHE = -@as(c_int, 5);
pub const NGX_SSL_MAX_SESSION_SIZE = @as(c_int, 4096);
pub const NGX_SSL_SSLv2 = @as(c_int, 0x0002);
pub const NGX_SSL_SSLv3 = @as(c_int, 0x0004);
pub const NGX_SSL_TLSv1 = @as(c_int, 0x0008);
pub const NGX_SSL_TLSv1_1 = @as(c_int, 0x0010);
pub const NGX_SSL_TLSv1_2 = @as(c_int, 0x0020);
pub const NGX_SSL_TLSv1_3 = @as(c_int, 0x0040);
pub const NGX_SSL_DEFAULT_PROTOCOLS = NGX_SSL_TLSv1_2 | NGX_SSL_TLSv1_3;
pub const NGX_SSL_BUFFER = @as(c_int, 1);
pub const NGX_SSL_CLIENT = @as(c_int, 2);
pub const NGX_SSL_BUFSIZE = @as(c_int, 16384);
pub const NGX_SSL_CACHE_CERT = @as(c_int, 0);
pub const NGX_SSL_CACHE_PKEY = @as(c_int, 1);
pub const NGX_SSL_CACHE_CRL = @as(c_int, 2);
pub const NGX_SSL_CACHE_CA = @as(c_int, 3);
pub const ngx_ssl_free_session = SSL_SESSION_free;
pub inline fn ngx_ssl_get_connection(ssl_conn: anytype) @TypeOf(SSL_get_ex_data(ssl_conn, ngx_ssl_connection_index)) {
    _ = &ssl_conn;
    return SSL_get_ex_data(ssl_conn, ngx_ssl_connection_index);
}
pub inline fn ngx_ssl_get_server_conf(ssl_ctx: anytype) @TypeOf(SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_server_conf_index)) {
    _ = &ssl_ctx;
    return SSL_CTX_get_ex_data(ssl_ctx, ngx_ssl_server_conf_index);
}
pub inline fn ngx_ssl_verify_error_optional(n: anytype) @TypeOf(((((n == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT) or (n == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN)) or (n == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)) or (n == X509_V_ERR_CERT_UNTRUSTED)) or (n == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE)) {
    _ = &n;
    return ((((n == X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT) or (n == X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN)) or (n == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)) or (n == X509_V_ERR_CERT_UNTRUSTED)) or (n == X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE);
}
pub const _NGX_PROCESS_CYCLE_H_INCLUDED_ = "";
pub const NGX_CMD_OPEN_CHANNEL = @as(c_int, 1);
pub const NGX_CMD_CLOSE_CHANNEL = @as(c_int, 2);
pub const NGX_CMD_QUIT = @as(c_int, 3);
pub const NGX_CMD_TERMINATE = @as(c_int, 4);
pub const NGX_CMD_REOPEN = @as(c_int, 5);
pub const NGX_PROCESS_SINGLE = @as(c_int, 0);
pub const NGX_PROCESS_MASTER = @as(c_int, 1);
pub const NGX_PROCESS_SIGNALLER = @as(c_int, 2);
pub const NGX_PROCESS_WORKER = @as(c_int, 3);
pub const NGX_PROCESS_HELPER = @as(c_int, 4);
pub const _NGX_CONF_FILE_H_INCLUDED_ = "";
pub const NGX_CONF_NOARGS = @as(c_int, 0x00000001);
pub const NGX_CONF_TAKE1 = @as(c_int, 0x00000002);
pub const NGX_CONF_TAKE2 = @as(c_int, 0x00000004);
pub const NGX_CONF_TAKE3 = @as(c_int, 0x00000008);
pub const NGX_CONF_TAKE4 = @as(c_int, 0x00000010);
pub const NGX_CONF_TAKE5 = @as(c_int, 0x00000020);
pub const NGX_CONF_TAKE6 = @as(c_int, 0x00000040);
pub const NGX_CONF_TAKE7 = @as(c_int, 0x00000080);
pub const NGX_CONF_MAX_ARGS = @as(c_int, 8);
pub const NGX_CONF_TAKE12 = NGX_CONF_TAKE1 | NGX_CONF_TAKE2;
pub const NGX_CONF_TAKE13 = NGX_CONF_TAKE1 | NGX_CONF_TAKE3;
pub const NGX_CONF_TAKE23 = NGX_CONF_TAKE2 | NGX_CONF_TAKE3;
pub const NGX_CONF_TAKE123 = (NGX_CONF_TAKE1 | NGX_CONF_TAKE2) | NGX_CONF_TAKE3;
pub const NGX_CONF_TAKE1234 = ((NGX_CONF_TAKE1 | NGX_CONF_TAKE2) | NGX_CONF_TAKE3) | NGX_CONF_TAKE4;
pub const NGX_CONF_ARGS_NUMBER = @as(c_int, 0x000000ff);
pub const NGX_CONF_BLOCK = @as(c_int, 0x00000100);
pub const NGX_CONF_FLAG = @as(c_int, 0x00000200);
pub const NGX_CONF_ANY = @as(c_int, 0x00000400);
pub const NGX_CONF_1MORE = @as(c_int, 0x00000800);
pub const NGX_CONF_2MORE = @as(c_int, 0x00001000);
pub const NGX_DIRECT_CONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00010000, .hex);
pub const NGX_MAIN_CONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x01000000, .hex);
pub const NGX_ANY_CONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xFF000000, .hex);
pub const NGX_CONF_UNSET = -@as(c_int, 1);
pub const NGX_CONF_UNSET_UINT = @import("std").zig.c_translation.cast(ngx_uint_t, -@as(c_int, 1));
pub const NGX_CONF_UNSET_PTR = @import("std").zig.c_translation.cast(?*anyopaque, -@as(c_int, 1));
pub const NGX_CONF_UNSET_SIZE = @import("std").zig.c_translation.cast(usize, -@as(c_int, 1));
pub const NGX_CONF_UNSET_MSEC = @import("std").zig.c_translation.cast(ngx_msec_t, -@as(c_int, 1));
pub const NGX_CONF_OK = NULL;
pub const NGX_CONF_ERROR = @import("std").zig.c_translation.cast(?*anyopaque, -@as(c_int, 1));
pub const NGX_CONF_BLOCK_START = @as(c_int, 1);
pub const NGX_CONF_BLOCK_DONE = @as(c_int, 2);
pub const NGX_CONF_FILE_DONE = @as(c_int, 3);
pub const NGX_CORE_MODULE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x45524F43, .hex);
pub const NGX_CONF_MODULE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x464E4F43, .hex);
pub const NGX_MAX_CONF_ERRSTR = @as(c_int, 1024);
pub const ngx_null_command = @compileError("unable to translate C expr: unexpected token '{'");
// src/core/ngx_conf_file.h:86:9
pub const NGX_CONF_BITMASK_SET = @as(c_int, 1);
pub inline fn ngx_get_conf(conf_ctx: anytype, module: anytype) @TypeOf(conf_ctx[@as(usize, @intCast(module.index))]) {
    _ = &conf_ctx;
    _ = &module;
    return conf_ctx[@as(usize, @intCast(module.index))];
}
pub const ngx_conf_init_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:180:9
pub const ngx_conf_init_ptr_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:185:9
pub const ngx_conf_init_uint_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:190:9
pub const ngx_conf_init_size_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:195:9
pub const ngx_conf_init_msec_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:200:9
pub const ngx_conf_merge_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:205:9
pub const ngx_conf_merge_ptr_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:210:9
pub const ngx_conf_merge_uint_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:215:9
pub const ngx_conf_merge_msec_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:220:9
pub const ngx_conf_merge_sec_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:225:9
pub const ngx_conf_merge_size_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:230:9
pub const ngx_conf_merge_off_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:235:9
pub const ngx_conf_merge_str_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:240:9
pub const ngx_conf_merge_bufs_value = @compileError("unable to translate C expr: unexpected token 'if'");
// src/core/ngx_conf_file.h:251:9
pub const ngx_conf_merge_bitmask_value = @compileError("unable to translate C expr: expected ')' instead got 'default'");
// src/core/ngx_conf_file.h:262:9
pub const _NGX_MODULE_H_INCLUDED_ = "";
pub const _NGINX_H_INCLUDED_ = "";
pub const nginx_version = @import("std").zig.c_translation.promoteIntLiteral(c_int, 1027004, .decimal);
pub const NGINX_VERSION = "1.27.4";
pub const NGINX_VER = "nginx/" ++ NGINX_VERSION;
pub const NGINX_VER_BUILD = NGINX_VER;
pub const NGINX_VAR = "NGINX";
pub const NGX_OLDPID_EXT = ".oldbin";
pub const NGX_MODULE_UNSET_INDEX = @import("std").zig.c_translation.cast(ngx_uint_t, -@as(c_int, 1));
pub const NGX_MODULE_SIGNATURE_0 = ngx_value(NGX_PTR_SIZE) ++ "," ++ ngx_value(NGX_SIG_ATOMIC_T_SIZE) ++ "," ++ ngx_value(NGX_TIME_T_SIZE) ++ ",";
pub const NGX_MODULE_SIGNATURE_1 = "0";
pub const NGX_MODULE_SIGNATURE_2 = "0";
pub const NGX_MODULE_SIGNATURE_3 = "0";
pub const NGX_MODULE_SIGNATURE_4 = "0";
pub const NGX_MODULE_SIGNATURE_5 = "1";
pub const NGX_MODULE_SIGNATURE_6 = "1";
pub const NGX_MODULE_SIGNATURE_7 = "1";
pub const NGX_MODULE_SIGNATURE_8 = "1";
pub const NGX_MODULE_SIGNATURE_9 = "1";
pub const NGX_MODULE_SIGNATURE_10 = "1";
pub const NGX_MODULE_SIGNATURE_11 = "0";
pub const NGX_MODULE_SIGNATURE_12 = "1";
pub const NGX_MODULE_SIGNATURE_13 = "0";
pub const NGX_MODULE_SIGNATURE_14 = "1";
pub const NGX_MODULE_SIGNATURE_15 = "1";
pub const NGX_MODULE_SIGNATURE_16 = "1";
pub const NGX_MODULE_SIGNATURE_17 = "0";
pub const NGX_MODULE_SIGNATURE_18 = "0";
pub const NGX_MODULE_SIGNATURE_19 = "1";
pub const NGX_MODULE_SIGNATURE_20 = "1";
pub const NGX_MODULE_SIGNATURE_21 = "1";
pub const NGX_MODULE_SIGNATURE_22 = "0";
pub const NGX_MODULE_SIGNATURE_23 = "1";
pub const NGX_MODULE_SIGNATURE_24 = "1";
pub const NGX_MODULE_SIGNATURE_25 = "1";
pub const NGX_MODULE_SIGNATURE_26 = "1";
pub const NGX_MODULE_SIGNATURE_27 = "1";
pub const NGX_MODULE_SIGNATURE_28 = "1";
pub const NGX_MODULE_SIGNATURE_29 = "0";
pub const NGX_MODULE_SIGNATURE_30 = "0";
pub const NGX_MODULE_SIGNATURE_31 = "0";
pub const NGX_MODULE_SIGNATURE_32 = "1";
pub const NGX_MODULE_SIGNATURE_33 = "1";
pub const NGX_MODULE_SIGNATURE_34 = "0";
pub const NGX_MODULE_SIGNATURE = NGX_MODULE_SIGNATURE_0 ++ NGX_MODULE_SIGNATURE_1 ++ NGX_MODULE_SIGNATURE_2 ++ NGX_MODULE_SIGNATURE_3 ++ NGX_MODULE_SIGNATURE_4 ++ NGX_MODULE_SIGNATURE_5 ++ NGX_MODULE_SIGNATURE_6 ++ NGX_MODULE_SIGNATURE_7 ++ NGX_MODULE_SIGNATURE_8 ++ NGX_MODULE_SIGNATURE_9 ++ NGX_MODULE_SIGNATURE_10 ++ NGX_MODULE_SIGNATURE_11 ++ NGX_MODULE_SIGNATURE_12 ++ NGX_MODULE_SIGNATURE_13 ++ NGX_MODULE_SIGNATURE_14 ++ NGX_MODULE_SIGNATURE_15 ++ NGX_MODULE_SIGNATURE_16 ++ NGX_MODULE_SIGNATURE_17 ++ NGX_MODULE_SIGNATURE_18 ++ NGX_MODULE_SIGNATURE_19 ++ NGX_MODULE_SIGNATURE_20 ++ NGX_MODULE_SIGNATURE_21 ++ NGX_MODULE_SIGNATURE_22 ++ NGX_MODULE_SIGNATURE_23 ++ NGX_MODULE_SIGNATURE_24 ++ NGX_MODULE_SIGNATURE_25 ++ NGX_MODULE_SIGNATURE_26 ++ NGX_MODULE_SIGNATURE_27 ++ NGX_MODULE_SIGNATURE_28 ++ NGX_MODULE_SIGNATURE_29 ++ NGX_MODULE_SIGNATURE_30 ++ NGX_MODULE_SIGNATURE_31 ++ NGX_MODULE_SIGNATURE_32 ++ NGX_MODULE_SIGNATURE_33 ++ NGX_MODULE_SIGNATURE_34;
pub const NGX_MODULE_V1 = blk: {
    _ = &NGX_MODULE_UNSET_INDEX;
    _ = &NGX_MODULE_UNSET_INDEX;
    _ = &NULL;
    _ = @as(c_int, 0);
    _ = @as(c_int, 0);
    _ = &nginx_version;
    break :blk NGX_MODULE_SIGNATURE;
};
pub const NGX_MODULE_V1_PADDING = blk: {
    _ = @as(c_int, 0);
    _ = @as(c_int, 0);
    _ = @as(c_int, 0);
    _ = @as(c_int, 0);
    _ = @as(c_int, 0);
    _ = @as(c_int, 0);
    _ = @as(c_int, 0);
    break :blk @as(c_int, 0);
};
pub const _NGX_OPEN_FILE_CACHE_H_INCLUDED_ = "";
pub const NGX_OPEN_FILE_DIRECTIO_OFF = NGX_MAX_OFF_T_VALUE;
pub const _NGX_OS_H_INCLUDED_ = "";
pub const NGX_IO_SENDFILE = @as(c_int, 1);
pub const NGX_IOVS_PREALLOCATE = @as(c_int, 64);
pub const _NGX_LINUX_H_INCLUDED_ = "";
pub const _NGX_CONNECTION_H_INCLUDED_ = "";
pub const NGX_LOWLEVEL_BUFFERED = @as(c_int, 0x0f);
pub const NGX_SSL_BUFFERED = @as(c_int, 0x01);
pub const NGX_HTTP_V2_BUFFERED = @as(c_int, 0x02);
pub const ngx_set_connection_log = @compileError("unable to translate C expr: unexpected token '='");
// src/core/ngx_connection.h:206:9
pub const _NGX_SYSLOG_H_INCLUDED_ = "";
pub const _NGX_PROXY_PROTOCOL_H_INCLUDED_ = "";
pub const NGX_PROXY_PROTOCOL_V1_MAX_HEADER = @as(c_int, 107);
pub const NGX_PROXY_PROTOCOL_MAX_HEADER = @as(c_int, 4096);
pub const _NGX_BPF_H_INCLUDED_ = "";
pub const __LINUX_BPF_H__ = "";
pub const __LINUX_BPF_COMMON_H__ = "";
pub inline fn BPF_CLASS(code: anytype) @TypeOf(code & @as(c_int, 0x07)) {
    _ = &code;
    return code & @as(c_int, 0x07);
}
pub const BPF_LD = @as(c_int, 0x00);
pub const BPF_LDX = @as(c_int, 0x01);
pub const BPF_ST = @as(c_int, 0x02);
pub const BPF_STX = @as(c_int, 0x03);
pub const BPF_ALU = @as(c_int, 0x04);
pub const BPF_JMP = @as(c_int, 0x05);
pub const BPF_RET = @as(c_int, 0x06);
pub const BPF_MISC = @as(c_int, 0x07);
pub inline fn BPF_SIZE(code: anytype) @TypeOf(code & @as(c_int, 0x18)) {
    _ = &code;
    return code & @as(c_int, 0x18);
}
pub const BPF_W = @as(c_int, 0x00);
pub const BPF_H = @as(c_int, 0x08);
pub const BPF_B = @as(c_int, 0x10);
pub inline fn BPF_MODE(code: anytype) @TypeOf(code & @as(c_int, 0xe0)) {
    _ = &code;
    return code & @as(c_int, 0xe0);
}
pub const BPF_IMM = @as(c_int, 0x00);
pub const BPF_ABS = @as(c_int, 0x20);
pub const BPF_IND = @as(c_int, 0x40);
pub const BPF_MEM = @as(c_int, 0x60);
pub const BPF_LEN = @as(c_int, 0x80);
pub const BPF_MSH = @as(c_int, 0xa0);
pub inline fn BPF_OP(code: anytype) @TypeOf(code & @as(c_int, 0xf0)) {
    _ = &code;
    return code & @as(c_int, 0xf0);
}
pub const BPF_ADD = @as(c_int, 0x00);
pub const BPF_SUB = @as(c_int, 0x10);
pub const BPF_MUL = @as(c_int, 0x20);
pub const BPF_DIV = @as(c_int, 0x30);
pub const BPF_OR = @as(c_int, 0x40);
pub const BPF_AND = @as(c_int, 0x50);
pub const BPF_LSH = @as(c_int, 0x60);
pub const BPF_RSH = @as(c_int, 0x70);
pub const BPF_NEG = @as(c_int, 0x80);
pub const BPF_MOD = @as(c_int, 0x90);
pub const BPF_XOR = @as(c_int, 0xa0);
pub const BPF_JA = @as(c_int, 0x00);
pub const BPF_JEQ = @as(c_int, 0x10);
pub const BPF_JGT = @as(c_int, 0x20);
pub const BPF_JGE = @as(c_int, 0x30);
pub const BPF_JSET = @as(c_int, 0x40);
pub inline fn BPF_SRC(code: anytype) @TypeOf(code & @as(c_int, 0x08)) {
    _ = &code;
    return code & @as(c_int, 0x08);
}
pub const BPF_K = @as(c_int, 0x00);
pub const BPF_X = @as(c_int, 0x08);
pub const BPF_MAXINSNS = @as(c_int, 4096);
pub const BPF_JMP32 = @as(c_int, 0x06);
pub const BPF_ALU64 = @as(c_int, 0x07);
pub const BPF_DW = @as(c_int, 0x18);
pub const BPF_MEMSX = @as(c_int, 0x80);
pub const BPF_ATOMIC = @as(c_int, 0xc0);
pub const BPF_XADD = @as(c_int, 0xc0);
pub const BPF_MOV = @as(c_int, 0xb0);
pub const BPF_ARSH = @as(c_int, 0xc0);
pub const BPF_END = @as(c_int, 0xd0);
pub const BPF_TO_LE = @as(c_int, 0x00);
pub const BPF_TO_BE = @as(c_int, 0x08);
pub const BPF_FROM_LE = BPF_TO_LE;
pub const BPF_FROM_BE = BPF_TO_BE;
pub const BPF_JNE = @as(c_int, 0x50);
pub const BPF_JLT = @as(c_int, 0xa0);
pub const BPF_JLE = @as(c_int, 0xb0);
pub const BPF_JSGT = @as(c_int, 0x60);
pub const BPF_JSGE = @as(c_int, 0x70);
pub const BPF_JSLT = @as(c_int, 0xc0);
pub const BPF_JSLE = @as(c_int, 0xd0);
pub const BPF_JCOND = @as(c_int, 0xe0);
pub const BPF_CALL = @as(c_int, 0x80);
pub const BPF_EXIT = @as(c_int, 0x90);
pub const BPF_FETCH = @as(c_int, 0x01);
pub const BPF_XCHG = @as(c_int, 0xe0) | BPF_FETCH;
pub const BPF_CMPXCHG = @as(c_int, 0xf0) | BPF_FETCH;
pub const MAX_BPF_REG = __MAX_BPF_REG;
pub const MAX_BPF_ATTACH_TYPE = __MAX_BPF_ATTACH_TYPE;
pub const MAX_BPF_LINK_TYPE = __MAX_BPF_LINK_TYPE;
pub const BPF_F_ALLOW_OVERRIDE = @as(c_uint, 1) << @as(c_int, 0);
pub const BPF_F_ALLOW_MULTI = @as(c_uint, 1) << @as(c_int, 1);
pub const BPF_F_REPLACE = @as(c_uint, 1) << @as(c_int, 2);
pub const BPF_F_BEFORE = @as(c_uint, 1) << @as(c_int, 3);
pub const BPF_F_AFTER = @as(c_uint, 1) << @as(c_int, 4);
pub const BPF_F_ID = @as(c_uint, 1) << @as(c_int, 5);
pub const BPF_F_STRICT_ALIGNMENT = @as(c_uint, 1) << @as(c_int, 0);
pub const BPF_F_ANY_ALIGNMENT = @as(c_uint, 1) << @as(c_int, 1);
pub const BPF_F_TEST_RND_HI32 = @as(c_uint, 1) << @as(c_int, 2);
pub const BPF_F_TEST_STATE_FREQ = @as(c_uint, 1) << @as(c_int, 3);
pub const BPF_F_SLEEPABLE = @as(c_uint, 1) << @as(c_int, 4);
pub const BPF_F_XDP_HAS_FRAGS = @as(c_uint, 1) << @as(c_int, 5);
pub const BPF_F_XDP_DEV_BOUND_ONLY = @as(c_uint, 1) << @as(c_int, 6);
pub const BPF_F_TEST_REG_INVARIANTS = @as(c_uint, 1) << @as(c_int, 7);
pub const BPF_F_NETFILTER_IP_DEFRAG = @as(c_uint, 1) << @as(c_int, 0);
pub const BPF_PSEUDO_MAP_FD = @as(c_int, 1);
pub const BPF_PSEUDO_MAP_IDX = @as(c_int, 5);
pub const BPF_PSEUDO_MAP_VALUE = @as(c_int, 2);
pub const BPF_PSEUDO_MAP_IDX_VALUE = @as(c_int, 6);
pub const BPF_PSEUDO_BTF_ID = @as(c_int, 3);
pub const BPF_PSEUDO_FUNC = @as(c_int, 4);
pub const BPF_PSEUDO_CALL = @as(c_int, 1);
pub const BPF_PSEUDO_KFUNC_CALL = @as(c_int, 2);
pub const BPF_F_QUERY_EFFECTIVE = @as(c_uint, 1) << @as(c_int, 0);
pub const BPF_F_TEST_RUN_ON_CPU = @as(c_uint, 1) << @as(c_int, 0);
pub const BPF_F_TEST_XDP_LIVE_FRAMES = @as(c_uint, 1) << @as(c_int, 1);
pub const BPF_BUILD_ID_SIZE = @as(c_int, 20);
pub const BPF_OBJ_NAME_LEN = @as(c_uint, 16);
pub const ___BPF_FUNC_MAPPER = @compileError("unable to translate C expr: expected ')' instead got '...'");
// /usr/include/linux/bpf.h:5794:9
pub const __BPF_FUNC_MAPPER_APPLY = @compileError("unable to translate C expr: unexpected token ''");
// /usr/include/linux/bpf.h:6012:9
pub inline fn __BPF_FUNC_MAPPER(FN: anytype) @TypeOf(___BPF_FUNC_MAPPER(__BPF_FUNC_MAPPER_APPLY, FN)) {
    _ = &FN;
    return ___BPF_FUNC_MAPPER(__BPF_FUNC_MAPPER_APPLY, FN);
}
pub const __BPF_ENUM_FN = @compileError("unable to translate macro: undefined identifier `BPF_FUNC_`");
// /usr/include/linux/bpf.h:6018:9
pub inline fn BPF_F_ADJ_ROOM_ENCAP_L2(len: anytype) @TypeOf((@import("std").zig.c_translation.cast(__u64, len) & BPF_ADJ_ROOM_ENCAP_L2_MASK) << BPF_ADJ_ROOM_ENCAP_L2_SHIFT) {
    _ = &len;
    return (@import("std").zig.c_translation.cast(__u64, len) & BPF_ADJ_ROOM_ENCAP_L2_MASK) << BPF_ADJ_ROOM_ENCAP_L2_SHIFT;
}
pub const __bpf_md_ptr = @compileError("unable to translate macro: undefined identifier `aligned`");
// /usr/include/linux/bpf.h:6204:9
pub const XDP_PACKET_HEADROOM = @as(c_int, 256);
pub const BPF_TAG_SIZE = @as(c_int, 8);
pub inline fn BPF_LINE_INFO_LINE_NUM(line_col: anytype) @TypeOf(line_col >> @as(c_int, 10)) {
    _ = &line_col;
    return line_col >> @as(c_int, 10);
}
pub inline fn BPF_LINE_INFO_LINE_COL(line_col: anytype) @TypeOf(line_col & @as(c_int, 0x3ff)) {
    _ = &line_col;
    return line_col & @as(c_int, 0x3ff);
}
pub const LF = @import("std").zig.c_translation.cast(u_char, '\n');
pub const CR = @import("std").zig.c_translation.cast(u_char, '\r');
pub const CRLF = "\r\n";
pub inline fn ngx_abs(value: anytype) @TypeOf(if (value >= @as(c_int, 0)) value else -value) {
    _ = &value;
    return if (value >= @as(c_int, 0)) value else -value;
}
pub inline fn ngx_max(val1: anytype, val2: anytype) @TypeOf(if (val1 < val2) val2 else val1) {
    _ = &val1;
    _ = &val2;
    return if (val1 < val2) val2 else val1;
}
pub inline fn ngx_min(val1: anytype, val2: anytype) @TypeOf(if (val1 > val2) val2 else val1) {
    _ = &val1;
    _ = &val2;
    return if (val1 > val2) val2 else val1;
}
pub const NGX_DISABLE_SYMLINKS_OFF = @as(c_int, 0);
pub const NGX_DISABLE_SYMLINKS_ON = @as(c_int, 1);
pub const NGX_DISABLE_SYMLINKS_NOTOWNER = @as(c_int, 2);
pub const _NGX_HTTP_VARIABLES_H_INCLUDED_ = "";
pub const ngx_http_variable = @compileError("unable to translate C expr: unexpected token '{'");
// src/http/ngx_http_variables.h:19:9
pub const NGX_HTTP_VAR_CHANGEABLE = @as(c_int, 1);
pub const NGX_HTTP_VAR_NOCACHEABLE = @as(c_int, 2);
pub const NGX_HTTP_VAR_INDEXED = @as(c_int, 4);
pub const NGX_HTTP_VAR_NOHASH = @as(c_int, 8);
pub const NGX_HTTP_VAR_WEAK = @as(c_int, 16);
pub const NGX_HTTP_VAR_PREFIX = @as(c_int, 32);
pub const ngx_http_null_variable = @compileError("unable to translate C expr: unexpected token '{'");
// src/http/ngx_http_variables.h:46:9
pub const _NGX_HTTP_CONFIG_H_INCLUDED_ = "";
pub const NGX_HTTP_MODULE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x50545448, .hex);
pub const NGX_HTTP_MAIN_CONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x02000000, .hex);
pub const NGX_HTTP_SRV_CONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x04000000, .hex);
pub const NGX_HTTP_LOC_CONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x08000000, .hex);
pub const NGX_HTTP_UPS_CONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x10000000, .hex);
pub const NGX_HTTP_SIF_CONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x20000000, .hex);
pub const NGX_HTTP_LIF_CONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hex);
pub const NGX_HTTP_LMT_CONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
pub const NGX_HTTP_MAIN_CONF_OFFSET = @compileError("unable to translate macro: undefined identifier `main_conf`");
// src/http/ngx_http_config.h:50:9
pub const NGX_HTTP_SRV_CONF_OFFSET = @compileError("unable to translate macro: undefined identifier `srv_conf`");
// src/http/ngx_http_config.h:51:9
pub const NGX_HTTP_LOC_CONF_OFFSET = @compileError("unable to translate macro: undefined identifier `loc_conf`");
// src/http/ngx_http_config.h:52:9
pub inline fn ngx_http_get_module_main_conf(r: anytype, module: anytype) @TypeOf(r.*.main_conf[@as(usize, @intCast(module.ctx_index))]) {
    _ = &r;
    _ = &module;
    return r.*.main_conf[@as(usize, @intCast(module.ctx_index))];
}
pub inline fn ngx_http_get_module_srv_conf(r: anytype, module: anytype) @TypeOf(r.*.srv_conf[@as(usize, @intCast(module.ctx_index))]) {
    _ = &r;
    _ = &module;
    return r.*.srv_conf[@as(usize, @intCast(module.ctx_index))];
}
pub inline fn ngx_http_get_module_loc_conf(r: anytype, module: anytype) @TypeOf(r.*.loc_conf[@as(usize, @intCast(module.ctx_index))]) {
    _ = &r;
    _ = &module;
    return r.*.loc_conf[@as(usize, @intCast(module.ctx_index))];
}
pub inline fn ngx_http_conf_get_module_main_conf(cf: anytype, module: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]ngx_http_conf_ctx_t, cf.*.ctx).*.main_conf[@as(usize, @intCast(module.ctx_index))]) {
    _ = &cf;
    _ = &module;
    return @import("std").zig.c_translation.cast([*c]ngx_http_conf_ctx_t, cf.*.ctx).*.main_conf[@as(usize, @intCast(module.ctx_index))];
}
pub inline fn ngx_http_conf_get_module_srv_conf(cf: anytype, module: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]ngx_http_conf_ctx_t, cf.*.ctx).*.srv_conf[@as(usize, @intCast(module.ctx_index))]) {
    _ = &cf;
    _ = &module;
    return @import("std").zig.c_translation.cast([*c]ngx_http_conf_ctx_t, cf.*.ctx).*.srv_conf[@as(usize, @intCast(module.ctx_index))];
}
pub inline fn ngx_http_conf_get_module_loc_conf(cf: anytype, module: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]ngx_http_conf_ctx_t, cf.*.ctx).*.loc_conf[@as(usize, @intCast(module.ctx_index))]) {
    _ = &cf;
    _ = &module;
    return @import("std").zig.c_translation.cast([*c]ngx_http_conf_ctx_t, cf.*.ctx).*.loc_conf[@as(usize, @intCast(module.ctx_index))];
}
pub inline fn ngx_http_cycle_get_module_main_conf(cycle: anytype, module: anytype) @TypeOf(if (cycle.*.conf_ctx[@as(usize, @intCast(ngx_http_module.index))]) @import("std").zig.c_translation.cast([*c]ngx_http_conf_ctx_t, cycle.*.conf_ctx[@as(usize, @intCast(ngx_http_module.index))]).*.main_conf[@as(usize, @intCast(module.ctx_index))] else NULL) {
    _ = &cycle;
    _ = &module;
    return if (cycle.*.conf_ctx[@as(usize, @intCast(ngx_http_module.index))]) @import("std").zig.c_translation.cast([*c]ngx_http_conf_ctx_t, cycle.*.conf_ctx[@as(usize, @intCast(ngx_http_module.index))]).*.main_conf[@as(usize, @intCast(module.ctx_index))] else NULL;
}
pub const _NGX_HTTP_REQUEST_H_INCLUDED_ = "";
pub const NGX_HTTP_MAX_URI_CHANGES = @as(c_int, 10);
pub const NGX_HTTP_MAX_SUBREQUESTS = @as(c_int, 50);
pub const NGX_HTTP_LC_HEADER_LEN = @as(c_int, 32);
pub const NGX_HTTP_DISCARD_BUFFER_SIZE = @as(c_int, 4096);
pub const NGX_HTTP_LINGERING_BUFFER_SIZE = @as(c_int, 4096);
pub const NGX_HTTP_VERSION_9 = @as(c_int, 9);
pub const NGX_HTTP_VERSION_10 = @as(c_int, 1000);
pub const NGX_HTTP_VERSION_11 = @as(c_int, 1001);
pub const NGX_HTTP_VERSION_20 = @as(c_int, 2000);
pub const NGX_HTTP_VERSION_30 = @as(c_int, 3000);
pub const NGX_HTTP_UNKNOWN = @as(c_int, 0x00000001);
pub const NGX_HTTP_GET = @as(c_int, 0x00000002);
pub const NGX_HTTP_HEAD = @as(c_int, 0x00000004);
pub const NGX_HTTP_POST = @as(c_int, 0x00000008);
pub const NGX_HTTP_PUT = @as(c_int, 0x00000010);
pub const NGX_HTTP_DELETE = @as(c_int, 0x00000020);
pub const NGX_HTTP_MKCOL = @as(c_int, 0x00000040);
pub const NGX_HTTP_COPY = @as(c_int, 0x00000080);
pub const NGX_HTTP_MOVE = @as(c_int, 0x00000100);
pub const NGX_HTTP_OPTIONS = @as(c_int, 0x00000200);
pub const NGX_HTTP_PROPFIND = @as(c_int, 0x00000400);
pub const NGX_HTTP_PROPPATCH = @as(c_int, 0x00000800);
pub const NGX_HTTP_LOCK = @as(c_int, 0x00001000);
pub const NGX_HTTP_UNLOCK = @as(c_int, 0x00002000);
pub const NGX_HTTP_PATCH = @as(c_int, 0x00004000);
pub const NGX_HTTP_TRACE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00008000, .hex);
pub const NGX_HTTP_CONNECT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x00010000, .hex);
pub const NGX_HTTP_CONNECTION_CLOSE = @as(c_int, 1);
pub const NGX_HTTP_CONNECTION_KEEP_ALIVE = @as(c_int, 2);
pub const NGX_NONE = @as(c_int, 1);
pub const NGX_HTTP_PARSE_HEADER_DONE = @as(c_int, 1);
pub const NGX_HTTP_CLIENT_ERROR = @as(c_int, 10);
pub const NGX_HTTP_PARSE_INVALID_METHOD = @as(c_int, 10);
pub const NGX_HTTP_PARSE_INVALID_REQUEST = @as(c_int, 11);
pub const NGX_HTTP_PARSE_INVALID_VERSION = @as(c_int, 12);
pub const NGX_HTTP_PARSE_INVALID_09_METHOD = @as(c_int, 13);
pub const NGX_HTTP_PARSE_INVALID_HEADER = @as(c_int, 14);
pub const NGX_HTTP_SUBREQUEST_IN_MEMORY = @as(c_int, 2);
pub const NGX_HTTP_SUBREQUEST_WAITED = @as(c_int, 4);
pub const NGX_HTTP_SUBREQUEST_CLONE = @as(c_int, 8);
pub const NGX_HTTP_SUBREQUEST_BACKGROUND = @as(c_int, 16);
pub const NGX_HTTP_LOG_UNSAFE = @as(c_int, 1);
pub const NGX_HTTP_CONTINUE = @as(c_int, 100);
pub const NGX_HTTP_SWITCHING_PROTOCOLS = @as(c_int, 101);
pub const NGX_HTTP_PROCESSING = @as(c_int, 102);
pub const NGX_HTTP_OK = @as(c_int, 200);
pub const NGX_HTTP_CREATED = @as(c_int, 201);
pub const NGX_HTTP_ACCEPTED = @as(c_int, 202);
pub const NGX_HTTP_NO_CONTENT = @as(c_int, 204);
pub const NGX_HTTP_PARTIAL_CONTENT = @as(c_int, 206);
pub const NGX_HTTP_SPECIAL_RESPONSE = @as(c_int, 300);
pub const NGX_HTTP_MOVED_PERMANENTLY = @as(c_int, 301);
pub const NGX_HTTP_MOVED_TEMPORARILY = @as(c_int, 302);
pub const NGX_HTTP_SEE_OTHER = @as(c_int, 303);
pub const NGX_HTTP_NOT_MODIFIED = @as(c_int, 304);
pub const NGX_HTTP_TEMPORARY_REDIRECT = @as(c_int, 307);
pub const NGX_HTTP_PERMANENT_REDIRECT = @as(c_int, 308);
pub const NGX_HTTP_BAD_REQUEST = @as(c_int, 400);
pub const NGX_HTTP_UNAUTHORIZED = @as(c_int, 401);
pub const NGX_HTTP_FORBIDDEN = @as(c_int, 403);
pub const NGX_HTTP_NOT_FOUND = @as(c_int, 404);
pub const NGX_HTTP_NOT_ALLOWED = @as(c_int, 405);
pub const NGX_HTTP_REQUEST_TIME_OUT = @as(c_int, 408);
pub const NGX_HTTP_CONFLICT = @as(c_int, 409);
pub const NGX_HTTP_LENGTH_REQUIRED = @as(c_int, 411);
pub const NGX_HTTP_PRECONDITION_FAILED = @as(c_int, 412);
pub const NGX_HTTP_REQUEST_ENTITY_TOO_LARGE = @as(c_int, 413);
pub const NGX_HTTP_REQUEST_URI_TOO_LARGE = @as(c_int, 414);
pub const NGX_HTTP_UNSUPPORTED_MEDIA_TYPE = @as(c_int, 415);
pub const NGX_HTTP_RANGE_NOT_SATISFIABLE = @as(c_int, 416);
pub const NGX_HTTP_MISDIRECTED_REQUEST = @as(c_int, 421);
pub const NGX_HTTP_TOO_MANY_REQUESTS = @as(c_int, 429);
pub const NGX_HTTP_CLOSE = @as(c_int, 444);
pub const NGX_HTTP_NGINX_CODES = @as(c_int, 494);
pub const NGX_HTTP_REQUEST_HEADER_TOO_LARGE = @as(c_int, 494);
pub const NGX_HTTPS_CERT_ERROR = @as(c_int, 495);
pub const NGX_HTTPS_NO_CERT = @as(c_int, 496);
pub const NGX_HTTP_TO_HTTPS = @as(c_int, 497);
pub const NGX_HTTP_CLIENT_CLOSED_REQUEST = @as(c_int, 499);
pub const NGX_HTTP_INTERNAL_SERVER_ERROR = @as(c_int, 500);
pub const NGX_HTTP_NOT_IMPLEMENTED = @as(c_int, 501);
pub const NGX_HTTP_BAD_GATEWAY = @as(c_int, 502);
pub const NGX_HTTP_SERVICE_UNAVAILABLE = @as(c_int, 503);
pub const NGX_HTTP_GATEWAY_TIME_OUT = @as(c_int, 504);
pub const NGX_HTTP_VERSION_NOT_SUPPORTED = @as(c_int, 505);
pub const NGX_HTTP_INSUFFICIENT_STORAGE = @as(c_int, 507);
pub const NGX_HTTP_LOWLEVEL_BUFFERED = @as(c_int, 0xf0);
pub const NGX_HTTP_WRITE_BUFFERED = @as(c_int, 0x10);
pub const NGX_HTTP_GZIP_BUFFERED = @as(c_int, 0x20);
pub const NGX_HTTP_SSI_BUFFERED = @as(c_int, 0x01);
pub const NGX_HTTP_SUB_BUFFERED = @as(c_int, 0x02);
pub const NGX_HTTP_COPY_BUFFERED = @as(c_int, 0x04);
pub inline fn ngx_http_ephemeral(r: anytype) ?*anyopaque {
    _ = &r;
    return @import("std").zig.c_translation.cast(?*anyopaque, &r.*.uri_start);
}
pub const ngx_http_set_log_request = @compileError("unable to translate C expr: unexpected token '='");
// src/http/ngx_http_request.h:619:9
pub const _NGX_HTTP_SCRIPT_H_INCLUDED_ = "";
pub const _NGX_HTTP_UPSTREAM_H_INCLUDED_ = "";
pub const _NGX_EVENT_H_INCLUDED_ = "";
pub const NGX_INVALID_INDEX = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0xd0d0d0d0, .hex);
pub const NGX_USE_LEVEL_EVENT = @as(c_int, 0x00000001);
pub const NGX_USE_ONESHOT_EVENT = @as(c_int, 0x00000002);
pub const NGX_USE_CLEAR_EVENT = @as(c_int, 0x00000004);
pub const NGX_USE_KQUEUE_EVENT = @as(c_int, 0x00000008);
pub const NGX_USE_LOWAT_EVENT = @as(c_int, 0x00000010);
pub const NGX_USE_GREEDY_EVENT = @as(c_int, 0x00000020);
pub const NGX_USE_EPOLL_EVENT = @as(c_int, 0x00000040);
pub const NGX_USE_RTSIG_EVENT = @as(c_int, 0x00000080);
pub const NGX_USE_AIO_EVENT = @as(c_int, 0x00000100);
pub const NGX_USE_IOCP_EVENT = @as(c_int, 0x00000200);
pub const NGX_USE_FD_EVENT = @as(c_int, 0x00000400);
pub const NGX_USE_TIMER_EVENT = @as(c_int, 0x00000800);
pub const NGX_USE_EVENTPORT_EVENT = @as(c_int, 0x00001000);
pub const NGX_USE_VNODE_EVENT = @as(c_int, 0x00002000);
pub const NGX_CLOSE_EVENT = @as(c_int, 1);
pub const NGX_DISABLE_EVENT = @as(c_int, 2);
pub const NGX_FLUSH_EVENT = @as(c_int, 4);
pub const NGX_LOWAT_EVENT = @as(c_int, 0);
pub const NGX_VNODE_EVENT = @as(c_int, 0);
pub const NGX_READ_EVENT = EPOLLIN | EPOLLRDHUP;
pub const NGX_WRITE_EVENT = EPOLLOUT;
pub const NGX_LEVEL_EVENT = @as(c_int, 0);
pub const NGX_CLEAR_EVENT = EPOLLET;
pub const NGX_ONESHOT_EVENT = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x70000000, .hex);
pub const NGX_EXCLUSIVE_EVENT = EPOLLEXCLUSIVE;
pub inline fn ngx_process_events(arg_260: [*c]ngx_cycle_t, arg_261: ngx_msec_t, arg_262: ngx_uint_t) ngx_int_t {
    return ngx_event_actions.process_events.?(arg_260, arg_261, arg_262);
}
pub inline fn ngx_done_events(arg_263: [*c]ngx_cycle_t) void {
    return ngx_event_actions.done.?(arg_263);
}
pub inline fn ngx_add_event(arg_264: [*c]ngx_event_t, arg_265: ngx_int_t, arg_266: ngx_uint_t) ngx_int_t {
    return ngx_event_actions.add.?(arg_264, arg_265, arg_266);
}
pub inline fn ngx_del_event(arg_267: [*c]ngx_event_t, arg_268: ngx_int_t, arg_269: ngx_uint_t) ngx_int_t {
    return ngx_event_actions.del.?(arg_267, arg_268, arg_269);
}
pub inline fn ngx_add_conn(arg_270: [*c]ngx_connection_t) ngx_int_t {
    return ngx_event_actions.add_conn.?(arg_270);
}
pub inline fn ngx_del_conn(arg_271: [*c]ngx_connection_t, arg_272: ngx_uint_t) ngx_int_t {
    return ngx_event_actions.del_conn.?(arg_271, arg_272);
}
pub inline fn ngx_notify(arg_273: ngx_event_handler_pt) ngx_int_t {
    return ngx_event_actions.notify.?(arg_273);
}
pub const ngx_add_timer = @compileError("unable to translate macro: undefined identifier `ngx_event_add_timer`");
// src/event/ngx_event.h:410:9
pub const ngx_del_timer = @compileError("unable to translate macro: undefined identifier `ngx_event_del_timer`");
// src/event/ngx_event.h:411:9
pub inline fn ngx_recv(arg_274: [*c]ngx_connection_t, arg_275: [*c]u_char, arg_276: usize) isize {
    return ngx_io.recv.?(arg_274, arg_275, arg_276);
}
pub inline fn ngx_recv_chain(arg_277: [*c]ngx_connection_t, arg_278: [*c]ngx_chain_t, arg_279: off_t) isize {
    return ngx_io.recv_chain.?(arg_277, arg_278, arg_279);
}
pub inline fn ngx_udp_recv(arg_280: [*c]ngx_connection_t, arg_281: [*c]u_char, arg_282: usize) isize {
    return ngx_io.udp_recv.?(arg_280, arg_281, arg_282);
}
pub inline fn ngx_send(arg_283: [*c]ngx_connection_t, arg_284: [*c]u_char, arg_285: usize) isize {
    return ngx_io.send.?(arg_283, arg_284, arg_285);
}
pub inline fn ngx_send_chain(arg_286: [*c]ngx_connection_t, arg_287: [*c]ngx_chain_t, arg_288: off_t) [*c]ngx_chain_t {
    return ngx_io.send_chain.?(arg_286, arg_287, arg_288);
}
pub inline fn ngx_udp_send(arg_289: [*c]ngx_connection_t, arg_290: [*c]u_char, arg_291: usize) isize {
    return ngx_io.udp_send.?(arg_289, arg_290, arg_291);
}
pub inline fn ngx_udp_send_chain(arg_292: [*c]ngx_connection_t, arg_293: [*c]ngx_chain_t, arg_294: off_t) [*c]ngx_chain_t {
    return ngx_io.udp_send_chain.?(arg_292, arg_293, arg_294);
}
pub const NGX_EVENT_MODULE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x544E5645, .hex);
pub const NGX_EVENT_CONF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x02000000, .hex);
pub const NGX_UPDATE_TIME = @as(c_int, 1);
pub const NGX_POST_EVENTS = @as(c_int, 2);
pub inline fn ngx_event_get_conf(conf_ctx: anytype, module: anytype) @TypeOf(ngx_get_conf(conf_ctx, ngx_events_module).*[@as(usize, @intCast(module.ctx_index))]) {
    _ = &conf_ctx;
    _ = &module;
    return ngx_get_conf(conf_ctx, ngx_events_module).*[@as(usize, @intCast(module.ctx_index))];
}
pub inline fn ngx_event_ident(p: anytype) @TypeOf(@import("std").zig.c_translation.cast([*c]ngx_connection_t, p).*.fd) {
    _ = &p;
    return @import("std").zig.c_translation.cast([*c]ngx_connection_t, p).*.fd;
}
pub const _NGX_EVENT_TIMER_H_INCLUDED_ = "";
pub const NGX_TIMER_INFINITE = @import("std").zig.c_translation.cast(ngx_msec_t, -@as(c_int, 1));
pub const NGX_TIMER_LAZY_DELAY = @as(c_int, 300);
pub const _NGX_EVENT_POSTED_H_INCLUDED_ = "";
pub const ngx_post_event = @compileError("unable to translate C expr: unexpected token 'if'");
// src/event/ngx_event_posted.h:17:9
pub const ngx_delete_posted_event = @compileError("unable to translate C expr: unexpected token '='");
// src/event/ngx_event_posted.h:31:9
pub const _NGX_EVENT_UDP_H_INCLUDED_ = "";
pub const NGX_HAVE_ADDRINFO_CMSG = @as(c_int, 1);
pub const _NGX_EVENT_CONNECT_H_INCLUDED_ = "";
pub const NGX_PEER_KEEPALIVE = @as(c_int, 1);
pub const NGX_PEER_NEXT = @as(c_int, 2);
pub const NGX_PEER_FAILED = @as(c_int, 4);
pub const _NGX_EVENT_PIPE_H_INCLUDED_ = "";
pub const NGX_HTTP_UPSTREAM_FT_ERROR = @as(c_int, 0x00000002);
pub const NGX_HTTP_UPSTREAM_FT_TIMEOUT = @as(c_int, 0x00000004);
pub const NGX_HTTP_UPSTREAM_FT_INVALID_HEADER = @as(c_int, 0x00000008);
pub const NGX_HTTP_UPSTREAM_FT_HTTP_500 = @as(c_int, 0x00000010);
pub const NGX_HTTP_UPSTREAM_FT_HTTP_502 = @as(c_int, 0x00000020);
pub const NGX_HTTP_UPSTREAM_FT_HTTP_503 = @as(c_int, 0x00000040);
pub const NGX_HTTP_UPSTREAM_FT_HTTP_504 = @as(c_int, 0x00000080);
pub const NGX_HTTP_UPSTREAM_FT_HTTP_403 = @as(c_int, 0x00000100);
pub const NGX_HTTP_UPSTREAM_FT_HTTP_404 = @as(c_int, 0x00000200);
pub const NGX_HTTP_UPSTREAM_FT_HTTP_429 = @as(c_int, 0x00000400);
pub const NGX_HTTP_UPSTREAM_FT_UPDATING = @as(c_int, 0x00000800);
pub const NGX_HTTP_UPSTREAM_FT_BUSY_LOCK = @as(c_int, 0x00001000);
pub const NGX_HTTP_UPSTREAM_FT_MAX_WAITING = @as(c_int, 0x00002000);
pub const NGX_HTTP_UPSTREAM_FT_NON_IDEMPOTENT = @as(c_int, 0x00004000);
pub const NGX_HTTP_UPSTREAM_FT_NOLIVE = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x40000000, .hex);
pub const NGX_HTTP_UPSTREAM_FT_OFF = @import("std").zig.c_translation.promoteIntLiteral(c_int, 0x80000000, .hex);
pub const NGX_HTTP_UPSTREAM_FT_STATUS = (((((NGX_HTTP_UPSTREAM_FT_HTTP_500 | NGX_HTTP_UPSTREAM_FT_HTTP_502) | NGX_HTTP_UPSTREAM_FT_HTTP_503) | NGX_HTTP_UPSTREAM_FT_HTTP_504) | NGX_HTTP_UPSTREAM_FT_HTTP_403) | NGX_HTTP_UPSTREAM_FT_HTTP_404) | NGX_HTTP_UPSTREAM_FT_HTTP_429;
pub const NGX_HTTP_UPSTREAM_INVALID_HEADER = @as(c_int, 40);
pub const NGX_HTTP_UPSTREAM_IGN_XA_REDIRECT = @as(c_int, 0x00000002);
pub const NGX_HTTP_UPSTREAM_IGN_XA_EXPIRES = @as(c_int, 0x00000004);
pub const NGX_HTTP_UPSTREAM_IGN_EXPIRES = @as(c_int, 0x00000008);
pub const NGX_HTTP_UPSTREAM_IGN_CACHE_CONTROL = @as(c_int, 0x00000010);
pub const NGX_HTTP_UPSTREAM_IGN_SET_COOKIE = @as(c_int, 0x00000020);
pub const NGX_HTTP_UPSTREAM_IGN_XA_LIMIT_RATE = @as(c_int, 0x00000040);
pub const NGX_HTTP_UPSTREAM_IGN_XA_BUFFERING = @as(c_int, 0x00000080);
pub const NGX_HTTP_UPSTREAM_IGN_XA_CHARSET = @as(c_int, 0x00000100);
pub const NGX_HTTP_UPSTREAM_IGN_VARY = @as(c_int, 0x00000200);
pub const NGX_HTTP_UPSTREAM_CREATE = @as(c_int, 0x0001);
pub const NGX_HTTP_UPSTREAM_WEIGHT = @as(c_int, 0x0002);
pub const NGX_HTTP_UPSTREAM_MAX_FAILS = @as(c_int, 0x0004);
pub const NGX_HTTP_UPSTREAM_FAIL_TIMEOUT = @as(c_int, 0x0008);
pub const NGX_HTTP_UPSTREAM_DOWN = @as(c_int, 0x0010);
pub const NGX_HTTP_UPSTREAM_BACKUP = @as(c_int, 0x0020);
pub const NGX_HTTP_UPSTREAM_MODIFY = @as(c_int, 0x0040);
pub const NGX_HTTP_UPSTREAM_MAX_CONNS = @as(c_int, 0x0100);
pub inline fn ngx_http_conf_upstream_srv_conf(uscf: anytype, module: anytype) @TypeOf(uscf.*.srv_conf[@as(usize, @intCast(module.ctx_index))]) {
    _ = &uscf;
    _ = &module;
    return uscf.*.srv_conf[@as(usize, @intCast(module.ctx_index))];
}
pub const _NGX_HTTP_UPSTREAM_ROUND_ROBIN_H_INCLUDED_ = "";
pub const ngx_http_upstream_rr_peers_rlock = @compileError("unable to translate C expr: unexpected token 'if'");
// src/http/ngx_http_upstream_round_robin.h:107:9
pub const ngx_http_upstream_rr_peers_wlock = @compileError("unable to translate C expr: unexpected token 'if'");
// src/http/ngx_http_upstream_round_robin.h:113:9
pub const ngx_http_upstream_rr_peers_unlock = @compileError("unable to translate C expr: unexpected token 'if'");
// src/http/ngx_http_upstream_round_robin.h:119:9
pub const ngx_http_upstream_rr_peer_lock = @compileError("unable to translate C expr: unexpected token 'if'");
// src/http/ngx_http_upstream_round_robin.h:126:9
pub const ngx_http_upstream_rr_peer_unlock = @compileError("unable to translate C expr: unexpected token 'if'");
// src/http/ngx_http_upstream_round_robin.h:132:9
pub const ngx_http_upstream_rr_peer_ref = @compileError("TODO postfix inc/dec expr");
// src/http/ngx_http_upstream_round_robin.h:139:9
pub const _NGX_HTTP_CORE_H_INCLUDED_ = "";
pub const NGX_HTTP_GZIP_PROXIED_OFF = @as(c_int, 0x0002);
pub const NGX_HTTP_GZIP_PROXIED_EXPIRED = @as(c_int, 0x0004);
pub const NGX_HTTP_GZIP_PROXIED_NO_CACHE = @as(c_int, 0x0008);
pub const NGX_HTTP_GZIP_PROXIED_NO_STORE = @as(c_int, 0x0010);
pub const NGX_HTTP_GZIP_PROXIED_PRIVATE = @as(c_int, 0x0020);
pub const NGX_HTTP_GZIP_PROXIED_NO_LM = @as(c_int, 0x0040);
pub const NGX_HTTP_GZIP_PROXIED_NO_ETAG = @as(c_int, 0x0080);
pub const NGX_HTTP_GZIP_PROXIED_AUTH = @as(c_int, 0x0100);
pub const NGX_HTTP_GZIP_PROXIED_ANY = @as(c_int, 0x0200);
pub const NGX_HTTP_AIO_OFF = @as(c_int, 0);
pub const NGX_HTTP_AIO_ON = @as(c_int, 1);
pub const NGX_HTTP_AIO_THREADS = @as(c_int, 2);
pub const NGX_HTTP_SATISFY_ALL = @as(c_int, 0);
pub const NGX_HTTP_SATISFY_ANY = @as(c_int, 1);
pub const NGX_HTTP_LINGERING_OFF = @as(c_int, 0);
pub const NGX_HTTP_LINGERING_ON = @as(c_int, 1);
pub const NGX_HTTP_LINGERING_ALWAYS = @as(c_int, 2);
pub const NGX_HTTP_IMS_OFF = @as(c_int, 0);
pub const NGX_HTTP_IMS_EXACT = @as(c_int, 1);
pub const NGX_HTTP_IMS_BEFORE = @as(c_int, 2);
pub const NGX_HTTP_KEEPALIVE_DISABLE_NONE = @as(c_int, 0x0002);
pub const NGX_HTTP_KEEPALIVE_DISABLE_MSIE6 = @as(c_int, 0x0004);
pub const NGX_HTTP_KEEPALIVE_DISABLE_SAFARI = @as(c_int, 0x0008);
pub const NGX_HTTP_SERVER_TOKENS_OFF = @as(c_int, 0);
pub const NGX_HTTP_SERVER_TOKENS_ON = @as(c_int, 1);
pub const NGX_HTTP_SERVER_TOKENS_BUILD = @as(c_int, 2);
pub const ngx_http_clear_content_length = @compileError("unable to translate C expr: unexpected token '='");
// src/http/ngx_http_core_module.h:553:9
pub const ngx_http_clear_accept_ranges = @compileError("unable to translate C expr: unexpected token '='");
// src/http/ngx_http_core_module.h:561:9
pub const ngx_http_clear_last_modified = @compileError("unable to translate C expr: unexpected token '='");
// src/http/ngx_http_core_module.h:569:9
pub const ngx_http_clear_location = @compileError("unable to translate C expr: unexpected token 'if'");
// src/http/ngx_http_core_module.h:577:9
pub const ngx_http_clear_etag = @compileError("unable to translate C expr: unexpected token 'if'");
// src/http/ngx_http_core_module.h:584:9
pub const _NGX_HTTP_CACHE_H_INCLUDED_ = "";
pub const NGX_HTTP_CACHE_MISS = @as(c_int, 1);
pub const NGX_HTTP_CACHE_BYPASS = @as(c_int, 2);
pub const NGX_HTTP_CACHE_EXPIRED = @as(c_int, 3);
pub const NGX_HTTP_CACHE_STALE = @as(c_int, 4);
pub const NGX_HTTP_CACHE_UPDATING = @as(c_int, 5);
pub const NGX_HTTP_CACHE_REVALIDATED = @as(c_int, 6);
pub const NGX_HTTP_CACHE_HIT = @as(c_int, 7);
pub const NGX_HTTP_CACHE_SCARCE = @as(c_int, 8);
pub const NGX_HTTP_CACHE_KEY_LEN = @as(c_int, 16);
pub const NGX_HTTP_CACHE_ETAG_LEN = @as(c_int, 128);
pub const NGX_HTTP_CACHE_VARY_LEN = @as(c_int, 128);
pub const NGX_HTTP_CACHE_VERSION = @as(c_int, 5);
pub const _NGX_HTTP_SSI_FILTER_H_INCLUDED_ = "";
pub const NGX_HTTP_SSI_MAX_PARAMS = @as(c_int, 16);
pub const NGX_HTTP_SSI_COMMAND_LEN = @as(c_int, 32);
pub const NGX_HTTP_SSI_PARAM_LEN = @as(c_int, 32);
pub const NGX_HTTP_SSI_PARAMS_N = @as(c_int, 4);
pub const NGX_HTTP_SSI_COND_IF = @as(c_int, 1);
pub const NGX_HTTP_SSI_COND_ELSE = @as(c_int, 2);
pub const NGX_HTTP_SSI_NO_ENCODING = @as(c_int, 0);
pub const NGX_HTTP_SSI_URL_ENCODING = @as(c_int, 1);
pub const NGX_HTTP_SSI_ENTITY_ENCODING = @as(c_int, 2);
pub const _NGX_HTTP_SSL_H_INCLUDED_ = "";
pub inline fn ngx_http_get_module_ctx(r: anytype, module: anytype) @TypeOf(r.*.ctx[@as(usize, @intCast(module.ctx_index))]) {
    _ = &r;
    _ = &module;
    return r.*.ctx[@as(usize, @intCast(module.ctx_index))];
}
pub const ngx_http_set_ctx = @compileError("unable to translate C expr: unexpected token '='");
// src/http/ngx_http.h:81:9
pub const NGX_HTTP_LAST = @as(c_int, 1);
pub const NGX_HTTP_FLUSH = @as(c_int, 2);
pub const timeval = struct_timeval;
pub const timespec = struct_timespec;
pub const __pthread_internal_list = struct___pthread_internal_list;
pub const __pthread_internal_slist = struct___pthread_internal_slist;
pub const __pthread_mutex_s = struct___pthread_mutex_s;
pub const __pthread_rwlock_arch_t = struct___pthread_rwlock_arch_t;
pub const __pthread_cond_s = struct___pthread_cond_s;
pub const __itimer_which = enum___itimer_which;
pub const itimerval = struct_itimerval;
pub const _G_fpos_t = struct__G_fpos_t;
pub const _G_fpos64_t = struct__G_fpos64_t;
pub const _IO_marker = struct__IO_marker;
pub const _IO_codecvt = struct__IO_codecvt;
pub const _IO_wide_data = struct__IO_wide_data;
pub const _IO_FILE = struct__IO_FILE;
pub const _IO_cookie_io_functions_t = struct__IO_cookie_io_functions_t;
pub const obstack = struct_obstack;
pub const __locale_struct = struct___locale_struct;
pub const random_data = struct_random_data;
pub const drand48_data = struct_drand48_data;
pub const sigval = union_sigval;
pub const sigevent = struct_sigevent;
pub const _fpx_sw_bytes = struct__fpx_sw_bytes;
pub const _fpreg = struct__fpreg;
pub const _fpxreg = struct__fpxreg;
pub const _xmmreg = struct__xmmreg;
pub const _fpstate = struct__fpstate;
pub const sigcontext = struct_sigcontext;
pub const _xsave_hdr = struct__xsave_hdr;
pub const _ymmh_state = struct__ymmh_state;
pub const _xstate = struct__xstate;
pub const _libc_fpxreg = struct__libc_fpxreg;
pub const _libc_xmmreg = struct__libc_xmmreg;
pub const _libc_fpstate = struct__libc_fpstate;
pub const passwd = struct_passwd;
pub const group = struct_group;
pub const dirent = struct_dirent;
pub const dirent64 = struct_dirent64;
pub const __dirstream = struct___dirstream;
pub const iovec = struct_iovec;
pub const statx_timestamp = struct_statx_timestamp;
pub const flock = struct_flock;
pub const flock64 = struct_flock64;
pub const __pid_type = enum___pid_type;
pub const f_owner_ex = struct_f_owner_ex;
pub const file_handle = struct_file_handle;
pub const rusage = struct_rusage;
pub const __rlimit_resource = enum___rlimit_resource;
pub const rlimit = struct_rlimit;
pub const rlimit64 = struct_rlimit64;
pub const __rusage_who = enum___rusage_who;
pub const __priority_which = enum___priority_which;
pub const sched_param = struct_sched_param;
pub const __socket_type = enum___socket_type;
pub const sockaddr = struct_sockaddr;
pub const sockaddr_storage = struct_sockaddr_storage;
pub const msghdr = struct_msghdr;
pub const cmsghdr = struct_cmsghdr;
pub const ucred = struct_ucred;
pub const linger = struct_linger;
pub const osockaddr = struct_osockaddr;
pub const in_addr = struct_in_addr;
pub const sockaddr_in = struct_sockaddr_in;
pub const in6_addr = struct_in6_addr;
pub const sockaddr_in6 = struct_sockaddr_in6;
pub const sockaddr_un = struct_sockaddr_un;
pub const mmsghdr = struct_mmsghdr;
pub const ip_opts = struct_ip_opts;
pub const in_pktinfo = struct_in_pktinfo;
pub const ip_mreq = struct_ip_mreq;
pub const ip_mreqn = struct_ip_mreqn;
pub const ip_mreq_source = struct_ip_mreq_source;
pub const ipv6_mreq = struct_ipv6_mreq;
pub const group_req = struct_group_req;
pub const group_source_req = struct_group_source_req;
pub const ip_msfilter = struct_ip_msfilter;
pub const group_filter = struct_group_filter;
pub const in6_pktinfo = struct_in6_pktinfo;
pub const ip6_mtuinfo = struct_ip6_mtuinfo;
pub const tcphdr = struct_tcphdr;
pub const tcp_ca_state = enum_tcp_ca_state;
pub const tcp_info = struct_tcp_info;
pub const tcp_md5sig = struct_tcp_md5sig;
pub const tcp_repair_opt = struct_tcp_repair_opt;
pub const tcp_cookie_transactions = struct_tcp_cookie_transactions;
pub const tcp_repair_window = struct_tcp_repair_window;
pub const tcp_zerocopy_receive = struct_tcp_zerocopy_receive;
pub const rpcent = struct_rpcent;
pub const netent = struct_netent;
pub const hostent = struct_hostent;
pub const servent = struct_servent;
pub const protoent = struct_protoent;
pub const addrinfo = struct_addrinfo;
pub const gaicb = struct_gaicb;
pub const timex = struct_timex;
pub const tm = struct_tm;
pub const itimerspec = struct_itimerspec;
pub const winsize = struct_winsize;
pub const termio = struct_termio;
pub const crypt_data = struct_crypt_data;
pub const utsname = struct_utsname;
pub const dl_find_object = struct_dl_find_object;
pub const prctl_mm_map = struct_prctl_mm_map;
pub const EPOLL_EVENTS = enum_EPOLL_EVENTS;
pub const epoll_data = union_epoll_data;
pub const epoll_event = struct_epoll_event;
pub const epoll_params = struct_epoll_params;
pub const __user_cap_header_struct = struct___user_cap_header_struct;
pub const __user_cap_data_struct = struct___user_cap_data_struct;
pub const vfs_cap_data = struct_vfs_cap_data;
pub const vfs_ns_cap_data = struct_vfs_ns_cap_data;
pub const udphdr = struct_udphdr;
pub const ngx_open_file_s = struct_ngx_open_file_s;
pub const ngx_log_s = struct_ngx_log_s;
pub const ngx_file_s = struct_ngx_file_s;
pub const ngx_buf_s = struct_ngx_buf_s;
pub const ngx_chain_s = struct_ngx_chain_s;
pub const ngx_pool_large_s = struct_ngx_pool_large_s;
pub const ngx_pool_cleanup_s = struct_ngx_pool_cleanup_s;
pub const ngx_pool_s = struct_ngx_pool_s;
pub const ngx_rbtree_node_s = struct_ngx_rbtree_node_s;
pub const ngx_queue_s = struct_ngx_queue_s;
pub const ngx_event_s = struct_ngx_event_s;
pub const ngx_rbtree_s = struct_ngx_rbtree_s;
pub const ngx_listening_s = struct_ngx_listening_s;
pub const ngx_proxy_protocol_s = struct_ngx_proxy_protocol_s;
pub const ssl_st = struct_ssl_st;
pub const ssl_ctx_st = struct_ssl_ctx_st;
pub const ssl_session_st = struct_ssl_session_st;
pub const ngx_ssl_ocsp_s = struct_ngx_ssl_ocsp_s;
pub const ngx_ssl_connection_s = struct_ngx_ssl_connection_s;
pub const ngx_udp_connection_s = struct_ngx_udp_connection_s;
pub const ngx_connection_s = struct_ngx_connection_s;
pub const ngx_cycle_s = struct_ngx_cycle_s;
pub const ngx_conf_s = struct_ngx_conf_s;
pub const ngx_command_s = struct_ngx_command_s;
pub const ngx_module_s = struct_ngx_module_s;
pub const ngx_event_aio_s = struct_ngx_event_aio_s;
pub const ngx_thread_task_s = struct_ngx_thread_task_s;
pub const ngx_ssl_s = struct_ngx_ssl_s;
pub const ngx_quic_stream_s = struct_ngx_quic_stream_s;
pub const ngx_output_chain_ctx_s = struct_ngx_output_chain_ctx_s;
pub const ngx_list_part_s = struct_ngx_list_part_s;
pub const ngx_table_elt_s = struct_ngx_table_elt_s;
pub const ngx_tree_ctx_s = struct_ngx_tree_ctx_s;
pub const pcre2_real_general_context_8 = struct_pcre2_real_general_context_8;
pub const pcre2_real_compile_context_8 = struct_pcre2_real_compile_context_8;
pub const pcre2_real_match_context_8 = struct_pcre2_real_match_context_8;
pub const pcre2_real_convert_context_8 = struct_pcre2_real_convert_context_8;
pub const pcre2_real_code_8 = struct_pcre2_real_code_8;
pub const pcre2_real_match_data_8 = struct_pcre2_real_match_data_8;
pub const pcre2_real_jit_stack_8 = struct_pcre2_real_jit_stack_8;
pub const pcre2_real_general_context_16 = struct_pcre2_real_general_context_16;
pub const pcre2_real_compile_context_16 = struct_pcre2_real_compile_context_16;
pub const pcre2_real_match_context_16 = struct_pcre2_real_match_context_16;
pub const pcre2_real_convert_context_16 = struct_pcre2_real_convert_context_16;
pub const pcre2_real_code_16 = struct_pcre2_real_code_16;
pub const pcre2_real_match_data_16 = struct_pcre2_real_match_data_16;
pub const pcre2_real_jit_stack_16 = struct_pcre2_real_jit_stack_16;
pub const pcre2_real_general_context_32 = struct_pcre2_real_general_context_32;
pub const pcre2_real_compile_context_32 = struct_pcre2_real_compile_context_32;
pub const pcre2_real_match_context_32 = struct_pcre2_real_match_context_32;
pub const pcre2_real_convert_context_32 = struct_pcre2_real_convert_context_32;
pub const pcre2_real_code_32 = struct_pcre2_real_code_32;
pub const pcre2_real_match_data_32 = struct_pcre2_real_match_data_32;
pub const pcre2_real_jit_stack_32 = struct_pcre2_real_jit_stack_32;
pub const ngx_radix_node_s = struct_ngx_radix_node_s;
pub const ngx_slab_page_s = struct_ngx_slab_page_s;
pub const ngx_shm_zone_s = struct_ngx_shm_zone_s;
pub const ngx_resolver_s = struct_ngx_resolver_s;
pub const ngx_resolver_ctx_s = struct_ngx_resolver_ctx_s;
pub const stack_st = struct_stack_st;
pub const stack_st_OPENSSL_STRING = struct_stack_st_OPENSSL_STRING;
pub const stack_st_OPENSSL_CSTRING = struct_stack_st_OPENSSL_CSTRING;
pub const stack_st_OPENSSL_BLOCK = struct_stack_st_OPENSSL_BLOCK;
pub const ossl_provider_st = struct_ossl_provider_st;
pub const asn1_string_st = struct_asn1_string_st;
pub const asn1_object_st = struct_asn1_object_st;
pub const ASN1_VALUE_st = struct_ASN1_VALUE_st;
pub const asn1_type_st = struct_asn1_type_st;
pub const asn1_string_table_st = struct_asn1_string_table_st;
pub const ASN1_ITEM_st = struct_ASN1_ITEM_st;
pub const asn1_pctx_st = struct_asn1_pctx_st;
pub const asn1_sctx_st = struct_asn1_sctx_st;
pub const bio_st = struct_bio_st;
pub const bignum_st = struct_bignum_st;
pub const bignum_ctx = struct_bignum_ctx;
pub const bn_blinding_st = struct_bn_blinding_st;
pub const bn_mont_ctx_st = struct_bn_mont_ctx_st;
pub const bn_recp_ctx_st = struct_bn_recp_ctx_st;
pub const bn_gencb_st = struct_bn_gencb_st;
pub const buf_mem_st = struct_buf_mem_st;
pub const stack_st_BIGNUM = struct_stack_st_BIGNUM;
pub const stack_st_BIGNUM_const = struct_stack_st_BIGNUM_const;
pub const err_state_st = struct_err_state_st;
pub const evp_cipher_st = struct_evp_cipher_st;
pub const evp_cipher_ctx_st = struct_evp_cipher_ctx_st;
pub const evp_md_st = struct_evp_md_st;
pub const evp_md_ctx_st = struct_evp_md_ctx_st;
pub const evp_mac_st = struct_evp_mac_st;
pub const evp_mac_ctx_st = struct_evp_mac_ctx_st;
pub const evp_pkey_st = struct_evp_pkey_st;
pub const evp_pkey_asn1_method_st = struct_evp_pkey_asn1_method_st;
pub const evp_pkey_method_st = struct_evp_pkey_method_st;
pub const evp_pkey_ctx_st = struct_evp_pkey_ctx_st;
pub const evp_keymgmt_st = struct_evp_keymgmt_st;
pub const evp_kdf_st = struct_evp_kdf_st;
pub const evp_kdf_ctx_st = struct_evp_kdf_ctx_st;
pub const evp_rand_st = struct_evp_rand_st;
pub const evp_rand_ctx_st = struct_evp_rand_ctx_st;
pub const evp_keyexch_st = struct_evp_keyexch_st;
pub const evp_signature_st = struct_evp_signature_st;
pub const evp_asym_cipher_st = struct_evp_asym_cipher_st;
pub const evp_kem_st = struct_evp_kem_st;
pub const evp_Encode_Ctx_st = struct_evp_Encode_Ctx_st;
pub const hmac_ctx_st = struct_hmac_ctx_st;
pub const dh_st = struct_dh_st;
pub const dh_method = struct_dh_method;
pub const dsa_st = struct_dsa_st;
pub const dsa_method = struct_dsa_method;
pub const rsa_st = struct_rsa_st;
pub const rsa_meth_st = struct_rsa_meth_st;
pub const X509_algor_st = struct_X509_algor_st;
pub const rsa_pss_params_st = struct_rsa_pss_params_st;
pub const ec_key_st = struct_ec_key_st;
pub const ec_key_method_st = struct_ec_key_method_st;
pub const rand_meth_st = struct_rand_meth_st;
pub const rand_drbg_st = struct_rand_drbg_st;
pub const ssl_dane_st = struct_ssl_dane_st;
pub const x509_st = struct_x509_st;
pub const X509_crl_st = struct_X509_crl_st;
pub const x509_crl_method_st = struct_x509_crl_method_st;
pub const x509_revoked_st = struct_x509_revoked_st;
pub const X509_name_st = struct_X509_name_st;
pub const X509_pubkey_st = struct_X509_pubkey_st;
pub const x509_store_st = struct_x509_store_st;
pub const x509_store_ctx_st = struct_x509_store_ctx_st;
pub const x509_object_st = struct_x509_object_st;
pub const x509_lookup_st = struct_x509_lookup_st;
pub const x509_lookup_method_st = struct_x509_lookup_method_st;
pub const X509_VERIFY_PARAM_st = struct_X509_VERIFY_PARAM_st;
pub const x509_sig_info_st = struct_x509_sig_info_st;
pub const pkcs8_priv_key_info_st = struct_pkcs8_priv_key_info_st;
pub const X509_req_st = struct_X509_req_st;
pub const stack_st_CONF_VALUE = struct_stack_st_CONF_VALUE;
pub const X509V3_CONF_METHOD_st = struct_X509V3_CONF_METHOD_st;
pub const v3_ext_ctx = struct_v3_ext_ctx;
pub const conf_method_st = struct_conf_method_st;
pub const lhash_st_CONF_VALUE = struct_lhash_st_CONF_VALUE;
pub const ossl_lib_ctx_st = struct_ossl_lib_ctx_st;
pub const conf_st = struct_conf_st;
pub const ossl_init_settings_st = struct_ossl_init_settings_st;
pub const ui_st = struct_ui_st;
pub const ui_method_st = struct_ui_method_st;
pub const engine_st = struct_engine_st;
pub const comp_ctx_st = struct_comp_ctx_st;
pub const comp_method_st = struct_comp_method_st;
pub const X509_POLICY_NODE_st = struct_X509_POLICY_NODE_st;
pub const X509_POLICY_LEVEL_st = struct_X509_POLICY_LEVEL_st;
pub const X509_POLICY_TREE_st = struct_X509_POLICY_TREE_st;
pub const X509_POLICY_CACHE_st = struct_X509_POLICY_CACHE_st;
pub const stack_st_GENERAL_NAME = struct_stack_st_GENERAL_NAME;
pub const AUTHORITY_KEYID_st = struct_AUTHORITY_KEYID_st;
pub const stack_st_X509_NAME_ENTRY = struct_stack_st_X509_NAME_ENTRY;
pub const DIST_POINT_NAME_st = struct_DIST_POINT_NAME_st;
pub const DIST_POINT_st = struct_DIST_POINT_st;
pub const ISSUING_DIST_POINT_st = struct_ISSUING_DIST_POINT_st;
pub const stack_st_GENERAL_SUBTREE = struct_stack_st_GENERAL_SUBTREE;
pub const NAME_CONSTRAINTS_st = struct_NAME_CONSTRAINTS_st;
pub const stack_st_void = struct_stack_st_void;
pub const crypto_ex_data_st = struct_crypto_ex_data_st;
pub const ossl_http_req_ctx_st = struct_ossl_http_req_ctx_st;
pub const ocsp_response_st = struct_ocsp_response_st;
pub const ocsp_responder_id_st = struct_ocsp_responder_id_st;
pub const sct_st = struct_sct_st;
pub const sct_ctx_st = struct_sct_ctx_st;
pub const ctlog_st = struct_ctlog_st;
pub const ctlog_store_st = struct_ctlog_store_st;
pub const ct_policy_eval_ctx_st = struct_ct_policy_eval_ctx_st;
pub const ossl_store_info_st = struct_ossl_store_info_st;
pub const ossl_store_search_st = struct_ossl_store_search_st;
pub const ossl_dispatch_st = struct_ossl_dispatch_st;
pub const ossl_item_st = struct_ossl_item_st;
pub const ossl_algorithm_st = struct_ossl_algorithm_st;
pub const ossl_param_st = struct_ossl_param_st;
pub const ossl_param_bld_st = struct_ossl_param_bld_st;
pub const ossl_encoder_st = struct_ossl_encoder_st;
pub const ossl_encoder_ctx_st = struct_ossl_encoder_ctx_st;
pub const ossl_decoder_st = struct_ossl_decoder_st;
pub const ossl_decoder_ctx_st = struct_ossl_decoder_ctx_st;
pub const ossl_self_test_st = struct_ossl_self_test_st;
pub const ossl_core_handle_st = struct_ossl_core_handle_st;
pub const openssl_core_ctx_st = struct_openssl_core_ctx_st;
pub const ossl_core_bio_st = struct_ossl_core_bio_st;
pub const crypto_threadid_st = struct_crypto_threadid_st;
pub const __jmp_buf_tag = struct___jmp_buf_tag;
pub const _pthread_cleanup_buffer = struct__pthread_cleanup_buffer;
pub const __cancel_jmp_buf_tag = struct___cancel_jmp_buf_tag;
pub const __pthread_cleanup_frame = struct___pthread_cleanup_frame;
pub const ssl_comp_st = struct_ssl_comp_st;
pub const stack_st_SSL_COMP = struct_stack_st_SSL_COMP;
pub const bio_addr_st = union_bio_addr_st;
pub const bio_addrinfo_st = struct_bio_addrinfo_st;
pub const bio_method_st = struct_bio_method_st;
pub const stack_st_BIO = struct_stack_st_BIO;
pub const bio_msg_st = struct_bio_msg_st;
pub const bio_mmsg_cb_args_st = struct_bio_mmsg_cb_args_st;
pub const bio_poll_descriptor_st = struct_bio_poll_descriptor_st;
pub const BIO_hostserv_priorities = enum_BIO_hostserv_priorities;
pub const BIO_lookup_type = enum_BIO_lookup_type;
pub const BIO_sock_info_u = union_BIO_sock_info_u;
pub const BIO_sock_info_type = enum_BIO_sock_info_type;
pub const stack_st_X509_ALGOR = struct_stack_st_X509_ALGOR;
pub const ASN1_ENCODING_st = struct_ASN1_ENCODING_st;
pub const stack_st_ASN1_STRING_TABLE = struct_stack_st_ASN1_STRING_TABLE;
pub const ASN1_TEMPLATE_st = struct_ASN1_TEMPLATE_st;
pub const ASN1_TLC_st = struct_ASN1_TLC_st;
pub const stack_st_ASN1_TYPE = struct_stack_st_ASN1_TYPE;
pub const BIT_STRING_BITNAME_st = struct_BIT_STRING_BITNAME_st;
pub const stack_st_ASN1_OBJECT = struct_stack_st_ASN1_OBJECT;
pub const stack_st_ASN1_INTEGER = struct_stack_st_ASN1_INTEGER;
pub const stack_st_ASN1_UTF8STRING = struct_stack_st_ASN1_UTF8STRING;
pub const stack_st_ASN1_GENERALSTRING = struct_stack_st_ASN1_GENERALSTRING;
pub const obj_name_st = struct_obj_name_st;
pub const evp_cipher_info_st = struct_evp_cipher_info_st;
pub const ec_method_st = struct_ec_method_st;
pub const ec_group_st = struct_ec_group_st;
pub const ec_point_st = struct_ec_point_st;
pub const ecpk_parameters_st = struct_ecpk_parameters_st;
pub const ec_parameters_st = struct_ec_parameters_st;
pub const ECDSA_SIG_st = struct_ECDSA_SIG_st;
pub const rsa_oaep_params_st = struct_rsa_oaep_params_st;
pub const DSA_SIG_st = struct_DSA_SIG_st;
pub const SHAstate_st = struct_SHAstate_st;
pub const SHA256state_st = struct_SHA256state_st;
pub const SHA512state_st = struct_SHA512state_st;
pub const stack_st_X509_NAME = struct_stack_st_X509_NAME;
pub const stack_st_X509 = struct_stack_st_X509;
pub const stack_st_X509_REVOKED = struct_stack_st_X509_REVOKED;
pub const stack_st_X509_CRL = struct_stack_st_X509_CRL;
pub const X509_val_st = struct_X509_val_st;
pub const X509_sig_st = struct_X509_sig_st;
pub const X509_name_entry_st = struct_X509_name_entry_st;
pub const X509_extension_st = struct_X509_extension_st;
pub const stack_st_X509_EXTENSION = struct_stack_st_X509_EXTENSION;
pub const x509_attributes_st = struct_x509_attributes_st;
pub const stack_st_X509_ATTRIBUTE = struct_stack_st_X509_ATTRIBUTE;
pub const X509_req_info_st = struct_X509_req_info_st;
pub const x509_cert_aux_st = struct_x509_cert_aux_st;
pub const x509_cinf_st = struct_x509_cinf_st;
pub const X509_crl_info_st = struct_X509_crl_info_st;
pub const private_key_st = struct_private_key_st;
pub const X509_info_st = struct_X509_info_st;
pub const stack_st_X509_INFO = struct_stack_st_X509_INFO;
pub const Netscape_spkac_st = struct_Netscape_spkac_st;
pub const Netscape_spki_st = struct_Netscape_spki_st;
pub const Netscape_certificate_sequence = struct_Netscape_certificate_sequence;
pub const PBEPARAM_st = struct_PBEPARAM_st;
pub const PBE2PARAM_st = struct_PBE2PARAM_st;
pub const PBKDF2PARAM_st = struct_PBKDF2PARAM_st;
pub const SCRYPT_PARAMS_st = struct_SCRYPT_PARAMS_st;
pub const lhash_node_st = struct_lhash_node_st;
pub const lhash_st = struct_lhash_st;
pub const lhash_st_OPENSSL_STRING = struct_lhash_st_OPENSSL_STRING;
pub const lhash_st_OPENSSL_CSTRING = struct_lhash_st_OPENSSL_CSTRING;
pub const stack_st_X509_LOOKUP = struct_stack_st_X509_LOOKUP;
pub const stack_st_X509_OBJECT = struct_stack_st_X509_OBJECT;
pub const stack_st_X509_VERIFY_PARAM = struct_stack_st_X509_VERIFY_PARAM;
pub const x509_trust_st = struct_x509_trust_st;
pub const stack_st_X509_TRUST = struct_stack_st_X509_TRUST;
pub const stack_st_X509_POLICY_NODE = struct_stack_st_X509_POLICY_NODE;
pub const stack_st_POLICYQUALINFO = struct_stack_st_POLICYQUALINFO;
pub const PKCS7_CTX_st = struct_PKCS7_CTX_st;
pub const pkcs7_issuer_and_serial_st = struct_pkcs7_issuer_and_serial_st;
pub const pkcs7_signer_info_st = struct_pkcs7_signer_info_st;
pub const stack_st_PKCS7_SIGNER_INFO = struct_stack_st_PKCS7_SIGNER_INFO;
pub const pkcs7_recip_info_st = struct_pkcs7_recip_info_st;
pub const stack_st_PKCS7_RECIP_INFO = struct_stack_st_PKCS7_RECIP_INFO;
pub const pkcs7_enc_content_st = struct_pkcs7_enc_content_st;
pub const pkcs7_enveloped_st = struct_pkcs7_enveloped_st;
pub const pkcs7_signedandenveloped_st = struct_pkcs7_signedandenveloped_st;
pub const pkcs7_digest_st = struct_pkcs7_digest_st;
pub const pkcs7_encrypted_st = struct_pkcs7_encrypted_st;
pub const pkcs7_st = struct_pkcs7_st;
pub const pkcs7_signed_st = struct_pkcs7_signed_st;
pub const stack_st_PKCS7 = struct_stack_st_PKCS7;
pub const conf_imodule_st = struct_conf_imodule_st;
pub const conf_module_st = struct_conf_module_st;
pub const stack_st_CONF_MODULE = struct_stack_st_CONF_MODULE;
pub const stack_st_CONF_IMODULE = struct_stack_st_CONF_IMODULE;
pub const async_job_st = struct_async_job_st;
pub const async_wait_ctx_st = struct_async_wait_ctx_st;
pub const stack_st_SCT = struct_stack_st_SCT;
pub const stack_st_CTLOG = struct_stack_st_CTLOG;
pub const tls_session_ticket_ext_st = struct_tls_session_ticket_ext_st;
pub const ssl_method_st = struct_ssl_method_st;
pub const ssl_cipher_st = struct_ssl_cipher_st;
pub const tls_sigalgs_st = struct_tls_sigalgs_st;
pub const ssl_conf_ctx_st = struct_ssl_conf_ctx_st;
pub const stack_st_SSL_CIPHER = struct_stack_st_SSL_CIPHER;
pub const srtp_protection_profile_st = struct_srtp_protection_profile_st;
pub const stack_st_SRTP_PROTECTION_PROFILE = struct_stack_st_SRTP_PROTECTION_PROFILE;
pub const lhash_st_SSL_SESSION = struct_lhash_st_SSL_SESSION;
pub const ssl_shutdown_ex_args_st = struct_ssl_shutdown_ex_args_st;
pub const ssl_stream_reset_args_st = struct_ssl_stream_reset_args_st;
pub const ssl_conn_close_info_st = struct_ssl_conn_close_info_st;
pub const ssl_poll_item_st = struct_ssl_poll_item_st;
pub const ERR_string_data_st = struct_ERR_string_data_st;
pub const lhash_st_ERR_STRING_DATA = struct_lhash_st_ERR_STRING_DATA;
pub const ui_string_st = struct_ui_string_st;
pub const stack_st_UI_STRING = struct_stack_st_UI_STRING;
pub const UI_string_types = enum_UI_string_types;
pub const ENGINE_CMD_DEFN_st = struct_ENGINE_CMD_DEFN_st;
pub const st_dynamic_MEM_fns = struct_st_dynamic_MEM_fns;
pub const st_dynamic_fns = struct_st_dynamic_fns;
pub const v3_ext_method = struct_v3_ext_method;
pub const stack_st_X509V3_EXT_METHOD = struct_stack_st_X509V3_EXT_METHOD;
pub const BASIC_CONSTRAINTS_st = struct_BASIC_CONSTRAINTS_st;
pub const OSSL_BASIC_ATTR_CONSTRAINTS_st = struct_OSSL_BASIC_ATTR_CONSTRAINTS_st;
pub const PKEY_USAGE_PERIOD_st = struct_PKEY_USAGE_PERIOD_st;
pub const otherName_st = struct_otherName_st;
pub const EDIPartyName_st = struct_EDIPartyName_st;
pub const GENERAL_NAME_st = struct_GENERAL_NAME_st;
pub const ACCESS_DESCRIPTION_st = struct_ACCESS_DESCRIPTION_st;
pub const stack_st_ACCESS_DESCRIPTION = struct_stack_st_ACCESS_DESCRIPTION;
pub const stack_st_GENERAL_NAMES = struct_stack_st_GENERAL_NAMES;
pub const stack_st_DIST_POINT = struct_stack_st_DIST_POINT;
pub const SXNET_ID_st = struct_SXNET_ID_st;
pub const stack_st_SXNETID = struct_stack_st_SXNETID;
pub const SXNET_st = struct_SXNET_st;
pub const ISSUER_SIGN_TOOL_st = struct_ISSUER_SIGN_TOOL_st;
pub const NOTICEREF_st = struct_NOTICEREF_st;
pub const USERNOTICE_st = struct_USERNOTICE_st;
pub const POLICYQUALINFO_st = struct_POLICYQUALINFO_st;
pub const POLICYINFO_st = struct_POLICYINFO_st;
pub const stack_st_POLICYINFO = struct_stack_st_POLICYINFO;
pub const POLICY_MAPPING_st = struct_POLICY_MAPPING_st;
pub const stack_st_POLICY_MAPPING = struct_stack_st_POLICY_MAPPING;
pub const GENERAL_SUBTREE_st = struct_GENERAL_SUBTREE_st;
pub const POLICY_CONSTRAINTS_st = struct_POLICY_CONSTRAINTS_st;
pub const PROXY_POLICY_st = struct_PROXY_POLICY_st;
pub const PROXY_CERT_INFO_EXTENSION_st = struct_PROXY_CERT_INFO_EXTENSION_st;
pub const x509_purpose_st = struct_x509_purpose_st;
pub const stack_st_X509_PURPOSE = struct_stack_st_X509_PURPOSE;
pub const ASRange_st = struct_ASRange_st;
pub const ASIdOrRange_st = struct_ASIdOrRange_st;
pub const stack_st_ASIdOrRange = struct_stack_st_ASIdOrRange;
pub const ASIdentifierChoice_st = struct_ASIdentifierChoice_st;
pub const ASIdentifiers_st = struct_ASIdentifiers_st;
pub const IPAddressRange_st = struct_IPAddressRange_st;
pub const IPAddressOrRange_st = struct_IPAddressOrRange_st;
pub const stack_st_IPAddressOrRange = struct_stack_st_IPAddressOrRange;
pub const IPAddressChoice_st = struct_IPAddressChoice_st;
pub const IPAddressFamily_st = struct_IPAddressFamily_st;
pub const stack_st_IPAddressFamily = struct_stack_st_IPAddressFamily;
pub const stack_st_ASN1_STRING = struct_stack_st_ASN1_STRING;
pub const NamingAuthority_st = struct_NamingAuthority_st;
pub const ProfessionInfo_st = struct_ProfessionInfo_st;
pub const Admissions_st = struct_Admissions_st;
pub const AdmissionSyntax_st = struct_AdmissionSyntax_st;
pub const stack_st_PROFESSION_INFO = struct_stack_st_PROFESSION_INFO;
pub const stack_st_ADMISSIONS = struct_stack_st_ADMISSIONS;
pub const stack_st_USERNOTICE = struct_stack_st_USERNOTICE;
pub const ocsp_cert_id_st = struct_ocsp_cert_id_st;
pub const ocsp_one_request_st = struct_ocsp_one_request_st;
pub const ocsp_req_info_st = struct_ocsp_req_info_st;
pub const ocsp_signature_st = struct_ocsp_signature_st;
pub const ocsp_request_st = struct_ocsp_request_st;
pub const stack_st_OCSP_CERTID = struct_stack_st_OCSP_CERTID;
pub const stack_st_OCSP_ONEREQ = struct_stack_st_OCSP_ONEREQ;
pub const ocsp_resp_bytes_st = struct_ocsp_resp_bytes_st;
pub const stack_st_OCSP_RESPID = struct_stack_st_OCSP_RESPID;
pub const ocsp_revoked_info_st = struct_ocsp_revoked_info_st;
pub const ocsp_cert_status_st = struct_ocsp_cert_status_st;
pub const ocsp_single_response_st = struct_ocsp_single_response_st;
pub const stack_st_OCSP_SINGLERESP = struct_stack_st_OCSP_SINGLERESP;
pub const ocsp_response_data_st = struct_ocsp_response_data_st;
pub const ocsp_basic_response_st = struct_ocsp_basic_response_st;
pub const ocsp_crl_id_st = struct_ocsp_crl_id_st;
pub const ocsp_service_locator_st = struct_ocsp_service_locator_st;
pub const ngx_ssl_sess_id_s = struct_ngx_ssl_sess_id_s;
pub const ngx_cached_open_file_s = struct_ngx_cached_open_file_s;
pub const bpf_cond_pseudo_jmp = enum_bpf_cond_pseudo_jmp;
pub const bpf_insn = struct_bpf_insn;
pub const bpf_lpm_trie_key = struct_bpf_lpm_trie_key;
pub const bpf_lpm_trie_key_hdr = struct_bpf_lpm_trie_key_hdr;
pub const bpf_lpm_trie_key_u8 = struct_bpf_lpm_trie_key_u8;
pub const bpf_cgroup_storage_key = struct_bpf_cgroup_storage_key;
pub const bpf_cgroup_iter_order = enum_bpf_cgroup_iter_order;
pub const bpf_iter_link_info = union_bpf_iter_link_info;
pub const bpf_cmd = enum_bpf_cmd;
pub const bpf_map_type = enum_bpf_map_type;
pub const bpf_prog_type = enum_bpf_prog_type;
pub const bpf_attach_type = enum_bpf_attach_type;
pub const bpf_link_type = enum_bpf_link_type;
pub const bpf_perf_event_type = enum_bpf_perf_event_type;
pub const bpf_addr_space_cast = enum_bpf_addr_space_cast;
pub const bpf_stats_type = enum_bpf_stats_type;
pub const bpf_stack_build_id_status = enum_bpf_stack_build_id_status;
pub const bpf_stack_build_id = struct_bpf_stack_build_id;
pub const bpf_attr = union_bpf_attr;
pub const bpf_func_id = enum_bpf_func_id;
pub const bpf_adj_room_mode = enum_bpf_adj_room_mode;
pub const bpf_hdr_start_off = enum_bpf_hdr_start_off;
pub const bpf_lwt_encap_mode = enum_bpf_lwt_encap_mode;
pub const bpf_flow_keys = struct_bpf_flow_keys;
pub const bpf_sock = struct_bpf_sock;
pub const __sk_buff = struct___sk_buff;
pub const bpf_tunnel_key = struct_bpf_tunnel_key;
pub const bpf_xfrm_state = struct_bpf_xfrm_state;
pub const bpf_ret_code = enum_bpf_ret_code;
pub const bpf_tcp_sock = struct_bpf_tcp_sock;
pub const bpf_sock_tuple = struct_bpf_sock_tuple;
pub const tcx_action_base = enum_tcx_action_base;
pub const bpf_xdp_sock = struct_bpf_xdp_sock;
pub const xdp_action = enum_xdp_action;
pub const xdp_md = struct_xdp_md;
pub const bpf_devmap_val = struct_bpf_devmap_val;
pub const bpf_cpumap_val = struct_bpf_cpumap_val;
pub const sk_action = enum_sk_action;
pub const sk_msg_md = struct_sk_msg_md;
pub const sk_reuseport_md = struct_sk_reuseport_md;
pub const bpf_prog_info = struct_bpf_prog_info;
pub const bpf_map_info = struct_bpf_map_info;
pub const bpf_btf_info = struct_bpf_btf_info;
pub const bpf_link_info = struct_bpf_link_info;
pub const bpf_sock_addr = struct_bpf_sock_addr;
pub const bpf_sock_ops = struct_bpf_sock_ops;
pub const bpf_perf_event_value = struct_bpf_perf_event_value;
pub const bpf_cgroup_dev_ctx = struct_bpf_cgroup_dev_ctx;
pub const bpf_raw_tracepoint_args = struct_bpf_raw_tracepoint_args;
pub const bpf_fib_lookup = struct_bpf_fib_lookup;
pub const bpf_redir_neigh = struct_bpf_redir_neigh;
pub const bpf_check_mtu_flags = enum_bpf_check_mtu_flags;
pub const bpf_check_mtu_ret = enum_bpf_check_mtu_ret;
pub const bpf_task_fd_type = enum_bpf_task_fd_type;
pub const bpf_func_info = struct_bpf_func_info;
pub const bpf_line_info = struct_bpf_line_info;
pub const bpf_spin_lock = struct_bpf_spin_lock;
pub const bpf_timer = struct_bpf_timer;
pub const bpf_wq = struct_bpf_wq;
pub const bpf_dynptr = struct_bpf_dynptr;
pub const bpf_list_head = struct_bpf_list_head;
pub const bpf_list_node = struct_bpf_list_node;
pub const bpf_rb_root = struct_bpf_rb_root;
pub const bpf_rb_node = struct_bpf_rb_node;
pub const bpf_refcount = struct_bpf_refcount;
pub const bpf_sysctl = struct_bpf_sysctl;
pub const bpf_sockopt = struct_bpf_sockopt;
pub const bpf_pidns_info = struct_bpf_pidns_info;
pub const bpf_sk_lookup = struct_bpf_sk_lookup;
pub const btf_ptr = struct_btf_ptr;
pub const bpf_core_relo_kind = enum_bpf_core_relo_kind;
pub const bpf_core_relo = struct_bpf_core_relo;
pub const bpf_iter_num = struct_bpf_iter_num;
pub const ngx_http_file_cache_s = struct_ngx_http_file_cache_s;
pub const ngx_http_cache_s = struct_ngx_http_cache_s;
pub const ngx_peer_connection_s = struct_ngx_peer_connection_s;
pub const ngx_event_pipe_s = struct_ngx_event_pipe_s;
pub const ngx_http_upstream_srv_conf_s = struct_ngx_http_upstream_srv_conf_s;
pub const ngx_http_upstream_s = struct_ngx_http_upstream_s;
pub const ngx_http_postponed_request_s = struct_ngx_http_postponed_request_s;
pub const ngx_http_posted_request_s = struct_ngx_http_posted_request_s;
pub const ngx_http_v2_stream_s = struct_ngx_http_v2_stream_s;
pub const ngx_http_v3_parse_s = struct_ngx_http_v3_parse_s;
pub const ngx_http_cleanup_s = struct_ngx_http_cleanup_s;
pub const ngx_http_request_s = struct_ngx_http_request_s;
pub const ngx_http_log_ctx_s = struct_ngx_http_log_ctx_s;
pub const ngx_http_chunked_s = struct_ngx_http_chunked_s;
pub const ngx_http_v3_session_s = struct_ngx_http_v3_session_s;
pub const ngx_http_variable_s = struct_ngx_http_variable_s;
pub const ngx_http_addr_conf_s = struct_ngx_http_addr_conf_s;
pub const ngx_http_upstream_rr_peer_s = struct_ngx_http_upstream_rr_peer_s;
pub const ngx_http_upstream_rr_peers_s = struct_ngx_http_upstream_rr_peers_s;
pub const ngx_http_core_loc_conf_s = struct_ngx_http_core_loc_conf_s;
pub const ngx_http_location_tree_node_s = struct_ngx_http_location_tree_node_s;
pub const ngx_http_phase_handler_s = struct_ngx_http_phase_handler_s;
