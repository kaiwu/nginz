--- cJSON.c	2025-02-09 11:15:17.266697451 +0800
+++ /tmp/cJSON.c	2025-02-09 11:15:06.104125721 +0800
@@ -155,15 +155,16 @@
 
 typedef struct internal_hooks
 {
-    void *(CJSON_CDECL *allocate)(size_t size);
+    void *(CJSON_CDECL *allocate)(size_t size, void* ctx);
     void (CJSON_CDECL *deallocate)(void *pointer);
     void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
+    void *ctx;
 } internal_hooks;
 
-#if defined(_MSC_VER)
 /* work around MSVC error C2322: '...' address of dllimport '...' is not static */
-static void * CJSON_CDECL internal_malloc(size_t size)
+static void * CJSON_CDECL internal_malloc(size_t size, void *ctx)
 {
+    (void) ctx;
     return malloc(size);
 }
 static void CJSON_CDECL internal_free(void *pointer)
@@ -174,16 +175,11 @@
 {
     return realloc(pointer, size);
 }
-#else
-#define internal_malloc malloc
-#define internal_free free
-#define internal_realloc realloc
-#endif
 
 /* strlen of character literals resolved at compile time */
 #define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))
 
-static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };
+static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc, NULL };
 
 static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
 {
@@ -196,7 +192,7 @@
     }
 
     length = strlen((const char*)string) + sizeof("");
-    copy = (unsigned char*)hooks->allocate(length);
+    copy = (unsigned char*)hooks->allocate(length, hooks->ctx);
     if (copy == NULL)
     {
         return NULL;
@@ -211,19 +207,19 @@
     if (hooks == NULL)
     {
         /* Reset hooks */
-        global_hooks.allocate = malloc;
-        global_hooks.deallocate = free;
-        global_hooks.reallocate = realloc;
+        global_hooks.allocate = internal_malloc;
+        global_hooks.deallocate = internal_free;
+        global_hooks.reallocate = internal_realloc;
         return;
     }
 
-    global_hooks.allocate = malloc;
+    global_hooks.allocate = internal_malloc;
     if (hooks->malloc_fn != NULL)
     {
         global_hooks.allocate = hooks->malloc_fn;
     }
 
-    global_hooks.deallocate = free;
+    global_hooks.deallocate = internal_free;
     if (hooks->free_fn != NULL)
     {
         global_hooks.deallocate = hooks->free_fn;
@@ -231,16 +227,18 @@
 
     /* use realloc only if both free and malloc are used */
     global_hooks.reallocate = NULL;
-    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
+    if ((global_hooks.allocate == internal_malloc) && (global_hooks.deallocate == internal_free))
     {
         global_hooks.reallocate = realloc;
     }
+
+    global_hooks.ctx = hooks->ctx;
 }
 
 /* Internal constructor. */
 static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
 {
-    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
+    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON), hooks->ctx);
     if (node)
     {
         memset(node, '\0', sizeof(cJSON));
@@ -510,7 +508,7 @@
     else
     {
         /* otherwise reallocate manually */
-        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
+        newbuffer = (unsigned char*)p->hooks.allocate(newsize, p->hooks.ctx);
         if (!newbuffer)
         {
             p->hooks.deallocate(p->buffer);
@@ -817,7 +815,7 @@
 
         /* This is at most how much we need for the output */
         allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
-        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
+        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""), input_buffer->hooks.ctx);
         if (output == NULL)
         {
             goto fail; /* allocation failure */
@@ -1103,7 +1101,7 @@
 /* Parse an object - create a new root, and populate. */
 CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)
 {
-    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
+    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0, 0} };
     cJSON *item = NULL;
 
     /* reset error position */
@@ -1202,7 +1200,7 @@
     memset(buffer, 0, sizeof(buffer));
 
     /* create buffer */
-    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
+    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size, hooks->ctx);
     buffer->length = default_buffer_size;
     buffer->format = format;
     buffer->hooks = *hooks;
@@ -1229,7 +1227,7 @@
     }
     else /* otherwise copy the JSON over to a new buffer */
     {
-        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
+        printed = (unsigned char*) hooks->allocate(buffer->offset + 1, hooks->ctx);
         if (printed == NULL)
         {
             goto fail;
@@ -1273,14 +1271,14 @@
 
 CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
 {
-    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
+    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0, 0 } };
 
     if (prebuffer < 0)
     {
         return NULL;
     }
 
-    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
+    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer, global_hooks.ctx);
     if (!p.buffer)
     {
         return NULL;
@@ -1304,7 +1302,7 @@
 
 CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)
 {
-    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
+    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0, 0 } };
 
     if ((length < 0) || (buffer == NULL))
     {
@@ -1321,6 +1319,27 @@
     return print_value(item, &p);
 }
 
+CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocatedWithLength(cJSON *item, char *buffer, const int length, const cJSON_bool format, size_t* len)
+{
+    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0, 0 } };
+    cJSON_bool b = 0;
+
+    if ((length < 0) || (buffer == NULL))
+    {
+        return false;
+    }
+
+    p.buffer = (unsigned char*)buffer;
+    p.length = (size_t)length;
+    p.offset = 0;
+    p.noalloc = true;
+    p.format = format;
+    p.hooks = global_hooks;
+    b = print_value(item, &p);
+    *len = p.offset + 1;
+    return b;
+}
+
 /* Parser core - when encountering text, process appropriately. */
 static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
 {
@@ -3133,7 +3152,7 @@
 
 CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
 {
-    return global_hooks.allocate(size);
+    return global_hooks.allocate(size, global_hooks.ctx);
 }
 
 CJSON_PUBLIC(void) cJSON_free(void *object)
